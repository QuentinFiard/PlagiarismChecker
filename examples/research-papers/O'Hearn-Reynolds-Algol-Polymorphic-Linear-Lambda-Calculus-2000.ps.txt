

From Algol to Polymorphic Linear Lambda-calculus
Peter W. O'Hearn
Queen Mary & Westfield College
and
John C. Reynolds
Carnegie Mellon University

In a linearly-typed functional language one can define functions that consume their arguments in
the process of computing their results. This is reminiscent of state transformations in imperative
languages, where execution of an assignment statement alters the contents of the store. We explore
this connection by translating two variations on Algol 60 into a purely functional language with
polymorphic linear types. On one hand the translations lead to a semantic analysis of Algol-like
programs, in terms of a model of the linear language. On the other hand they demonstrate that
a linearly-typed functional language can be at least as expressive as Algol.

Categories and Subject Descriptors: D.3.1 [Programming Languages]: Formal Definitions and
Theory--semantics; F.3.2 [Logics and Meanings of Programs]: Semantics of Programming
Languages--denotational semantics

General Terms: Languages, Theory
Additional Key Words and Phrases: Parametric polymorphism, logical relations, local state, linear
logic

Contents
1 Introduction 2

1.1 Linear Typing and State Transformations . . . . . . . . . . . . . . . 4
1.2 Polymorphism, Data Abstraction and Store Shapes . . . . . . . . . . 6

2 Two Variations on Algol 8

2.1 Idealized Algol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8

Name: P.W. O'Hearn
Address: Department of Computer Science, Queen Mary and Westfield College, London E1 4NS,
UK. e-mail: ohearn@dcs.qmw.ac.uk
Name: J.C. Reynolds
Address: School of Computer Science, Carnegie Mellon University, Pittsburgh PA 15213-3891,
USA. e-mail: john.reynolds@cs.cmu.edu

Permission to make digital or hard copies of part or all of this work for personal or classroom use is
granted without fee provided that copies are not made or distributed for profit or direct commercial
advantage and that copies show this notice on the first page or initial screen of a display along
with the full citation. Copyrights for components of this work owned by others than ACM must
be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on
servers, to redistribute to lists, or to use any component of this work in other works, requires prior
specific permission and/or a fee. Permissions may be requested from Publications Dept, ACM
Inc., 1515 Broadway, New York, NY 10036 USA, fax +1 (212) 869-0481, or permissions@acm.org.

2 \Delta  P.W. O'Hearn and J.C. Reynolds

2.2 Basic SCI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3 A Polymorphic Linear *-calculus 11
4 Translations of Types 14

4.1 Idealized Algol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
4.2 Basic SCI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

5 Translations of Terms 16

5.1 Idealized Algol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
5.2 Expansions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
5.3 Basic SCI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

6 The Strict Parametricity Model 22

6.1 Semantics of Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
6.2 Semantics of Terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

7 Working With the Model 25

7.1 Snapback . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
7.2 Sample Type Analyses . . . . . . . . . . . . . . . . . . . . . . . . . . 27
7.3 A Limitation of Binary, Strict Parametricity . . . . . . . . . . . . . . 29

8 Relation to Functor Models 30

8.1 Idealized Algol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
8.2 Basic SCI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34

9 On Naturality and Parametricity 36

9.1 Basic SCI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
9.2 Idealized Algol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
9.3 Technical Lemmas . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38

10 Resumptions and Idealized Algol 40

10.1 A Representation Theorem . . . . . . . . . . . . . . . . . . . . . . . 40
10.2 Proof of the Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . 41
10.3 A Full Abstraction Result . . . . . . . . . . . . . . . . . . . . . . . . 48

11 Related Work 50
12 Discussion 52
1. INTRODUCTION
Traditional denotational semantics models imperative languages using state-tostate functions [Scott and Strachey 1971; Tennent 1991]. This approach successfully
accounts for the fact that storage variables take on different values at different times
during computation, but it does not cope nearly as well with the idea that a state
change destructively alters the contents of the store.

To see the difficulty, suppose we use a function p : States ! States \Theta  Values to
model the behaviour of an expression with side effects. Because a state is treated as

From Algol to Polymorphic Linear Lambda-calculus \Delta  3
a value like any other we are free, in the semantics, to manipulate any such function
in a decidedly non-imperative manner. For instance, we can define a function

snap : (States ! States \Theta  Values) ! (States ! States \Theta  Values)
as follows:

snap(p)s = [s; v]; where ps = [s0; v]:
(Here we are ignoring issues of non-termination.) This snap operator is a perfectly
reasonable mathematical function, but if we try to read it in an imperative fashion
it contradicts the intuitive understanding of a state transformation as altering the
store. Instead, it displays a "snapback" effect; snap(p) proceeds by executing p,
producing a new state s0 and value v, and then snapping the state back to its initial
value s. The use of p here does not destroy the initial state s.

In this paper we present an approach that better captures the imperative character of state transformations. The approach is based on a combination of linear
typing and parametric polymorphism, and is given, formally, via syntactic translations from two variations on Algol 60 into a linear polymorphic *-calculus. The
translations are based on the idea that a program is linearly polymorphic in the
type of the state; this allows for a subtle interplay between the copyability of specific values put into the store, and the inability of a program to copy the entire
store. We analyze the translations using a model of the target language.

Although our analysis mainly focuses on the resulting semantics of the source
languages, the translations can be regarded as well as indicating the imperative
nature of the target language. That is, although the linear polymorphic calculus
is a purely functional language, the translations can be regarded as providing an
imperative reading of a range of types in the functional target.

Before continuing we would like to stress that the "problem" with the traditional
semantics should be understood in its historical context. Indeed, Strachey on a
number of occasions emphasized the fundamentally different way that the state
and environment are used. For example:

"The state transformation produced by obeying a command is essentially
irreversible and it is, by the nature of the computers we use, impossible
to have more than one version of [the state] available at any one time."

C. Strachey [1972]

And Scott identified the non-copyability of state as crucial:

"We will be tempted to copy ae [the environment], but we will never
generally feel free to ask for a copy of the whole computer store - there
is just no room for that." D.S. Scott [1972]

But, while Scott and Strachey's prose vividly distinguished the state from the
environment, in 1972 the theoretical techniques were not yet in place to allow for
a precise description of the imperative, or irreversible, nature of state change, as
expressed informally by them.

In 1975, one of the authors (Reynolds) attempted to use the polymorphic *-
calculus [Girard 1972; Reynolds 1974] to describe Algol, discovering much of the
translation we will exhibit in Sections 4.1, 5.1, and 5.2. At the time, this seemed

4 \Delta  P.W. O'Hearn and J.C. Reynolds
to be a quixotic effort to define a well-understood language in terms of a less
understood one. (The author overlooked the fact that the translation avoided
impredicativity.)

The intervening years, however, have seen the development of a relational semantics of polymorphism [Reynolds 1983]; possible world semantics of imperative
languages [Reynolds 1981b; Oles 1982]; a connection between polymorphism and local state [O'Hearn and Tennent 1995]; and linear logic [Girard 1987]. Drawing upon
all of these developments, we are now able to give a refined translation of Algol-like
languages into the linear polymorphic *-calculus that, when coupled with a relational semantics for the latter language, gives a more abstract description of Algol
that earlier formulations of its semantics.

The translations are essentially a recasting of the the functor-category semantics
developed by Reynolds [1981b] and Oles [1982] in the early eighties, using a linear polymorphic *-calculus in place of a functor category. Their store shapes are
replaced by type variables, natural transformations are replaced by polymorphic
functions, and state-to-state functions are replaced by linear functions. This use of
polymorphism is as in the parametric-functor semantics of O'Hearn and Tennent
[1995], but refined by the use of linearity.

In the remainder of this Introduction we give an extended, informal, description
of the main elements underlying our approach.

1.1 Linear Typing and State Transformations
The central idea, on which linear logic hinges, is that of a linear function. The
guiding intuition is that a linear function "uses" its argument exactly once; as a
result, it cannot freely copy or ignore its argument, because doing so would violate
the use criterion. One often speaks also of a linear function as "consuming" its
argument in the process of producing its result. The connection between use and
consumption is that, after a linear function has used its argument once, the argument is no longer available, because to use it again would constitute two uses. The
problem with snapback is that it uses the initial state twice, once when producing
an intermediate result and again when producing a final answer. Thus, it is not
linear in its state argument.

Linear logic is based on Girard's identification of the structural rules of logic as
a source of discarding and copying data [Girard 1987]:

\Gamma  ` A
\Gamma ; B ` A Weakening

\Gamma ; B; B ` A

\Gamma ; B ` A Contraction:

Weakening introduces a dummy assumption: In computational terms it may be
understood as transforming a computation depending on \Gamma  into a computation
depending on \Gamma  and B, but which ignores B. In Girard's resource description of
logical rules, the ignoring of the B component involves the discarding of a datum of
type B. Similarly, Contraction involves copying: From a computation depending
on two B-typed values a computation depending on only one can be obtained, if we
have the ability to duplicate that value and supply the two copies to the original
computation.

Linear logic is a refinement of traditional logic which arises by restricting the
use of Weakening and Contraction. When the logic is used as a type system for

From Algol to Polymorphic Linear Lambda-calculus \Delta  5
a programming language, this control over structural rules translates into restrictions on the occurrences of identifiers within terms [Abramsky 1993; Wadler 1991;
Benton et al. 1993]. These restrictions result in a type A\Gamma ffi B of linear functions,
which cannot discard or duplicate their arguments through free use of Weakening
or Contraction.

To connect these ideas back to imperative computation, let us try to write snap
in a programming notation:

snap(p) = *s: let [s0; v] be p s in [s; v]:
This term uses both Contraction and Weakening: Contraction corresponds to the
two non-binding occurrences of the initial state s in the body of the *-expression,
and Weakening to the absence of s0 in [s; v]. As a result, if we were to use
States\Gamma ffi States \Omega  Values as the type of side-effecting expressions (where States \Omega 
Values is a type of "eager pairs") then snap(p) would fail to typecheck; snapback
is excluded by linear typing.

There is thus a tantalizing analogy between linear functions and imperative state
transformations. So it is natural to ask whether, or the extent to which, linear logic
can give rise to an improved semantic treatment of state.

As a first test of the analogy, we might translate a basic imperative language,
such as the language of while programs, into a linear functional language. It is
clear that one could express typical constructs, such as sequencing, assignment and
iteration, in terms of linear functions.

This is all well and good, but it only connects up imperative and linear functional
programming on a basic level, for an imperative language without procedures. And
such a language does not in fact provide a satisfactory test. For, basic sequential
imperative languages, without procedures, already possess a satisfactory foundation, with simple semantic models based on partial functions on states and logics
based on Hoare triples or weakest preconditions. It is difficult to see how this understanding could be improved by phrasing the semantics in terms of linear types.

How can this be? We began by describing problems in traditional semantics
based on state-to-state functions, and the language of while programs uses precisely
that kind of semantics. Consider again the snapback example: snap is a function
from state transformations to state transformations; in imperative terms it is a
procedure that expects an expression thunk as an argument. It takes an arbitrary
state transformation, runs it, and then restores the state to its initial value. The
whole discussion of snapback and irreversibility hinged on having procedures, which
are missing from the language of while programs.

We can go further still if we use local variables: We can then write programs
whose observable behaviour is sensitive to whether or not snapback is present in
the semantics:

snaptester = *p: new x: x := 0; p(x := x + 1); if x ? 0 then diverge:
The termination/nontermination behaviour of snaptester is equivalent to that of
*p: p(diverge). The reason is that if p executes its argument at all then the value
of x on termination of p(x := x + 1) will be greater than 0, since there is no way for
p to alter the value of x other than by using its argument. Snapback contradicts
this informal reasoning, since snaptester(snap) converges while snaptester(diverge)

6 \Delta  P.W. O'Hearn and J.C. Reynolds
diverges.

Thus, it makes sense to consider imperative languages that have procedures and
local state, in addition to assignment. In this paper we consider two such languages,
based on Idealized Algol [Reynolds 1981b].

1.2 Polymorphism, Data Abstraction and Store Shapes
It is evident how to model state transformations with linear functions, but now we
must consider how to model procedures and local state. We might attempt to do so
directly in a simply-typed linear language, using \Gamma ffi to model state transformations
and a conventional function type ! to model procedures, but there is a further
problem: It is not obvious how we might account for the interaction of procedures
and local state (as given, for example, in snaptester).

To expand on this last last point, consider how a "counter class" can be programmed in an Algol-like language using procedures and local state [Reynolds 1978]:

newcounter = *p: new x: x := 0; p(x := x + 1; x):
This code works by declaring a local variable x, and then passing the ability to
increment and read x to the procedure p. (The second argument x of p is implicitly
dereferenced from a variable to an expression, so that it cannot be assigned to by
p.). Because the procedure p can never access the local variable x we are assured,
for example, that the value of x can never be decremented. This illustrates how
a form of data abstraction results from the combination of procedures and local
state; it is hard to see how this phenomenon could be modelled in a simply typed
version of linear *-calculus.

This discussion has been leading toward our choice of target language. We can
account for data abstraction and local state using polymorphic types [Reynolds
1974; O'Hearn and Tennent 1995], so our target language will be a linearly-typed,
polymorphic *-calculus.

We can now sketch the main ideas behind the translations. The starting point is
to allow for multiple state types instead of only one. In terms of the polymorphic
target language we regard type variables as ranging over various "store shapes" or
state types, so that in a type ff\Gamma ffi ff of state transformations the type variable ff
can be instantiated to a variety of different representations of the state. The basic
idea is that programs working with different store shapes act on separate parts of
the store.

To see how this works recall the counter class above. An argument p to newcounter is a procedure that accepts a command and an expression as arguments,
and produces a command as a result. We assign p the polymorphic type

8fi:(fi\Gamma ffi fi)&(fi\Gamma ffi fi \Omega  nat) ! (ff \Omega  fi\Gamma ffi ff \Omega  fi):
The idea is that the state in use when p is called is partitioned into the ff-typed
part, which p may access directly, and the fi-typed part, about which p knows
nothing. The argument type fi\Gamma ffi fi corresponds to a command for changing this
unknown state, and fi\Gamma ffi fi \Omega  nat to a natural number-valued expression (possibly
with side effects).

The type constructors & and ! here are for conventional product and function
types; they are not subject to linearity restrictions. The mixing of linear and nonFrom Algol to Polymorphic Linear Lambda-calculus \Delta  7
linear type constructors in the type of p implies that it is only the state that must
be used linearly; the two arguments, of types fi\Gamma ffi fi and fi\Gamma ffi fi \Omega  nat, may be used
zero, one, or many times, as is common in imperative languages.

Now, if we apply the counter class to such a p, i.e., newcounter(p), we obtain a
function of type ff\Gamma ffi ff:

*s : ff: let [s0; n0] be p[nat]h*n: n + 1; *n: [n; n]i[s; 0]

in s0.

We can see from this how the fi-component in the type of p is regarded as ranging
over possible pieces of local state. What a local-variable declaration does first is
extend the state s to [s; 0], i.e., a state with an additional component initialized
to 0. In this process of initialization the type of the state changes from ff to
ff\Omega nat, with nat being the type of the values that can be held by the local variable.
Instantiating the fi component to nat allows p to work in this enlarged state:
Communication between local state and non-local procedures is achieved through
polymorphic instantiation. Intuitively, the independence of non-local procedures
from local state corresponds to the parametricity of a polymorphic function whose
type argument ranges over possible pieces of local state [Reynolds 1983; O'Hearn
and Tennent 1995].

This example also illustrates how the move from simple to polymorphic types has
an additional effect, beyond enabling a treatment of data abstraction. To see this,
consider that we have used Contraction and Weakening of nat-typed identifiers:
Contraction is used for dereferencing, in *n: [n; n], and Weakening of n0 is used to
model deallocation of the local variable on block exit. (We also sometimes need
Weakening to model updates.) These uses of Contraction and Weakening do not
contradict the intuitive connection between linearity and state change, because the
polymorphic uses of nat by p (obtained by instantiating fi) will still all be linear.
This point deserves careful consideration, and we will return to it several times,
but the general idea is that polymorphic instantiation mediates between the linear
way that state is manipulated, and the use of non-linear values to make up specific
states.

Local-variable declarations are a special mechanism for ensuring absence of interference through shared variables. We can also use polymorphic typing to treat
non-interference more generally. For example, consider the type

8fi 8fl: (fi\Gamma ffi fi)&(fl\Gamma ffi fl \Omega  nat) ! (ff \Omega  fi \Omega  fl\Gamma ffi ff \Omega  fi \Omega  fl):
In imperative terms, a procedure of this type accepts two arguments, one a command and the other a side-effecting expression. If q is such a procedure then in an
application q[A][B]hc; ei it is never possible to use c to change the state in a way
that affects a future use of e. This is because, in q, using c produces a fi-typed
value, while e expects a fl-typed value, and these types do not match up. So the
use of different type variables for the arguments means that the output state of one
cannot be used as the input state of the other. Again in imperative terms, we take
this to mean that the two arguments c and e don't interfere.

We now proceed to present the translations, and the semantics. Our two source
languages are Idealized Algol [Reynolds 1981b] (without jumps or coercions, and
with side effects in expressions) and syntactic control of interference [Reynolds

8 \Delta  P.W. O'Hearn and J.C. Reynolds
1978] (without passivity). The target language is based on the \Gamma ffi , \Omega , &, ! (or
"!") fragment of intuitionistic linear logic [Girard 1987; Barber and Plotkin 1997],
extended with a fixed-point operator and a predicative form of polymorphism. The
semantic model of the target language is based on strict continuous functions and
binary relational parametricity [Reynolds 1983]. We analyze the model by looking
at sample equivalences, and by characterizing the structure of first-order types in
terms of domain equations for resumptions.

In Section 8 we will describe the connection to functor-category semantics in some
detail, but for the most part we will work directly with the polymorphic language
and its model.

2. TWO VARIATIONS ON ALGOL
Our imperative languages are based on the analysis of Algol 60 given in [Reynolds
1978; Reynolds 1981b]. The one, substantial, caveat is that our languages do not
account for passivity. Thus, evaluation of a natural-number expression can produce
a side effect, and we do not consider a concept of passive type [Reynolds 1978] (also,
[O'Hearn et al. 1999]).

Both languages use the following grammar of types:

' ::= exp j acc j comm primitive types
` ::= ' j ` \Theta  `0 j ` ! `0 types

The primitive type exp is the type of natural-number expressions, acc is the type
of acceptors, and comm is the type of commands. Commands change the state of
the store but do not produce values, and an acceptor changes the state when it is
supplied with an integer. The type var of storage variables is an abbreviation for
acc \Theta  exp. The factors of var give the basic capabilities of updating and accessing
a storage variable.

2.1 Idealized Algol
The typing rules for Idealized Algol follow. A typing context \Gamma  is a finite list of
assumptions x : ` pairing identifiers with types, with the proviso that no identifier

From Algol to Polymorphic Linear Lambda-calculus \Delta  9
appears twice.

\Gamma ; x : ` ` x : `

\Gamma  ` M : `e
\Gamma  ` M : ` where e\Gamma  is a permutation of \Gamma 

\Gamma ; x : ` ` M : `0
\Gamma  ` *x : `: M : ` ! `0

\Gamma  ` M : ` ! `0 \Gamma  ` N : `

\Gamma  ` M N : `0

\Gamma  ` M : `1 \Theta  `2

\Gamma  ` ssi M : `i where i is 1 or 2

\Gamma  ` M : ` \Gamma  ` N : `0

\Gamma  ` hM; N i : ` \Theta  `0

\Gamma  ` 0 : exp

\Gamma  ` N1 : exp \Gamma  ` Ni : ' ; i = 2; 3

\Gamma  ` if N1 = 0 then N2 else N3 : '

\Gamma  ` M : exp
\Gamma  ` succ M : exp

\Gamma  ` M : exp
\Gamma  ` pred M : exp

\Gamma  ` M : ` ! `

\Gamma  ` Y` M : `

\Gamma  ` M : var ! '

\Gamma  ` new' M : '

\Gamma  ` skip : comm

\Gamma  ` M : comm \Gamma  ` N : '

\Gamma  ` M ; N : '

\Gamma  ` M : exp ! comm

\Gamma  ` byvalue M : acc

\Gamma  ` M : acc \Gamma  ` N : exp

\Gamma  ` M := N : comm

Idealized Algol contains the functional constructs of PCF [Plotkin 1977]. Of
the imperative constructs, new(*x: C) works by binding x to a local storage variable that is initialized to 0, ";" is sequential composition, skip is the do-nothing
command, and assignment supplies an integer value to an acceptor.

Acceptors were originally introduced as part of a generalized approach to variables [Reynolds 1981b], in which an acceptor was considered simply as a function
from data values to commands. On this view acceptors are similar to functions of
type exp ! comm, except that they accept integer values rather than expressionthunks as arguments; they are thus a form of call-by-value procedures. The byvalue
construct converts a thunk-expecting procedure to an acceptor using a coercion
from natural-number values to expressions. (It would be conceivable to provide
instead an alternate binding form for call-by-value, as was done in Algol 60 using
the keyword value with a formal parameter.)

We will often use syntactic sugar in an informal, but hopefully clear, way. For
instance, newcounter is rendered formally as

*p : (comm \Theta  exp ! comm) ! comm:

newcomm (*x : var: (ss1x) := 0; ph(ss1x) := (succ ss2x); ss2xi):

Generally, we omit mention of types in new or on *-bound identifiers, we omit
the projections when using a term of type var, and we write new x: M instead of
new (*x: M ).

An important difference with the original Idealized Algol is that a sequential
composition of the form M ; N when N : exp may result in an "active expression,"
which may return different natural numbers on different uses. For example, if

10 \Delta  P.W. O'Hearn and J.C. Reynolds
x : var is a declared variable then x := x + 1; x returns successive natural numbers
on successive uses.

We have not attempted to produce an irredundant collection of basic constructs.
For instance, the expression newacc P of type acc could be eliminated, as it is
equivalent to byvalue (*y : exp: newcomm z: P z := y).

It is worth considering how the inclusion of side effects in expressions impacts
the coding of arithmetic operations. A typical functional encoding of addition is

plus = Y (* plus: * x: *y: if x = 0 then y else plus (pred x) (succ y)).
In Idealized Algol (with side effects) an evaluation of plus e1 e2 will evaluate e1 and
e2 multiple times, perhaps changing the state each time. For example,

newexp z: z := 1; (plus (z := z + 1; z) 2)
diverges since z is incremented each time pred is evaluated.

Using new we can program a version of addition that evaluates its arguments
once each, left followed by right, and adds the resulting values together:

leftadd = *x: *y: new x0: new y0: x0 := x; y0 := y; plus (x0) (y0).
We can also define rightadd = *x: *y: leftadd y x.
2.2 Basic SCI
Basic SCI (for syntactic control of interference) is similar to Idealized Algol, but
for a few modifications. First, it uses the affine *-calculus as its type system,
whereas Idealized Algol uses the full simply-typed calculus. The affine calculus is
just the usual simply-typed calculus, except that the rule for procedure application
is restricted so that procedure and argument have no free identifiers in common.
(This is another way of saying that the calculus does not have Contraction.) This
restriction prevents interference between different identifiers. For instance, y and z
are aliases in ((*y*z: \Delta  \Delta  \Delta  y := a \Delta  \Delta  \Delta  z := b \Delta  \Delta  \Delta )x)x if x denotes a storage variable. But
a term of this form cannot typecheck in Basic SCI because there is an occurrence
of x in a procedure and its argument.

Second, the rule for recursion is restricted to procedures with no free identifiers.
This restriction is needed because otherwise a recursive unwinding Y(F ) \Lambda  F (Y(F ))
would violate the disjointness between procedure and argument that is characteristic of Basic SCI.

Third, in Basic SCI we have a determinate form of parallelism, where the parallel
composition M k N is allowed if the free identifiers of M and N are disjoint. This
illustrates the difference with Idealized Algol, where the same construct would
(because of interference) lead to indeterminacy.

These modifications and additions to Idealized Algol are summed up in the following rules:

\Gamma  ` M : ` ! `0 \Gamma 0 ` N : `

\Gamma ; \Gamma 0 ` M N : `0

\Gamma  ` M : comm \Gamma 0 ` N : comm

\Gamma ; \Gamma 0 ` M k N : comm

` M : ` ! `

` Y` M : `

From Algol to Polymorphic Linear Lambda-calculus \Delta  11
To illustrate further the difference between SCI and Idealized Algol consider the
addition operations leftadd; rightadd : exp ! exp ! exp. In Idealized Algol these
operations are inequivalent because of interfering side-effects. For example, in a
state where the contents of storage variable x is 5, evaluation of leftadd(succ x)(x :=
succ x; x) returns value 12, whereas rightadd(succ x)(x := succ x; x) returns value
13. In contrast, in SCI the arguments to these functions never interfere: The typing
rules ensure that in a procedure call leftadd(e1)(e2) the procedure leftadd(e1) and
argument e2 have disjoint sets of free identifiers. As a result, even though we allow
side effects in expressions, leftadd and rightadd are equivalent in SCI.

An interfering version of addition can be programmed in SCI using the type
exp \Theta  exp ! exp instead of exp ! exp ! exp. The point is that SCI types can
be used to specify both potential dependence and necessary independence between
program parts.

3. A POLYMORPHIC LINEAR *-CALCULUS
Now we introduce the polymorphic target language. We follow the version of linear
type theory formulated by Barber and Plotkin [1997], where two zones are used in
a typing context to keep track of intuitionistic and linear assumptions. The basic
idea is that linear assumptions are used once, while intuitionistic assumptions can
be used multiple times in a term. (We refer to [Abramsky 1993; Benton et al. 1993;
Wadler 1990; Wadler 1991] for further discussions of linear *-calculi.)

The kind of polymorphism we need for interpreting Algol is predicative in nature,
so we work with the following stratification of types:

oe ::= ff j nat j oe \Omega  oe j I Level 1
A ::= oe j 8ff: A j A\Gamma ffi A j A ! A j A &A j !A Level 2

Type variables are denoted by ff (or other Greek letters fi, fl). The essence of
the stratification is that the 8 quantifier ranges over only Level 1 types. This
is significant because it makes the construction of models much easier than for
impredicative calculi.

This stratification is possible because of the distinction between data types and
phrase types (or between storable and denotable values) in Algol. The Level 1 types
correspond, intuitively, to store shapes in the sense of Reynolds and Oles, whereas
Level 2 types are, after translation, types of phrases in the imperative languages.

It would be possible to define A ! B as !A\Gamma ffi B. But since, for the purpose of
the two translations, the only significant uses of "!" would be in this encoding we
prefer to work explicitly with both function types \Gamma ffi and !. For emphasis we use
two binding forms, *x : A: t and *x : A: t, one for each function type. We will use
the same syntax for applying both kinds of function (in effect leaving dereliction
implicit in !); no confusion is likely to arise from this.

The system uses typing judgements of the form

\Gamma ; \Delta  ` t : A;
where the context is broken into an intuitionistic zone \Gamma  and a linear zone \Delta .

12 \Delta  P.W. O'Hearn and J.C. Reynolds
Identity

\Gamma ; \Delta  ` t : Ae

\Gamma ; e\Delta  ` t : A where e\Gamma ; e\Delta  are permutations of \Gamma ; \Delta 

\Gamma ; x : A; ` x : A \Gamma ; x : A ` x : A

Additives

\Gamma ; \Delta  ` t : A \Gamma ; \Delta  ` u : B

\Gamma ; \Delta  ` ht; ui : A &B

\Gamma ; \Delta  ` t : A &B

\Gamma ; \Delta  ` ss1 t : A

\Gamma ; \Delta  ` t : A &B

\Gamma ; \Delta  ` ss2 t : B

\Gamma ; x : A; \Delta  ` t : B
\Gamma ; \Delta  ` *x : A: t : A ! B

\Gamma ; \Delta  ` t : A ! B \Gamma ; ` u : A

\Gamma ; \Delta  ` t u : B

Multiplicatives

\Gamma ; ` \Lambda  : I

\Gamma ; \Delta 1 ` t : I \Gamma ; \Delta 2 ` u : A
\Gamma ; \Delta 1; \Delta 2 ` let \Lambda  be t in u : A

\Gamma ; \Delta 1 ` u : A \Omega  B \Gamma ; \Delta 2; x : A; y : B ` t : C

\Gamma ; \Delta 1; \Delta 2 ` let [x; y] be u in t : C

\Gamma ; \Delta 1 ` t : A \Gamma ; \Delta 2 ` u : B

\Gamma ; \Delta 1; \Delta 2 ` [t; u] : A \Omega  B

\Gamma ; \Delta ; x : A ` t : B
\Gamma ; \Delta  ` *x : A: t : A\Gamma ffi B

\Gamma ; \Delta 1 ` t : A\Gamma ffi B \Gamma ; \Delta 2 ` u : A

\Gamma ; \Delta 1; \Delta 2 ` t u : B

\Gamma ; ` t : A
\Gamma ; ` !t : !A

\Gamma ; \Delta 1 ` u : !A \Gamma ; x : A; \Delta 2 ` t : B

\Gamma ; \Delta 1; \Delta 2 ` let !x be u in t : B

Polymorphism

\Gamma ; \Delta  ` t : 8ff:A
\Gamma ; \Delta  ` t[oe] : A[oe=ff]

\Gamma ; \Delta  ` t : A
\Gamma ; \Delta  ` \Lambda ff:t : 8ff:A ff 62 fv(\Gamma ; \Delta )

From Algol to Polymorphic Linear Lambda-calculus \Delta  13
Natural Numbers and Recursion

\Gamma ; ` 0 : nat

\Gamma ; ` t : A ! A

\Gamma ; ` YA t : A

\Gamma ; \Delta  ` t : nat
\Gamma ; \Delta  ` succ t : nat

\Gamma ; \Delta  ` t : nat
\Gamma ; \Delta  ` pred t : nat

\Gamma ; \Delta  ` t : nat
\Gamma ; \Delta  ` copy t : nat \Omega  nat

\Gamma ; \Delta  ` t : nat
\Gamma ; \Delta  ` discard t : I

\Gamma ; \Delta 1 ` u1 : nat \Gamma ; \Delta 2 ` u2 : A \Gamma ; \Delta 2 ` u3 : A

\Gamma ; \Delta 1; \Delta 2 ` if u1 = 0 then u2 else u3 : A

In this formulation of linear typing we have introduction and elimination rules for
each type constructor. However, we do not have to add explicit rules that permit
Weakening and Contraction of "!"-typed identifiers; this is because of the use of
two zones, which allows Weakening and Contraction in the intuitionistic zone to be
left implicit, as is the case in simply-typed *-calculus. This allows for a particularly
smooth treatment of the intuitionistic function type !, which is attractive for our
purposes: We will have need for !, but not explicitly for "!."

The characteristic feature of the additive rules is the sharing of typing contexts.
For instance, in the introduction rule for &, the linear zone \Delta  is shared between
both premises. On the other hand, the characteristic feature of the multiplicatives is
the splitting of typing contexts in the linear zone. For instance, in the introduction
rule for \Omega , the contexts \Delta 1 and \Delta 2 must be made up of disjoint collections of
identifiers. The absence of Contraction is reflected in this splitting of contexts in
the multiplicative rules, and the absence of Weakening is reflected in the rules for
identifiers; the linear zone is empty when an identifier from the intuitionistic zone
is typed, and of length one when a linear identifier is typed.

One point to notice is the presence of explicit terms for copying and discarding
natural numbers. Using these and the rules for I we can define appropriate copying
and discarding terms of types oe\Gamma ffi oe \Omega  oe and oe\Gamma ffi I, for any closed Level 1 type
oe. But we do not have copying or discarding of Level 1 types available generically,
as terms of type 8ff: ff\Gamma ffi ff \Omega  ff or 8ff: ff\Gamma ffi I. This distinction between specific and
generic copying/discarding is related to the following idea in Idealized Algol: A
state change effected by a command on any fixed finite number of storage variables
could be reversed by using local variables to store and restore the values. But we
cannot program a general snapback mechanism that reverses state changes for every
possible shape of the store.

We have used [s; t] as notation for \Omega -pairs, reserving f \Omega  g for the functorial
action of \Omega , where

f \Omega  g = *x : A \Omega  B: let [y; z] be x in [f y; gz];
when f : A\Gamma ffi A0 and g : B\Gamma ffi B0.

We use \Omega A to abbreviate YA(*x : A:x). In a fully polymorphic language Y would
have type 8ff: (ff ! ff) ! ff, but in the predicative sublanguage this type is not
sufficient because ff does not range over all types.

14 \Delta  P.W. O'Hearn and J.C. Reynolds
4. TRANSLATIONS OF TYPES
In this section we give the translations on the level of types. We consider terms
by treating a few examples, leaving the detailed translation to the next section.
In presenting examples we will be somewhat liberal in the use of syntactic sugar
and the application of (meaning-preserving) syntactic simplifications in the linear
calculus.

4.1 Idealized Algol
The translation takes a judgement

x1 : `1; : : : ; xn : `n ` M : `
in Idealized Algol to a judgement

x1 : `?1ff; : : : ; xn : `?nff; ` M ?ff : `?ff
in polymorphic linear *-calculus, where

comm?ff = ff\Gamma ffi ff

acc?ff = ff \Omega  nat\Gamma ffi ff
exp?ff = ff\Gamma ffi ff \Omega  nat
(` \Theta  `0)?ff = `?ff & `0?ff
(` ! `0)?ff = 8fi: `?(ff \Omega  fi) ! `0?(ff \Omega  fi):

The translation `? of an Idealized Algol type is a type with a "hole" that can
be filled by substituting type variables and other Level 1 types. For instance,
comm?(ff \Omega  fi) is ff \Omega  fi\Gamma ffi ff \Omega  fi. Similarly, a term M gets mapped to a term M ?
with a type variable hole that can be filled with various type variables or Level 1
types: M \Lambda oe, M \Lambda oe0... and so on. (The translation could be arranged so that each
M ? was a polymorphic function of type 8ff: `?1ff & \Delta  \Delta  \Delta  & `?nff ! `?ff. We prefer,
however, to use the term-with-hole representation in order to minimize explicit
manipulations of environments.)

The only essential uses of linearity involve primitive types and states. In particular, the translations of Algol types always appear in the intuitionistic zone of a
typing judgement.

In the informal translation of newcounter in the Introduction we used Weakening
and Contraction of nat-typed identifiers. With our linear language, however, we
have to be more explicit, using copy and discard. Also, a slight adjustment is
needed because the translation of procedure types in Idealized Algol allows ff to
appear to the left of !, whereas the type for the procedure p in the Introduction
used the SCI interpretation (see below) where ff does not appear to the left. So p
now has type

8fi: (ff \Omega  fi\Gamma ffi ff \Omega  fi) \Theta  (ff \Omega  fi\Gamma ffi ff \Omega  fi \Omega  nat) ! (ff \Omega  fi\Gamma ffi ff \Omega  fi);
and the translation of newcounter(p) is the following function of type ff\Gamma ffi ff:

*s : ff: let [s0; n0] be p[nat]h(idff \Omega  *n: succ n); (idff \Omega  *n: copy n)i[s; 0]

in (let \Lambda  be (discard n0) in s0),

where idff is *s : ff: s.

From Algol to Polymorphic Linear Lambda-calculus \Delta  15
Some equivalences between Idealized Algol terms can be proven using basic laws
of polymorphic *-calculus. For example, the equivalence (new * x: c) j c, for an
identifier c : comm, follows from basic equivalences of polymorphic *-calculus together with the assumption that discard and copy give nat a comonoid structure.
Typically, the basic equations that are valid in models where 8 is interpreted simply
as an indexed product are sufficient for reasoning about new blocks whose only free
identifiers are of primitive type, but parametricity is needed when there are free
identifiers of procedural type.

In the Introduction we discussed snapback in the context of a single collection
States of states. In the polymorphic language snapback would ostensibly be given
by a term

\Lambda ff: *s : ff: let [s0; n] be c s in [s; n]
of type 8ff: (ff\Gamma ffi ff\Omega nat) ! (ff\Gamma ffi ff\Omega nat) which (given the isomorphism ff ,= I \Omega ff)
would determine a closed term of type (exp ! exp)?I. But this term does not
have the indicated type because it uses Contraction of s and Weakening of s0,
where s and s0 are ff-typed values. This does not show that no other term produces
the behaviour of snapback - for that we will appeal to a semantic model - but it
illustrates that it is the general, or polymorphic, snapback that we expect control
of structural rules to forbid.

4.2 Basic SCI
We translate

x1 : `1; : : : ; xn : `n ` M : `
in Basic SCI to a judgement

x1 : `ffi1ff1; : : : ; xn : `ffinffn; ` M ffi(ff1; : : : ; ffn) : `ffi(ff1 \Omega  \Delta  \Delta  \Delta  \Omega  ffn)
in polymorphic linear *-calculus, where

commffiff = ff\Gamma ffi ff

accffiff = ff \Omega  nat\Gamma ffi ff
expffiff = ff\Gamma ffi ff \Omega  nat
(` \Theta  `0)ffiff = `ffiff & `0ffiff
(` ! `0)ffiff = 8fi: `ffifi ! `0ffi(ff \Omega  fi):

Compared to the other translation, each identifier xi is now associated with a
separate state-type ffi; the idea is that each identifier has a separate piece of the
store that it acts upon. The other difference is that the procedure type uses `ffifi
in the argument position instead of `ffi(ff \Omega  fi). The result is that the procedure
and argument types no longer share type variable ff, mirroring the restricted rule
for application in SCI which ensures that procedures and their arguments don't
interfere.

For example, the type comm ! exp ! comm translates as

8fi: (fi\Gamma ffi fi) ! (8fl: (fl\Gamma ffi fl \Omega  nat) ! (ff \Omega  fi \Omega  fl\Gamma ffi ff \Omega  fi \Omega  fl));
which is isomorphic to the type

8fi 8fl: (fi\Gamma ffi fi) & (fl\Gamma ffi fl \Omega  nat) ! (ff \Omega  fi \Omega  fl\Gamma ffi ff \Omega  fi \Omega  fl)

16 \Delta  P.W. O'Hearn and J.C. Reynolds
that we used to illustrate non-interference in the Introduction.

Note that the absence of Contraction in linear logic is not being used to account
for the absence of Contraction in SCI. Indeed, the translations of SCI types always appear in the intuitionistic zone in the translation of a judgement. It is the
use of different type variables that corresponds to the absence of Contraction in
SCI: Different occurrences of the same SCI type `, say x1 : `; x2 : `, get sent to
different types, x1 : `ffiff1; x2 : `ffiff2. Generally, parametric polymorphism is used
to model both local state and non-interference, whereas linearity (combined with
polymorphism) ensures that there is no snapback.

We give several examples of term translations. First, if x1 and x2 are different
identifiers of type comm, then the translation of x1 k x2 is

x1 : ff1\Gamma ffi ff1; x2 : ff2\Gamma ffi ff2;
` * s : ff1 \Omega  ff2: let [s1; s2] be s in [x1s1; x2s2] : ff1 \Omega  ff2\Gamma ffi ff1 \Omega  ff2.

From this we can see how the disjointness property of SCI is very explicit: It is
obvious that x and y act on disjoint portions of the store, so we can run them in
parallel.

Consider next the sequential composition x; y of two command identifiers. This
is translated as

x1 : ff1\Gamma ffi ff1; x2 : ff2\Gamma ffi ff2;
` * s : ff1 \Omega  ff2: x02(x01(s)) : ff1 \Omega  ff2\Gamma ffi ff1 \Omega  ff2,

where

x01 = *s : ff1 \Omega  ff2: let [s1; s2] be s in [x1s1; s2]
x02 = *s : ff1 \Omega  ff2: let [s1; s2] be s in [s1; y2s2].

Although the translation uses x02(x01(s)), which indicates that x1 is evaluated first,
it reduces to let [s1; s2] be s in [x1s1; x2s2] using typical reductions of linear *-
calculus. Thus, it is clear that x1; x2 and x1 k x2 are equivalent.

Finally, consider our two addition operations leftadd and rightadd. The translations of leftadd(x1)(x2) and rightadd(x1)(x2) are both

x1 : ff1\Gamma ffi ff1 \Omega  nat; x2 : ff2\Gamma ffi ff2 \Omega  nat;
` * s : ff1 \Omega  ff2: let [s1; s2] be s in

let[[s01; n]; [s02; m]] be [x1s1; x2s2] in [[s01; s02]; m + n]
: ff1 \Omega  ff2\Gamma ffi ff1 \Omega  ff2 \Omega  nat.

We regard the two arguments as being evaluated in parallel, possibly altering different portions of the store, before their results are added together. (The translations
do not literally result in this term, but in ones that are, by an easy analysis using
the semantic model of Section 6, seen to be equivalent to it.)

5. TRANSLATIONS OF TERMS
The detailed translations of terms follow ideas from functor-category semantics
[Oles 1982].

From Algol to Polymorphic Linear Lambda-calculus \Delta  17
5.1 Idealized Algol
We begin by translating assignment. An assignment statement M := N is executed
by first evaluating N , obtaining a changed state and value, and then supplying this
value and state to M . Thus, assignment is simply a composition of the form

ff ff \Omega  nat ff:-N

?ff -M ?ff

More explicitly, we may define

(M := N )?ff = *s : ff: let [s0; m] = (N ?ff s) in (M ?ff [s0; m]):
To translate newcomm we follow the pattern of the newcounter example in the
Introduction:

(newcomm P )?ff = *s : ff: let [s0; n] be (P ?ff)[nat] (v[ff]) [s; 0] in

let \Lambda  be (discard n) in s0:

In this equation the expanded state [s; 0] and a local variable v[ff] (defined below)
are passed as arguments to the procedure P , and the final value n of the local
variable is discarded on termination of P . The translation P ?ff of P has type
8fi: var?(ff \Omega  fi) ! comm?(ff \Omega  fi), and polymorphic instantiation is used to set
the fi-component to nat.

The local variable v is given by the term \Lambda ff: hassign[ff]; lookup[ff]i of type
8ff: (acc \Theta  exp)?(ff \Omega  nat), where

assign = \Lambda ff: *s : (ff \Omega  nat)\Omega  nat: let [[a; n]; m] be s in

let \Lambda  be (discard n) in [a; m]

lookup = \Lambda ff: * s : ff \Omega  nat: let [a; n] be s in

let [n0; n00] be (copy n) in [[a; n0]; n00].

The essence of these two operations is the use of discard in assign and copy
in lookup. Similar assignment and lookup operations are therefore available if we
replace nat by any type that has appropriate versions of copy and discard maps.
Since all types of the form !A have copy and discard maps, if we were to consider
an impredicative polymorphic calculus we could write lookup and assign maps
for "storing" elements of any such type. An interesting question is whether such
operations make (imperative) operational sense.

The translation of newexp is similar:

(newexp P )?ff = *s : ff: let [[s0; n]; m] be (P ?ff)[nat] (v[ff]) [s; 0] in

let \Lambda  be (discard n) in [s0; m]:

If we had interpreted comm as ff\Gamma ffi ff \Omega  I then the two new constructs could have
been treated uniformly, by the same defining equation. The translation of newacc P
is obtained by viewing it as sugar for byvalue (*y : exp: newcomm z: P z := y).

To translate an application (M N )?, where M : ` ! `0 and N : `, we must use
translations of M and N with the following types:

M ?ff : 8fi: `?(ff \Omega  fi) ! `0?(ff \Omega  fi)
N ?ff : `?ff.

18 \Delta  P.W. O'Hearn and J.C. Reynolds
In order to apply M ? to N ?, we apply M ?ff to the unit I of \Omega , and then use a
canonical isomorphism ff \Omega  I ,= ff to make the types of the procedure and argument
match up. That is,

(M N )?ff = h\Gamma (M ?ff)[I](i(N ?ff))\Delta ,
where h : `0?(ff \Omega  I)\Gamma ffi `0?ff and i : `?ff\Gamma ffi `?(ff \Omega  I) are terms coding canonical
isomorphisms.

We will not give the explicit definitions of h and i, but simply say that they
are defined in a standard way by induction on types. If T (ff) is a type of the
polymorphic calculus with a free type variable ff, and f : ff\Gamma ffi fi and g : fi\Gamma ffi ff are
terms (fi 62 fv(T )), then there is an induced term T [f; g] : T (ff)\Gamma ffi T (fi) obtained by
applying f for positive occurrences of ff and g for negative occurrences. Further,
T [f; g] is an isomorphism (say, in the model of the following section) whenever f
and g denote inverse isomorphisms.

This use of canonical isomorphisms is unpleasant, and is treated much more
smoothly in a semantics based explicitly on a functor category.

The next case we consider is *-abstraction. We need to define

(*x : `: M )?ff : 8fi: `?(ff \Omega  fi) ! `0?(ff \Omega  fi)
in terms of

M ?ff : `0ff, assuming x : `?ff.
The type mismatch between `?ff and `?(ff \Omega  fi) is dealt with now by using "expansion" mappings expand` : 8fffi: `?ff\Gamma ffi `?(ff \Omega  fi). Expansions show how a piece of
code defined outside the scope of a local-variable declaration can be used within
the scope of the declaration. For instance, a command identifier c : comm\Lambda ff gets
sent to *[s; s0] : ff \Omega  fi: [c(s); s0].

A detailed description of expand is postponed until later in this section, but the
way expansions are used to treat *-abstraction can be set out now. Suppose we are
given

x1 : `?1 : ff; : : : ; xn : `?nff; x : `?ff ; ` M ?ff : `0ff.
Then we also have

x1 : `?1(ff \Omega  fi); : : : ; xn : `?n(ff \Omega  fi);x : `?(ff \Omega  fi) ;

` M ?(ff \Omega  fi) : `0(ff \Omega  fi),

and using a typical substitution lemma for the linear calculus we can infer

x1 : `?1 : ff; : : : ; xn : `?nff;x : `?(ff \Omega  fi) ;

` (M ?(ff \Omega  fi))[expand`i [ff][fi]xi=xi] : `0(ff \Omega  fi),

where (M ?(ff \Omega  fi))[expand`i[ff][fi]xi=xi] denotes the term obtained by substituting
expand`i[ff][fi]xi for each xi. Notice that x is not replaced. Given this judgement
we can first *-abstract x and then \Lambda -abstract fi, leading to the definition

(*x : `: M )?ff = \Lambda fi *x : `?(ff \Omega  fi): (M ?(ff \Omega  fi))[expand`i [ff][fi]xi=xi]:
Note that the use of expansions makes the translation M ? dependent on the
types of free identifiers; e.g. *x : comm: y(z) gets translated differently, depending

From Algol to Polymorphic Linear Lambda-calculus \Delta  19
on the types of y and z. So to be precise the translation in fact defines terms M ?\Gamma ff,
indexed by Idealized Algol type assignments \Gamma .

The remaining clauses are straightforward by comparison. A canonical isomorphism h : `?(ff \Omega  I)\Gamma ffi `?(ff) is used to deal with the function application in the
translation of the fixed-point combinator.

x?ff = x
(ssiM )?ff = ssi(M ?ff)
hM; N i?ff = hM ?ff; N ?ffi

0?ff = *s : ff: [s; 0]
(if N1 = 0 then N2 = *s : ff: let [s0; y] be N ?1 s in

else N3)?ff if y = 0 then N ?2 ff s0 else N ?3 ff s0

(succ M )?ff = *s : ff: let [s0; y] be M ?ff s in [s0; (succ y)]
(pred M )?ff = *s : ff: let [s0; y] be M ?ff s in [s0; (pred y)]

(Y` M )?ff = h(Y`?(ff\Omega I)M ?ff[I])
(byvalue M )?ff = *[s; n] : ff \Omega  nat:

let [s0; x] = (M ?ff[I](*a : ff \Omega  I: [a; n])[s; \Lambda ]) in

let \Lambda  be x in s0

(M ; N )?ff = *s : ff: N ?ff (M ?ff s)

skip?ff = *s : ff: s

The clause for M ; N is for the cases when N : exp or N : comm. The
case of M ; N when N : acc is treated by the translation as sugar for the expression (byvalue *x : exp: M ; (N := x)). Similarly, the clause for if is when
N2; N3 : comm or N2; N3 : exp , and the acceptor case is sugar for the expression
(byvalue *x : exp: if N1 = 0 then N1 := x else N2 := x).

5.2 Expansions
We define functions

expand` : 8ff8fi: `?ff\Gamma ffi `?(ff \Omega  fi);
where ff and fi are different type variables. These functions will be given by closed
terms. In the present setup, the Expansion Parametricity Lemma of [O'Hearn and
Tennent 1995] is then a consequence of the definability of these expansions and the

20 \Delta  P.W. O'Hearn and J.C. Reynolds
Logical Relations Lemma. The definition goes by induction on `:

expandcomm = \Lambda fffi: *c : ff\Gamma ffi ff: *[a; b] : ff \Omega  fi: [c a; b]

expandacc = \Lambda fffi: *c : ff \Omega  nat\Gamma ffi ff: *[[a; b]; n] : (ff \Omega  fi) \Omega  nat: [c[a; n]; b]
expandexp = \Lambda fffi: *e : ff\Gamma ffi ff \Omega  nat: *[a; b] : ff \Omega  fi: let [a0; n] = e a

in [[a0; b]; n]

expand`\Theta `0 = \Lambda fffi: (expand`[ff; fi])&(expand`0[ff; fi])
expand`!`0 = \Lambda fffi: *p: \Lambda fl: i1 ffi p[fi \Omega  fl] ffi i2
Here we have used the shorthand of composition ffi (in functional order) and the
functorial action of &. The terms i1 and i2 are for associativity isomorphisms:

i1 : `0((ff \Omega  fi) \Omega  fl)\Gamma ffi `0(ff \Omega  (fi \Omega  fl))
i2 : `((ff \Omega  fi) \Omega  fl)\Gamma ffi `(ff \Omega  (fi \Omega  fl)).

Thus, expansions for function types are defined according to the following diagram:

`?((ff \Omega  fi) \Omega  fl)
`?(ff \Omega  (fi \Omega  fl))

`0?((ff \Omega  fi) \Omega  fl)
`0?(ff \Omega  (fi \Omega  fl))
6i2

-p[fi \Omega  fl]

-expand
`!`0[ff][fi]p[fl]

?i1

5.3 Basic SCI
In the translation for Basic SCI we will gloss over isomorphisms for permuting and
associating \Omega . The translation is similar in many ways to the one for Idealized
Algol: We concentrate on the main differences.

First, to translate identifiers, given

x1 : `1; : : : ; xm : `m ` xi : `i
in SCI we must define

x1 : `ffi1ff1; : : : ; xm : `ffimffm; ` xffii (ff1; : : : ; ffm) : `ffii (ff1 \Omega  \Delta  \Delta  \Delta  \Omega  ffm):
We define xffii (ff1; : : : ; ffm) = e(xi), where e : `ffii ffi\Gamma ffi `ffii (ff1 \Omega  \Delta  \Delta  \Delta  \Omega  ffm) is obtained
by composing an expansion with appropriate symmetry isomorphisms.

For *-abstraction, given

x1 : `ffi1ff1; : : : ; xm : `ffimffm; y : `ffifi;
` M ffi(ff1; : : : ; ffm; fi) : `0ffi(ff1 \Omega  \Delta  \Delta  \Delta  \Omega  ffm \Omega  fi)

we can form the judgement

x1 : `ffi1ff1; : : : ; xm : `ffimffm;
` \Lambda fi: *y : `ffifi: M ffi(ff1; : : : ; ffm; fi): : 8fi: `fi ! `0(ff1 \Omega  \Delta  \Delta  \Delta  \Omega  ffm \Omega  fi):

We take this as the interpretation of *-abstraction in SCI; it is remarkably simple
compared to the translation for Idealized Algol.

From Algol to Polymorphic Linear Lambda-calculus \Delta  21
The SCI rule for application is of the form

x1 : `1; : : : ; xn : `n ` M : ` ! `0 xn+1 : `1; : : : ; xm : `m ` N : `

x1 : `1; : : : ; xm : `m ` M N : `0 ;

and we define (M N )ffi(ff1; : : : ; ffm) to be\Gamma 

M ffi(ff1; : : : ; ffn)[ffn+1 \Omega  \Delta  \Delta  \Delta  \Omega  ffm]\Delta \Gamma N ffi(ffn+1; : : : ; ffm)\Delta :
In this definition the fi-component of

M ffi(ff1; : : : ; ffn) : 8fi: `ffifi ! `0ffi(ff1 \Omega  \Delta  \Delta  \Delta  \Omega  ffn \Omega  fi)
is instantiated to the type ffn+1 \Omega  \Delta  \Delta  \Delta  \Omega  ffm of the state for N .

For parallel composition, given

x1 : `1; : : : ; xn : `n ` M : comm xn+1 : `1; : : : ; xm : `m ` N : comm

x1 : `1; : : : ; xm : `m ` M k N : comm ;

we translate as follows:

(M k N )ffi(ff1; : : : ; ffm) = *s : ff let [z1; : : : ; zm] be s in\Theta 

M ffi(ff1; : : : ; ffn)[z1; : : : ; zn];

N ffi(ffn+1; : : : ; ffm)[zn+1; : : : ; zm]\Lambda :

This interpretation splits the state into components z1; : : : ; zn and zn+1; : : : ; zm
that are acted upon independently by M and N .

The equations for newcomm and newexp are as in Idealized Algol, except that
the variable v[ff] is replaced by v : (acc \Theta  exp)ffi(nat), given by hassign; lookupi,
where

assign = *[n; m] : nat \Omega  nat: let \Lambda  be (discard n) in m

lookup = * n : nat: copy n.
There is no longer a need for the ff component of v because procedures and arguments don't interfere in Basic SCI.

Finally, expansions for procedure types are defined as follows:

expand`!`0 = \Lambda fffi: *p: \Lambda fl: i ffi expand`0[ff \Omega  fl][fi] ffi p[fl],
where i is an isomorphism as indicated in the following diagram

`ffi(fl)
`0ffi(ff \Omega  fl)

`0ffi((ff \Omega  fi) \Omega  fl)
`0ffi((ff \Omega  fl) \Omega  fi))
6p[fl]

-expand`0[ff \Omega  fl][fi]

-expand
`!`0[ff][fi]p[fl]

?i

Expansions for the primitive types are the same as in Idealized Algol.

There is another candidate definition for expansions at procedure types, based

22 \Delta  P.W. O'Hearn and J.C. Reynolds
on the following diagram.

`ffi(fl)
`ffi(fi \Omega  fl)

`0ffi((ff \Omega  fi) \Omega  fl)
`0ffi(ff \Omega  (fi \Omega  fl))
6expand
`[fl][fi]

-p[fi \Omega  fl]

-expand
`!`0[ff][fi]p[fl]

?i

The equivalence of these two definitions depends on a naturality property for p,
which we will be able to verify later (Theorem 11) using a semantic model of the
linear calculus.

6. THE STRICT PARAMETRICITY MODEL
Having defined the translations we now want to analyze them in more detail. The
approach we take is to look at a simple semantic model of the target language,
and push it as far as possible. This will allow us (in Section 7) to very quickly go
beyond previous functor models [Oles 1982; O'Hearn and Tennent 1995]. Another
possibility for analysis would have been to directly relate contextual equivalence
relations for the source and target languages: A syntactic study along these lines
would be interesting, but is outside the scope of the present paper. Additionally, the
semantic model contains useful information beyond contextual equivalence, which
can be viewed as providing relational reasoning principles, and which leads to representation results.

The model is based on strict continuous functions and relational parametricity;
we call it simply the strict parametricity model. It actually supports Contraction,
though it does not support Weakening. Such a simple model is useful for our purpose, it seems, because problematic examples like snapback in imperative languages
typically use both Weakening and Contraction. Removing just one of Weakening
or Contraction banishes many of these examples.

6.1 Semantics of Types
In the strict parametricity model, types are interpreted as cpo's, i.e., directedcomplete partial orders possessing a least element [Plotkin 1983; Abramsky and
Jung 1994]. Level 1 types will always denote countable, flat cpo's, where there is a
discretely-ordered set of elements arranged just above a least element ?.

More specifically, a type A determines a function [[A]] from type environments
to cpo's, where a type environment D maps type variables to countable, flat cpo's.
Most type constructors are interpreted directly by their cpo counterparts:

[[ff]]D = Dff
[[I]]D = I
[[nat]]D = N?
[[oe \Omega  oe0]]D = [[oe]]D \Omega  [[oe0]]D
[[A &B]]D = [[A]]D &[[A]]D
[[A ! B]]D = [[A]]D ! [[B]]D
[[A\Gamma ffi B]]D = [[A]]D\Gamma ffi [[B]]D
[[!A]]D = ([[A]]D)?:

On the right-hand side I is the two-point cpo, (\Delta )? is lifting, \Omega  is smash product,

From Algol to Polymorphic Linear Lambda-calculus \Delta  23
& is cartesian product, \Gamma ffi is strict continuous function space (pointwise ordered),
and ! is continuous function space.

To define 8 we make use of an auxiliary relational semantics [Reynolds 1983].
Suppose R (a relation environment) is a function mapping each type variable into
a pointed (i.e., h?; ?i-containing) binary relation between flat cpo's, such that

R(ff) : Dff $ D0ff; all ff
for type environments D; D0. Then we define a complete relation

[[A]]R : [[A]]D $ [[A]]D0
as follows. (Completeness means that the relation is closed under lubs of directed
sets in [[A]]D $ [[A]]D0. This condition is needed for recursion to be compatible with
the Logical Relations Lemma, below.)

[[ff]]R = Rff

[[I]]R = fha; ai j a 2 Ig
[[nat]]R = fhn; ni j n 2 N?g
[[oe \Omega  oe0]]R = fh[d; d0]; [e; e0]i j hd; ei 2 [[oe]]R ^ hd0; e0i 2 [[oe0]]Rg

[[A &B]]R = fhhd; d0i; he; e0ii j hd; ei 2 [[A]]R ^ hd0; e0i 2 [[B]]Rg
[[A ! B]]R = fhf; f 0i j 8hd; d0i 2 [[A]]R: hf d; f 0d0i 2 [[B]]Rg

[[A\Gamma ffi B]]R = fhf; f 0i j 8hd; d0i 2 [[A]]R: hf d; f 0d0i 2 [[B]]Rg

[[!A]]R = fhd; ei j hd; ei 2 [[A]]R . d = e = ?g:

The relational actions of ! and \Gamma ffi use the same clauses, the difference being that
the clause for \Gamma ffi assumes that both f and f 0 are strict. In the definition of \Omega , [x; y]
is the least element h?; ?i if x or y is ? and is the pair hx; yi otherwise. We often
refer to the relational action of type constructors directly, for example by writing
R \Omega  S instead of [[ff \Omega  fi]](ff 7! R; fi 7! S).

The relational action of \Omega  deserves comment. A basic justification for the definition is the following two properties that it satisfies:

--If hf; gi 2 R\Gamma ffi S and hf 0; g0i 2 R0\Gamma ffi S0 then hf \Omega  f 0; g \Omega  g0i 2 R \Omega  R0\Gamma ffi S \Omega  S0,
--R \Omega  S\Gamma ffi T ,= R\Gamma ffi (S\Gamma ffi T ).

The first property connects the functorial and relational actions of \Omega , and is needed
for the interpretation of the elimination rule for \Omega  to satisfy relevant parametricity properties (needed for the Logical Relations Lemma below). The second is a
relationship we expect between \Omega  and \Gamma ffi .

Next, note that we do not have the property that

ha; bi\Gamma R \Omega  S\Delta hc; di implies aRc and bSd.
For instance if ?Rc and bSd then h?; ?i\Gamma R \Omega  S\Delta hc; di even when we do not have
?Sd. The property fails because of the use of [\Delta ; \Delta ] in the definition of R \Omega  S.

Finally, a particular subtlety is that the formula for R\Omega S does not always produce
a complete relation, for complete relations R and S on arbitrary cpo's. For example,
consider relations R : N? $ I and S : N? $ V nat where R = fh?; ?i; h?; \Lambda ig and
S = fh?; 0i; h1; 2i; h2; 3i; :::g, and V nat is the vertical natural numbers. Then R\Omega S
contains a chain of all tuples hh?; ?i; h\Lambda ; nii, for n ? 1, but it does not contain the
lub hh?; ?i; h\Lambda ; 1ii. Nevertheless, R \Omega  S is strict and trivially complete whenever

24 \Delta  P.W. O'Hearn and J.C. Reynolds
R and S are strict relations on flat (or finite height) cpo's. In the semantics of our
polymorphic language \Omega  is only ever applied to flat cpo's, so the definition of the
relational action is suitable for this language.

Returning to the definition of the model, we can now define the cpo and relational
semantics for 8. For this, let Level1 stand for the collection of countable, flat cpo's.
A polymorphic function will be an element of an indexed product, indexed by cpo's
in Level1, subject to a relational parametricity condition:

[[8ff:A]]D = fp 2 Qd2Level1[[A]]Djff7!d j

8d; d0 2 Level1 ; 8r : d $ d0: hp[d]; p[d0]i 2 [[A]]IDjff7!r
g;

ordered pointwise

hp; p0i 2 [[8ff:A]]R , 8d; d0 2 Level1 ; 8r : d $ d0: hp[d]; p0[d0]i 2 [[A]]Rjff7!d:
Here ID maps each ff to the identity relation \Delta Dff on Dff. The notation r : d $ d0
indicates that r is a relation between (flat) cpo's d and d0 that relates their least
elements. For the well-definedness of this definition it is crucial that Level1 is
essentially small - there are only set-many countable, flat cpo's (at least up to
isomorphic copies).

With these definitions one may verify that each [[A]]D is a cpo and each [[A]]R is a
complete relation on cpo's. This ensures that the least fixed-point operator exists
in the model.

By "parametric model" we mean a model satisfying the Identity Extension Lemma:

[[A]]ID = fha; ai j a 2 [[A]]Dg:
This is usually taken as the defining characteristic of relational parametricity [Reynolds
1983], and the definition of 8 is arranged precisely to ensure the identity property
(which is included here as part of the Isomorphism Lemma).

Lemma 1. (Isomorphism Functoriality Lemma) For any type A, the relational action of [[A]] is functorial on isomorphisms. That is, (i) if Rff is the graph
of an isomorphism between flat cpo's for each ff free in A then [[A]]R is the graph of
an isomorphism, and (ii) [[A]] preserves identities and composites of isomorphisms.

6.2 Semantics of Terms
A typing judgement

x1 : A1; : : : ; xn : An; y1 : B1; : : : ; ym : Bm ` t : C
is interpreted by a D-indexed family of strict continuous functions

[[t]]D : ([[A1]]D)? \Omega  \Delta  \Delta  \Delta  \Omega  ([[An]]D)? \Omega  [[B1]]D \Omega  \Delta  \Delta  \Delta  \Omega  [[Bm]]D \Gamma ! [[C]]D:
We omit the detailed definition, which is standard, but we do describe the uniformity property of this family. For this, we extend relational actions from types to
typing contexts using the actions for \Omega  and !:

[[x1 : A1; : : : ; xn : An; y1 : B1; : : : ; ym : Bm]]R
= [[!A1]]R \Omega  \Delta  \Delta  \Delta  \Omega  [[!An]]R \Omega  [[B1]]R \Omega  \Delta  \Delta  \Delta  \Omega  [[Bm]]R:

From Algol to Polymorphic Linear Lambda-calculus \Delta  25
Lemma 2. (Logical Relations Lemma) If

\Gamma ; \Delta  ` t : A
Rff : Dff $ D0ff, for all ff
hj; j0i 2 [[\Gamma ; \Delta ]]R,

then

h [[t]]Dj ; [[t]]D0j0 i 2 [[A]]R.
Since logical relations are used to constrain 8 types, the lemma and the welldefinedness of the maps [[t]]D are proven simultaneously by induction on t.

7. WORKING WITH THE MODEL
Our aim in this section is to illustrate how strict, relational parametricity can be
used to reason about types and terms in the source languages. All of the examples
go beyond those that can be treated properly in either the basic functor category
model of Oles [1982] or the parametric functor models of O'Hearn and Tennent
[1995], and Sieber [1996]. (The ability to relate ? to non-? states is responsible
for the improvement over [O'Hearn and Tennent 1995].)

From now on we will often mix notation for polymorphic types and cpo's. For
instance, we write

8fi: (S \Omega  fi\Gamma ffi S \Omega  fi) ! (S \Omega  fi\Gamma ffi S \Omega  fi)
instead of the more cumbersome

[[8fi: (ff \Omega  fi\Gamma ffi ff \Omega  fi) ! (ff \Omega  fi\Gamma ffi ff \Omega  fi)]](ff7!S):
Similarly, we write M ?S and M ffiS to indicate functions, and `?S and `ffiS to
indicate cpo's, obtained by composing the translations with the semantics of the
linear langauge.

7.1 Snapback
Example 1. We consider a snapback operator of type

8ff: (ff\Gamma ffi ff \Omega  nat) ! (ff\Gamma ffi ff \Omega  nat):
Were it to exist in the model, this operator would satisfy the property

snap[S]e s = ae hs; ni if e(s) = hs

0; ni

? if e(s) = ?

for countable flat cpo's S and s 2 S. We show that snap is not parametric.

Consider any p 2 [[8ff: (ff\Gamma ffi ff \Omega  nat) ! (ff\Gamma ffi ff \Omega  nat)]]. We show the following
property (where 2 = f0; 1g):

If e : 2?\Gamma ffi 2? \Omega  N? is such that e(s) = h1; 1i when s 6= ?,
and p[2?]e0 = h0; 1i
then p[2?]?0 = h0; 1i.

This property says that if you use e at all, the final state can no longer be 0: Using
e causes an irreversible state change.

26 \Delta  P.W. O'Hearn and J.C. Reynolds

To prove the property, suppose the two assumptions hold for p and e, and consider
the relation R : 2? $ 2? consisting of tuples h0; 0i, h?; ?i, h1; ?i. Then he; ?i 2
[R\Gamma ffi R \Omega  \Delta N?] and by parametricity hp[2?]e0; p[2?]?0i 2 R \Omega  \Delta N?. Since h0; 1i is
only R \Omega  \Delta N?-related to itself the property follows.

In contrast, the property is not satisfied by snap because snap[2?]?0 = ?, even
though we will have snap[2?]e0 = h0; 1i for any e satisfying the first assumption
in the property. Thus, snap does not exist in the model.

The argument for the non-parametricity of snapback is, in fact, a transcription of
the failure of Weakening in the category of cpo's and strict functions. Specifically,
for any cpo D there is a candidate Weakening map wD : D\Gamma ffi I that takes ? to ?
and all other elements of D to the non-? element of I. Though this map exists for
all D, it is not natural, in that

D

E

I
?
f

-wD

jj

jj

j3

wE

does not commute when f takes a non-? element to ?. Re-expressing this in
relational form, using the graph of such an f , shows that the family wD of maps,
indexed by countable, flat cpo's D 2 Level1, is not in [[8ff: ff\Gamma ffi I]].

The failure of the naturality of this Weakening map is reminiscent of our contention that it is general, or polymorphic, snapback that does not exist in Algol,
whereas specific state changes can often be reversed.

Example 2. The reasoning in Example 1 can be used more positively, to verify
the snaptester equivalence from the Introduction:

new x: x := 0; p(x := x + 1); if (x ? 0) then diverge j p(diverge):
To show the equivalence we argue that the translations

(2) *s : ff: let [s0; n0] be p[nat](idff \Omega  *n: n + 1)[s; 0]

in let [s00; n00] be (if n0 ? 0 then \Omega  s0 else s0)

in (let \Lambda  be (discard n00) in s00) : ff\Gamma ffi ff

and

(3) *s : ff: let [s0; n] be p[I](\Omega (ff\Omega I)\Gamma ffi (ff\Omega I)) [s; \Lambda ] in

let \Lambda  be (discard n) in s0

are equivalent, where

p : 8fi: (ff \Omega  fi\Gamma ffi ff \Omega  fi) ! (ff \Omega  fi\Gamma ffi ff \Omega  fi).
Let S be a countable, flat cpo (the denotation of ff) and consider the relation
R : N? $ I consisting of the tuples h?; ?i, h0; \Lambda i, and hi; ?i for i ? 0. Let
c : S \Omega  N?\Gamma ffi S \Omega  N? be idS \Omega  succ, where succ is the strict extension of successor.
Then

hc; ?i 2 \Delta S \Omega  R\Gamma ffi \Delta S \Omega  R:
As a result, for arbitrary p we can use the parametricity property to get

hp[N?]c[s; 0] ; p[I]?[s; \Lambda ]i 2 \Delta S \Omega  R:

From Algol to Polymorphic Linear Lambda-calculus \Delta  27
Next, for any s 2 S suppose that p[N?]c[s; 0] = [s0; n] and p[I]?[s; \Lambda ] = [s00; x].
Using h[s0; n]; [s00; x]i 2 \Delta S \Omega  R we can argue that (2)=(3) by cases as follows:

--If [s0; n] = ? then [s00; x] = ? by the definition of R and \Omega , and so (2)s=(3)s.
--If p[N?]c[s; 0] = [s0; n] 6= ? then there are two subcases.

--If n = 0 then, by the definition of R, we must have that [s00; x] = [s0; \Lambda ] and

obviously (2)s=(3)s, since both will, when beginning in state s, return s0.
--If n ? 0 then we know that (2) applied to s returns ?. But since n ? 0 we

know, from the definition of R and parametricity, that [s00; x] = ?, and so both
(2) and (3) return ? when started in state s.

Many other equivalences can be treated using this form of reasoning. Typically,
one finds a relation between pieces of local state and implementations of different
objects. For example, to show the equivalence of two counter classes

*p: new * x: x := 0; j *p: new * x: x := 0;

p(x := x + 1; x) p(x := x + 2; x=2)

for p : comm \Theta  exp ! comm, we simply use a relation on their local states
R : N? $ N? consisting of h?; ?i and all pairs hi; 2ii. This example (taken from
[O'Hearn and Tennent 1995]) indicates that the strict-function model provides an
extension of the reasoning methods presented there.

Example 3. Since the cpo model of PCF contains functions such as "parallel or,"
[Plotkin 1977] one might expect similar functions to arise in the model here. But,
in the presence of side effects, if we are to evaluate two arguments in parallel then
indeterminacy typically results, unless we use snapback. For example, a "parallel
or" function of type (exp ! exp ! exp)ffiI in SCI would be determined by a
function of type

8fffi: (ff\Gamma ffi ff \Omega  nat)&(fi\Gamma ffi fi \Omega  nat) ! (ff \Omega  fi\Gamma ffi ff \Omega  fi \Omega  nat)
with the following defining property:

por[S1][S2]he1; e2i [s1; s2] = 8!:

hs1; s2; 0i if 9s01: e1(s1) = hs01; 0i

. 9s02: e2(s2) = hs02; 0i
? otherwise

This function is not parametric, because por[I][-]h?; -i would essentially be the
unary snapback which, as we saw in Example 1, is not parametric. Note here
that the condition 9s01: e1(s1) = hs01; 0i is testing whether running e1 results in
termination with result 0, and possibly some state change; it, and the other disjunct,
are false in the case of non-termination and also in the case of producing a result
other than 0.

A more subtle form of parallelism and snapback, which is not correctly treated
by the model, will be considered at the end of this section.

7.2 Sample Type Analyses
Example 4. The polymorphic type (comm ! comm)?I corresponds to closed
terms of type comm ! comm in Idealized Algol. We can calculate its structure

28 \Delta  P.W. O'Hearn and J.C. Reynolds
as follows:

(comm ! comm)?I
= 8fi: ((I \Omega  fi)\Gamma ffi (I \Omega  fi)) ! ((I \Omega  fi)\Gamma ffi (I \Omega  fi)),
= 8fi: (fi\Gamma ffi fi) ! (fi\Gamma ffi fi),
= N?;

where the last isomorphism uses a parametricity argument in the strict-function
model. On the level of Idealized Algol, we obtain a correspondence

n 7! *c : comm: cn
? 7! *c : comm : diverge;

where c0 = skip and ci+1 = c; ci. This representation of comm ! comm should
be compared to that of O'Hearn and Tennent [1995], where (comm ! comm)I is
N? \Omega  V natop, with V natop the vertical natural numbers flipped upside-down. The
V nat component was concerned exclusively with a form of snapback.

It is instructive to examine the parametricity argument giving the final isomorphism with N?. (It is in fact the usual parametricity argument for Church numerals
[Plotkin 1980; Reynolds 1983], extended to take appropriate care of the presence
of ?.) Let p 2 [[8fi: (fi\Gamma ffi fi) ! (fi\Gamma ffi fi)]] and consider any flat cpo D, d 2 D, and c :
D\Gamma ffi D. Let R : N? $ D be the relation consisting of pairs h?; ?i and hm; cm(d)i.
Then hsucc; ci 2 R\Gamma ffi R and, by parametricity, (p[N?] succ 0) R (p[D] c d). Next,
if (p[N?] succ 0) = ? then the definition of R ensures that (p[D] c d) = ?, and
so p = ?. And if (p[N?] succ 0) = n 6= ? then the definition of R ensures that
(p[D] c d) = cnd, and so p is the n'th Church numeral. We may conclude that
[[8fi: (fi\Gamma ffi fi) ! (fi\Gamma ffi fi)]] is isomorphic to N?.

In this argument note that R is strict and single-valued. Note also that n is
related to ? when cnd = ?. In [O'Hearn and Tennent 1995], relations that relate
? to non-? elements were not considered, which is why this argument could not
go through.

Example 5. The SCI interpretation (comm ! comm)ffiI turns out to be the
same as (comm ! comm)?I. However, when we replace I by a non-trivial flat
cpo S a difference appears. We calculate

(comm ! comm)ffiS
= 8fi: (fi\Gamma ffi fi) ! ((S \Omega  fi)\Gamma ffi (S \Omega  fi)),
= S\Gamma ffi (S \Omega  N?);

where the last isomorphism is again a straightforward parametricity argument. In
the cpo S\Gamma ffi (S \Omega  N?), the N? part corresponds to use of the fi-component, the
number of times the command argument is executed (so this part is essentially a
Church numeral). This cpo illustrates how the computation on the S and fi components can be carried out independently: The input state can affect the number of
times the command argument is used, but not what happens on each use. Equally,
none of the uses of the command argument affects the S-component, which is why
there is a single transformation from input state to output that is independent of
fi. This independence is reflected in certain equivalences between terms, such as
between procedures *c: c; x := 1 and *c: x := 1; c of type comm ! comm.

From Algol to Polymorphic Linear Lambda-calculus \Delta  29
The same type in Idealized Algol translates as follows:

(comm ! comm)?S
= 8fi: (S \Omega  fi\Gamma ffi S \Omega  fi) ! ((S \Omega  fi)\Gamma ffi (S \Omega  fi)):

The representation in terms of S\Gamma ffi (S \Omega  N?) no longer works due to the possibility
of interference between procedure and argument in Idealized Algol. For instance,
the terms *c: c; x := 1 and *c: x := 1; c can be now distinguished by being applied
to an argument that interferes with x.

An explicit description of the cpo for (comm ! comm)?S can be given in terms
of resumptions. This will be presented as a special case of a representation result
in Section 10.1.

Example 6. Next we consider a type for functions with two arguments:

(comm \Theta  comm ! comm)?I,
= 8fi: (fi\Gamma ffi fi)&(fi\Gamma ffi fi) ! (fi\Gamma ffi fi),
= (listf1; 2g)?:

A list ` of 1's and 2's corresponds to *c : comm \Theta  comm : c`, where cffl = skip and
ci;` = (ssic); c`, for i = 1; 2 and i; ` is the cons of i onto `. The parametricity argument showing the last isomorphism is essentially the same as in Example 4. With
this representation we can see which argument an element of this type evaluates
first: i; ` evaluates the i'th argument.

Example 7. Two-argument curried functions in SCI are less rigidly sequential, in
that it is not necessary for one argument to be evaluated first:

(comm ! comm ! comm)ffiS,
= 8fifl: (fi\Gamma ffi fi)&(fl\Gamma ffi fl) ! (S \Omega  fi \Omega  fl\Gamma ffi S \Omega  fi \Omega  fl),
= S\Gamma ffi (S \Omega  N? \Omega  N?):

In this case computation in the fi, fl, and S components can all be carried out
independently, being again Church numerals in fi and fl. If we consider the case
where S = I, then we obtain a correspondence between N? \Omega  N? and closed SCI
terms of type comm ! comm ! comm:

hn; mi 7! *c1: *c2: cn k cm
? 7! *c1: *c2 : diverge:

In contrast to Example 6, the evaluations of the two command arguments can
proceed completely independently, in parallel.

7.3 A Limitation of Binary, Strict Parametricity
Independence from evaluation order in SCI gives rise to examples that require
stronger principles than binary relational parametricity to treat correctly.

Example 8. We define a function rotate in the denotation of the type

8ff1ff2ff3: (ff1\Gamma ffi ff1 \Omega  nat)&(ff2\Gamma ffi ff2 \Omega  nat)&(ff3\Gamma ffi ff3 \Omega  nat)

\Gamma ! (ff1 \Omega  ff2 \Omega  ff3\Gamma ffi ff1 \Omega  ff2 \Omega  ff3 \Omega  nat)

30 \Delta  P.W. O'Hearn and J.C. Reynolds
This type is isomorphic to (exp ! exp ! exp ! exp)ffiI. The definition is

rotate[S1; S2; S3]hc1; c2; c3i[s1; s2; s3]

= 8??!??:

[s01; s02; s3; 0] if c1s1 = [s01; 0] 6= ? ^ c2s2 = [s02; 0] 6= ?
[s1; s02; s03; 1] if c2s2 = [s02; 1] 6= ? ^ c3s3 = [s03; 1] 6= ?
[s01; s2; s03; 2] if c1s1 = [s01; 2] 6= ? ^ c3s3 = [s03; 2] 6= ?
? otherwise

Informally, to evaluate rotate we begin by evaluating its three arguments in parallel. Of the three possible rightmost conditions above only one can apply. If it is
the first, then we return the altered states s01 and s02, while leaving s3 unchanged.
Similarly we leave s1 unchanged in the second case and s2 in the third. Intuitively,
this involves a form of snapback in each argument. Nevertheless, rotate does exist
in the model. (We leave the verification of parametricity conditions as an exercise.)

This example shows a limitation of the strict-function model of the polymorphic
calculus, and of the corresponding model of Basic SCI. In particular, because of
the example we would not expect a result to the effect that the syntactic type
(exp ! exp ! exp ! exp)ffiI is, in the model, characterized by SCI-definable
elements: It seems reasonably clear that rotate is not definable in the linear language
(though a rigorous proof would be very involved).

Although this points to a limitation in the strict parametricity model, it does
not indicate a problem in our syntactic translation. We believe that the elements
of the cpo (exp ! exp ! exp ! exp)ffiI that are definable by source and target
language terms are the same. Furthermore, it appears that these definable elements
(and their lubs) form a cpo that is isomorphic to the cpo N \Lambda  \Theta  N \Lambda  \Theta  N \Lambda  !s N?
of Kahn-Plotkin sequential functions, where N \Lambda  is a stream cpo.

The rotate function is a variation on Berry's [1978] example of a stable function
that is not sequential. It came to our attention in the context of SCI because of
Reddy's coherence space model, where a version of it is also present. This indicates
that neither model fully accounts for sequentiality, or for the absence of snapback.
Reddy has suggested that one might hope that the approach to sequentiality using
games [Abramsky et al. ; Hyland and Ong 1994] might help to resolve this issue.
Another possibility would be to use a stronger form of parametricity based, perhaps,
on Kripke relations, which have also proven useful in approaching sequentiality
[O'Hearn and Riecke 1995; Riecke and Sandholm 1997].

8. RELATION TO FUNCTOR MODELS
While we have said that our translations are based on functor-category models, the
precise relationship to them may not be obvious. In particular, the translation for
Idealized Algol relies on special properties of the functor-category model defined
by Oles [1982, 1997], and does not use standard structure found in all functor
categories. Furthermore, the translation for Basic SCI is unusual, in that each
identifier is associated with a separate store shape. In this section we describe the
ingredients allowing connections between the polymorphic and functor-category
forms of semantics to be drawn.

For Idealized Algol we define a logical relation between our model and the functorFrom Algol to Polymorphic Linear Lambda-calculus \Delta  31
category model of Oles (allowing for side effects in expressions). The logical relation
establishes that our model agrees with Oles's on the meanings of closed terms of
primitive type. A corollary of this is a computational adequacy result, connecting
the model to an operational semantics for Idealized Algol. Interestingly, parametricity is not needed for this connection to be made, and it goes through for a
model in which 8 is simply an indexed product. For Basic SCI we relate the style
of interpretation where each identifier is associated with a separate store shape to
a notion of multi-map between functors.

It would be helpful to have some familiarity with functor-category models here.
In the next section we return to an analysis of the translations in their own right.

8.1 Idealized Algol
We recall the category \Sigma  of store shapes [Oles 1982; Oles 1987].

--The objects are countable sets.
--The morphisms from W to X are pairs of set-theoretic functions

' : X ! W; ae : W \Theta  X ! X such that

(1) 8x 2 X: aeh'(x); xi = x;
(2) 8x 2 X: 8w 2 W: '(aehw; xi) = w;
(3) 8x 2 X: 8w; w0 2 W: aehw; aehw0; xii = aehw; xi:

The propotypical example is the "expansion" morphism ('; ae): W ! W \Theta  Y where
W \Theta  Y is the set-product, ' is the first projection and aehw0; hw; yii = hw0; yi. The
composite of morphisms ('; ae): W ! X and ('0; ae0): X ! Y is ('00; ae00): W ! Y
such that '00 = '0; ' and ae00hw; yi = ae0haehw; '0(y)i; yi. The identity morphism on
W is ('; ae) such that '(w) = w and ae(w; w0) = w. ('; ae) is an isomorphism iff ' is
a bijection.

Let Predom denote the category of predomains (possibly bottomless cpo's) and
continuous functions. The functor category Predom\Sigma  is Cartesian closed. In fact,
PredomC is Cartesian closed, for any small category C: The internal hom can be
given in a standard way using the definition

(F ) G)X = PredomC[C[X; -] \Theta  F; G]: (Standard Definition)
(Note that this formula is covariant in X, which gives the action on morphisms.)
However, in the case that C = \Sigma  a factorization of morphisms shown by Oles allows
the internal hom to be calculated in a special way.

Lemma 3. (Expansion Factorization Lemma) Any morphism ('; ae) : X !
Y in \Sigma  factors as an expansion followed by an isomorphism X e! X \Theta  Z i! Y .

Lemma 4. (Exponent Representation Lemma) The internal hom ) in
Predom\Sigma  is such that

(F ) G)X ,= Predom\Sigma [F (X \Theta  -); G(X \Theta  -)]; ordered pointwise
for any functors F; G : \Sigma  ! Predom and any countable set X. (We are using
X \Theta  - to denote the evident endofunctor on \Sigma ; but note that \Theta  is not the categorical
product in \Sigma .)

32 \Delta  P.W. O'Hearn and J.C. Reynolds
Proof: The proof of the Factorization Lemma is in [Oles 1982]; we sketch why the
Representation Lemma follows from it. Any p 2 (F ) G)X accepts a store shape
Y and a pair (('; ae) : X ! Y; a 2 F Y ) as arguments, and produces a result in GY .

Using Oles's lemma, we can factor ('; ae) into a composite X e! X \Theta  Z i! Y . By
functoriality F (i\Gamma 1) and Gi are both isomorphisms, where i\Gamma 1 is the isomorphism
inverse to i. By naturality for the isomorphisms, p[Y ](('; ae); a) must be equal
to Gi(p[X \Theta  Z](e; (F i\Gamma 1)a). Thus, we can see that p is completely determined
by its action on expansions, and this leads in a straightforward fashion to the
representation result.

Notice that the formula for the internal hom in the Representation Lemma is formally similar to the translation of function types in Idealized Algol. With this it is
possible to establish a connection with the translation (\Delta )?, which we now outline.

First, given the Representation Lemma, we might as well define the internal hom
as

(F ) G)X = Predom\Sigma [F (X \Theta  -); G(X \Theta  -)]: (Alternate Definition)
If e : X ! X \Theta  Y is an expansion then the required functorial action of F ) G is
given (suppressing associativity isomorphisms) by

((F ) G)e p)[W ] = p[Y \Theta  W ] : F (X \Theta  Y \Theta  W ) ! G(X \Theta  Y \Theta  W ):
If i : X ! Y is an isomorphism then

((F ) G)i p)[W ] = F (i \Theta  W )\Gamma 1; p[W ]; G(i \Theta  W );
and the functorial action for arbitrary \Sigma -morphisms is then obtained from the
Expansion Factorization Lemma.

In order to interpret recursion we need to work in the full subcategory whose
objects are functors F where [Oles 1982]: (i) F X has a least element, for each store
shape X, and (ii) F ('; ae) preserves least elements, for each \Sigma -morphism ('; ae). All
of the objects we mention will in fact lie in this subcategory.

We can now define a functor O[[`]] for each Idealized Algol type `. (The product
F \Theta  G of functors is defined pointwise as usual.)

O[[comm]]W = W?\Gamma ffi W?
O[[comm]]('; ae)cs = ae ? if s = ? or c('s) = ?aehc('(s)); si otherwise

O[[acc]]W = W? \Omega  N?\Gamma ffi W?
O[[acc]]('; ae)chs; ni = ae ? if s = ? or c[('s); n] = ?aehc['(s); n]; si otherwise

O[[exp]]W = W?\Gamma ffi W? \Omega  N?
O[[exp]]('; ae)es = ae ? if s = ? or e('s) = ?aehae(s; s0); ni when hs0; ni = e('s)

O[[` ! `0]] = O[[`]] ) O[[`0]]
O[[` \Theta  `0]] = O[[`]] \Theta  O[[`0]]

From Algol to Polymorphic Linear Lambda-calculus \Delta  33
The morphism part of O[[comm]] appears, at first sight, to be nonlinear in the store,
where s is copied. Apart from the fact that the two occurrences of s are in different
arms of a pairing for a categorical product h\Delta ; \Delta i, this is not a problem because
when ('; ae) is an expansion the "otherwise" clause of the definition is equivalent to
aehcx; yi, and this is what we use in the translation to linear *-calculus.

Now we set up a logical relation between (\Delta )? and O[[\Delta ]], the former understood in
terms of the strict parametricity model. For each type ` and countable set X, we
define a relation

RX` ` `?X? \Theta  O[[`]]X:
For ` = comm, acc or exp, RW` is an identity relation, and product types use the
obvious pointwise definition. For procedures,

hp; qi 2 RX`!`0 () 8W: ha; bi 2 RX\Theta W` ) hp[W?]a; q[W ]bi 2 RX\Theta W`0 :
We define RX\Gamma  by viewing a type assignment \Gamma  as a product as usual.

Lemma 5. Each RX` is a pointed, complete relation.
Lemma 6. (Expansion Relatedness Lemma) If ha; bi 2 RX` then

h(expand`[X?][Y?]a); (O[[`]](e)b)i 2 RX\Theta Y` ;
where e : X ! X \Theta  Y is the expansion in \Sigma .
The proof of the Expansion Relatedness Lemma is straightforward, as the definition
of expand` merely copies the definition of O[[`]]e in the functor category.

Each judgement \Gamma  ` M : ` in Idealized Algol is interpreted as a natural transformation

O[[M ]] : O[[\Gamma ]] :! O[[`]]:
The interpretations are essentially as in the translations (\Delta )?, except that we use
environment manipulations in place of substitution. Representing environments u 2
O[[\Gamma ]]X as functions from identifiers to appropriately-typed values, representative
equations are:

O[[M ; M 0]]W us = O[[M 0]]W u(O[[M ]]W us)

O[[*x : `: M ]]W u[X]d = O[[M ]](W \Theta  X) ((O[[\Gamma ]]f u) j x 7! d)

O[[M (M 0)]]W u = h(O[[M ]]W u[I](iO[[M 0]]W u))

O[[newcomm M ]]W uw = ae w

0 if O[[M ]]W u[N ]v[w; 0] = [w0; n]

? if O[[M ]]W u[N ]v[w; 0] = ?:
In these definitions, i and h are suitable isomorphisms, f : W ! W \Theta  X is the
expansion morphism, N is the set of natural numbers. The standard local variable v
is ha; ei, where e : (X \Theta N )?\Gamma ffi ((X \Theta N )\Theta N )? and a : ((X \Theta N )\Theta N )?\Gamma ffi (X \Theta N )?
are the unique strict functions such that

ehx; ni = hhx; ni; ni, and
ahhx; ni; mi = hx; mi.

(Notice that a and e are obtained by lifting ae and ' from the expansion map
('; ae) : X ! X \Theta  N in the category \Sigma .)

34 \Delta  P.W. O'Hearn and J.C. Reynolds

Lemma 7. Suppose \Gamma  ` M : ` in Idealized Algol, and that hu; u0i 2 RX\Gamma  . Then
h(M ?X? u); (O[[M ]]X u0)i 2 RX` .

Proof: By induction on M . We indicate the key cases of new and *-abstraction.

For new'(M ), by induction we know that hp; qi 2 RXvar!', where p is the denotation of M in the strict parametricity model and q in the Oles model. new'(M )
is defined in the models by supplying local variables v and v0 to p and q, and deallocating on termination. Clearly, by the definition of R for procedure types, this
case will hold if we can show that the two standard variables are in relation RX\Theta Nvar ,
and this is easy to check from their definitions above and in Section 5.

For the case \Gamma  ` *x : `: M : ` ! `0, suppose hd; d0i 2 RX\Theta Y` . We need to show

that hm; m0i 2 RX\Theta Y`0 , where

m = ((M ?(ff \Omega  fi))[expand`i [ff][fi]xi=xi])(ff 7! X?; fi 7! Y?)(u j x 7! d),
m0 = O[[M ]](X \Theta  Y )(O[[\Gamma ]]eu0jx 7! d0).

Here, e : X ! X \Theta  Y is the expansion, m is the translation of a *-abstraction, applied in the strict parametricity model to an appropriate world Y? and argument d0,
and m0 is obtained from the meaning of *-abstraction in the functor category. Using a substitution lemma for the parametricity model of the linear lambda-calculus
we can infer

m = (M ?(X? \Omega  Y?)(xi 7! (expand?`i[X?][Y?](uxi)) ; x 7! d).
Further, (O[[\Gamma ]](e)u0jx 7! d0) is of the form (xi 7! O[[`i]]e(u0xi); x 7! d), so we know
that the environments (xi 7! (expand?`i[X?][Y?](uxi)) ; x 7! d) and ([[\Gamma ]](e)u0jx 7!

d0) are RX\Theta Y\Gamma ;x:`0-related, using the Expansion Relatedness Lemma and the assumptions that u and u0, and d and d0, are related. We can then use the induction
hypothesis to conclude that m and m0 are related.

At primitive types this lemma reduces to the following.
Proposition 8. (Adequacy with Oles's Model) If ` M : ' in Idealized
Algol then M ?X? = O[[M ]]X.

Furthermore, Lent [1993] has verified that Oles's model satisfies an adequacy correspondence with a suitable operational semantics, to the effect that a closed term
of command type converges operationally iff it does not denote ? (and the proof
carries through equally in the presence of expressions with side effects). Thus, adequacy with respect to Oles's model establishes also adequacy with respect to a
standard operational semantics. Note that parametricity has not been used thus
far in this section, and the adequacy result would go through for the unconstrained
model of polymorphism, where 8 is simply indexed product over countable, flat
cpo's.

The logical relation, however, contains more information than required for adequacy, which will be put to use in some technical lemmas at the end of the next
section.

8.2 Basic SCI
It is not difficult to interpret SCI in Predom\Sigma , by mimicking (\Delta )ffi, and to verify an
adequacy correspondence as was done for Idealized Algol. Rather than do this, we

From Algol to Polymorphic Linear Lambda-calculus \Delta  35
want to relate the somewhat unusual form of interpretation, where each identifier
gets a separate piece of the store, to structure found in the functor category; see
also [O'Hearn et al. 1999].

First, recall the translation of the SCI function type:

(` ! `0)ffiff = 8fi: `ffifi ! `0ffi(ff \Omega  fi):
We can rewrite this in functorial form as follows: If G; F : \Sigma  \Gamma ! Predom are
functors, then the functor GF is defined by the equation

(GF )X = Predom\Sigma [F (-); G(X \Theta  -)]; ordered pointwise:
This formula is covariant in X, which gives the action on morphisms.

What is the sense in which GF is a function type? One way to explain this would
be to find a tensor product of functors satisfying the usual adjunction property

Predom\Sigma [E \Omega  F; G] ,= Predom\Sigma [E; GF ]:
In fact, GF is precisely the exponent of functors described by Day [1970], who also
gives a recipe for obtaining the required tensor products.

Another, for our purposes more direct, way is to proceed is to look explicitly at
maps of multiple arity.

Definition 9. Suppose F1; : : : ; Fn and G are functors in Predom\Sigma . A multimap

j : F1; : : : ; Fn \Gamma ! G
is a family of continuous functions

j[X1; : : : ; Xn] : F1X1 \Theta  \Delta  \Delta  \Delta  \Theta  FnXn \Gamma ! G(X1 \Theta  \Delta  \Delta  \Delta  \Theta  Xn)
natural in store shapes X1; : : : ; Xn. (In case n = 0 a multi-map is a function from
a one-point cpo to G(1), for 1 a one-point set.)

The connection between multi-maps and GF is immediate from the definitions.

Proposition 10. Given functors F1; : : : ; Fn, F and G, multi-maps

j : F1; : : : ; Fn; F \Gamma ! G
are in bijective correspondence with multi-maps

j : F1; : : : ; Fn \Gamma ! GF .
Proposition 10 could be restated in more abstract terms by saying that functors
in Predom\Sigma , together with multi-maps, comprise a closed multi-category [Lambek
1989]. We regard this as a kind of categorical justification for, or commentary on,
the form of the translation of SCI.

At this point the reader may be wondering why we arranged the (\Delta )ffi translation
in this multi-map form: It would be more standard to follow the structure of a
monoidal closed category, where we would interpret a term using a map out of a
tensor product. There are two reasons. First, explicitly associating a different piece
of local state with each identifier is very appealing, as it directly models the idea
that distinct identifiers don't interfere. Second, it is not clear to us how to describe
Day's tensor product of functors in polymorphic linear *-calculus. As a result, if
we were to add types ` \Omega  `0 of noninterfering pairs to SCI, it would not be evident
how to interpret them in the linear calculus.

36 \Delta  P.W. O'Hearn and J.C. Reynolds
9. ON NATURALITY AND PARAMETRICITY
We have seen a close relationship between our translations and semantic equations
in a functor-category model. The main difference is that functor models require
meanings to be natural with respect to expansions, where in the strict parametricity
model we use binary relational parametricity. In this section we explore circumstances under which the former is implied by the latter. We begin by considering
SCI, where the situation is simpler.

9.1 Basic SCI
In SCI, parametricity implies naturality at all types.

Theorem 11. (Naturality Theorem for SCI) Any p 2 (`1 ! `2)ffiS is natural with respect to expansions: for all flat cpo's S1 and S2,

`ffi1(S1)

`ffi1(S1 \Omega  S01)

`ffi2(S \Omega  S1)
`ffi2(S \Omega  S1 \Omega  S01)?
expand`

1[S1][S01]

-p[S1]

-p[S
1 \Omega  S01]

?expand

`2[S \Omega  S1][S01]

(where we have elided canonical isomorphisms (S \Omega  S1) \Omega  S2 $ S \Omega  (S1 \Omega  S2)).
Proof: First, it is easy to see that the result holds for `1 ! (`2 \Theta  `3) iff it holds
for `1 ! `2 and `1 ! `3. By an inductive argument we obtain that it suffices to
prove the result for types of the form

`1 ! (`2 ! \Delta  \Delta  \Delta  (`n ! ') \Delta  \Delta  \Delta ):
We prove it for ' = comm; the cases of acc and exp are similar. Also, to keep
things simple, we give the proof for the case n = 2. This case shows the key role of
disjointness between arguments in the proof, and is easily extended to other n.

We are required to show that (a)=(b), where

(a) = p[S1 \Omega  S01]\Gamma expand`1 [S1][S01]a1\Delta [S2]a2 [s; s1; s01; s2]
(b) = \Gamma expand`

2!comm[S \Omega  S1][S01](p[S1]a1)\Delta [S2]a2 [s; s1; s01; s2]

for all S2, [s; s1; s01; s2] 2 S \Omega  S1 \Omega  S01 \Omega  S2, a1 2 `ffi1S1 and a2 2 `ffi2S2. It is crucial
here that a2 lives in store shape S2, which is separate from the S01 component; this
allows us to use a relation that fixes S01 below.

By the definition of expand for procedure types, (b) is equal to

(c) = [q; q1; s01; q2], where p[S1]a1[S2]a2[s; s1; s2] = [q; q1; q2].
Let R : S1 \Omega  S01 $ S1 be the relation that fixes s01, i.e. it contains h?; ?i and all
pairs h[x; s01]; xi where x 6= ?. By the Identity Extension property (a special case
of the Isomorphism Functoriality Lemma) we know that

(d) ha1; a1i 2 `ffi1\Delta S1 and ha2; a2i 2 `ffi2\Delta S2 .
Further, we claim that

(e) h(expand`1 [S1][S01]a1); a1i 2 `ffi1R.

From Algol to Polymorphic Linear Lambda-calculus \Delta  37
Postponing the proof of (e) for a moment, (d), (e), and parametricity of p imply
that (a) and [q; q1; q2] are \Delta S \Omega  R \Omega  \Delta S2-related, and hence by the definition of R
that (a)=(c). Since (b)=(c) we obtain the desired result (a)=(b).

Property (e) follows from parametricity of expand`

1 : 8fi8fl: `ffi1fi\Gamma ffi `ffi1(fi \Omega  fl).Specifically, we noted ha

1; a1i 2 `ffi1\Delta S1 in (d), and taking R0 : S01 $ I as the
relation containing h?; ?i and hs01; ?i, we obtain

(f) h(expand`1 [S1][S01]a1); (expand`1[S1][I]a1)i 2 `ffi1(\Delta S1 \Omega  R0).
Now, R is equal to the composition of \Delta 1 \Omega  R0 : S1 \Omega  S01 $ S1 \Omega  I with the canonical isomorphism S1 \Omega  I $ S1. We can then use Isomorphism Functoriality and
parametricity of expand`1 once more (with respect to this canonical isomorphism)
to obtain (e) from (f).

Similarly, we can show that the interpretation

x1 : `ffi1ff1; : : : ; xm : `ffimffm ` M ffi(ff1; : : : ; ffn) : `ffi(ff1 \Omega  \Delta  \Delta  \Delta  \Omega  ffm):
of a judgement satisfies a naturality property corresponding to Definition 9.

9.2 Idealized Algol
The proof of the Naturality Theorem for SCI relies on the simpler interpretation
of function types, where the state for procedures and arguments is separate. In
Idealized Algol, we have only been able to verify the corresponding result for types
of a specific form.

Theorem 12. (Naturality Theorem for Idealized Algol) If ' is a primitive
type then any p 2 (`1 ! ')?S is natural with respect to expansions:

`?1(S \Omega  S1)

`?1(S \Omega  S1 \Omega  S01)

'?(S \Omega  S1)
'?(S \Omega  S1 \Omega  S01)?
expand`1[S \Omega  S1][S01]

-p[S1]

-p[S
1 \Omega  S01]

?expand

'[S \Omega  S1][S01]

(where we have elided canonical isomorphisms (S \Omega  S1) \Omega  S01 $ S \Omega  (S1 \Omega  S01)).

The proof can follow the proof of Naturality Theorem in [O'Hearn and Tennent
1995], and is essentially similar to the case of ` ! ' in the proof of Naturality for
SCI. The reason that the SCI proof does not generalize can be seen in the case `1 !
`2 ! comm. In Idealized Algol the application p[S1 \Omega  S01](expand[S1][S2]a1)[S2]a2
uses an element a2 2 `?2(S \Omega  S1 \Omega  S01 \Omega  S2) that can change members of S01, thus
preventing the use of a relation that fixes the S01 component in the proof.

In [O'Hearn and Tennent 1995], Section 9, there was a counterexample to "parametricity implies naturality," which showed that this result failed to hold with '
replaced by arbitrary `. But the counterexample there used Weakening and Contraction and does not exist in the strict parametricity model. As a result, using
the representation in the Resumption Theorem in Section 10.1, we have been able
to slightly extend Theorem 12 to cases where ' is replaced by a first-order type
'1 \Theta  \Delta  \Delta  \Delta  \Theta  'n ! '. The question of whether it holds for all types remains open.

Naturality is important, e.g., for proving the isomorphism `1 \Theta  `2 ! `3 ,= `1 !
`2 ! `3 that is characteristic of Cartesian closed categories. So, even though we

38 \Delta  P.W. O'Hearn and J.C. Reynolds
have the adequacy result above, we have not verified the indicated CCC isomorphism at higher types in Idealized Algol.

Interesting though the open question may be, it does not pose a fundamental
problem for our semantics, as it can be dealt with in at least two ways. First,
every Idealized Algol type can be converted to a "canonical form" of a product of
types of the form ` ! ', and we could simply use an uncurried presentation of
the semantics of types (as in [O'Hearn and Tennent 1995], Section 2). The second
option is to add naturality as an explicit additional requirement (as in [O'Hearn
and Tennent 1995], Section 7). In either case, we get an interpretation of Idealized
Algol using CCC structure, and satisfying all the laws of the typed *-calculus. Since
these two alternatives are thoroughly examined in [O'Hearn and Tennent 1995], the
details do not bear repeating here. Instead, we choose to carry working on with
the translation (\Delta )? as defined (which we have seen satisfies an adequacy property),
and simply note that the naturality properties that we can verify are sufficient to
support the technical results that we shall prove about low-order types. To this
end, we finish this section with some technical lemmas that will be needed later, in
Section 10.3.

9.3 Technical Lemmas
We now prove some technical lemmas that will be used to help produce a distinguishing context during the proof of full abstraction in the next section; the reader
may wish to move on and refer back to these lemmas as necessary.

The first lemma reduces the domain approximation p v q between certain polymorphic functions to the ordering p[N?] v q[N?] of their instantiations to N?.
This is one of the steps which enables us to use a single local variable, which lives
in store shape N?, to produce a distinguishing context.

The use of I in the lemma corresponds, semantically, to meanings for closed terms
of the indicated type.

Lemma 13. If p; q 2 `?I, where ` = ('1 \Theta  \Delta  \Delta  \Delta  \Theta  'n ! ') ! '0, then p v q iff
p[N?] v q[N?].

Proof: The only if part is immediate. For the if part, consider any countable, flat
cpo S, and suppose p[N?] v q[N?]. We must show p[S] v q[S] for arbitrary S.
If S is f?g then the result is trivial. Otherwise, first note that N? and S \Omega  N?
are isomorphic, since both are countably infinite and flat. Using the Isomorphism
Functoriality Lemma and parametricity we infer p[S \Omega  N?] v q[S \Omega  N?]. We know
that p and q are natural with respect to expansions by Theorem 12, and so we
can then show that p[S] v q[S] using naturality with respect to the expansion
S\Gamma ffi S \Omega  N? and the easy fact that expansion maps expand'0 [S1][S2] reflect order
for primitive types '0.

The next lemma refers to the logical relation R between (\Delta )? and O[[\Delta ]] defined in
Section 8.1.

Lemma 14. If ` = ('1 \Theta  \Delta  \Delta  \Delta  \Theta  'n ! ') ! '0 then the opposite of relation RX`
is single-valued: if pRX` m and p0RX` m then p = p0.

The point of this result is that, at first order types, the relationship between the
two models can be described by a partial function; an element in the Oles model

From Algol to Polymorphic Linear Lambda-calculus \Delta  39
can correspond to at most one element in the parametricity model (which is more
constrained).

Proof: Assume the antecedent. By Theorem 12 we have an injection

i : (('1 \Theta  \Delta  \Delta  \Delta  \Theta  'n) ! ')?(X \Theta  W )? ,! O[[('1 \Theta  \Delta  \Delta  \Delta  \Theta  'n) ! ']](X \Theta  W );
and it is clear that if q 2 (('1 \Theta \Delta  \Delta  \Delta \Theta 'n) ! ')?(X \Theta W )? then qRX\Theta W'

1\Theta \Delta \Delta \Delta \Theta 'n!'(iq).By the logical relation property for p and p0 this means that

(p[W ]q)RX\Theta W'0 (m[W ](iq)) and (p0[W ]q)RX\Theta W'0 (m[W ](iq)):
But the logical relation RX\Theta W'0 at primitive type is an equality relation. Thus, we
have shown that p[W ]q = p0[W ]q for arbitrary W and q, so p = p0.

Lemma 15. If ` M : `, where ` = ('1 \Theta  \Delta  \Delta  \Delta  \Theta  'n ! ') ! '0, then M is
natural:

I

I

`?S
`?(S \Omega  S0)?
id

-M ?S

-M ?(S \Omega  S0) ?

expand`[S][S0]

Proof: Let S = X? and S0 = X0?. From Lemma 7 we know that

(M ?X?\Lambda )RX` (O[[M ]]X\Lambda ) and (M ?(X \Theta  X0)?\Lambda )RX\Theta X

0

` (O[[M ]](X \Theta  X0)\Lambda ):

By Expansion Relatedness (Lemma 6),

(expand`[S][S0](M ?X?\Lambda ))RX\Theta X

0

` (O[[`]] e (O[[M ]]X\Lambda ));

where e : X ! X \Theta  X0 is the expansion. Further, by naturality of O[[M ]] we know

O[[`]] e (O[[M ]]X\Lambda ) = O[[M ]](X \Theta  X0) \Lambda  :
Naturality follows from these facts together with Lemma 14 and the standard isomorphism (X \Theta  X0)? ,= S \Omega  S0.

The order v on p and q in Lemma 13 is determined pointwise. Likewise, any
derivable judgement \Gamma  ` M : ` in Idealized Algol determines a family of maps
M ?(-) : \Gamma ?(-)\Gamma ffi `?(-) in the strict parametricity model, which we also order pointwise.

Lemma 16. If ` M; N : `, where ` = ('1 \Theta  \Delta  \Delta  \Delta  \Theta  'n ! ') ! '0, then

M ? v N ? iff M ?I v N ?I:
Proof: The only if part is immediate from the pointwise order for v. For the if
part, if M ?I v N ?I we get M ?(I \Omega  S) v N ?(I \Omega  S) from naturality (Lemma 15),
and then M ?S v N ?S using the Isomorphism Functoriality Lemma (Section 6)
with the isomorphism S $ I \Omega  S.

40 \Delta  P.W. O'Hearn and J.C. Reynolds
10. RESUMPTIONS AND IDEALIZED ALGOL
In this section we show that the meanings of first-order types in our model of Idealized Algol may be characterized using domain equations for resumptions. The proof
of this result goes by a parametricity argument which characterises the elements of
these types exactly. Using this characterization, we derive a full abstraction result
for closed terms of second-order type.

We have already seen in Section 7.3 that such representation results do not go
through in our model of SCI.

10.1 A Representation Theorem
The domain equation we give will need to deal with a number of different capabilities
for the primitive types, and it will help to look at some instances of it before giving
the general equation.

To begin, (comm ! comm)?S is an initial solution of the familiar domain
equation for deterministic resumptions [Plotkin 1983]:

D ,= S\Gamma ffi \Gamma S \Phi  (S \Omega  D)\Delta ;
where S is a flat cpo and \Phi  is coalesced sum. Using this domain equation we
understand a procedure of type comm ! comm as follows. A procedure with a
command argument begins by possibly changing the state. It then either terminates
or resumes. Resuming causes the argument to be evaluated once, with the state
resulting from this evaluation fed through as an argument to the resumed procedure.

For expressions we augment deterministic resumptions with input and output
capabilities. The equation for exp ! exp is

D ,= S\Gamma ffi \Gamma (S \Omega  N?) \Phi  (S \Omega  (N?\Gamma ffi D))\Delta :
This equation allows for an output value in the component S \Omega  N? for the final
value of execution of the resumption, and an input value in N?\Gamma ffi D that is obtained
from evaluating the input expression once.

For acceptors to the left of ! consider a procedure p : acc ! comm. A
procedure call p(a) is a command which may assign a number of values to a during
its evaluation. The appropriate domain equation is the one for comm ! comm,
augmented with natural number values to be supplied to the input acceptor on
resumption:

D ,= S\Gamma ffi \Gamma S \Phi  (S \Omega  D \Omega  N?)\Delta :
For acceptors to the right of ! consider a procedure p : acc ! acc. A procedure
call p(a) is an acceptor, so that it accepts a natural number value and then behaves
like a command, during evaluation of which a can be used a number of times.
Accordingly, (acc ! acc)?S is isomorphic to N?\Gamma ffi D, where D is the domain just
given for acc ! comm.

This treatment of acceptors can in fact be regarded as being derived from a view
of acc as an infinite product of comm; semantically, acc?S is isomorphic to an
infinite product (comm?S)N . For acceptors to the right of !, the domain N?\Gamma ffi D
is isomorphic to the infinite product DN . To the left of ! the term S \Omega  D \Omega  N?
in the domain equation can be isomorphically rewritten to \Sigma i2N S \Omega  D, for \Sigma  the

From Algol to Polymorphic Linear Lambda-calculus \Delta  41
coalesced sum: Below we will use summation in this way to account for explicit
product types to the left of !.

To formulate the general equation, for each primitive type ' we define functors
'in, 'arg and and 'res (for input, argument, and result) on the category of cpo's
and strict continuous functions:

expin = (-) exparg = N?\Gamma ffi (-) expres = (-) \Omega  N?
accin = N?\Gamma ffi (-) accarg = (-) \Omega  N? accres = (-)
commin = (-): commarg = (-) commres = (-)

Now we add the capability to choose among multiple arguments to the domain
equations above.

Theorem 17. (Resumption Theorem) If '1; :::; 'n; ' are primitive Idealized
Algol types and S a countable flat cpo, then

('1 \Theta  \Delta  \Delta  \Delta  \Theta  'n ! ')?S
is isomorphic to 'in(D), where D is an initial solution of the domain equation

D ,= S\Gamma ffi \Gamma 'res(S) \Phi  (S \Omega  (\Sigma ni=1'argi (D)))\Delta ;
where \Phi  and \Sigma  are coalesced sum.

The summation over i 2 1; :::; n here corresponds to a strong form of sequentiality
where a resumption must choose a specific i, which causes the i'th argument to be
evaluated before resuming. This is analogous to strategies for picking sequentiality
indices in sequential algorithms [Berry and Curien 1982]: In contrast, Kahn-Plotkin
sequential functions require mere existence of a sequentiality index, and as a result
are less distinguishing than the stronger form of sequentiality found in Idealized
Algol. The weaker sequential-function form of sequentiality is closer to functions
in SCI, where non-interference leads to less dependence on evaluation order than
in Idealized Algol. (So the parallelism in SCI is reminiscent of independence from
evaluation order in PCF, and appears to be actually sequential in this weaker sense
of sequentiality.)

The proof of the Resumption Theorem is lengthy, and we give it separately in
the following subsection. In describing the proof we have attempted to isolate the
more conceptual part, the parametricity argument, from the technical development
needed to apply the argument to verify the theorem.

10.2 Proof of the Theorem
To keep the notation simple we give the proof for the type exp \Theta  exp ! exp. This
requires us to address the most important issues raised by the domain equation,
including multiple arguments and possibly non-trivial input and output values. The
proof for more or fewer than two arguments involving comm or exp is a straight
notational reworking of what follows, and acc requires only minor modifications
(recall the remarks about acc as a infinite product of comm above).

The relevant cpo in the strict parametricity model is

Z = 8fi: (S \Omega  fi\Gamma ffi S \Omega  fi \Omega  nat)&(S \Omega  fi\Gamma ffi S \Omega  fi \Omega  nat)

! (S \Omega  fi\Gamma ffi S \Omega  fi \Omega  nat):

42 \Delta  P.W. O'Hearn and J.C. Reynolds
Let D be an initial solution of the equation D ,= T D, where T is the following
functor on the category of cpo's and strict continuous functions:

T (-) = S\Gamma ffi S \Omega  \Gamma N? \Phi  (N?\Gamma ffi (-)) \Phi  (N?\Gamma ffi (-))\Delta :
(The functor S\Gamma ffi \Gamma (S \Omega N?)\Phi (S \Omega \Sigma 2i=1(N?\Gamma ffi (-)))\Delta  is explicitly given by the statement of the theorem, but it is isomorphic to T , which is obtained by distributing
\Phi  over \Omega .)

Our aim is to show that Z and D are isomorphic. To do this, we proceed in four
steps. First, we describe the structure of D. This is straightforward, and follows
from standard material on recursive domain equations [Plotkin 1983; Abramsky
and Jung 1994]. Second, we give the parametricity argument, which relates uses of
polymorphic functions to the structure described in the first step. Steps three and
four consist of technical results, which use the information from the first two steps
to verify that D and Z are isomorphic.

Step 1: Structure of D.

From the solution of domain equations by the inverse limit construction [Plotkin
1983; Abramsky and Jung 1994], we know that D is a bounded complete, algebraic
cpo. As a result, any element is the lub of the finite elements beneath it. The first
step needed for relating D to Z is to describe this structure explicitly. We do this
using step functions. If E is a flat cpo, F is bounded complete and algebraic, e 2 E
is not ?, and f 2 F is finite, then the step function e & f : E\Gamma ffi F is such that

(e & f )e0 = ae f if e = e

0

? otherwise.

The domain D can be described using special finite elements, the atoms. Recall
that an atom a in a cpo is an element just above ?, i.e. a 6= ? and 8b: b v a =)
b = a . b = ?. The atoms a 2 D can be generated using step functions as follows:

a ::= s & [s0; e] (? 6= s; s0 2 S)
e ::= n j 1 : n & a j 2 : n & a (n 2 N )

Here, we use n, 1 : n & a and 2 : n & a to indicate elements in respective
components of the coproduct N? \Phi  N?\Gamma ffi D \Phi  N?\Gamma ffi D. We will follow the usual
practice of suppressing isomorphisms between D and T D. For instance, s & [s0; n]
is, strictly speaking, an element of T D, which we could coerce to D using an
isomorphism.

It is not difficult to verify that each element a generated by this grammar is
indeed an atom, and also that this exhausts the atoms of D. The role of the atoms
in D is summed up by the following lemma.

Lemma 18. D is isomorphic to fA ` D j A is a pairwise-consistent set of atomsg,
ordered by subset inclusion. (That is, D is a coherence space.)

Here, two elements are said to be consistent when they have an upper bound. The
lemma can be shown using a routine calculation with the inverse limit construction.

Step 2: The Parametricity Argument.

From Algol to Polymorphic Linear Lambda-calculus \Delta  43
The essential part of the proof is the following use of parametricity. Suppose
p 2 Z, E is a flat cpo, c1; c2 : S \Omega  E\Gamma ffi S \Omega  E \Omega  N? and p[E]hc1; c2i[s0; e0] =
[s00; e00; n0] 6= ?. We identify an element of D that tracks the calls of c1 and c2.

Let L be the flat cpo whose non-? elements are lists of elements drawn from the
set coproduct S0 + N + N , where S0 is the set of non-? elements of S. We use s,
1 : n, and 2 : n, with subscripts or superscripts, to range over components of the
coproduct. Define R : L $ E to be the smallest strict relation such that

(s0)Re0 ci[s; e] = [s0; e0; n] 6= ? and `Re =) (`; s; s0; i : n)Re0:
The initial and final values of the state on a use of ci[s; e], together with component i
(which is 1 or 2) and produced value n, are recorded in (`; s; s0; i : n). (We are using
a comma for appending an element to a list.) R is single-valued and determines a
function fR : L\Gamma ffi E, where fR` = e if `Re, and fR` = ? if there is no e such that
`Re. For i equal to 1 or 2, define c\Lambda i : S \Omega  L\Gamma ffi S \Omega  L \Omega  N? to be the function where

c\Lambda i [s; `] = let [s0; e; n] be ci[s; fR`] in [s0; (`; s; s0; i : n); n]:
This definition is such that

h(s0); e0i 2 R ^ hc\Lambda i ; cii 2 \Delta S \Omega  R\Gamma ffi \Delta S \Omega  R \Omega  \Delta N?:
Parametricity of p then implies that

h p[L]hc\Lambda 1; c\Lambda 2i[s0; (s0)] ; p[E]hc1; c2i[s0; e0]i 2 \Delta S \Omega  R \Omega  \Delta N?:
By the definition of R, this means p[L]hc\Lambda 1; c\Lambda 2i[s0; (s0)] 6= ?. Further, the use of
\Delta S \Omega  R \Omega  \Delta N? implies that p[L]hc\Lambda 1; c\Lambda 2i[s0; (s0)] 2 S \Omega  L \Omega  N? is of the form

[s00; (s0; s1; s01; i1 : n1; :::; sk; s0k; ik : nk); n0]
for some, possibly empty, list s1; s01; i1 : n1:::; sk; s0k; ik : nk (here s00 and n0 are
the final values in p[E]hc1; c2i[s0; e0] = [s00; e00; n0]). From this we can read off the
behaviour of p[E]hc1; c2i[s0; e0] as a sequence of calls to c1 and c2, together with
initial and final states and values produced when each call was made.

This determines an atom

s0 & [s1; i1 : (n1 & (s01 & \Delta  \Delta  \Delta  [sk; ik : (nk & (s0k & [s00; n0]))] \Delta  \Delta  \Delta ))]
in D, which we denote by a(E; p; c1; c2; s0; e0). The logical relation argument we
have just given is a recipe for obtaining a(E; p; c1; c2; s0; e0) from appropriately
typed E; p; c1; c2; s0; e0, as long as p[E]hc1; c2i[s0; e0] 6= ?.

This completes the most important part of the proof. The remainder of the section consists of technical lemmas, showing how this way of generating atoms in D
from elements of Z can be used to establish an isomorphism between D and Z.

Step 3: From D to Z.

We obtain a map from D to Z using the fact that there is an initial T -algebra

T D h

D! D, the structure map hD of which is an isomorphism [Abramsky and

Jung 1994]. Initiality implies that there is a (unique) strict continuous function

44 \Delta  P.W. O'Hearn and J.C. Reynolds
 : D ! Z making

T D

D

T Z

Z?
hD

-T 

- ?

hZ

commute, where the T -algebra structure map T Z h

Z! Z is as follows:

hZ = *p 2 T Z

\Lambda fi *hc1; c2i : (S \Omega  fi\Gamma ffi S \Omega  fi \Omega  nat)&(S \Omega  fi\Gamma ffi S \Omega  fi \Omega  nat)
*[s; b] : S \Omega  fi

let [s0; x] be p s in

case x of

n 7! [s0; b; n]
1 : f 7! (let [s00; b0; n] be c1[s0; b] in (f n)[fi]hc1; c2i[s00; b0])
2 : g 7! (let [s00; b0; n] be c2[s0; b] in (g n)[fi]hc1; c2i[s00; b0]).

We are using polymorphic *-calculus notation as a convenient way of defining elements of Z in a way that makes the satisfaction of parametricity conditions obvious.
The case construct is used to branch on coproduct components, where n, (1 : f ),
and (2 : g) range over components of N? \Phi  (N?\Gamma ffi E) \Phi  (N?\Gamma ffi E). Note that the
use of case is not a problem for parametricity because we are not branching on
anything we are required to be parametric in.

The map  can be obtained from general considerations ([Abramsky and Jung
1994], Lemma 5.3.1) as a least fixed-point:

 = _g: (h\Gamma 1D ; T (g); hZ):
For concreteness, it will be useful to spell out the action of  on atoms. Consider
an atom

a = s0 & [s1; i1 : (n1 & (s01 & \Delta  \Delta  \Delta  [sk; ik : (nk & s0k & [s00; n0])] \Delta  \Delta  \Delta ))]
in D. Then we define the polymorphic function (a) 2 Z by induction on the size
of a. The base case is for atoms of the form s0 & [s00; n0], and (a) is then the
function

\Lambda fi: *hc1; c2i: *[s; b]: if (s = s0) then [s00; b; n0] else ?:
For the induction case, suppose that we know the polymorphic function (a0) corresponding to the atom

a0 = (s01 & \Delta  \Delta  \Delta  [sk; ik : (nk & s0k & [s00; n0])] \Delta  \Delta  \Delta ):
Then (a) is

\Lambda fi: *hc1; c2i: *[s; b]:

if (s = s0) then\Gamma 

let [s0; b0; n] = ci1 [s1; b] in

if n = n1 then (a0)[fi]hc1; c2i[s0; b0] else ?\Delta 
else ?:

From Algol to Polymorphic Linear Lambda-calculus \Delta  45
It is not difficult to see that this description is consistent with the abstract definition
of  as a least fixed-point.

From Lemma 18 we know that D is determined by its atoms, and consistency
between them. A key point is that  respects this consistency structure.

Lemma 19. (1) If d and d0 are consistent in Z then d and d0 are consistent

in D.

(2)  reflects order: d v d0 =) d v d0.

Proof: For part (1) of the lemma, by Lemma 18 it suffices to prove the result for
atoms only. From the description of atoms in D it is clear that, if d and d0 are
inconsistent, then we must have a situation in which

d = s0 & [s1; i1 : (n1 & (s01 & \Delta  \Delta  \Delta  [sk; ik : (nk & s0k & [q; e])] \Delta  \Delta  \Delta ))]
d0 = s0 & [s1; i1 : (n1 & (s01 & \Delta  \Delta  \Delta  [sk; ik : (nk & s0k & [q0; e0])] \Delta  \Delta  \Delta ))]

where one of three cases must be true:

(1) e = m and e0 = n are in the first component, and m 6= n,
(2) q 6= q0, or
(3) e and e0 are in different components.

For each case it is straightforward to find arguments E, c1, c2 and e0 such that
( d)[E]hc1; c2i[s0; e0] and ( d0)[E]hc1; c2i[s0; e0] are unequal and non-?. For instance, in the first case we can choose E = N?, e0 = 0, and for y equal to 1 or 2
define cy to be the least function such that cy[sj; j \Gamma  1] = [s0j; j; nj], for 1 ! j ! k.
A routine calculation with the definition of  shows that ( d)[E]hc1; c2i[s0; e0] and
( d0)[E]hc1; c2i[s0; e0] are inconsistent. The other two cases are similar.

Part (2) of the lemma can also be shown straightforwardly by proving the contrapositive, constructing arguments that show d 6v d0 when d 6v d0.

From part (2) of this result it follows that  is an an injection that preserves and
reflects order, so that D "sits inside" Z. The next result sets the stage for the proof
that  is bijective; it shows that the behaviour of any polymorphic function p 2 Z
is completely determined by elements of the form (a) lying below it, for a an atom
of D.

Lemma 20. (1) (a(E; p; c1; c2; s0; e0))[E]c[s0; e0] = p[E]hc1; c2i[s0; e0]

(2) (a(E; p; c1; c2; s0; e0)) v p.

Proof: (1) follows straightforwardly from the relational parametricity property
for (a(E; p; c1; c2; s0; e0)), with the relation R used to define a(E; p; c1; c2; s0; e0)
above. For (2) we need more work because we must consider cpo's other than E.
That is, we must show the following for every flat cpo B:

(a) If (a(E; p; c1; c2; s0; e0))[B]hh1; h2i[q0; b0] = [q00; b00] 6= ?

then p[B]hh1; h2i[q0; b0] = [q00; b00].

Fix B and assume the antecedent of (a). Note that we must have s0 = q0, or else
we would have (a(E; p; c1; c2; s0; e0))[B]hh1; h2i[q0; b0] = ?.

Let L and R : L $ E be as in the parametricity argument that defined the atom
a(E; p; c1; c2; s0; e0), and define Q : L $ B as the least strict relation such that

(s0)Qb0 hi[q; e] = [q0; b0; n] 6= ? ^ `Qb ) (`; q; q0; i : n)Qb0:

46 \Delta  P.W. O'Hearn and J.C. Reynolds
We define fQ and h\Lambda i similarly to fR and c\Lambda i . Again we have

h(s0); b0i 2 Q ^ hh\Lambda i ; hii 2 \Delta S \Omega  Q\Gamma ffi \Delta S \Omega  Q \Omega  \Delta N?;
so, by parametricity (remembering s0 = q0) we obtain

(b) h p[L]hh\Lambda 1; h\Lambda 2i[s0; (s0)] ; p[B]hh1; h2i[s0; b0]i 2 \Delta S \Omega  Q \Omega  \Delta N? ;
and

(c) \Omega  (a(E; p; c1; c2; s0; e0))[L]hh\Lambda 1; h\Lambda 2i[s0; (s0)];

(a(E; p; c1; c2; s0; e0))[B]hh1; h2i[s0; b0]ff 2 \Delta S \Omega  Q \Omega  \Delta N?:

Then (b) and (c) imply, since Q is single-valued, that to prove (a) it suffices to
show

(d) (a(E; p; c1; c2; s0; e0))[L]hh\Lambda 1; h\Lambda 2i[s0; (s0)] = p[L]hh\Lambda 1; h\Lambda 2i[s0; (s0)]:
Now, the atom a(E; p; c1; c2; s0; e0) must be of the form

s0 & [s1; i1 : (n1 & (s01 & \Delta  \Delta  \Delta  [sk; ik : (nk & s0k & [s00; n0])] \Delta  \Delta  \Delta ))]:
Fixing k, for each 0 ^ j ^ k define

`j = (s0; s1; s01; i1 : n1:::; sj; s0j; ij : nj);
and, for i equal to 1 or 2, define cmini to be the function where

cmini [sj; `j\Gamma 1] = [s0j; `j; nj], for 1 ^ j ^ k,
and cmini [s; `] = ? in all other cases. Define U : L $ L to be the relation containing
h?; ?i, all pairs h`j; `ji for 0 ^ j ^ k, and h?; `i for all `'s whose length is greater
than 3k + 1 (which is the length of `k).

Intuitively, cmini is like c\Lambda i , except that it is just defined enough to enable the
polymorphic application p[L]hcmin1 ; cmin2 i[s0; (s0)] to be non-?.

More formally, it is easy to see that

hcmini ; c\Lambda i i 2 \Delta S \Omega  U \Gamma ffi \Delta S \Omega  U \Omega  \Delta N?;
and parametricity then implies

h p[L]hcmin1 ; cmin2 i[s0; (s0)] ; p[L]hc\Lambda 1; c\Lambda 2i[s0; (s0)]i 2 \Delta S \Omega  U \Omega  \Delta N?:
We know from the parametricity argument that defined a(E; p; c1; c2; s0; e0) that

p[L]hc\Lambda 1; c\Lambda 2i[s0; (s0)] = [s00; `k; n0]:
Further, the definition of U implies that

if h`; `ki 2 U then ` = `k,
so we may conclude that

p[L]hcmin1 ; cmin2 i[s0; (s0)] = [s00; `k; n0]:
In particular, it is not ?.

Next, we claim

(e) hcmini ; h\Lambda i i 2 \Delta S \Omega  U \Gamma ffi \Delta S \Omega  U \Omega  \Delta N?:

From Algol to Polymorphic Linear Lambda-calculus \Delta  47
To see why (e) must hold, consider how cmini is defined in terms of the atom. If (e)
did not hold then we would have

(a(E; p; c1; c2; s0; e0))[L]hh\Lambda 1; h\Lambda 2i[s0; (s0)] = ?,
and that cannot be the case because, by (c) and the definition of Q, it would
contradict the assumed antecedent of (a).

From (e) and parametricity of p we obtain

h p[L]hcmin1 ; cmin2 i[s0; (s0)] ; p[L]hh\Lambda 1; h\Lambda 2i[s0; (s0)]i 2 \Delta S \Omega  U \Omega  \Delta N?:
By the definition of U and the fact, shown above, that p[L]hcmin1 ; cmin2 i[s0; (s0)] 6= ?,
this implies

(f) p[L]hcmin1 ; cmin2 i[s0; (s0)] = p[L]hh\Lambda 1; h\Lambda 2i[s0; (s0)]:
By a similar (but easier) argument, parametricity of (a(E; p; c1; c2; s0; e0)) with
respect to U implies

(g) (a(E; p; c1; c2; s0; e0))[L]hcmin1 ; cmin2 i[s0; (s0)]

= (a(E; p; c1; c2; s0; e0))[L]hh\Lambda 1; h\Lambda 2i[s0; (s0)]:

The desired result (d) follows directly from (f) and (g).

Step 4: From Z to D.

Finally, we define the inverse map ^ : Z ! D:

^ p = Gfa 2 D j a v p and a is an atomg:
Lemma 21. ^ is well-defined.
Proof: If d; d0 v p then d and d0 are consistent by Lemma 19(1). Thus, the set
fa 2 D j a v p and a is an atomg is pairwise consistent, and by Lemma 18 its lub
exists.

This shows that ^ is a function but we do not, as yet, claim that it is continuous.

Lemma 22. ^d = d.
Proof:

^d = Ffa 2 D j a v d and a is an atomg (definition)

= Ffa 2 D j a v d and a is an atomg (Lemma 19(2))
= d (Lemma 18)

Lemma 23. ^p = p.
Proof: Certainly we have ^p v p by the definition of ^. Conversely, suppose that p[E]hc1; c2i[s0; e0] = [s00; e00] and consider a(E; p; c1; c2; s0; e0) 2 D. We
know from Lemma 20(1) that (a(E; p; c1; c2; s0; e0)) v p, and since, by definition,
a(E; p; c1; c2; s0; e0) is an atom in D, the inequality a(E; p; c1; c2; s0; e0) v ^p follows from the definition of ^. This and Lemma 20(2) imply the desired equality
(^p)[E]hc1; c2i[s0; e0] = [s00; e00], and we are done.

48 \Delta  P.W. O'Hearn and J.C. Reynolds
To prove the Resumption Theorem, note that in the specific category of cpo's and
strict continuous functions any order-reflecting bijection is an isomorphism. Lemmas 22 and 23 show that  is a bijection, so by Lemma 19 we conclude that it is
an isomorphism (and we can finally infer that ^ is continuous).

This Concludes the Proof of the Resumption Theorem

After all this work it is reasonable to ask if Theorem 17 could be seen as an
instance of a more general result about relational parametricity in linear type theory. In suitably parametric models of (intuitionistic) polymorphic *-calculus types
of the form 8ff: (T ff ! ff) ! ff denote initial T -algebras, and this paves the way
for a characterization of all second-order types in prenex form. Plotkin [1993] in
lectures has indicated that the corresponding property in linear polymorphic type
theory is that 8ff: (T ff\Gamma ffi ff) ! ff denotes an initial T -algebra, for covariant functors
T on a "linear" category where morphisms correspond to terms of \Gamma ffi type. It is
not immediately obvious that this implies our result because our translations of
first-order Idealized Algol types have quite a different form. Further, in contrast to
intuitionistic type theory the mixing of intuitionistic and linear facilities blocks an
evident reduction of these and other low order types to the form 8ff: (T ff\Gamma ffi ff) ! ff.
Finally, note that the map ^ in the proof, which essentially gives (weak) initiality,
was defined using details about the structure of solutions of domain equations in
the category of cpo's and strict continuous functions.

10.3 A Full Abstraction Result
We know from the Resumption Theorem that the first-order types have algebraic
cpo structure. We show that the finite elements are definable in a suitable sense.
(This is related, but not identical, to the argument in [O'Hearn and Reddy 1999],
Proposition 5.2.)

Let vN? 2 var?N? be the evident variable that directly updates and reads from
N?. It can be obtained from the standard variable v[I] 2 var?(I \Omega  N?) using the
canonical isomorphism I \Omega  N? $ N?.

Lemma 24. (Definability Lemma) If '1; :::; 'n; ' are primitive Algol types
then every finite element d of ('1 \Theta  \Delta  \Delta  \Delta  'n ! ')?N? is definable by an Idealized
Algol term

x : var ` Md : '1 \Theta  \Delta  \Delta  \Delta  'n ! ';
in the sense that

(M ?d N?) vN? = d
in the strict parametricity model.

In this result (M ?d N?) is a map of type var?N?\Gamma ffi ('1 \Theta  \Delta  \Delta  \Delta  'n ! ')?N?. The
standard variable vN? for updating N? is given as the only component in the
environment, and is denoted by x in (M ?d N?) vN?.

Proof: Again we concentrate on exp \Theta  exp ! exp. It is standard that the finite
elements d in the resumption domain can be generated as follows.

From Algol to Polymorphic Linear Lambda-calculus \Delta  49
d ::= (s1 & [s01; e1]) t \Delta  \Delta  \Delta  t (sk & [s0k; ek])

(where si; s0i 2 N , s1; :::; sk are all distinct)

e ::= n j i : (n1 & d1) t \Delta  \Delta  \Delta  t (nm & dm)

(where all nj 2 N are distinct, and i = 1 or 2)

We define terms Nd, Fe by induction on d and e, where

x : var; c1 : exp; c2 : exp ` Nd : exp
x : var; c1 : exp; c2 : exp ` Fe : exp.

Nd is defined by

N(s1&[s0

1;e1])t\Delta \Delta \Delta t(sk&[s

0
k;ek])= if x = s

1 then x := s01; Fe1.

..

else if x = sk then x := s0k; Fek
else \Omega .

Fe is defined according to the component of e:

Fn = n

Fi:(n1&d1)t\Delta \Delta \Delta t(nm&dm)
= newexp y: y := ci; if y = n1 then Nd1

...

else if y = nm then Ndm
else \Omega .

Then we set Md = *hc1; c2i: Nd, and it is straightforward to verify that Md defines
d in the sense of the statement of the Lemma.

To formulate the full abstraction result, we will take convergence of closed terms
of type comm as the observable. (We could also observe integers generated by
terms of type exp, but this would lead to the same contextual equivalence relation.) To define this precisely, first note that if M is a closed term of type comm
in Idealized Algol, the family of maps M ?(-) : I\Gamma ffi comm?(-) is completely determined by the component M ?I : I\Gamma ffi '?I at I. (This follows from the Logical
Relations Lemma, using relations of the form I $ S that fix a state in S.) The
resulting function M ?I\Lambda  : I\Gamma ffi I takes as an argument the state \Lambda  2 I and produces
as a result either \Lambda  or ?. We take as observable this final value M ?I \Lambda  \Lambda , and we
look at approximation in all comm-typed contexts.

Theorem 25. (Full Abstraction to 2nd order) Suppose ` M : ` and ` N : `
in Idealized Algol where ` = ('1 \Theta  \Delta  \Delta  \Delta  'n ! ') ! '0. Then

M ? v N ? () 8C[\Delta ]: C[M ]?I \Lambda  \Lambda  v C[N ]?I \Lambda  \Lambda 
(where C[\Delta ] is understood to be a context such that C[M ] and C[N ] are closed terms
of type comm).

Proof: The =) direction is immediate from compositionality. For (=, suppose
that [[M ?ff]] 6v [[N ?ff]]. We require a distinguishing context where C[M ]? 6v C[N ]?.

50 \Delta  P.W. O'Hearn and J.C. Reynolds

First suppose that '0 is comm or exp. By Lemmas 13 and 16, and continuity,
there is a finite element d and n 2 N such that

(M ?I)[N?]d[\Lambda ; n] 6v (N ?I)[N?]d[\Lambda ; n]:
By the Definability Lemma (using also an isomorphism N? $ I \Omega  N?) there is a
term Md that defines d in an environment where x denotes the standard variable
v[I] for local variables.

If '0 is comm then (M ?I)[N?]d[\Lambda ; n] = [\Lambda ; m] for some m, and a distinguishing
context is

C[\Delta ] = new'0 x: x := n; ([\Delta ]Md); if x = m then skip else diverge:
If '0 is exp then (M ?I)[N?]d[\Lambda ; n] = [\Lambda ; m; m0] for some m and m0, and a distinguishing context is

C[\Delta ] = new'0 x: x := n; if ([\Delta ]Md) = m0 then

if x = m then skip else diverge
else diverge.

The proof when '0 is acc is similar, if we observe that assignment to an acceptor is
needed when using continuity and definability to generate a distinguishing context.

We have formulated the full abstraction result for second-order types of a specific
form, but it is not difficult (observing remarks on naturality in Section 9.2) to extend
the argument to all second-order types. We do not know if the result extends to
higher types.

11. RELATED WORK
There are two ways to read the contribution of this paper. One has to do with
semantic models of imperative languages, and the other with translating from an
imperative language to a (linear) purely functional language. From the first point
of view the semantics is being used to analyze the imperative source languages,
while from the second the translation may be regarded just as much as telling us
something about the functional target language. In discussing related work we
consider these points of view in turn.

This paper builds on prior work on functor category semantics [Reynolds 1981a;
Oles 1982; Oles 1997; O'Hearn and Tennent 1995; Sieber 1996], the main technical
improvement being the elimination of snapback operators. The semantics may
in fact be regarded as a refinement of the parametric-functor model of O'Hearn
and Tennent [1995], obtained by moving from standard to linear polymorphism.
Another difference with these works is our use of a polymorphic target language
in place of a functor category (an aspect left implicit in the description of the
parametric-functor model). This makes the store shape typing information implicit
in a functor category more explicit, and statically checkable; we do not yet fully
appreciate the significance of this point.

Pitts [1996] has carried out a study of contextual equivalence in Algol-like languages using operational techniques. His work is a good example of useful interplay
between denotational and operational semantics. He proves a "possible worlds"

From Algol to Polymorphic Linear Lambda-calculus \Delta  51
version of the context lemma [Milner 1977], the formulation of which mimicks the
structure of a functor category; it characterizes equivalence of functions in terms
of applications to arguments at accessible worlds or store shapes. He uses an operational formulation of the relational principles considered here (and in [O'Hearn
and Tennent 1995]) to prove his main result. A key point in Pitts's work is that he
separates the use of logical relations as reasoning principles from their use in constructing a model. This does not lead to representation results, and it de-emphasizes
the connection with linear polymorphic typing, but it does provide a pleasantly simple mathematical expression of the relational principles, and interesting technical
results.

A completely different view of imperative computation is given by implicit-state
models, which interpret imperative programs using histories of events. The basic
conception of this approach is similar to ideas in work on processes (e.g. [Milner
1989]), but novel models of Algol-like languages have now been defined using denotational tools. The first of these is due to Reddy [1996], who defined a model for
syntactic control of interference using coherence spaces; more recently, Abramsky
and McCusker [1997] gave a game model of Idealized Algol.

Reddy's semantics is similar in spirit to domain-theoretic models of functional
languages, and is based on a concrete description of domain-theoretic structure
associated with SCI types. It accounts especially well for independence between
arguments to functions. The model of Abramsky and McCusker is an extension the
game semantics of PCF developed by Hyland and Ong [1994], obtained by dropping
the "innocence" condition; this results in a clear distinction between functional
and imperative behaviours in the model. They show that all finite elements in
their model are definable by terms in essentially the same version of Idealized Algol
considered here; this leads, after quotienting, to a fully abstract model. Previously,
full abstraction had only been obtained up to second-order types [O'Hearn and
Reddy 1999], which is where our analysis here (which was carried out around the
same time) ends as well.

The difference between our semantics and implicit-state models is striking. For
us the primitive concepts are sets of states, and the linearly polymorphic way
that states are used. In the implicit models the primitive concepts are events or
observations, and interaction of a program with its environment. The conceptual
distance between the two approaches is thus very great. It is not obvious how to
formulate a precise linkage between them, but to do so would be valuable.

We now turn to related work on linear functional programming. The informal
connection between imperative-like state transformations and linear functions was
emphasized from the beginning in linear logic. It formed part of the motivation
for a number of linear functional languages [Mackie 1994; Lafont 1988; Holmstr"om
1988; Chirimar et al. 1994], where linearity could be used to restrict the number of
pointers to functional values and, in some cases, guarantee the safety of destructive
array update.

This connection was illustrated particularly clearly by Wadler [1990], by translating an imperative langauge, without procedures, into a linear functional language.
We argued in the Introduction that a language without procedures does not itself
provide a stringent test for the imperative expressiveness of a linear language, but
we do want to emphasize our debt to the work of Wadler, and to other early works

52 \Delta  P.W. O'Hearn and J.C. Reynolds
on linear logic, for making the connection between imperative-like state transformations and linear functions. To these works we would add the point that moving
from simple to polymorphic linear types allows for a treatment of procedures and
local state, and as a result it becomes possible to cover a much wider range of
imperative programming. We would also add that polymorphism can be used to
capture that a non-linear state be used linearly.

Prior to the appearance of linear logic, Schmidt [1985] had already studied the
relationship between syntactic restrictions on *-terms and the imperative nature of
state transformations. His aim was to detect, in a standard denotational definition,
when a parameter was "single threaded." The idea was that this would enable a
compiler generator to detect when the parameter could be implemented in a storelike manner, by overwriting. His aim, and form of analysis, was thus different from
ours; in particular, he works with simple types, where polymorphism plays a central
role here. Some of his basic ideas are reflected in our translations, but one that
is not is passivity [Reynolds 1978], where multiple copies of a store parameter are
allowed in contexts that ensure that they are used in a read-only fashion.

12. DISCUSSION
In the course of the paper we have presented syntactic translations from two Algollike languages into a polymorphic, linear lambda-calculus, given a semantic model
of the linear language, and used it characterize the cpo structure of a number
of low-order types. We hope particularly to have convinced the reader that the
translations and semantic model provide simple and effective principles that can be
utilized in a variety of circumstances. This is highlighted by our work in Section 7,
and also by Pitts's work referenced above.

The semantic analysis provided by the strict parametricity model is, however,
incomplete in come respects. We were in fact surprised to find that we could push
the model as far as we could. To clarify this incompleteness we discuss a number
of unanswered questions.

The first question arises from the work in Section 9.2: Does parametricity imply
naturality with respect to expansions at all types for the Idealized Algol translation?
If the answer is no then the translation of Idealized Algol, as it stands, would not
verify the isomorphisms of cartesian closed categories at higher types. We indicated
in Section 9.2 that this is not a fundamental problem, as we know a number of ways
to overcome it. Furthermore, in Section 8 we verified an adequacy result to the effect
that the translation gets convergence at primitive types right, so the translation
can be used to soundly reason about Idealized Algol programs. But the question
is irksome, because one might expect that parametricity should imply naturality
[Plotkin and Abadi 1993].

Our analysis of equivalence only went as far as second-order types. We have
not found a counterexample to full abstraction at higher types in Idealized Algol,
but we did find an explicit limitation in the model for SCI in Section 7.3. One
could consider a more focused study of contextual equivalence, either by using
different models or by a syntactic analysis of the translations. Independently of
any specific model we could ask if the translations are fully abstract, i.e., whether
they preserve and reflect appropriate notions of contextual equivalence for source
and target languages.

From Algol to Polymorphic Linear Lambda-calculus \Delta  53
It may have seemed odd that we did use the strict function model, since it is
actually a model of relevant lambda-calculus (it models Contraction). We observed
that snapback requires both Contraction and Weakening, so that eliminating one
has the effect of banishing snapback operators. But there may be a more comprehensive explanation than this. For primitive types in the translations there is
always a unique occurrence of any type variable to the left or right of \Gamma ffi : Intuitively, if you perform a Contraction, copying a value of one of these types, it must
be followed by a Weakening to preserve the uniqueness property (and conversely if
a Weakening is performed first). This leads to the question (which we leave imprecisely stated) of whether the translations are the same if we take relevant, linear, or
affine lambda-calculus as the target language. When one moves outside the ranges
of our translations, beyond Algol-like types, we expect that linearity would play
a more crucial role; we would benefit from a more precise understanding of these
points.

With this discussion of technical properties, it is well to remember that the
original motivation for semantics based on store shapes was much more basic: It
was to build a model that made the stack discipline obvious [Reynolds 1981a]. In
particular, it is clear from the semantics of types that the shape of the store in the
final state obtained by evaluating a command must be the same as the shape in
the initial state. While the translation for Idealized Algol follows previous functorcategory models closely, in SCI store shapes play a further role, making clear that
different identifiers work with different pieces of the state. So, more generally,
we may say that semantics based on store shapes aims to communicate a spatial
intuition: Programs working with different store shapes act on separate parts of
the store, and consequently don't interfere.

Our work here gives an implementation of store shape semantics by translation
into a linear polymorphic functional language. We have, for the most part, concentrated on what the resulting semantics says about the source languages, but if
we switch focus to the target language then the translations can just as well be
regarded as telling us about it. In particular, since we already understand Algol
as an imperative language, the translations (and representation results) give us a
precise imperative way of reading certain linear types. This does not, however, help
us to understand types that lie beyond the ranges of our translations, because there
we do not have a prior understanding of an imperative language to fall back on.

A final note on the source languages, and limitations. While we concentrate
on call-by-name, the adaptation of our semantic methods to a call-by-value setting
does not appear to raise insuperable difficulties. Much more difficult is the inclusion
of storable procedures or commands. Idealized Algol and SCI allow only stateless
entities, such as integers, to be stored, and we do not know how well our methods
might extend to deal with stateful values in the store.

We wonder whether this apparent limitation could be turned into a feature.
That is, both Idealized Algol and Basic SCI are higher-order imperative languages
that obey a stack discipline for variable declarations. While the stack discipline is
made evident by the translations of types, there are other polymorphic types, lying
outside the ranges of the translations, that display the same stack-like character.
This raises the question of whether the stack-like sublanguage could be demarcated,
perhaps leading to an imperative language that is more general and flexible than

54 \Delta  P.W. O'Hearn and J.C. Reynolds
Algol, while maintaining efficient storage utilization.
Acknowledgements. This work first came to light at a workshop on Syntactic
Control of Interference and Linear Logic in Glasgow in August of 1995, where the
authors presented independently discovered translations into a linear polymorphic
target language. The translations were essentially the same, except that O'Hearn
used Idealized Algol as the source language where Reynolds used SCI. We are grateful to the workshop participants, especially the host Phil Wadler, for contributing to
a remarkably congenial research atmosphere. Special thanks go to Uday Reddy for
discussions on how the strict function model could eliminate snapback, to Gordon
Plotkin for emphasizing the suitability of linear typing in the presence of recursion,
and to Bob Tennent for numerous discussions, especially in relation to the material
in Section 8. Thanks also to Jeff Polakow and Chris Stone for comments on the
presentation in the paper, and the referees for helpful suggestions. O'Hearn was
supported by NSF grant CCR-92110829 in the initial stages of this work. Reynolds
was supported by NSF grant CCR-9409997. Support during extended visits was
given to both authors from the Isaac Newton Programme on Semantics of Computation, held in Cambridge in 1995; to O'Hearn from the Electrotechnical Laboratory,
Tsukuba, Japan; and to Reynolds from Bell Laboratories, Lucent Technologies,
New Jersey.

REFERENCES

Abramsky, S. 1993. Computational interpretations of linear logic. Theoretical Computer

Science 111, 1-2 (April 12), 3-57.
Abramsky, S., Jagadeesan, R., and Malacaria, P. Full abstraction for PCF. To appear in

Information and Computation.
Abramsky, S. and Jung, A. 1994. Domain theory. In S. Abramsky, D. M. Gabbay, and

T. S. E. Maibaum Eds., Handbook of Logic in Computer Science, Volume 3, pp. 1-168.
Clarendon Press.

Abramsky, S. and McCusker, G. 1997. Linearity, sharing and state. In P. W. O'Hearn

and R. D. Tennent Eds., Algol-like Languages, Volume 2, pp. 297-330. Boston:
Birkhauser. Extended abstract to appear in Proceedings of Linear Logic 1996, Electronic
Notes in Theoretical Computer Science, volume 3, Elsevier Science, 1996.

Barber, A. and Plotkin, G. 1997. Dual intuitionistic linear logic. Submitted.
Benton, N., Bierman, G., de Paiva, V., and Hyland, M. 1993. A term calculus for

intuitionistic linear logic. In M. Bezen and J. F. Groote Eds., Typed Lambda Calculi and
Applications, Volume 664 of Lecture Notes in Computer Science (Utrecht, The Netherlands,
March 1993), pp. 75-90. Springer-Verlag, Berlin.
Berry, G. 1978. Stable models of typed lambda-calculi. Automata, Languages and Programming, Fifth Colloquium, Udine, 72-89. Lecture Notes in Computer Science 62.
Berry, G. and Curien, P.-L. 1982. Sequential algorithms on concrete data structures.

Theoretical Computer Science 20, 265-321.
Bezen, M. and Groote, J. F. Eds. 1993. Typed Lambda Calculi and Applications, Volume 664 of Lecture Notes in Computer Science (Utrecht, The Netherlands, March 1993).
Springer-Verlag, Berlin.
Brookes, S., Main, M., Melton, A., and Mislove, M. Eds. 1995. Mathematical Foundations of Programming Semantics, Eleventh Annual Conference, Volume 1 of Electronic
Notes in Theoretical Computer Science (Tulane University, New Orleans, Louisiana, March
29-April 1 1995). Elsevier Science.

Chirimar, J., Gunter, C. A., and Riecke, J. 1994. Reference counting as a computational

interpretation of linear logic. Journal of Functional Programming 2, 6, 194-244.

From Algol to Polymorphic Linear Lambda-calculus \Delta  55
Day, B. J. 1970. On closed categories of functors. In S. Mac Lane Ed., Reports of the Midwest Category Seminar, Volume 137 of Lecture Notes in Mathematics, pp. 1-38. SpringerVerlag, Berlin-New York.

Girard, J.-Y. 1972. Interpr'etation Fonctionnelle et Elimination des Coupures de l'Arithm'etique d'Ordre Sup'erieur. Ph. D. thesis, Universit'e Paris VII.

Girard, J.-Y. 1987. Linear logic. Theoretical Computer Science 46, 1-102.
Holmstr"om, S. 1988. Linear functional programming. Proceedings of the Workshop on

Implementation of Lazy Functional Languages, Chalmers University.

Hyland, J. M. E. and Ong, C.-H. L. 1994. On full abstraction for PCF: I, II and III.

Submitted for publication.

Lafont, Y. 1988. The linear abstract machine. Theoretical Computer Science 59, 157-180.
Lambek, J. 1989. Multicategories revisited. In J. W. Gray and A. Scedrov Eds., Categories in Computer Science and Logic, Volume 92 of Contemporary Mathematics, pp.
217-240. American Mathematical Society.

Lent, A. F. 1993. The category of functors from state shapes to bottomless CPOs is adequate for block structure. In ACM SIGPLAN Workshop on State in Programming Languages (Copenhagen, Denmark, June 12, 1993), pp. 101-119. Technical report RR-968,
Department of Computer Science, Yale University.

Mackie, I. 1994. Lilac : A functional programming language based on linear logic. Journal

of Functional Programming 4, 4 (Oct.), 395-433.

Milner, R. 1977. Fully abstract models of typed *-calculi. Theoretical Computer Science 4,

1-22.

Milner, R. 1989. Communication and Concurrency. Prentice Hall, New York.
O'Hearn, P. W., Power, A. J., Takeyama, M., and Tennent, R. D. 1999. Syntactic

control of interference revisited. Theoretical Computer Science ??, ???-??? To appear.
Preliminary version in [Brookes et al. 1995] and in [O'Hearn and Tennent 1997b].

O'Hearn, P. W. and Reddy, U. S. 1999. Objects, interference and the Yoneda embedding.

Theoretical Computer Science ??, ???-??? To appear. Preliminary version in [Brookes et al.
1995].

O'Hearn, P. W. and Riecke, J. G. 1995. Kripke logical relations and PCF. Information

and Computation 120(1), 107-116.

O'Hearn, P. W. and Tennent, R. D. 1995. Parametricity and local variables. J.

ACM 42(3), 658-709. Also in [O'Hearn and Tennent 1997b], pages 109-164.

O'Hearn, P. W. and Tennent, R. D. Eds. 1997a. Algol-like Languages, Volume 1.

Birkhauser, Boston.

O'Hearn, P. W. and Tennent, R. D. Eds. 1997b. Algol-like Languages, Volume 2.

Birkhauser, Boston.

Oles, F. J. 1982. A Category-Theoretic Approach to the Semantics of Programming Languages. Ph. D. thesis, Syracuse University, Syracuse, N.Y.

Oles, F. J. 1987. Lambda calculi with implicit type conversions. Technical Report

RC 13245, IBM Research, T. J. Watson Research Center, Yorktown Heights, N.Y.

Oles, F. J. 1997. Functor categories and store shapes. In P. W. O'Hearn and R. D.

Tennent Eds., Algol-like Languages, Volume 2, pp. 3-12. Boston: Birkhauser.

Pitts, A. 1996. Reasoning about local variables with operationally-based logical relations.

In Proceedings, 11th Annual IEEE Symposium on Logic in Computer Science (New Jersey,
USA, 1996), pp. 152-163. IEEE Computer Society Press, Los Alamitos, California. Also in
[O'Hearn and Tennent 1997b], pages 165-186.

Plotkin, G. 1983. Domains. 1992 TeXed edition of course notes prepared by Yugo Kashiwagi and Hidetaka Kondoh from notes by Tatsuya Hagino.

Plotkin, G. and Abadi, M. 1993. A logic for parametric polymorphism. In M. Bezen and

J. F. Groote Eds., Typed Lambda Calculi and Applications, Volume 664 of Lecture Notes
in Computer Science (Utrecht, The Netherlands, March 1993), pp. 361-375. SpringerVerlag, Berlin.

56 \Delta  P.W. O'Hearn and J.C. Reynolds

Plotkin, G. D. 1977. lcf considered as a programming language. Theoretical Computer

Science 5, 223-255.
Plotkin, G. D. 1980. Lambda-definability in the full type hierarchy. In J. P. Seldin and

J. R. Hindley Eds., To H. B. Curry: Essays in Combinatory Logic, Lambda Calculus and
Formalism, pp. 363-373. Academic Press.

Plotkin, G. D. 1993. Type theory and recursion (extended abstract). In Proceedings,

Eighth Annual IEEE Symposium on Logic in Computer Science (Montreal, Canada, 19-23
June 1993), pp. 374. IEEE Computer Society Press.
Reddy, U. S. 1996. Global states considered unnecessary: introduction to object-based

semantics. Lisp and Symbolic Computation. Special issue on State in Programming Languages. Also in [O'Hearn and Tennent 1997b], pages 227-296.

Reynolds, J. C. 1974. Towards a theory of type structure. In Proc. Colloque sur la Programmation, Volume 19 of Lecture Notes in Computer Science (Berlin, 1974), pp. 408-425.
Springer-Verlag.
Reynolds, J. C. 1978. Syntactic control of interference. In Conference Record of the Fifth

Annual ACM Symposium on Principles of Programming Languages (Tucson, Arizona, January 1978), pp. 39-46. ACM, New York. Also in [O'Hearn and Tennent 1997a], pages
273-286.
Reynolds, J. C. 1981a. The Craft of Programming. Prentice-Hall International, London.
Reynolds, J. C. 1981b. The essence of Algol. In J. W. de Bakker and J. C. van Vliet

Eds., Algorithmic Languages (Amsterdam, October 1981), pp. 345-372. North-Holland,
Amsterdam. Also in [O'Hearn and Tennent 1997a], pages 67-88.

Reynolds, J. C. 1983. Types, abstraction and parametric polymorphism. In R. E. A.

Mason Ed., Information Processing 83 , pp. 513-523. Amsterdam: North Holland.

Riecke, J. G. and Sandholm, A. 1997. A relational account of call-by-value sequentiality.

In Proceedings, Twelth Annual IEEE Symposium on Logic in Computer Science (Warsaw,
Poland, 29 June-2 July 1997), pp. 258-267. IEEE Computer Society Press.
Schmidt, D. A. 1985. Detecting global variables in denotational specifications. ACM Trans.

on Programming Languages and Systems 7, 3 (April), 299-310.
Scott, D. S. 1972. Mathematical concepts in programming language semantics. In Proc.

1972 Spring Joint Computer Conference (1972), pp. 225-34. AFIPS Press, Montvale, N.J.

Scott, D. S. and Strachey, C. 1971. Toward a mathematical semantics for computer

languages. In J. Fox Ed., Proceedings of the Symposium on Computers and Automata,
Volume 21 of Microwave Research Institute Symposia Series (1971), pp. 19-46. Polytechnic Institute of Brooklyn Press, New York. Also Technical Monograph PRG-6, Oxford
University Computing Laboratory, Programming Research Group, Oxford.

Sieber, K. 1996. Full abstraction for the second order subset of an Algol-like language.

Theoretical Computer Science 168, 1 (10 Nov.), 155-212.
Strachey, C. 1972. The varieties of programming language. In Proceedings of the International Computing Symposium (Venice, April 1972), pp. 222-233. Cini Foundation, Venice.
Also in [O'Hearn and Tennent 1997a], pages 51-64.
Tennent, R. D. 1991. Semantics of Programming Languages. International Series in Computer Science. Prentice-Hall International.

Wadler, P. 1990. Linear types can change the world! In M. Broy and C. Jones Eds.,

IFIP TC-2 Working Conference on Programming Concepts and Methods (Sea of Galilee,
Israel, April 1990), pp. 347-359. North Holland, Amsterdam.
Wadler, P. 1991. Is there a use for linear logic? In ACM/IFIP Symposium on Partial

Evaluation and Semantics-Based Program Manipulation (1991). Proceedings of the 1991
Conference.