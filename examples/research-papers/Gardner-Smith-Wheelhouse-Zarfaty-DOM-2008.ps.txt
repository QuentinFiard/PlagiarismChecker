

Local Hoare Reasoning about DOM
Philippa A. Gardner

Imperial Collegepg@doc.ic.ac.uk

Gareth D. Smith

Imperial Collegegds@doc.ic.ac.uk

Mark J. Wheelhouse

Imperial Collegemjw03@doc.ic.ac.uk

Uri D. Zarfaty
Imperial Collegeudz@doc.ic.ac.uk

ABSTRACT
The W3C Document Object Model (DOM) specifies an XML
update library. DOM is written in English, and is therefore
not compositional and not complete. We provide a first
step towards a compositional specification of DOM. Unlike
DOM, we are able to work with a minimal set of commands
and obtain a complete reasoning for straight-line code. Our
work transfers O'Hearn, Reynolds and Yang's local Hoare
reasoning for analysing heaps to XML, viewing XML as an
in-place memory store as does DOM. In particular, we apply recent work by Calcagno, Gardner and Zarfaty on local
Hoare reasoning about simple tree update to this real-world
DOM application. Our reasoning not only formally specifies
a significant subset of DOM Core Level 1, but can also be
used to verify, for example, invariant properties of simple
Javascript programs.

Categories and Subject Descriptors
F.3.1 [Specifying and Verifying and Reasoning about
Programs]: Logics of programs

General Terms
Languages, Theory, Verification

1. INTRODUCTION

The Document Object Model (DOM) [12] specifies an
XML update library, and is maintained by the World Wide
Web Consortium (W3C). Its purpose is to be:

a platform- and language-neutral interface that
will allow programs and scripts to dynamically
access and update the content, structure and style
of documents.

A DOM implementation exists in most popular high-level
languages, and is used in many applications for accessing
and updating XML. For example, consider a webpage with
a button labelled `today's weather'; click on the button and

Permission to make digital or hard copies of all or part of this work forpersonal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copiesbear this notice and the full citation on the first page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior specificpermission and/or a fee.
PODS'08 June 9-12,2008, Vancouver, BC, Canada.Copyright 2008 ACM 978-1-60558-108-8/08/06 ...$5.00.

embedded Javascript (using an implementation of DOM)
puts `today's weather' in the tree.

DOM provides an interesting example of a library which is
important enough to be given a comparatively formal specification. Over the years, it has evolved into a specification
which, by consensus, seems to be correct. DOM is, however,
written in English. This means that it is liable to misinterpretation; until recently, the Python mini-DOM implementation was incorrect. It also means that DOM is not compositional, in the sense that a specification of a composite
command cannot be determined directly from the specification of its parts. DOM is thus larger than it need be,
specifying for example composite commands such as getPreviousSibling. It also means that DOM is not complete; for example, it specifies the insertBefore command,
but not its sister command insertAfter.

We provide a compositional specification of a significant
fragment of DOM. Unlike DOM, we are able to work with
a minimal set of commands and obtain complete reasoning
for straight-line code. We do this by transferring techniques
from program verification for reasoning about heaps [7] to
XML, viewing XML as an in-place memory store as does
DOM. In particular, O'Hearn, Reynolds and Yang have recently introduced local Hoare reasoning about shared data
structures in memory using Separation Logic [7]. Calcagno,
Gardner and Zarfaty adapted this work to provide local
Hoare reasoning about simple tree update [3], introducing
Context Logic for reasoning about both data and contexts.
In this paper, we demonstrate that their reasoning scales to
DOM's richer tree structure and update commands.

The Document Object Model
The documentation for DOM is substantial [13]. DOM is
divided into a number of levels, of which the Level 1 is the
most fundamental. The Level 1 specification is itself separated into two parts: Core, which `provides a low-level set
of fundamental interfaces that can represent any structured
document'; and HTML, which `provides additional, higherlevel interfaces. . . to provide a more convenient view of an
HTML document'. In this paper, we are interested in the
fundamental interfaces in DOM Core Level 1. In Section
1.1.4 of the DOM Specification, we read:

The DOM Core APIs present two somewhat different sets of interfaces to an XML/HTML document; one presenting an `object-oriented' approach with a hierarchy of inheritance, and a
`simplified' view that allows all manipulation to
be done via the Node interface.

1

We work with the Node interface. We make a further simplification, concentrating on that part of DOM Core Level
1 which focuses on the XML tree structure and simple text
nodes, rather than dealing directly with more complex content of the structure such as Attributes, DocumentFragments, etc. The main conceptual difficulties lie with this
tree and text structure; the other structures are presented
in DOM as nodes with similar properties. We will extend
our specification to the full DOM Core Level 1 in future.

The fact that DOM is written in English means that understanding the precise conditions under which a command
applies is error prone. This is significant, since the DOM
approach only works if a DOM implementation really does
conform with the specification. For example, the command
appendChild has the DOM specification

appendChild Adds the node newChild to the end of the list of

children to this node. If the newChild is already
in the tree, it is first removed.
....
Exceptions ...

HIERARCHY_REQUEST_ERR: Raised if this node is of a type
that does not allow children of type of the newChild node,
or if the node to append is one of this node's ancestors.

This DOM specification first gives the intuition regarding
the behaviour of the method, and then reinforces this intuition with details about when it does not work, such as
when newChild is an ancestor of the node in question. This
fundamental safety condition is buried inside one of several
exceptions associated with the method and is easy to miss.

We observed that this safety error condition had been
missed by Python mini-DOM [10, 14]; Orendorff has recently
provided a patch which corrects this error [9]. The documentation for Python mini-DOM [11] states: `DOMException
is currently not supported in xml.dom.minidom. Instead,
xml.dom.minidom uses standard Python exceptions such as
TypeError and AttributeError'. This is a perfectly sensible
design decision, especially since DOM actively encourages
this approach to reporting errors: `error conditions may be
indicated using native error reporting mechanisms'. However, it meant that the programmers understandably did
not pay close attention to the HIERARCHY REQUEST ERR
above: the first part of the error involving typing is covered
by Python exceptions; the part stating that newChild cannot be an ancestor is not covered by Python exceptions and
was ignored. The operation therefore silently went ahead,
creating a structure with a loop. If the loop was subsequently traversed by a program, then the program would
diverge. With our style of local reasoning, this fundamental
error in basic update behaviour would have been avoided.

Local Hoare Reasoning
We provide local Hoare reasoning about our fragment of
DOM Core Level 1, inspired by a recent breakthrough in
reasoning about the way programs manipulate the memory.
Researchers previously used Hoare reasoning based on Firstorder Logic to specify how programs interacted with the
whole memory. O'Hearn, Reynolds and Yang instead introduced local Hoare reasoning based on Separation Logic [7].
They summarise their key idea as follows:

To understand how a program works, it should
be possible for reasoning and specification to be
confined to the cells that the program actually
accesses. The value of any other cell will automatically remain unchanged.

Their work is having substantial impact, proving to be important for modular reasoning about large programs [1] and
for concurrent, distributed programming [8]. It has led to
the verification tool Smallfoot [2], a tool for automatically
checking the absence of memory errors in C-programs based
on a decidable fragment of Separation Logic. Ideas from
Smallfoot are now being used in the program analysis tool
SLAyer being developed at Microsoft Research Cambridge.

Following O'Hearn et al.'s work, Calcagno, Gardner and
Zarfaty developed local Hoare reasoning about a simple treeupdate language using Context Logic [3]. This work required
a fundamental shift in how we reason about structured data.
The key idea is that local data update typically identifies the
portion of data to be replaced, removes it, and inserts new
data in the same place. Context Logic reasons disjointly
about both data and this place of insertion (contexts).

In this paper, we provide local Hoare reasoning for our
fragment of DOM Core Level 1, using Context Logic applied
to DOM's comparatively rich tree structure. We illustrate
our reasoning using the command `appendChild (parent,
newChild)', which moves the tree at newChild to be the last
child of parent. The command only succeeds when the trees
parent and newChild are present in the store, and when
newChild is not an ancestor of parent. This safety property
is expressible in Context Logic by the formula

9 name, name0. (?F -ffi(cg ffi nameparent[trueF])) ffi hname0newChildiF

This formula states that the data structure can be split
into two disjoint parts: a subforest containing a tree satisfying formula name0newChild , which states that the top node
is newChild, and a context satisfying formula (?F -ffi(cg ffi
nameparent[trueF])) which states that, when the empty forest?

F is put in the hole, then the result contains a subtree with
top node parent. Thus, both newChild and parent are in

the tree, and newChild is not an ancestor of parent. The
corresponding postcondition is

9name, name0. cg ffi (nameparent[trueF \Omega  hname0newChildiF])

This formula states that the resulting store has a changed
subtree parent, which now has the subforest hname0newChild iF
at the end of its list of children.

Our specification is compositional in the sense that two
Hoare triples compose if the postcondition of the first logically implies the precondition of the second. This compositionality enables us to focus on a minimal set of update
commands, whereas DOM has to specify all the commands
for which a specification is useful: e.g., we can derive the
specification of the command getPreviousSibling with our
reasoning, whereas DOM specifies it directly. Our specification is complete for straight-line code, which we prove using
a standard technique of deriving the weakest preconditions
of our commands: e.g., unlike DOM we can derive a specification of insertAfter. Finally, our reasoning can be used to
verify invariant properties of simple programs: e.g., we show
that a program for moving a person to a new address in an
address book satisfies an XML schema invariant specifying
that an XML document is indeed an address book.

2. MINIMAL DOM

We describe Minimal DOM, capturing the fragment of
DOM Core Level 1 which deals with tree and text update.
DOM is specified in an object-oriented manner, and hence
encapsulates both data and behaviour into objects. We

2

separate the concerns, by first presenting an abstract data
structure and then commands over that structure. This approach is consistent with DOM's `simplified' view where all
manipulation is done via the Node interface.

2.1 The Tree Structure

We focus on the basic XML tree structure with simple
text content, presenting an abstract data structure consisting of trees, forests, groves and strings. Trees t correspond
to (part of) the Node interface. Forests f are lists of trees
and correspond to the sub-collections of the NodeList interface. Complete forests [f ]fid with identifier fid correspond
directly to the NodeList interface. Groves g are sets of completed trees and correspond to the object store in which
Nodes exist. Strings s correspond to the type DOMString.

Like DOM, we update our data in place. This means
that we must refer to subdata directly. Each node and list
of children therefore has a unique identifier which can be
directly referenced by a program using program variables.

Definition 1. (Trees, forests, groves and strings).
Given an infinite set Id of node identifiers and a finite set
Char of text characters, with a distinguished character #,
we define trees t 2 T, forests f 2 F, groves g 2 G and
strings s 2 S by: (with id, fid 2 Id and c 2 Char)

trees t ::= sid[f ]fid | #textid[s]
forests f ::= ?F | htiF | f \Omega  f
groves g ::= ?G | htiG | g \Phi  g
strings s ::= ?S | c | s * s

For well-formedness, the identifiers must be unique. We
write d to denote arbitrary data, and id 62 d for when the
identifier id is not found in d. There is a simple structural
congruence, denoted j, stating that \Omega  is associative with
identity ?F, that \Phi  is associative and commutative with
identity ?G, and that * is associative with identity ?S. We
use a notational shorthand for strings, writing abc for a*b*c.
Trees are built from element nodes sid and text nodes #textid,
where #text is a string with the distinguished character #
and the string s is an element name which must not include
the # character; we write EltNames ae S to denote this set
of strings without #. We write |f|, |g| and |s| for the length
of a forest, size of a grove or length of a string respectively.

Notice that the list of children is given its own identifier fid, following DOM which refers to such child lists directly (for example, see the DOM command getChildNodes
in section 2.2). As an example, consider the XML structure:

hhouseholdih

personiTricia McMillanh/personih
addressiIslingtonh/addressih
phonei020 267 7091h/phoneih
/householdi

which can be written as the tree:

householdid1[h

personid2[h#textid6[Tricia McMillan]iF]fid2 iF \Omega h
addressid3 [h#textid7[Islington]iF]fid3iF \Omega h
phoneid4 [h#textid8[020 267 7091]iF]fid4iF]fid1

using an arbitrary choice of unique identifiers. We do not
give identifiers to arbitrary forests f or strings, only to complete lists [f]fid, as in DOM.

We also define natural contexts for each of our data structures. Contexts are not used in DOM. We shall see that they
are essential for the context reasoning described in Section 3.

Definition 2. (Contexts). Given an infinite set Id of
node identifiers and a finite set Char of single text characters, we define tree contexts ct 2 CT, forest contexts cf 2 CF,
grove contexts cg 2 CG and string contexts cs 2 CS by

tree contexts ct ::= -T | sid[cf]fid | #textid[cs]
forest contexts cf ::= -F | hctiF | cf \Omega  f | f \Omega  cf
grove contexts cg ::= -G | hctiG | cg \Phi  g
string contexts cs ::= -S | cs * s | s * cs

As before, we have element names in EltNames, unique
identifiers, and an analogous congruence on contexts.

Given data types D1, D2 2 {T, F, G, S}, we sometimes write
cd : D1 ! D2 to denote a context cd 2 CD2 with hole -D1.
We call D1 ! D2 the context type of cd. The DOM context
structure is quite complex compared with our previous work
on a simple tree structure which had one hole type [3]: string
contexts have just string holes, but tree and forest contexts
have tree, forest and string holes, and grove contexts have
holes of arbitrary type. Notice that a forest hole of a grove
context must have a parent node, whereas this is not the
case for a tree or grove hole. The distinction between the
tree t, the forest htiF and the grove htiG is thus important
for our context reasoning.

We define the partial application function ap : (D1\Delta D2)*
D1 * D2, which returns a result if there is no clash of
identifiers between the arguments of the function.

Definition 3. (Context application). Given data types
D1, D2 2 {T, F, G, S}, the partial application function ap :
(D1\Delta D2)*D1 * D2 is defined by induction on the structure
of the first argument (and undefined where not given):

ap(-T, t) , t
ap(sid[cf ]fid, d1) , sid[ap(cf, d1)]fid if id,fid /2 d1

else undefined

ap(#textid[cs], s) , #textid[ap(cs, s)]

ap(-F, f) , f
ap(hctiF, d1) , hap(ct, d1)iF
ap(cf \Omega  f, d1) , ap(cf, d1) \Omega  f
ap(f \Omega  cf, d1) , f \Omega  ap(cf, d1)

ap(-G, g) , g
ap(hctiG, d1) , hap(ct, d1)iG
ap(cg \Phi  g, d1) , ap(cg, d1) \Phi  g

ap(-S, s) , s
ap(cs * s0, s) , ap(cs, s) * s0
ap(s0 * cs, s) , s0 * ap(cs, s)

We use ap(cd2, d1) # to denote that ap(cd2, d1) is defined.

As normal for in-place update, our language depends on a
variable store and expressions. The store s includes variables
of type Id, S, Z and B. The expressions consist of variables and constants, concatenation on strings, arithmetic
operations on integers, and logical operations on booleans.
Variables of type Id also permit a null value, recording the
absence of a node (e.g., the top node of a tree in the grove
has no parent node). Expressions of type Id only include
variables and the null value, since programs do not refer directly to identifier constants, just like standard imperative
programs do not refer to literal heap addresses.

3

Definition 4. (Variable store). The variable store s is
a total function sending variables to values. The store contains four types of store variable: identifier variables VarId ={

id, fid, list, newChild, . . . }, string variables VarS = {str,
name, . . . }, integer variables VarZ = {int, length, . . . } and
boolean variables VarB = {bool, . . . }:

s : (VarId ! Id ] {null}) * (VarS ! S) *

(VarZ ! Z) * (VarB ! B)

The notation Varstore denotes the set of store variables. By
convention, all variable names are in lower camelCase. Note
that, unlike element node names, string variable values may
contain any character.

Definition 5. (Expressions). Expressions build up values from constants and variables. There are four types:
identifier expressions ExpId = {Id, . . . }, string expressions
ExpS = {Str, Arg, . . . }, integer expressions ExpZ = {Int,
Offset, . . . } and boolean expressions ExpB = {Bool, . . . }:

Id ::= null | id
Str ::= ?S | c | str | Str * Str
Int ::= n | int | Int + Int | Int - Int
Bool ::= false | bool | Bool ) Bool | Id = Id|

Str = Str | Int = Int | Int > Int

where id 2 VarId, c 2 Char, str 2 VarS, n 2 Z, int 2 VarZ
and bool 2 VarB. Evaluation JExpV Ks of expression ExpV
on store s, for V 2 {Id, S, Z, B}, is defined as expected. By
convention, expression names are in upper CamelCase.

2.2 The Language

We now introduce Minimal DOM, which represents the
essence of the Node interface view of the DOM API in
a minimal and sufficient update language. In the spirit
of presenting an imperative (`flattened') interface to the
object-oriented library, we abandon object-oriented notation. We therefore specify the methods of the Node interface as imperative commands over a shared grove: e.g.,
the method call `p.appendChild(c)' becomes the command
`appendChild(p, c)'. Similarly, we represent object attributes
as a pair of get and set commands, with the set command
omitted if the attribute is read only: e.g., the CharacterData attribute `n.data' can be represented by the commands
`getData(n)' and `setData(n)' while the `n.parentNode' attribute can be represented by the `getParentNode(n)' command alone. Some attributes and methods in the Node interface are omitted from Minimal DOM since they are not
concerned with the tree structure or contents of text nodes.
Others are omitted because they are redundant, in that they
may be expressed as the composition of other commands.
Finally, neither the Node nor the NodeList interface provide
a means of introducing new Nodes into the grove. For this
functionality, we introduce the Minimal DOM commands
createNode and createTextNode, which here perform the
same functions as the DOM Document methods createElement and createTextNode.

To reason about programs which use the Minimal DOM
library, we also require a Minimal DOM language for those
programs to be written in. Our language is as simple and
general as possible, consisting only of imperative sequencing,
conditionals, while loops, and the variables and expressions.
For convenience, we implicitly assume procedural recursion.

Definition 6. (Minimal DOM). The Minimal DOM commands are: (with the arguments named as in DOM)

C ::= appendChild(parent, newChild) append tree|

removeChild(parent, oldChild) remove child|
name := getNodeName(node) get node name|
id := getParentNode(node) get parent node|
fid := getChildNodes(node) get child nodes|
node := createNode(Name) new elt. node|
node := item(list, Int) get forest elt.|
str:=substringData(node,Offset,Count) get substring|
appendData(node, Arg) append string|
deleteData(node, Offset, Count) erase substring|
node := createTextNode(Str) new text node

| id:=Id| str := Str | int := Int | bool := Bool assignment|

C ; C sequencing|
if Bool then C else C if-then-else|
while Bool do C while-do|
skip skip

The DOM commands have the following behaviour:
appendChild (parent, newChild) moves the tree newChild

to the end of parent's child list. Requires that parent
exists and is not a text node, and that newChild exists
and is not an ancestor of parent, or it faults.
removeChild (parent,oldChild) removes the tree oldChild

from the tree parent's child forest and re-inserts it at
the root of the grove. Requires that parent exists and
oldChild is a child of parent, or it faults.
name := getNodeName (node) assigns to the variable name

the nodeName value of node if it exists, or it faults. If
node is a text node, then name = #text.
id := getParentNode (node) assigns to the variable id the

identifier of the parent of node, if it exists, and null
otherwise. Requires that node exists or it faults.
fid := getChildNodes (node) assigns to the variable fid

the identifier of the child forest of the element node,
which must exist or it faults.
node := createNode (Name) creates a new element node at

the root of the grove, with fresh id and fid and a
name equal to Name, and records its identifier in the
variable node. It faults if JNameKs 62 EltNames.
node := item (list, Int) sets the variable node to the Int+

1th node in the list pointed to by list, setting it to
null if Int evaluates to an invalid index. It faults if
list does not exist.
str := substringData (node,Offset,Count) assigns to the

variable str the substring of the string of the text node
node starting at character Offset with length Count.
If Offset + Count exceeds the string length, then all
the characters to the string end are returned. Requires
that node exists, Offset and Count be non-negative,
and Offset be at most the string length, or it faults.
appendData (node, Arg) appends the string Arg to the end

of the string contained in node. Requires that node
exists and be a text node, or it faults.
deleteData (node, Offset, Count) deletes the substring of

the string of node starting at the character Offset
with length Count. If Offset + Count exceeds the
string length, then all the characters to the string end
are deleted. Requires that node exists, Offset and
Count be non-negative, and Offset be at most the
string length, or it faults.

4

node := createTextNode (Str) creates a new text node at

the grove level, with fresh id and the string contained
within the text node set to Str, and records the new
node's identifier in the variable node.

The behaviour of these Minimal DOM commands can be described formally by an operational semantics (see [5]), using
an evaluation relation  relating configuration triples C, s, g
where C is a command, s is a store and g a grove, to either
terminal states s0, g0, or fault. Notice that removeChild
does not delete the tree identified by oldChild, but instead
moves it to the grove. It is not possible to delete a tree from
the grove in Minimal DOM. This follows DOM, which deliberately declines to specify any destructive memory management methods, so as to leave open the question of whether
memory should be manually managed or garbage collected.
It is natural therefore to think of programs written in `pure'
Minimal DOM (without destructive memory management)
as garbage collected programs.

DOM operations raise exceptions in `exceptional circumstances, i.e., when an operation is impossible to perform'
[DOM, Section 1.2]. Examples include: trying to move a tree
into its own subtree using appendChild; trying to create a
node with #text as a name; and trying to use removeChild
to remove a non-existent subtree of a given tree. Where
DOM calls for a DOMException, we raise a fault. This is
compatible with the specification, which states that in languages that do not support exceptions, `error conditions may
be indicated using native error reporting mechanisms'.

Theorem 1 (Minimality/Sufficiency). Minimal
DOM is indeed minimal, and sufficient to describe the tree
structure and text nodes of DOM Core Level 1.

3. CONTEXT LOGIC APPLIED TO DOM

We study Context Logic for analysing our DOM tree structure, following previous work on Context Logic for analysing
simple trees (forests) [15]. Although the basic reasoning is
the same, the transition was by no means easy due to the
comparative complexity of the DOM structures.

With Context Logic, the fundamental idea is that, in order
to provide local Hoare reasoning about tree update, we must
reason about both trees and the interim contexts. Such local
Hoare reasoning is not possible using, for example, Ambient Logic [4], despite its reasoning about static trees being
analogous to the Separation Logic reasoning about heaps.

Context Logic consists of standard formulae constructed
from the connectives of first-order logic, variables, expression tests, and quantification over variables. In addition,
it has general structural formulae and specific formulae applicable to DOM. The structural formulae of Context Logic
are constructed from an application connective for analysing
context application, and its two corresponding right adjoints:
for data types D, D1, D2 2 {T, F, G, S},

* the application formula P ffiD1 P1 describes data of e.g.

type D2, which can be split into a context of type
D1 ! D2 satisfying P , and disjoint subdata of type D1
satisfying P1; the application connective is annotated
with type information about the context hole, since
this cannot be determined from the given data;

* one right adjoint P ffi-D2P2 describes data of e.g. type

D1 which, whenever it is successfully placed in a context of type D1 ! D2 satisfying P , results in data of

type D2 satisfying P2; the adjoint is annotated with
type information about the resulting data, since this
cannot be determined from the hole type; and

* the right adjoint P1 -ffiP2 describes a context of e.g.

type D1 ! D2 which, whenever data of type D1 satisfying P1 is successfully inserted into it, results in data
of type D2 satisfying P2; there is no type annotation
as it can be inferred from the type of the given data.

The DOM-specific formulae analyse the data and context
structure of DOM, and have a direct correspondence with
the data structures given in definitions 1 and 2. For example,
the specific forest formula hpid[trueF]fidiF describes a forest
containing one tree with top node labelled p, an arbitrary
subforest, and identifiers determined by the values of the
identifier variables given by the store. The formula9

id, fid. trueF!T ffiF hpid[trueF]fidiF
describes a tree which can be split into a context and a subforest containing one tree with top node labelled p. Formula9

id, id0, fid, fid0. (?F -ffiP ) ffiF hpid[trueF]fidiF
describes a tree that can be split into a context and a subforest containing a tree with top node p. This time the context
satisfies the property that, when the empty forest is put into
the context hole, the resulting tree satisfies formula P .

Recall that Minimal DOM uses identifier, string, integer
and boolean variables. For our Hoare reasoning, we also
require tree, forest, grove and context variables. Our logic
therefore uses a logical environment e as well as the store s.
The logical environment assigns values for data variables in
VarD0 , where D0 2 {T, F, G}; string variables are excluded
from the environment, as they are also program variables
and are hence assigned values via the store. The environment also assigns values to context variables VarD1!D2. For
simplicity, we let D1, D2 2 {T, F, G, S}. However, there are
no contexts R ! S, G ! R or G ! S for R 2 {T, F}, so
we assume the corresponding variable sets are empty.

Definition 7. (Logical environment). A logical environment e is a total function sending data variables VarD0
and context variables VarD1!D2 to their values:

e : Y

D02{T,F,G}

VarD0 ! D0 * Y

D1,D22{T,F,G,S}

(VarD1!D2) ! D1 ! D2

Varenv denotes the set of environment variables.

Definition 8. (Formulae for DOM). Let A denote a
data or context type of the form D or D1 ! D2. The
formulae for DOM are defined by:

P ::= P ) P | falseA Boolean formulae

P ffiD1 P | P ffi-D2P | P -ffiP structural formulae
. . . (see below) . . . DOM-specific formulae
vare | ExpV = ExpV expression equality
Int= len(f) | Int= len(Str) length equality
eltName(Str) valid element name9

var. P quantification

where vare denotes a logical variable, V2{Id, S, Z, B}, var 2
Varenv [ Varstore. The DOM-specific formulae are:

P ::= . . . | -T | Pid[P ]fid | #textid[P ]| ?

F | -F | hP iF | P \Omega  P| ?
G | -G | hP iG | P \Phi  P| -
S | Str | P * P

5

The type annotations on the formulae enable us to define
a simple typing relation P : A, where A is a data or context type, by induction on the structure of formula P . The
Boolean formulae and quantified formulae inherit their types
from the subformulae. The equalities satisfy arbitrary A,
since they are really outside the typing system as they test
the store rather than the data and context structures. We
give the cases for the structural formulae and for the DOMspecific formulae for trees, and give one forest case; the cases
for the other DOM-specific formulae are similar:

(P1 ffiD1 P2): D2 , P1 : D1\Delta D2 ^ P2 : D1
(P1 ffi-D2 P2): D1 , P1 : D1\Delta D2 ^ P2 : D2
(P1-ffiP2): D1\Delta D2 , P1 : D1 ^ P2 : D2-

T : T\Delta TP
id[P 0]fid : T , P : S ^ P 0 : FP
id[P 0]fid : R\Delta T , P : S ^ P 0 : R\Delta F

#textid[P ]: T , P : S

#textid[P ]: S\Delta T , P : S\Delta S

(P1 \Omega  P2): F , P1 : F ^ P2 : F
(P1 \Omega  P2): R\Delta F , (P1 : R\Delta F ^ P2 : F) . (P1 : F ^ P2 : R\Delta F)

where R 2 {T, F, S} denotes the possible tree or forest context holes. The formulae Pid[P1]fid and #textid[P ] have two
typings, depending on whether they describe trees or tree
contexts. P1 \Omega  P2 also has the two typings; notice that the
context case has two options for typing subformulae, depending on which one describes the forest context.

Definition 9. (Satisfaction Relation). The satisfaction relation e, s, a |=A P is defined on environment e, variable store s, datum or context a of type A, and formula P
of type A by induction on P . A is a data or context type
and R 2 {T, F, S} as above. For the Booleans, we have:

e, s, a |=A P ) P 0 , e, s, a |=A P ) e, s, a |=A P 0
e, s, a |=A falseA never

For the structural formulae, we have
e,s,d2 |=D2P1 ffiD1 P2 , 9cd:(D1\Delta D2), d1:D1. d2 = ap(cd, d1)^

e, s, cd|=D1\Delta D2 P1 ^ e, s, d1 |=D1 P2

e,s,d1 |=D1 P1 ffi-D2P2 , 8cd:(D1\Delta D2). (e, s, cd |=D1\Delta D2 P1 ^

ap(cd, d1)#) ) e, s, ap(cd, d1) |=D2 P2

e,s,cd2|=D1\Delta D2P1-ffiP2 , 8d1:D1. e, s, d1 |=D1 P1 ^ ap(cd2, d1)#)

e, s, ap(cd2, d1) |=D2 P2

For the DOM-specific formulae, we have:

e, s, ct |=T\Delta T -T , ct j -T
e, s, t |=T Pid[P 0]fid , 9s:S, f:F. (t j ss(id)[f]s(fid)) ^

e, s, s |=S P ^ e, s, f |=F P 0
e, s, ct |=R\Delta T Pid[P 0]fid , 9s:S, cf:(R\Delta T). (ctjss(id)[cf]s(fid))^

e, s, s |=S P ^ e, s, cf |=R\Delta F P 0

e, s, t |=T #textid[P ] , 9s:S. (tj#texts(id)[s]) ^ e, s, s |=S P
e,s,ct |=S\Delta T #textid[P ] , 9cs:(S\Delta S). (ct j #texts(id)[cs]) ^

e, s, cs |=S\Delta S P

e, s, f |=F ?F , f j ?F
e, s, cf |=F\Delta F -F , cf j -F

e, s, f |=F hP iF , 9t:T. (f j htiF) ^ e, s, t |=T P
e, s, cf |=R\Delta F hP iF , 9ct:(R\Delta T). (cfjhctiF) ^ e, s, ct|=R\Delta TP

e, s, f |=F P1 \Omega  P2 , 9f1:F, f2:F. (f j f1 \Omega  f2) ^

e, s, f1 |=F P1 ^ e, s, f2 |=F P2

e, s, cf |=R\Delta F P1\Omega P2 , 9cf0:(R\Delta F), f0:F.

((cf j cf0\Omega f0) ^ e, s, cf0 |=R\Delta F P1 ^ e, s, f0 |=F P2) .
((cf j f0\Omega cf0) ^ e, s, f0 |=F P1 ^ e, s, cf0 |=R\Delta F P2)

e, s, g |=G ?G , g j ?G
e, s, cg |=G\Delta G -G , cg j -G

e, s, g |=G hP iG , 9t:T. (g j htiG) ^ e, s, t |=T P
e, s, cg |=R\Delta G hP iG , 9ct:(R\Delta T). (cgjhctiG)^e,s,ct|=R\Delta TP

e, s, g |=G P1 \Phi  P2 , 9g1:G, g2:G. (g j g1 \Phi  g2) ^

e, s, g1 |=G P1 ^ e, s, g2 |=G P2

e,s,cg |=D\Delta G P1\Phi P2 , 9cg0:(D\Delta G), g:G. (cg j cg0 \Phi  g) ^

e, s, cg0 |=CG P1 ^ e, s, g |=G P2

e, s, cs |=S\Delta S -S , cs j -S
e, s, s |=S Str , s j JStrKs

e, s, s |=S P1 * P2 , 9s1:S, s2:S. (s j s1 * s2) ^

e, s, s1 |=S P1 ^ e, s, s2 |=S P2

e,s,cs |=S\Delta S P1*P2 , 9cs0:(S\Delta S), s:(S).

((csjcs0*s0) ^ e,s,cs0|=S\Delta SP1 ^ e,s,s0|=SP2) .
((csjs0*cs0) ^ e,s,s0|=SP1 ^ e,s,cs0|=S\Delta SP2)

Finally, for the remaining formulae, we have:

e, s, a |=A vare , a j e(vare)
e, s, a |=A ExpV = Exp0V , JExpVKs = JExp0VKs
e, s, a |=A Int = len(f) , JIntKs = |e(f)|
e, s, a |=A Int = len(Str) , JIntKs = |JStrKs|
e, s, a |=A eltName(Str) , JStrKs 2 EltNames
e, s, a |=A 9vare. P , 9b. e[vare 7! b], s, a |=A P
e, s, a |=A 9varV. P , 9v. e, s[varV 7! v], a |=A P

The standard classical connectives `true', ^, ., ~, 8 are
all derivable. We introduce notation for expressing `somewhere, potentially deep down' \Sigma D1\Delta D2 P and `everywhere'\Lambda 

D1\Delta D2P , where D1, D2 2 {T, F, G, S}. Similarly, we define the related concept of `somewhere at this forest-level'\Sigma 

\Omega P and `everywhere at this forest-level' \Lambda \Omega P :

\Sigma D1\Delta D2P , trueD1\Delta D2 ffiD1 P \Sigma \Omega P , (trueF\Omega -F\Omega trueF)ffiFP\Lambda 

D1\Delta D2P , ~\Sigma D1\Delta D2~P \Lambda \Omega P , ~\Sigma \Omega ~P

As shorthand, we write Bool for Bool = true and derive:

Pid[P 0] , 9fid. Pid[P 0]fid P [P 0] , 9id. Pid[P 0]

#text , 9id. #textid[trueS]
nameid , nameid[trueF] . (name = #text ^ #textid[trueS])

The order of binding precedence is: ~, ffi, ^, ., {ffi-, -ffi} and)

, with no precedence between the elements in {ffi-, -ffi}.

Example 1. (Context Logic examples).
(a) Two equivalent ways of specifying a tree containing a

node with name p, but otherwise unconstrained:

9id, fid. trueT\Delta T ffiT (pid[trueF]fid) j \Sigma T\Delta T(p[trueF])

(b) A tree consisting of a body node with 0 or more paragraph nodes underneath:

body[\Lambda \Omega (htrueTiF ) hparagraph[trueF]iF)]
The \Lambda \Omega  constraint on the forest beneath body specifies
that all the subforests that satisfy htrueTiF--namely,
the subtrees--also satisfy hparagraph[trueF]iF. This
sort of formula turns out to be particularly useful when
describing the XML schema invariant in Section 5.3.

(c) hnamenode ^ tiG

A grove containing a node (which may be a text node
or an element) described by the tree variable t, with
nodeName name and identifier id. We use this form of
exact specification to specify that certain parts of the
tree remain unchanged by a command.

6

*(?

G-ffi(cg ffiT (nameparent[f]fid)))ffiGhname0newChild ^ tiG_ appendChild(parent, newChild) *cg ffiT (nameparent[f \Omega  hname0newChild ^ tiF]fid)_*

(?F -ffi(cg ffiT (nameparent[f]fid)))ffiFhname0newChild ^ tiF_ appendChild(parent, newChild) *cg ffiT (nameparent[f \Omega  hname0newChild ^ tiF]fid)_*h

ctffiT(nameparent[f1\Omega hname0oldChild^tiF\Omega f2]fid)iG_ removeChild(parent, oldChild) *hct ffiT (nameparent[f1\Omega f2]fid)iG\Phi hname0oldChild^tiG_*

name0node ^ t_ name := getNodeName(node) *name0node ^ t ^ (name = name0)_*
name0node0[f1\Omega hnamenode^tiF\Omega f2]fid_ id := getParentNode(node) *name0node0[f1\Omega hnamenode^tiF\Omega f2]fid^(id=node0)_*h

name0node ^ tiG_ id := getParentNode(node) *hname0node ^ tiG ^ (id = null)_*

namenode[f]fid0 _ fid := getChildNodes(node) *namenode[f]fid0 ^ (fid = fid0)_*?

G ^ eltName(Name)_ node := createNode(Name) *hNamenode[?F]fidiG_*
nameid[f1\Omega hname0id0^tiF\Omega f2]list^(Int= len(f1))_ node := item(list, Int) *nameid[f1\Omega hname0id0^tiF\Omega f2]list^(node = id0)_*

nameid[f]list ^ (Int < 0 . Int >= len(f))_ node := item(list, Int) *nameid[f]list ^ (node=null)_j
#textnode[str1*str0*str2] ^ (Offset= len(str1))^

(Count = len(str0))ff str:=substringData(node,Offset,Count) *#textnode[str1 * str0 * str2] ^ (str = str0)_j

#textnode[str1 * str0] ^ (Offset = len(str1))^

(Count > len(str0))ff str:=substringData(node,Offset,Count) *#textnode[str1 * str0] ^ (str = str0)_*

#textnode[str]_ appendData(node, Arg) *#textnode[str * Arg]_j
#textnode[str1*str*str2] ^ (Offset= len(str1))^

(Count = len(str))ff deleteData(node, Offset, Count) *#textnode[str1 * str2]_j

#textnode[str1 * str] ^ (Offset = len(str1))^

(Count > len(str))ff deleteData(node, Offset, Count) *#textnode[str1]_*?

G_ node := createTextNode(Str) *h#textnode[Str]iG_*
d ^ (var0V = ExpV)_ varV := ExpV *d ^ (varV = var0V)_*

d_ skip *d_

where cg 2 VarT\Delta G, ct 2 VarT\Delta T, d 2 VarD and D 2 {T, G}.

Figure 1: Minimal DOM Axioms

(d) 9cg, name, name0.(?F -ffi(cg ffiT (namenode2[trueF]))) ffiF hname0node1iF

A grove containing the nodes node1 and node2, where
node1 is not an ancestor of node2. This makes use of
variable cg 2 VarT\Delta G. This sort of formula occurs in
the axiom of appendChild.

4. LOCAL HOARE REASONING

We use Context Logic applied to our DOM tree structure to provide local Hoare reasoning about Minimal DOM
programs. This is possible because all Minimal DOM commands are local. A command is local if it satisfies two natural properties [6]: the safety-monotonicity property specifying that, if a command is safe in a given state (i.e., it does
not fault), then it is safe in a larger state; and the frame
property specifying that, if a command is safe in a given
state, then any execution of the command on a larger state
can be tracked to an execution on the smaller state.

With Minimal DOM, the formal operational semantics for
the commands is defined on groves.The commands appendChild, removeChild, createNode, createTextNode do act
at the grove level: appendChild potentially takes a subtree of one grove tree and appends it to a subtree of another grove tree; the other commands result in new grove
trees. However, the commands getNodeName, getChildNodes, item, substringData, appendData, deleteData essentially act on specific subtrees identified by the command,
rather than at the grove level, and the command getParentNode is a hybrid, having different behaviour at the subtree
level (where it returns the parent) and the grove level (where
it returns null). We therefore provide two forms of local
Hoare triple, depending on whether we are reasoning about
trees or groves. We use O'Hearn's fault-avoiding partial correctness interpretation of triples, which says that if a state
satisfies a precondition, then the command cannot fault and
the resulting state must satisfy the postcondition.

Definition 10. (Local Hoare Triples). Recall the evaluation relation  relating configuration triples C, s, g, terminal states s, g, and faults. The fault-avoiding partial correctness interpretation of local Hoare Triples is given by:{

P } C {Q} ,
(P :G ^ Q:G ^ 8e, s, g. e, s, g |=G P )

C, s, g 6 fault ^ 8s0, g0. C, s, g  s0, g0 ) e, s0, g0|=GQ).

(P :T ^ Q:T ^ 8e, s, g. e, s, g |=G hP iG )
C, s, g 6 fault ^ 8s0, g0. C, s, g  s0, g0 ) e, s0, g0|=GhQiG)

Notice that our interpretation of the Hoare triples on trees
coerces those trees to groves using h iG. This is necessary as

is defined for configuration triples containing groves.

Definition 11. (Command Axioms). The axioms for the
basic Minimal DOM commands are given in Figure 1.

The appendChild command has two axioms, corresponding
to when newChild has a parent node and when it is at the top
of the grove. getParentNode also has two axioms, returning
the parent node when it exists and null when it does not.
Similarly, the item, substringData and deleteData commands have two axioms, for the cases when the indices are
within range or not. The axioms for assignment and skip
are standard, and do not change the grove.

Definition 12. (Local Hoare Reasoning). The local
Hoare reasoning framework consists of the command axioms given in Definition 11 and seven general inference rules:
the Rules of Sequence, If Then Else, While, Consequence,
Disjunction1 and Auxiliary Variable Elimination, which are
standard and so are not presented here, and the Frame Rule:

Frame Rule: *P_ C *Q_*K ffi

D P_ C *K ffiD Q_ mod(C)" free(K)=;

where P, Q : D for D 2 {T, G}, and K has type T\Delta T, T\Delta G
or G\Delta G as appropriate. The set of free variables free(K) is
standard and mod(C) is the set of variables assigned to by C.

1The Disjunction Rule is required for the commands with

two axioms; the Conjunction Rule, meanwhile, is admissible.

7

The Frame Rule is key to local Hoare reasoning [7]. It allows
properties of programs on a smaller state to be uniformly extended to properties about the larger state. Since our Hoare
triples work on both trees and groves, a state may be made
larger by extending a tree upwards (to obtain a larger tree
or grove) or by extending a grove sideways (applying a context which contains a grove hole). The side-condition simply
prevents clashes between the variables in context formula K
and the store variables modified by the command.

As a sanity check, we note that the weakest preconditions
of the Minimal DOM commands are derivable in the logic
(see [5] for details). Our local Hoare reasoning is therefore
complete for straight line code.

Theorem 2 (Weakest Preconditions). The weakest
precondition triples of Minimal DOM are derivable.

5. EXAMPLES

We present several examples of our Minimal DOM reasoning. We illustrate the minimal nature of Minimal DOM by
specifying getPreviousSibling, a DOM Core Level 1 command that is not included in Minimal DOM (Section 5.1).
We illustrate the completeness of our reasoning by specifying
insertAfter, which is not in DOM (Section 5.2). Finally,
we demonstrate the potential of our framework for reasoning
about real-world programs by proving that an example program for manipulating address books maintains properties
specified by an accompanying XML Schema (Section 5.3).

5.1 GetPreviousSibling

We define the DOM command getPreviousSibling, using an auxiliary command `getIndex' which is not in DOM
Core Level 1 (and which is also useful in its own right). getIndex returns the index of a given node in a given list. The
implementations of getIndex and getPreviousSibling are:

n := getIndex(nodeList, node) ,

n := 0 ; current := item(nodeList, n) ;
while (current 6= node ^ current 6= null) do

n := n + 1 ; current := item(nodelist, n)

sibling := getPreviousSibling(node) ,

parent := getParentNode(node) ;
if parent = null then sibling := null else

children := getChildNodes(parent) ;
n := getIndex(children, node) ;
sibling := item(nodelist, n - 1)

The getIndex command uses a simple while loop to do a
linear search of the nodes in the parameter nodeList, counting the elements in turn until the target node is found. It
then returns the position of that node. The getPreviousSibling command uses getParentNode and getChildNodes
to obtain the list of siblings of the parameter node. It then
uses getIndex to find the position of node in that list, and
item to return the previous one if it exists or null otherwise.
If node is a root level node and therefore has no siblings,
getPreviousSibling returns null.

getIndex is described by two complementary specifications. When node is an element of nodeList (the only case
used by getPreviousSibling), the specification is:*

nameid[f \Omega  hname0node ^ tiF \Omega  f0]nodeList _
n := getIndex(nodeList, node)*

nameid[f \Omega  hname0node ^ tiF \Omega  f0]nodeList ^ (n = len(f))_

The precondition states that a tree identified by node is
a child of a tree with a child list identified by nodeList.
The postcondition states that the tree is unaltered, and that
the store now records the position of the tree node in the
variable n. When node is not contained in nodeList, the
store records the length of the list which is an invalid index.

getPreviousSibling, meanwhile, is described using three
specifications, corresponding to when the node is at the
grove level, the beginning of the nodeList, or elsewhere:*

hnamenode ^ tiG_
sibling := getPreviousSibling(node)*h

namenode ^ tiG ^ (sibling = null)_*

nameid[hname00node ^ t0iF \Omega  f2]fid_
sibling := getPreviousSibling(node)*

nameid[hname00node ^ t0iF \Omega  f2]fid ^ (sibling = null)_*

nameid[f1 \Omega  hname0id0 ^ tiF \Omega  hname00node ^ t0iF \Omega  f2]fid_
sibling := getPreviousSibling(node)j

nameid[f1 \Omega  hname0id0 ^ tiF \Omega  hname00node ^ t0iF \Omega  f2]fid^

(sibling = id0) ff

The derivations for the specifications are given in Figure 2.
5.2 InsertAfter

In a similar fashion, we can implement the DOM Core
Level 1 command insertBefore, which moves a subtree
newChild into a parent's list of children, immediately before some refNode. More interestingly, we can use insertBefore to implement insertAfter, which is not in DOM
Core Level 1. The specifications for each of these commands
have two cases: the case when refNode is null which we do
not give here; and the case when refNode is a node in the
tree or grove. In this later case, the specification of insertBefore is:j

(?X -fficg ffiT (nameparent[f1\Omega hname0refNode^tiF\Omega f2]fid))ffi

X hname00newChild^t0iX ff

insertBefore(parent, newChild, refNode)*

cgffiT(nameparent[f1\Omega hname00newChild ^ t0iF\Omega hname0refNode ^ tiF\Omega f2]fid)_

where X 2 {F, G} and cg 2 VarT\Delta G. When refNode 6= null,
insertAfter corresponds to two calls of insertBefore:

insertAfter(parent, newChild, refNode) ,

insertBefore(parent, newChild, refNode) ;
insertBefore(parent, refNode, newChild)

and has the specification:j

(?X -fficg ffiT (nameparent[f1\Omega hname0refNode^tiF\Omega f2]fid))ffi

X hname00newChild^t0iX ff

insertAfter(parent, newChild, refNode);*

cgffiT(nameparent[f1\Omega hname0refNode ^ tiF\Omega hname00newChild ^ t0iF\Omega f2]fid)_

This specification may be derived compositionally from
the non-null case of the specification of insertBefore:j

(?X -fficg ffiT (nameparent[f1\Omega hname0refNode^tiF\Omega f2]fid))ffi

X hname00newChild^t0iX ff

insertBefore(parent, newChild, refNode);*

cg ffiT (nameparent[f1\Omega hname00newChild ^ t0iF\Omega hname0refNode ^ tiF\Omega f2]fid)_j

(?F -fficg ffiT (nameparent[f1\Omega hname00newChild ^ t0iF\Omega ?F\Omega f2]fid))ffi

F hname0refNode ^ tiF ffj

(?F -fficg ffiT (nameparent[f1\Omega hname00newChild ^ t0iF\Omega f2]fid))ffi

F hname0refNode ^ tiF ff

insertBefore(parent, refNode, newChild);*

cg ffiT (nameparent[f1\Omega hname0refNode ^ tiF\Omega hname00newChild ^ t0iF\Omega f2]fid)_

8

getIndex derivation*

nameid[f \Omega  hname0node ^ tiF \Omega  f0]nodeList_
n := 0 ; current := item(nodeList, n) ;8<:9

name00, f1, f2. (n = len(f1))

^ nameid >>"(f \Omega  hname0node ^ tiF) ^(f1 \Omega  hname00

currentiF \Omega  f2)<< \Omega  f

0-

nodeList9=;while (current 6= node ^ current 6= null) do8>><

>>:

9name00, name000, id000, f1, f02. (n = len(f1))

^ nameid 240@

(f \Omega  hname0nodeiF) ^"

f1 \Omega  hname00currentiF \Omega h

name000id000iF \Omega  f02 <<1A \Omega 

f035

nodeList

9>>=>>
;
n := n + 1 ; current := item(nodelist, n)8<:9

name000, f01, f02. (n = len(f01))

^ nameid >>"(f \Omega  hname0nodeiF) ^(f01 \Omega  hname000

currentiF \Omega  f02)<< \Omega  f

0-

nodeList9=;8<

:

9name00, f1, f2. (n = len(f1)) ^ (current = node)

^ nameid >>"(f \Omega  hname0nodeiF) ^(f1 \Omega  hname00

currentiF \Omega  f2)<< \Omega  f

0-

nodeList9=;*
nameid[f \Omega  hname0nodeiF \Omega  f0]nodeList ^ (n = len(f))_

getPreviousSibling derivation*

hnamenode ^ tiG_
parent := getParentNode(node) ;*h

namenode ^ tiG ^ (parent = null)_
if parent := null then sibling := null else . . .*h

namenode ^ tiG ^ (sibling = null)_*

nameid[hname00node ^ t0iF \Omega  f2]fid_
parent := getParentNode(node) ; if parent := null then . . . else*

nameid[hname00node ^ t0iF \Omega  f2]fid ^ (parent = id)_
children := getChildNodes(parent) ; n := getIndex(children, node) ;*

nameid[hname0node ^ t0iF \Omega  f2]fid ^ (parent=id)^(children=fid)^(n=0)_
sibling := item(nodelist, n - 1)*

nameid[hname00node ^ t0iF \Omega  f2]fid ^ (sibling = null)_*

nameid[f1 \Omega  hname0id0 ^ tiF \Omega  hname00node ^ t0iF \Omega  f2]fid_
parent := getParentNode(node) ; if parent := null then . . . else*

nameid[f1 \Omega  hname0id0 ^ tiF \Omega  hname00node ^ t0iF \Omega  f2]fid ^ (parent = id)_
children := getChildNodes(parent) ; n := getIndex(children, node) ;j

nameid[f1 \Omega  hname0id0 ^ tiF \Omega  hname00node ^ t0iF \Omega  f2]fid^

(parent = id) ^ (children = fid) ^ (n - 1 = len(f1))ff
sibling := item(nodelist, n - 1)*

nameid[f1 \Omega  hname0id0 ^ tiF \Omega  hname00node ^ t0iF \Omega  f2]fid ^ (sibling=id0)_

Figure 2: Derivations for the getIndex and getPreviousSibling Specifications

This example serves as a good illustration of the modularity of our reasoning. The specification of the composite
command is of the same form as the specifications of each
of the individual commands, and does not refer to any other
specification. The nearest DOM equivalent is an English
language statement declaring that, assuming `b 6= null', the
command `p.insertAfter(a, b)' is equivalent to the sequence
`p.insertBefore(a, b); p.insertBefore(b, a)'. The reader must
then refer to the specification of insertBefore in order to
understand the specification of insertAfter.

5.3 Proving Schema Invariants

When reasoning about programs, it is often desirable to
prove a particular property about a program rather than
proving the whole (often complex) specification. One example of this involves proving XML schema invariants. For
example, consider writing a program to update an XML addressBook document which complies with the XML schema:

<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
elementFormDefault="qualified">
<xs:element name="addressBook">

<xs:element name="household" minOccurs="0"

maxOccurs="unbounded">
<xs:complexType>

<xs:sequence>

<xs:element name="person" maxOccurs="unbounded">

<xs:complexType>

<element name="name" type="string"/>
</xs:complexType>
</xs:element>
<xs:element name="address" type="string"/>
<xs:element name="phone" type="string"/>
</xs:sequence>
</xs:complexType>
</xs:element>
</xs:element>

The schema asserts that the root element of the document
should be an addressBook node, whose children should be
zero or more household nodes. These household nodes should
contain one or more person nodes, one address node and one

phone node. Each of these third-level nodes should contain
data of type `string'.

We can specify this XML schema using the grove formula S:

S , haddressBook[households]iG where

households , \Lambda \Omega (htrueTiF )fi

household >> hperson[txts]iF \Omega  people \Omega haddress[txts]iF \Omega  hphone[txts]iF -fl

F

)

txts , h#textiF \Omega  \Lambda \Omega (htrueTiF ) h#textiF)
people , \Lambda \Omega (htrueTiF ) hperson[txts]iF)

Now consider a Minimal DOM program which updates
the addressBook document when a specified person leaver
moves house. The program moves leaver out of its current
household, into a newly created house with a user-supplied
address and phone number. The program checks if the original household is now empty and, if it is, deletes it.

moveHouse(leaver, newAddress, newPhone) ,

// Move leaver into a new house.
house := getParentNode(leaver);
book := getParentNode(house);
newHouse := createNode(`household');
appendChild(newHouse, leaver);
addr := createNode(`address');
adtxt := createTextNode(newAddress);
appendChild(addr, adtxt);
appendChild(newHouse, addr);
phn := createNode(`phone');
phntxt := createTextNode(newPhone);
appendChild(phn, phntxt);
appendChild(newHouse, phn);
appendChild(book, newHouse);

// Remove old house if empty.
kids := getChildNodes(house);
firstChild := item(kids, 0);
firstName := getNodeName(firstChild);
if firstName = `person' then skip

else removeChild(book, house);

The safety condition that leaver refers to a person node
can be simply expressed by the formula

P , \Sigma T\Delta Gpersonleaver[trueF]

9

*S ^ P _*

haddressBook ^households\Omega hhousehold ^people\Omega hpersonleaver[txts]iF\Omega people\Omega haddress[txts]iF\Omega hphone[txts]iF~iF\Omega households~iG_
moveHouse(leaver, newAddress, newPhone) ,

// Move leaver into a new house.
house := getParentNode(leaver); book := getParentNode(house); newHouse := createNode(`household'); appendChild(newHouse, leaver);
addr := createNode(`address'); adtxt := createTextNode(newAddress); appendChild(addr, adtxt); appendChild(newHouse, addr);
phn := createNode(`phone'); phntxt := createTextNode(newPhone); appendChild(phn, phntxt); appendChild(newHouse, phn);jh

addressBookbook ^households \Omega  hhouseholdhouse ^people \Omega  haddress[txts]iF \Omega  hphone[txts]iF~iF \Omega  households~iG\Phi  h

householdnewHouse[hpersonleaver[txts]iF \Omega  haddress[newAddress]iF \Omega  hphone[newPhone]iF]iG ff

appendChild(book, newHouse);*h

addressBookbook ^households \Omega  hhouseholdhouse ^people \Omega  haddress[txts]iF \Omega  hphone[txts]iF~iF \Omega  households~iG_
// Remove old house if empty.
kids := getChildNodes(house); firstChild := item(kids, 0); firstName := getNodeName(firstChild);
if firstName = `person' then skip*h

addressBook ^households\Omega hhousehold ^hperson[txts]iF\Omega people\Omega haddress[txts]iF\Omega hphone[txts]iF~iF\Omega households~iG_
else removeChild(book, house);*h

addressBook[households]iG \Phi  trueG_*
S \Phi  trueG_

Figure 3: Schema Preservation Derivation

We can prove that moveHouse maintains the schema formulaS provided that this safety formula P also holds:*

S ^ P _ moveHouse(leaver, newAddress, newPhone) *S \Phi  trueG_
As discussed in Section 2.2, we treat Minimal DOM as a
garbage collected language. We thus have trueG in the postcondition to refer to uncollected garbage generated by the
program, which is safely ignored. The proof is in Figure 3.

6. CONCLUSION

Using Context Logic, we have developed local Hoare reasoning about Minimal DOM. Our reasoning is compositional
and complete for straight-line code. This means that we
can focus on a minimal set of DOM commands and prove
invariant properties about simple programs. We made the
deliberate choice to work with the DOM tree structure and
text nodes, rather than the full DOM structure which also
consists of Attributes, DocumentFragments, etc. We took
the view that it was important to understand the reasoning about the fundamental tree structure first, especially
since DOM treats these other structures as nodes with similar properties. We will extend our reasoning to DOM Core
Level 1 in future. We conjecture that there will be little
additional conceptual reasoning to this extension. We have
however already found holes in the DOM specification: for
example, DOM does not specify how the normalize method
of the Element class interacts with pointers in the store.

A future goal is to develop a prototype verification tool
for reasoning first about Minimal DOM, and then about
DOM Core Level 1. Calcagno, Dinsdale-Young and Gardner have recently shown that model-checking and validity
are decidable for quantifier-free Context Logic applied to
simple trees. We believe this result will extend to Context
Logic for the DOM tree structure presented here. With
quantifiers however, Context Logic applied both to simple
trees and to the DOM tree structure becomes undecidable,
just as for Separation Logic and Ambient Logic. We will investigate tractable fragments of Context Logic, inspired by
the verification tool Smallfoot based on a fragment of Separation Logic. In particular, the last example in Section 5.3,
which verifies that an XML address book schema is an invariant of a simple program which moves a person to a new
address, is particularly enticing. An ambitious challenge is

to provide a `one-click' tool that checks if, for example, embedded Javascript in a web page can ever violate the schema
assertions on that web page.
Acknowledgements We thank Brotherstone, Calcagno,
Dinsdale-Young, Kahramanogullari, O'Hearn and Raza for
insightful discussions, and acknowledge financial support from
EPSRC, Microsoft and the Royal Academy of Engineering.

7. REFERENCES[1] J. Berdine, C. Calcagno, B. Cook, D. Distefano,

P. O'Hearn, T. Wies, and H. Yang. Shape analysis for
composite data structures. In CAV, 2007.

[2] J. Berdine, C. Calcagno, and P. O'Hearn. Smallfoot:

Modular automatic assertion checking with separation
logic. In FMCO, 2006.

[3] C. Calcagno, P. Gardner, and U. Zarfaty. Context logic &

tree update. In POPL, 2005.
[4] C. Calcagno, P. Gardner, and U. Zarfaty. Context logic as

modal logic: Completeness and parametric inexpressivity.
In POPL, 2007.

[5] P. Gardner, G. Smith, M. Wheelhouse, and U. Zarfaty.

Local hoare reasoning about DOM. Extended version,
available online at
http://www.doc.ic.ac.uk/,pg/publications.html.

[6] S. Isthiaq and P. O'Hearn. BI as an assertion language for

mutable data structures. In POPL, 2001.

[7] P. O'Hearn, J. Reynolds, and H. Yang. Local reasoning

about programs that alter data structures. In CSL, 2001.
[8] P. W. O'Hearn. Resources, concurrency and local

reasoning. Theoretical Computer Science, 2005.

[9] J. Orendorff. Compliance Patches for minidom. Included

with Python, 2007. See
http://bugs.python.org/issue1704134.
[10] G. Smith. A context logic approach to analysis and

specification of xml update. PhD 1st year report, 2006.

[11] Various. xml.dom.minidom, 2006. http:

//docs.python.org/lib/module-xml.dom.minidom.html.

[12] W3C. Document Object Model (DOM) Level 1

Specification (2nd Ed.). Working draft, 2000.
http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/.

[13] W3C. DOM: Document Object Model. W3C

recommendation, 2005. See http://www.w3.org/DOM/.

[14] M. Wheelhouse. Dom: Towards a formal specification.

Master's thesis, Imperial College, 2007.

[15] U. Zarfaty and P. Gardner. Local reasoning about tree

update. In MFPS, 2006.

10