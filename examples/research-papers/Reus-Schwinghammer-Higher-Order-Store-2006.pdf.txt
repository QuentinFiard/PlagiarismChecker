

Separation Logic for Higher-order Store

Bernhard Reus1 and Jan Schwinghammer2
1 Department of Informatics, University of Sussex, Brighton, UK
2 Programming Systems Lab, Saarland University, Saarbr"ucken, Germany

Abstract. Separation Logic is a sub-structural logic that supports local
reasoning for imperative programs. It is designed to elegantly describe
sharing and aliasing properties of heap structures, thus facilitating the
verification of programs with pointers. In past work, separation logic
has been developed for heaps containing records of basic data types.
Languages like C or ML, however, also permit the use of code pointers.
The corresponding heap model is commonly referred to as "higher-order
store" since heaps may contain commands which in turn are interpreted
as partial functions between heaps.
In this paper we make Separation Logic and the benefits of local reasoning available to languages with higher-order store. In particular, we
introduce an extension of the logic and prove it sound, including the
Frame Rule that enables specifications of code to be extended by invariants on parts of the heap that are not accessed.

1 Introduction and Motivation
Since the beginning of program verification for high-level languages [7], pointers(and the aliasing they cause) have presented a major stumbling block for formal
correctness proofs. Some of the pain of verifying pointer programs has beenremoved in recent years with the introduction of Separation Logic, developed by
Reynolds, O'Hearn and others [25, 9, 14]. This is a variant of Hoare logic whereassertions may contain the separation conjunction: The assertion

P * Q statesthat
P and Q hold for disjoint parts of the heap store - in particular, thereis no sharing between these regions. The separation connective allows for the

elegant formulation of a frame rule which is key to local reasoning: In a triple{

P } c {Q}, the assertions P and Q need to specify the code c only in terms of theheap cells that are actually used (the "footprint"). Clients can add invariants

Rfor disjoint heap areas in a modular fashion, to obtain {
P * R} c {Q * R} withoutreproving
c.Some impressive results have been obtained within this formalism, including

the verification of several algorithms operating on heap-based graph structuressuch as the Schorr-Waite graph marking algorithm [29, 4]. Separation logic has
been extended in several directions, covering shared-variable concurrent pro-grams [13], modules [16] and higher-order procedures [5]. However, in all cases
only values of basic data types can be stored. On the other hand, languages likeC, ML, Scheme, and (implicitly) Java provide code pointers. In object-oriented

programs, stored procedures are commonly used as callbacks. Moreover, codepointers "also appear in low-level programs that use techniques of higher-order
or object-oriented programming" [25].In this paper we address the problem of extending Separation Logic to languages that allow the storage of procedures. Reynolds emphasized the impor-tance of code pointers in [25], speculating that the marriage of separation logic
with continuation semantics could provide a way to reason about them. A stepin this direction has been taken in [28] (although mutual dependencies of stored
procedures were initially excluded) and [12]. Building on our results in [23, 22,21] we suggest a much more direct extension of Separation Logic, by using a
denotational semantics instead of an operational one. This allows us to modelcode pointers by means of a higher-order store, i.e., as a (mixed-variant) recursively defined domain where stores map locations to basic values or to statetransformers (denoting partial maps from store to store).

The starting point for our work is [23] where a Hoare-style logic for a languagewith higher-order store is presented. This language assumes a global store and
does not provide explicit means to allocate or dispose memory. The logic in [23]extends traditional Hoare logic by rules to reason about the (mutual) recursion
through the store that becomes possible with command storage [10].We extend the language of [23] with memory allocation constructs, and the
logic with the rules of Separation Logic. The semantics of dynamically allocatedmemory raises a subtle point in connection with Separation Logic: soundness
of the frame rule relies on the fact that the choice of a fresh location madeby the allocation mechanism is irrelevant, as far as the logic is concerned. To
the best of our knowledge, in all previous approaches this requirement has beenenforced by making allocation non-deterministic so that valid predicates cannot possibly depend on assumptions about particular locations. However, in thepresence of higher-order store where we have to solve recursive domain equations
we found the use of (countable) non-determinism quite challenging (for instance,programs would no longer denote

!-continuous functions, see also [6, 2]). Stan-dard techniques [18] for proving the existence of recursively defined predicates

over recursively defined domains are not immediately applicable.Instead, our technical development takes place in a functor category so that
the semantic domains are indexed by sets w of locations. Intuitively, w containsall the locations that are in use, and we can define a deterministic memory
allocator. Non-determinism is not needed, due to the following observations:

- A renaming f : w ! w0 between location sets gives rise to a correspondingtransformation in the semantics of programs.

- We can identify a class of predicates (over stores) that are invariant underlocation renamings. This property captures the irrelevance of location names.

In contrast to previous uses of possible worlds models [24, 17, 15, 11] our seman-tics is not "tight" in the sense that stores may have allocated only a subset of the
locations in w. Thus runtime errors are still possible by dereferencing danglingpointers. Memory faults are unavoidable because the language includes a free
operation that may create dangling pointers. Moreover, once stores are "taken

Table 1. Syntax of expressions and commands
x, y 2 Var variables

b, e 2 Exp ::= true | false | e1<=e2 | ~b | b1 ^ b2 | . . . | boolean expressions

0 | -1 | 1 | . . . | x | e1 + e2 | . . . | integer expressions
`c' quote (command as expression)
c 2 Com ::= skip | c1;c2 | if b then c1 else c2 fi | no op, composition, conditional

let x = new e in c | free x | memory allocation, disposal
[x]:=e | let y=[x] in c | assignment, lookup
eval e unquote

apart" according to the separation conjunction, the concept of incomplete storesis convenient, even in the context of a statically typed language [20]. Nevertheless, with respect to the logic, proved programs do not yield memory faults.In summary, we extend Separation Logic to higher-order store, thereby facilitating reasoning about code pointers. Technically, this is achieved by developinga functor category semantics that provides explicit location renamings, instead
of using a non-determistic computation model. We believe this latter aspect isalso of interest independently of the presence of higher-order store.
Structure of the paper. In Section 2 we present the syntax of programming lan-guage and logic, along with the proof rules. Section 3 develops the necessary
background to interpret the language and logic, the semantics itself is given inSection 4. Section 5 concludes with an outlook on related and future work.

2 Programming Language and Logic
We present a variant of the language considered by Reus and Streicher [23], butextended with constructs for the dynamic allocation and disposal of memory
cells. Two assumptions on the language simplify our presentation: Firstly, wefollow [5] in the slightly non-standard adoption of (ML-like) immutable identifiers. That is, all mutation takes place in the heap, whereas the stack variablesare immutable. Secondly, expressions only depend on the stack but not on the
heap. As a consequence there is no need for modifies clauses in the proof rules.

2.1 Programming Language
The syntax of the language is given in Table 1. The set Exp of expressionsincludes boolean and integer expressions. Additionally, a command

c can beturned into an expression (delaying its execution), via the quote operation `

c'.The set
Com of commands consists of the usual no op, sequential composi-tion, and conditional constructs. Because stack variables are not mutable, new

memory is allocated by let x = new e in c that introduces an identifier with localscope

c that is bound to (the location of) the new memory cell. We stress thatthe initial contents

e may be a (quoted) command. This is also the case for anupdate, [
x]:=e. The command free x disposes the memory cell that x denotes,

Table 2. Syntax of assertions
A, B 2 pAssn ::= true | e1 <= e2 | pure basic predicates~

A | A ^ B | 8x. A predicate logic connectives
P, Q 2 Assn ::= x 7! e | emp | P * Q | separation logic connectives

A | P ^ Q | P . Q | 8x. P | 9x. P predicate logic connectives

Table 3. Specific proof rules
Frame{

P } c {Q}{

P * R} c {Q * R}

Free{

x 7! } free x {emp}

New{

P * x 7! e} c {Q}{

P } let x = new e in c {Q} x /2fv(e, P, Q)
Eval{

P } c {Q}{

P } eval `c' {Q}

Assign{

x 7! } [x] := e {x 7! e}

Deref{

P * x 7! e} c[e/y] {Q}{

P * x 7! e} let y = [x] in c {Q}
RecV

1<=i<=n {P1} eval x1 {Q1} . . . {Pn} eval xn {Qn} ` {Pi} ci {Qi}{

Pj[`c'/x]} eval `cj' {Qj[`c'/x]} 1 <= j <= n

and let y=[x] in c introduces a new stack variable y bound to the cell contents.Finally,

eval e is the "unquote" command, i.e., if e denotes a quoted command
c then c is executed. We give a formal semantics of this language in Section 4,after developing the necessary machinery in Section 3.

Note that Table 1 does not include any looping constructs - recursion can beexpressed "through the store" [10]. Here is a simple example of a non-terminating
command: [x]:=`let y=[x] in eval y'; let y=[x] in eval y.

2.2 Assertions and Proof Rules
The assertions used in Hoare triples are built from the formulae of predicatelogic and the additional separation logic assertions that describe the heap ( 7! ,

emp describing the empty heap, and P * Q; cf. [25]). Note that in our languagevariables can also be bound to quoted code. The syntax of the assertions is given
in Table 2. It is important to note that we distinguish between "pure" assertions
pAssn, i.e., those that do not depend on the heap, and normal assertions Assnwhich do depend on the heap. Only the former allow negation. The reason for this

will become clear when we give the semantics in Section 4.1. As usual, assertion
e1 <= e2 ^ e2 <= e1 is abbreviated e1 = e2 and assertion 9z. x 7! z is abbreviatedto

x 7! . For pure assertions pAssn the predicate false and connectives ., ),and 9

x.A can be derived as usual using negation.
The inference rules of our program logic contain the standard Hoare rules(for

skip, conditional, sequential composition, weakening and substitution), astandard axiomatization of predicate logic as well as an axiomatization of the

Separation Logic connectives stating associativity and symmetry of *, neutralityof

emp with respect to *, and some distributive laws (see e.g. [25]). The rulesspecific to our programming language are given in Table 3.

The frame rule extends triples by invariants for inaccessible parts of the heap.Rules (

Free) and (Assign) specify the corresponding heap operations "tightly".The inferences (

New) and (Deref) combine heap allocation and dereferencing,resp., with local variable definitions (and hence are not tight). Unlike [5] our

(New) permits (non-recursive) initializations (and self-reference can be intro-duced by assignment as in Section 2.3). Substitution on

c is used in the premissof (
Deref) to avoid equations of the form y = e that would be problematic when
e is a stored procedure. Rule (Eval) is reminiscent of standard non-recursiveprocedure call rules; it expresses that evaluating a quoted command has the same

effect as the command itself. Indeed, (Eval) is a degenerated case of rule (Rec)that deals with recursion through the store. It is similar to the standard rule for
Hoare-calculus with (mutually) recursive procedures, but since procedures arestored on the heap, they have to be accounted for in the assertions which leads
to the substitution in the conclusion.

2.3 Example
Let \Sigma n be the sum P0<=i<=n i, let cP be the command

let !y= [y] in let !x= [x] in if !x<=0 then skip else [y]:=!y+!x; [x]:=!x-1; let c= [f] in eval c fi
and observe that !x and !y are stack variable names representing the values inthe cells denoted by (pointers)

x and y, respectively. If cP is stored in f , theprogram is defined by recursion through the store since

cP calls the procedurestored in heap cell
f. This is also referred to as a "knot in the store." We provebelow that
cP adds to !y the sum \Sigma !x of natural numbers up to and including !x.In the presentation we omit various applications of the weakening rule (which

are easy to insert).

New

Seq

Frame Assign {f7!`skip'} [f]:=`cP ' {f7!`cP '}{x7!n * y7!0 * f7!`skip'} [f]:=`c

P ' {x7! * y7!0 * f7!`cP '}

Deref

Subst

Rec ff{x7!n * y7!m * f7!`c

P '} eval `cP ' {x7! * y7!\Sigma n+m * f7!`cP '}{

x7!n * y7!0 * f7!`cP '} eval `cP ' {x7! * y7!\Sigma n * f7!`cP '}{
x7!n * y7!0 * f7!`cP '} let c= [f] in eval c {x7! * y7!\Sigma n * f7!`cP '}{
x7!n * y7!0 * f7!`skip'} [f]:=`cP '; let c= [f] in eval c {x7! * y7!\Sigma n * f7!`cP '}{
x7!n * y7!0} let f= new `skip' in [f]:=`cP '; let c= [f] in eval c {x7! * y7!\Sigma n * f7!`cP '}

For the derivation tree ff we let xP denote `cP ' and assume

{x7!n * y7!m * f7!xP } eval xP {x7!n * y7!\Sigma n+m * f 7!xP } (#)
and prove {x7!n * y7!m * f7!xP } cP {x7!0 * y7!\Sigma n+m * f7!xP }.

Deref2

If fit fif{x7!n * y7!m * f7!x

P } if n<=0 then skip else . . . fi {x7! * y7!\Sigma n+m * f7!xP }{

x7!n * y7!m * f7!xP } let !y= [y] in . . . [y]:=!y+!x . . .| {z }

cP {

x7! * y7!\Sigma n+m * f7!xP }

where fit and fif , respectively, are:
Weak Skip {x7!n * y7!m * f7!xP ^ n <= 0} skip {x7!n * y7!m * f7!xP ^ n <= 0}{x7!n * y7!m * f7!x

P ^ n <= 0} skip {x7! * y7!\Sigma n+m * f7!xP }

Seq2 fl ffi ffl{x7!n * y7!m * f7!x

P ^ n>0} [y]:= . . . ; [x]:= . . . ; let. . . {x7! * y7!\Sigma n+m * f7!xP }

The derivations fl, ffi and ffl are as follows:

Frame Assign {y7!m} [y]:=m+n {y7!m+n}{x7!n * y7!m * f7!x

P } [y]:=m+n {x7!n * y7!m+n * f7!xP }

Frame Assign {x7!n} [x]:=n-1 {x7!n-1}{x7!n * y7!m+n * f7!x

P } [x]:=n-1 {x7!n-1 * y7!m+n * f7!xP }

Deref

Subst (#) j {x7!n * y7!m * f7!xP } eval xP {x7! * y7!\Sigma n+m * f7!xP }{x7!n-1 * y7!m+n * f7!x

P } eval xP {x7! * y7!\Sigma n+m * f7!xP }{

x7!n-1 * y7!m+n * f7!xP } let c= [f] in eval c {x7! * y7!\Sigma n+m * f7!xP }

Note how the Frame Rule is used to peel off those predicates of the assignmentrule that do not relate to the memory cell affected.

3 A Model of Dynamic Higher-order Store
This section defines the semantic domains in which the language of Section 2finds its interpretation. The semantic properties (safety monotonicity and frame
property) that programs must satisfy to admit local reasoning [25] are rephrased,using the renamings made available by the functor category machinery. Due to
the higher-order character of stores, these predicates are recursive and theirexistence must be established. The framework of Pitts is used [18, 11].

3.1 Worlds
Fix a well-ordered, countably infinite set L of locations (e.g., the natural num-bers). Let W be the category consisting of finite subsets

w ` L as objects andinjections
f : w1 ! w2 as morphisms. We call the objects w of W worlds. Theintuition is that

w 2 W describes (a superset of) the locations currently in use; inparticular, every location not in

w will be fresh. The inclusion w ` w0 is written
'w0w , and the notation f : w1 ,! w2 is used to indicate that f is a bijection.The injections formalise a possible renaming of locations, as well as an extension of the set of available locations because of allocation.

3.2 Semantic Domains: Stores, Values and Commands
Let pCpo be the category of cpos (partial orders closed under taking least upperbounds of countable chains, but not necessarily containing a least element) and

partial continuous functions. For a partial continuous function g we write g(a) # if

the application is defined, and g(a) " otherwise. By g; h we denote composition indiagrammatic order. Let

Cpo be the subcategory of pCpo where the morphismsare total continuous functions. For cpos

A and B we write A * B and A ! Bfor the cpos of partial and total continuous functions from

A to B, respectively,each with the pointwise ordering. For a family (
Ai) of cpos, Pi Ai denotes theirdisjoint union; we write its elements as h
i, ai where a 2 Ai.For every
w 2 W we define a cpo of w-stores as records of values whosedomain is a subset of

w (viewed as discrete cpo). The fields of such a storecontain values that may refer to locations in

w:

St(w) = Recw(Val (w)) = X

w0`w(

w0 ! Val (w)) (1)

We abuse notation to write s for hw0, si 2 St(w); we set dom(s) = w0 and may userecord notation {|

l = vl|}l2dom(s) where s(l) = vl. The order on (1) is defined in

the evident way, by r v s iff dom(r) = dom(s) and r(l) v s(l) for all l 2 dom(r).A value (over locations

w 2 W) is either a basic value in BVal, a location
l 2 w, or a command, i.e.,

Val(w) = BVal + w + Com(w) (2)
We assume BVal is a discretely ordered cpo that contains integers and booleans.Commands

c 2 Com(w) operate on the store; given an initial store the com-mand may either diverge, terminate abnormally or terminate with a result store.

Abnormal termination is caused by dereferencing dangling pointers which mayrefer to memory locations that either have not yet been allocated, or have already been disposed of. Thus, in contrast to [23] where store could not varydynamically, we need to have a defined result error to flag undefined memory
access. The possibility of dynamic memory allocation prompts a further refine-ment compared to [23]: a command should work for extended stores, too, and
may also extend the store itself.Formally, the collection of commands is given as a functor Com : W -! Cpo,
defined on objects by

Com(w) = Y

i:w!w0(St(

w0) * (error + X

j:w0!w00 St(

w00))) (3)

and on morphisms by the obvious restriction of the product,

Com(f : w1 ! w2)(c)i:w2!w3 = c(f;i)
Viewing commands this way is directly inspired by Levy's model of an ML-likehigher-order language with general references [11].

By considering BVal as constant functor, and locations as the functor W -!
Cpo that acts on f : w1 ! w2 by sending l 2 w1 to f(l) 2 w2, Val can also beseen as a functor W -! Cpo. Note that, by expanding the requirements (1), (2)

and (3), Val is expressed in terms of a mixed-variant recursion. In Section 3.3we address the issue of well-definedness of Val .

One might want to exclude run-time memory errors statically (which is pos-sible assuming memory is never disposed, so that there is no way of introducing
dangling pointers from within the language). An obvious solution to model thisis by defining

w-stores as Qw Val(w), i.e., all locations occurring in values areguaranteed to exist in the current store. However, this approach means that there

is no canonical way to extend stores, nor can values be restricted to smaller lo-cation sets. Consequently St is neither co- nor contravariantly functorial

3. In

contrast, our more permissive definition of stores (that may lead to access er-rors) does allow a functorial interpretation of St, as follows. For an injection

f : w1 ! w2 we write f-1 : imf ! w1 for the right-inverse to f , and let

St(f) : Recw1(Val(w1)) ! Recw2(Val (w2))
St(f) = *hw ` w1, si. hf w, f -1; s; Val (f)i

The case where f is a bijection then corresponds to a consistent renaming of thestore and its contents. We will make some use of the functoriality of St in the
following, to lift recursively defined predicates from values to stores.

For s1, s2 2 St(w) we write s1 ? s2 if their respective domains w1, w2 ` w aredisjoint. In this case, their composition

s1 * s2 2 St(w) is defined by conjoiningthem in the obvious way, it is undefined otherwise. Observe that for

f : w ! w0we have St(
f )(s1 * s2) = St(f )(s1) * St(f)(s2); the right-hand side is definedbecause
f is injective.

3.3 Domain Equations and Relational Structures on

Bilimit-Compact Categories

This section briefly summarises the key results from [11, 27] about the solutionof recursive domain equations in bilimit-compact categories. We will make use of

the generalisation of Pitts' techniques [18] for establishing the well-definednessof (recursive) predicates, as outlined in [11].

Definition 1 (Bilimit-Compact Category [11]). A category C is bilimit-compact if

- C is Cpo-enriched and each hom-cpo C(A, B) has a least element ?A,B suchthat ? ffi

f = ? = g ffi ?;
- C has an initial object; and
- in the category CE of embedding-projection pairs of C, every !-chain \Delta  =

D0 ! D1 ! . . . has an O-colimit [27]. More precisely, there exists a cocone(

en, pn)n<! : \Delta  ! D in CE such that tn<!(pn; en) = id D in C(D, D).

It follows that every locally continuous functor F : Cop * C -! C hasa minimal invariant, i.e., an object

D and isomorphism i in C such that i :
F (D, D) ,= D (unique up to unique isomorphism) and idD is the least fixed

3 Levy [11] makes this observation for a similar, typed store model.

Table 4. Solving the domain equation: FVal, FCom : Cop * C -! C and FSt : C -! C
On C-objects A-, A+, B, worlds w, w0 2 W and f : w ! w0,

FVal(A-, A+)(w) = BVal + w + FCom (A-, A+)(w)

FVal(A-, A+)(f) = *v. 8><>:

v if v 2 BVal
f(v) if v 2 w
FCom (A-, A+)(f)(v) if v 2 FCom(A-, A+)(w)
FCom (A-, A+)(w) = Qi:w!w0(FSt (A-)(w0) * (error + Pj:w0!w00 FSt (A+)(w00)))
FCom (A-, A+)(f) = *c*i. c(f;i)

FSt (B)(w) = Pw1`w(w1 ! B(w))
FSt (B)(f) = *hw1, si. hfw1, f-1; s; B(f)i

On C-morphisms h = (hw) : B- .* A- and k = (kw) : A+ .* B+,

FVal(h, k)w = *v. (v if v 2 BVal or v 2 wF

Com(h, k)w(v) if v 2 FCom (A-, A+)

FCom (h, k)w = *c*i:w ! w0*s.8>>>>>><

>>>>>>:

undefined if FSt (h)w0(s) "

or FSt (h)w0(s)# ^ ci(FSt (h)w0(s))"
or ci(FSt (h)w0(s)) = hj : w0 ! w00, s0i ^ FSt (k)w00(s0)"
error if FSt (h)w0(s) # ^ ci(FSt (h)w0(s)) = errorh

j, FSt (k)w00(s0)i if ci(FSt (h)w0(s)) = hj : w0 ! w00, s0i ^ FSt(k)w00(s0)#

FSt (k)w = *hw1, si. (hw1, s; kwi if 8l 2 w1. kw(s(l))#undefined otherwise

point of the continuous endofunction ffi : C(D, D) ! C(D, D) defined by ffi(e) =
i-1; F (e, e); i [18]. To ease readability the isomorphism i is usually omitted below.To solve the domain equation of the preceding subsection we shall be interested in the case where C denotes the category [W, Cpo] of functors W -! Cpoand partial natural transformations, i.e., a morphism

e : A .* B in C is afamily
e = (ew) of partial continuous functions ew : A(w) * B(w) such that
A(f ); ew0 = ew; B(f) for all f : w ! w0.

Lemma 1 (Bilimit-Compactness [11]). C = [W, Cpo] is bilimit-compact.

Thus, for well-definedness of Val it suffices to show that requirements (1),(2) and (3) induce a locally continuous functor C

op * C -! C for which Val is

the minimal invariant. Table 4 defines such a functor FVal in the standard way[18], by separating positive and negative occurrences of St in (3).

Lemma 2 (Minimal Invariant). FVal : Cop * C -! C is locally continuous.In particular, the minimal invariant Val =

FVal (Val, Val ) exists.

From this we can then define Com = FCom (Val , Val ) and St = FSt (Val)which satisfy (3) and (1). The minimal invariant in fact lives in the category

of functors W -! Cpo and natural transformations that are total, i.e., those
e = (ew) : A .! B where each ew is a total continuous function A(w) ! B(w).

This is because FVal restricts to this category, which is sub-bilimit-compactwithin C in the sense of [11]. A (normal) relational structure R on C in the
sense of Pitts [18] is given as follows.
Definition 2 (Kripke Relational Structure). For each A : W -! Cpolet R(

A) consist of the W-indexed families R = (Rw) of admissible predicates
Rw ` A(w) such that for all f : w ! w0 and a 2 A(w),

a 2 Rw =) A(f )(a) 2 Rw0 (KripkeMon)
For each natural transformation e = (ew) : A .* B and all R 2 R(A), S 2 R(B),

e : R ae S :() 8w 2 W 8a 2 A(w). a 2 Rw ^ ew(a) # =) ew(a) 2 Sw
Note that (KripkeMon) in particular covers the case where f : w ! w is abijection, i.e., the Kripke relations are invariant under permutation of locations.

For an object A : W -! Cpo and R-relation R = (Rw) 2 R(A) we letSt(
R) 2 R(FSt (A)) be the relation where s 2 St(R)w if and only if s(l) 2 Rwfor all

l 2 dom(s). It is easy to check admissibility and (KripkeMon). Twoelementary properties are stated in the following lemma.

Lemma 3 (Relations over St). Let A, B : W -! Cpo, R 2 R(A), S 2R(

B). Let e : A .! B and w 2 W.

1. If e : R ae S then FSt (e) : St(R) ae St(S).2. If

s1, s2 2 FSt (A)(w) and s1 ? s2 then s1 2 St(R)w and s2 2 St(R)w if andonly if

s1 * s2 2 St(R)w.

Theorem 1 (Invariant Relation [18]). Let FVal be the locally continuousfunctor for which Val is the minimal invariant. Suppose

\Phi  maps R-relations toR-relations such that for all
R, R0, S, S0 2 R(Val ) and e v idVal ,

e : R0 ae R ^ e : S ae S0 =) F (e, e) : \Phi (R, S) ae \Phi (R0, S0)
Then there exists a unique \Delta  2 R(Val ) such that \Phi (\Delta , \Delta ) = \Delta .
Proof. By [11], the proof of Pitts' existence theorem [18, Thm. 4.16] gener-alises from

Cppo (pointed cpos and strict continuous maps) to arbitrary bilimit-compact categories. Since the R-relations of Definition 2 are admissible in the

sense of [18] and R has inverse images and intersections, the theorem follows. ut

3.4 Safety Monotonicity and Frame Property
Safety monotonicity is the observation that if executing a command in heap
h does not result in a memory fault, then this is also true when running thecommand in a heap that extends

h. The second key semantic principle underlyingseparation logic is the observation that if execution of a command does not result

in a memory fault (i.e., no dangling pointers are dereferenced), then running thecommand in an extended heap does not influence its observable behaviour -- in

particular, the additional heap region remains unaffected. The frame property[25] formalises this idea. Since the actual results of these executions may differ in
the action of the memory allocator, the choice of locations is taken into account.As the store may contain commands itself (which may be executed), both
safety monotonicity and frame property must already be required to hold of thedata in the initial store. In order to give a sufficiently strong induction hypothesis
later, we additionally require that the properties are preserved by the executionof commands. Unfortunately, we cannot adopt separate definitions for safety
monotonicity and frame property (like [25]) but have to combine them. Thereason is that safety monotonicity is not preserved by composition of commands,
unless commands additionally satisfy the frame property.4 Because of the higher-order store, both properties are expressed by mixed-variant recursive definitions,
and existence of a predicate satisfying these definitions requires a proof. It is inthis proof that both properties are needed simultaneously.

For this reason the following property LC (for "local commands") is pro-posed, subsuming both safety and frame property: For

R, S 2 R(Val) let \Phi (R, S)be the W-indexed family of relations where

c 2 \Phi (R, S)w :() c 2 Com(w) =)8

f :w!w2 8i:w2 ,!w02 8g:w2!w3 8s1, s2 2 St(R)w2 8s0 2 St(w3). s1 ? s2 =)

cf (s1) " =) cf;i(St(i)(s1 * s2)) "^

cf (s1 * s2) = error =) cf;i(St(i)(s1)) = error oe safety mon.^
cf (s1) 6= error ^ cf (s1 * s2) = hg, s0i =)9

g0:w02!w03 9j:w03 ,!w3 9s01 2 St(w03) 9s02 2 St(w2).

cf;i(St(i)(s1)) = hg0, s01i ^ s02 v s2 ^ i; g0; j = g^

s0 = St(j)(s01 * St(i; g0)(s02)) ^ s0 2 St(S)w3

9??=??
;

frame property

and define the predicate LC 2 R(Val ) on values as the fixpoint LC = \Phi (LC , LC )of this functional.

This definition is complex so some remarks are in order. Besides combiningsafety and frame property,

\Phi  strengthens the obvious requirements by allowingthe use of a renaming
i on the initial store as well. This provides a stronginvariant that we need for the proof of Theorem 2 below in the case of sequential

composition. To obtain the fixed point of \Phi , Lemma 4 appeals to Theorem 1which forced us to weaken the frame property to an inequality (

s02 v s2). Thisextends conservatively the usual notion of [25] to the case of higher-order stores.

Lemma 4 (Existence). LC is well-defined, i.e., there exists a unique LC 2R(Val ) such that LC =

\Phi (LC , LC ).

Proof. One checks that \Phi  maps Kripke relations to Kripke relations, i.e. for all
R, S 2 R(Val), \Phi (R, S) 2 R(Val ). By Theorem 1 it remains to show for all
e v id Val , if e : R0 ae R and e : S ae S0 then FVal (e, e) : \Phi (R, S) ae \Phi (R0, S0). ut

4 As pointed out to us by Hongseok Yang, this is neither a consequence of using a denotational semantics, nor of our particular formulation employing renamings rather
than non-determinism; counter-examples can easily be constructed in a relational
interpretation of commands.

4 Semantics of Programs and Logic
Table 5 contains the interpretation of the language. Commands and expressionsdepend on environments because of free (stack) variables, so that E J

eK : Env .!Val and C J
cK : Env .! Com where the functor Env is ValVar. The semantics ofboolean and integer expressions is standard and omitted from Table 5; because of

type mismatches (negation of integers, addition of booleans,. . . ) expressions maydenote

error. The semantics of quote refers to the interpretation of commandsand uses the injection of Com into Val . Sequential composition is interpreted

by composition in the functor category but also propagates errors and non-termination. Conditional and

skip are standard. The semantics of the memorycommands is given in terms of auxiliary operations extend and update.

The following theorem shows the main result about the model: commands ofthe above language satisfy (and preserve) the locality predicate LC .

Theorem 2 (Locality). Let w 2 W and ae 2 Env(w) such that ae(x) 2 LC w forall

x 2 Var. Let c 2 Com. Then JcKw ae 2 LC w.

Proof. By induction on c. The case of sequential composition relies on LC takingsafety monotonicity and frame property into account simultaneously. ut

4.1 Interpretation of the Logic
The assertions of the logic are interpreted as predicates over St that are compati-ble with the possible-world structure. In contrast to the R-relations of Section 3.3

they depend on environments, and downward-closure is required to prove theframe rule sound. This is made precise by the following relational structure S.

Definition 3 (dclKripke Relational Structure). Let S consist of the W-indexed families

p = (pw) of predicates pw ` Env(w) * St(w) such that for all
f : w ! w0, ae 2 Env(w) and s 2 St(w),

Kripke Monotonicity if (ae, s) 2 pw then (Env(f)(ae), St(f)(s)) 2 pw0;Downward Closure {

s 2 St(w) | (ae, s) 2 pw} is downward-closed in St(w).

For each natural transformation e = (ew) : Val .* Val and p, q 2 S we write
e : p ae q if for all w 2 W, ae 2 Env(w) and s 2 St(w),

(ae, s) 2 pw ^ (FEnv(e)w(ae)# . FSt (e)w(s) #) =) (FEnv(e)w(ae), FSt (e)w(s)) 2 qw
where FEnv(e) = FVal Var(e, e).
Assertions P 2 Assn are interpreted by S-relations A JP K. Some cases of thedefinition are given in Table 6. All assertions are indeed downward-closed in the

store component, and pure assertions denote either true or false since they donot depend on the heap. The interpretation shows that <= is not supposed to
compare code (but yield false instead). Correspondingly, we assume the non-standard axiom ~(`

c1' <= e2) ^ ~(e1 <= `c2') for the comparison operator.We can now give the semantics of Hoare triples. Correctness is only ensured

if the command in question is run on stores that contain local procedures only.

Table 5. Semantics of expressions and commands
E JeK : Env .! Val + error where f : w ! w0E J

`c'Kw ae = C JcKw aeC J

cK : Env .! Com where f : w ! w0 and s 2 St(w0)
(C JskipKw ae)f (s) = hid, si

(C Jc1;c2Kw ae)f (s) = 8><>:

undefined if (C Jc1Kw ae)f s "
error if (C Jc1Kw ae)f s = error
(C Jc2Kw ae)(f;g)s0 if (C Jc1Kw ae)f s = hg, s0i

(C Jif b then c1 else c2Kw ae)f (s) = 8><>:

(C Jc1Kw ae)f s if E JbKw ae = true
(C Jc2Kw ae)f s if E JbKw ae = false
error otherwise
(C Jlet x=new e in cKw ae)f (s) = let l = min{l 2 L | l /2 w}, s0 = extendw0,l(Val(f)(E JeKw ae), s)

in (C JcKw0[{l} (Env(f; 'w0[{l}w0 )(ae))[x := l])id s0; shift(f;'w0[{l}

w0 )

(C Jfree xKw ae)f (s) = 8><>: h

id, {|l0 = s(l0)|}l02dom(s), l06=li

if 9l 2 w. E JxKw ae = l and f(l) 2 dom(s)
error otherwise

(C J[x]:=eKw ae)f (s) = 8>>><>>>:

hid, updatew0(f(l), s, Val(f)(E JeKw ae))i

if 9l 2 w. E JxKae = l and f(l) 2 dom(s)
and E JeKw ae 2 Val(w)
error otherwise

(C Jlet y = [x] in cKw ae)f (s) = 8><>:

(C JcKw0 (Env(f)(ae))[y := s(f(l))])id(s); shiftf

if 9l 2 w. E JxKw ae = l and f(l) 2 dom(s)
error otherwise

(C Jeval eKw ae)f (s) = ((E JeKw ae)f s if E JeKw ae 2 Com(w)error otherwise

shiftf : (error + Pg0:w0!w00 St(w00)) ! (error + Pg:w!w00 St(w00))
shiftf (v) = (error if v = errorhf; g0, s0i if v = hg0, s0i
extendw,l : Val(w) * St(w) ! St(w ] {l})
extendw,l(v, s) = St('w[{l}w )(s) * {|l = Val('w[{l}w )(v)|}

updatew : w * St(w) * Val(w) ! St(w)
updatew(l, s, v) = {|l=v|} * {|l0=s(l0)|}l02dom(s),l06=l

Definition 4 (Validity). Let w 2 W, ae 2 Env(w), s 2 St(LC )w, c 2 Com(w)"LC

w and p, q 2 S. An auxiliary meaning of "semantical triples" with respect toa fixed world, written (

ae, s) |=w {p} c {q}, holds if and only if for all f : w ! w1,

8g : w1 ! w2 8s0 2 St(w2). (Env(f )(ae), St(f)(s)) 2 pw1 ^

cf (St(f )(s)) = hg, s0i =) (Env(f ; g)(ae), s0) 2 qw2

Observe that {p} c {true} means that, assuming p for the initial state, the com-mand does not lead to a memory fault. Validity of syntactic triples in context

Table 6. Interpretation of assertions
A JP K : S
(ae, s) 2 A JtrueKw :() true
(ae, s) 2 A Je1 <= e2Kw :() E JeiKw ae /2 Com(w) ^ E Je1Kw ae <= E Je2Kw ae
(ae, s) 2 A J~AKw :() (ae, s) /2 A JAKw

(ae, s) 2 A JP ^ QKw :() (ae, s) 2 A JP Kw ^ (ae, s) 2 A JQKw
(ae, s) 2 A J8x. P Kw :() 8v2Val(w). (ae[x 7! v], s) 2 A JP Kw

(ae, s) 2 A JempKw :() dom(s) = ;
(ae, s) 2 A JP1 * P2Kw :() 9s1, s2 2 St(w). s = s1 * s2 ^ (ae, si) 2 A JPiKw
(ae, s) 2 A Jx 7! eKw :() dom(s) = {ae(x)} ^ s(ae(x)) v E JeKw ae

of assumptions is written |= {P1} c1 {Q1} , . . . , {Pn} cn {Qn} ` {P } c {Q} andholds if and only if for all

w 2 W,

8ae2Env(w) 8s2St(LC )w. ^

1<=i<=n (

ae, s) |=w {A JPiK} C JciKw ae {A JQiK}

=) (ae, s) |=w {A JP K} C JcKw ae {A JQK}
For an empty context we simply write |= {P } c {Q} instead of |= ` {P } c {Q}.
Theorem 3 (Soundness). The logic presented in Section 2.2 is sound withrespect to our semantics.

Proof. Lack of space permits only a sketch for the two most interesting rules.
Soundness of the frame rule (Frame). Except for exploiting the renaming oflocations the proof uses the standard argument: Suppose {

P } c {Q} is valid, let
w1 2 W, ae 2 Env(w1) and s 2 St(LC )w1 such that (Env(f )(ae), St(f )(s)) 2A J

P * RKw2 and cf (St(f )(s)) #, where f : w1 ! w2. Thus, St(f)(s) = s1 * s2 forsome

s1, s2 with (Env(f )(ae), s1) 2 A JP Kw2 and (Env(f )(ae), s2) 2 A JRKw2.Now if

cf (St(f)(s)) = error then, by assumption c 2 LC w, also cf (s1) = errorwhich contradicts validity of {

P } c {Q}. Thus, cf (St(f )(s)) = hg, s0i for some
g : w2 ! w3 and s0 2 St(w3). By c 2 LC w there exist g0 : w2 ! w03, j : w03 ,! w3,
s01 2 St(w03) and s02 2 St(w2) such that s02 v s2, cf (s1) = hg0, s01i and

s0 = St(j)(s01) * St(g0; j)(s02) (4)
Downward-closure of A JRK entails (Env(f )(ae), s02) 2 A JRKw2, and therefore(Env(

f; g0; j)(ae), St(g0; j)(s02)) 2 A JRKw3 by Kripke monotonicity. By validity of{
P } c {Q} we have (Env(f ; g0)(ae), s01) 2 A JQKw03. Kripke monotonicity of A JQK

and (4) entail (Env(f; g)(ae), s0) 2 A JQ * RKw3, proving |= {P * R} c {Q * R}.

Soundness of the recursion rule (Rec). This is proved along the lines of [23]:Pitts' technique (cf. Theorem 1) is used to establish existence of a suitable recursive S-relation containing the commands defined by mutual recursion. As in[23] one shows for all assertions

P that A JP K 2 S satisfies the following prop-erties: for all
w 2 W, the set {s | (ae, s) 2 A JP Kw} is downward closed, the set{
ae | (ae, s) 2 A JP Kw} is upward closed, and e : A JP K ae A JP K for all e v id Val .

The first property is built into the definition of S-relations, the latter two canbe established by induction on assertions. Note that the way

x 7! e and e1 <= e2are defined in Table 6 is essential for this result. In particular,

e1 <= e2 had tobe defined differently in [23] where the extra level of locations was absent. ut

5 Conclusions and Further Work
We have presented a logic for higher-order store that admits a local reasoningprinciple in form of the (first-order) frame rule. Soundness relies on a denotational semantics employing powerful constructions known from domain theory.Our reasoning principle for recursion through the store (

Rec) is based onexplicitly keeping track of the code in pre- and postconditions. Instead of code,

Honda et al. [8] use abstract specifications of code, in terms of nested triplesin assertions. Their logic is for programs of an ML-like imperative higher-order
language, with dynamic memory allocation and function storage. In contrastto our work, it builds on operational techniques and does not address local
reasoning. Consequently, an improvement of our logic would be the integrationof nested triples in assertions while admitting a frame rule that is proved sound
employing the semantical approach presented here.Stored procedures are particularly important for object-oriented programming, and we are currently investigating how a separation logic for higher-orderstore can be extended to simple object-based languages like the object calculus
to obtain a logic that combines the power of local reasoning with the principleideas of Abadi and Leino's logic [1, 21]. To achieve that, our results need to be
generalised from Hoare triples to more general transition relations. Separationconjunction in such a framework has been considered in [19].

There are several possibilities for further improvements. It would be inter-esting to see if the FM models of [26, 3], rather than a presheaf semantics, can
simplify the semantics. It also needs to be investigated whether a higher-orderframe rule can be proven sound in our setting analogous to [16, 5].

References

1. M. Abadi and K. R. M. Leino. A logic of object-oriented programs. In Verification:

Theory and Practice. Essays Dedicated to Zohar Manna on the Occasion of His 64th
Birthday, pages 11-41. Springer, 2004.
2. K. R. Apt and G. D. Plotkin. Countable nondeterminism and random assignment.

Journal of the ACM, 33(4):724-767, 1986.
3. N. Benton and B. Leperchey. Relational reasoning in a nominal semantics for

storage. In Proc. TLCA'05, volume 3461 of LNCS, pages 86-101. Springer, 2005.
4. L. Birkedal, N. Torp-Smith, and J. C. Reynolds. Local reasoning about a copying

garbage collector. In Proc. 31st POPL, pages 220-231. ACM Press, 2004.
5. L. Birkedal, N. Torp-Smith, and H. Yang. Semantics of separation-logic typing

and higher-order frame rules. In Proc. 20th LICS. IEEE Press, 2005.
6. P. di Gianantonio, F. Honsell, and G. D. Plotkin. Uncountable limits and the

lambda calculus. Nordic Journal of Computing, 2(2):126-145, 1995.

7. C. A. R. Hoare. An Axiomatic Basis of Computer Programming. Communications

of the ACM, 12:576-580, 1969.
8. K. Honda, N. Yoshida, and M. Berger. An observationally complete program logic

for imperative higher-order functions. In Proc. 20th LICS, pages 270-279. IEEE
Computer Society Press, 2005.
9. S. S. Ishtiaq and P. W. O'Hearn. BI as an assertion language for mutable data

structures. ACM SIGPLAN Notices, 36(3):14-26, 2001.
10. P. J. Landin. The mechanical evaluation of expressions. Computer Journal,

6(4):308-320, 1964.
11. P. B. Levy. Call-By-Push-Value. A Functional/Imperative Synthesis, volume 2 of

Semantic Structures in Computation. Kluwer, 2004.
12. Z. Ni and Z. Shao. Certified assembly programming with embedded code pointers.

In Proc. 33rd POPL, pages 320-333. ACM Press, 2006.
13. P. W. O'Hearn. Resources, concurrency and local reasoning. In Proc. CONCUR'04,

volume 3170 of LNCS, pages 49-67. Springer, 2004.
14. P. W. O'Hearn, J. C. Reynolds, and H. Yang. Local reasoning about programs

that alter data structures. In Proc. CSL'01, volume 2142 of LNCS, pages 1-18.
Springer, 2001.
15. P. W. O'Hearn and R. D. Tennent. Semantics of local variables. In Applications

of Categories in Computer Science, volume 177 of London Mathematical Society
Lecture Note Series, pages 217-238. Cambridge University Press, 1992.
16. P. W. O'Hearn, H. Yang, and J. C. Reynolds. Separation and information hiding.

In Proc. 31st POPL, pages 268-280. ACM Press, 2004.
17. F. J. Oles. A Category-theoretic approach to the semantics of programming languages. PhD thesis, Syracuse University, 1982.
18. A. M. Pitts. Relational properties of domains. Information and Computation,

127:66-90, 1996.
19. A. Podelski and I. Schaefer. Local reasoning for termination. In Informal Workshop

Proc. Verification of Concurrent Systems with Dynamically Allocated Heaps, 2005.
20. U. S. Reddy and H. Yang. Correctness of data representations involving heap data

structures. Science of Computer Programming, 50(1-3):129-160, 2004.
21. B. Reus and J. Schwinghammer. Denotational semantics for a program logic of

objects. Mathematical Structures in Computer Science, 16(2):313-358, 2006.
22. B. Reus and T. Streicher. Semantics and logic of object calculi. Theoretical Computer Science, 316:191-213, 2004.
23. B. Reus and T. Streicher. About Hoare logics for higher-order store. In Proc.

ICALP'05, volume 3580 of LNCS, pages 1337-1348. Springer, 2005.
24. J. C. Reynolds. The essence of Algol. In J. W. deBakker and J. C. van Vliet,

editors, Algorithmic Languages, pages 345-372. North-Holland, 1981.
25. J. C. Reynolds. Separation logic: A logic for shared mutable data structures. In

Proc. 17th LICS, pages 55-74. IEEE Computer Society, 2002.
26. M. R. Shinwell and A. M. Pitts. On a monadic semantics for freshness. Theoretical

Computer Science, 342:28-55, 2005.
27. M. B. Smyth and G. D. Plotkin. The category-theoretic solution of recursive

domain equations. SIAM Journal on Computing, 11(4):761-783, Nov. 1982.
28. H. Thielecke. Frame rules from answer types for code pointers. In Proc. 33rd

POPL, pages 309-319. ACM Press, 2006.
29. H. Yang. An example of local reasoning in BI pointer logic: the Schorr-Waite graph

marking algorithm. In Proc. 2nd SPACE workshop, 2001.