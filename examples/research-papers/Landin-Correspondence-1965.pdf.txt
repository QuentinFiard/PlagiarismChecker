

iiii~(i 
i~4,!i 

( /) 

S.  GORN,  Editor;  R.  W.  BEMER,  Asst.  Editor,  Glossary  &  Terminology E.  LOHSE,  Asst.  Editor,  Information  Interchange 

R.  V.  SMITH ,  Asst.  Editor.  Programming  Languages 

J 

A  Correspondence Between 
ALGOL  60  and  Church's  Lambda- 

Notation:  Part  I* 

its-  P.  J.  I,~XDtN} 

This  paper  describes  how  some  of  the  semantics  of  ALGOL 
60  can  be  formalized  by  establishing  a  correspondence 
between  expressions  of  ALGOL  60  and  expressions  in  a 
modified  form  of  Church's  n-notation.  First  a model  for  com- 

puter  languages  and  computer  behavior  is described,  based  on 
the  notions  of  functional  application  and  functional  abstraction, 
but  also  having analogues  for  imperative  language  features. 
Then  |his  model  is  used  as  an  "abstract  object  language"  into 

which  ALGOL  60  is  mapped.  Many  of  ALGOL  60's  features 
emerge  as  particular  arrangements  of  a  small  number  of  struc- 
tural  rules,  suggesting  new  classifications  and  generalizations. 

The  correspondence  is  first  described  informally,  mainly  by 
illustrations.  The  second  part  of  the  paper  gives  a formal 
description,  i.e.  an  "abstract  compiler"  into  the  "abstract  object 
language."  lhis  is  itself  presented  in  a "purely  functional" 
notation,  that  is one  using  only  application  and  abstraction. 

/ii 

Collten  [S 

(Part J) 
Introduction Motivatioi~ 

[ ,O lit-tel" Ill  Prospects Short-term  Aims 
[mper~ttive  Applieativ(!  ]!]Xl)r(~ssions 

A  Gener:dization  of  ,Imnps 
IIItrodlleillb~ (;Ollllii}~ilds  into  a  I"Llne- tii/tlal  S(:} i() IIL(~ 

Tim  Sllaring  Machine 
ALGOl,  60 as  Sugared  IAE8 
Informal  Presentation  of  the  Corre- 

S !~)()II (]ellCe Brief  Ou'Hine 

The  DomMn  of  Reference  of 

AI,GOL 60 
Fo>lists 

Streams 
Types 

Tlhe  ('onstants  and  Primitives  of ALGOL  60 

[[lustrat[otl~  of  the  (.~ortespon(lenee Identifiers 

Variables 

Ex pressions Blocks 

Pseudo  blocks Declarations 
Statements Labels and  Jumps 
Own Identifiers 
(Part H) 
I"ormal  Presentation  of  the  Con'espoud~ ence 

Abstract  ALGOL 
The  Synthetic  Syntax  I"unction The 

Soma, lille IFtlltctioli 
(:(melllsion 

I n t r o d u c t i o n  

Anyone  familiar  with  both  (~hurch's  X-calculi  (see  e.g. [7])  attd  ALTO],  60  [61  will  have  noticed  a  superticial  re- 

semblance  t)etween  the  uay  variables  tie  up  with  the  X's in  a  nest  of  X-expressions,  and  the  way  identifiers  tie  up 

wiltt  the  headings  in a  nesl, of procedures  and  blocks.  Some may  also  have  observed  that  in,  say 

{\f.f(a)  +  f(b)} [Xx.:c 2  + px  +  q] 
the  two  X-expressions,  i.e.  the  operator  and  the  opcr~md, play  roughly  the  roles  of  Mock-body  and  procedure- 

declaration,  respectively.  The  present  paper  explores  this resemblance  ii~ some  detail. 

The  presenlal~ion  falls  into  four  sections.  Tim  first  see- Lion,  f(illowing  this  introduegi(in,  gives  some  moi;ivation 
for examining  lhe  e(n'respondenee.  The  second  section  de- 
scribes  mt  abstxaeL  language  based  on  Ctmreh's  X-calculi. This  abstrae(  language  is a  development  of  the 

AE/ S ECI )  system  presented  in  [3]  and  sontc  acquaintance  with  thai; 

paper  (hereinMter  referred  to  as  [SiEE])  is  assumed  here. The  third  seclion  describes  inforlnally,  mMnly  by  illus- 
lral;ions,  a  correspondence  between  expressions  of  ALCOL 60  and  expressions  of  the  abstract  language.  The  last 
see(ion  formalizes  tiffs  eorrespondenee;  i(  first  describes 
a  sort  of  "abstracl~ ALcol, 60"  and  then  presents  Lwo  func- tiotts  that  map  expressions  of  ~bstraet  AL(alL  60  inlo,  on 

l;he  one  hand,  AL(~OL 60  texl;s,  and  on  the  other  hand expressions  of  the  abstrac{;  language. 

Mo ti v a ti on  

It  seems  possible  that  the  correspondence  might:  form the basis of a formal  description of  the  semantics  of  AL(;OL 

60/  As  presented  here  it  reduces  the  problem  of  specifying ALt,;OL 60  semani.ies  t,o t.hal~ of  specifying  t)he semantics  of 
a  sLrueturalty  simpler  language.  The  formal  treaLment  of the  latter  problem  is  beyond  the  scope  of  this  paper,  and 
hence  likewise  a  formM t)roof  l~hat~ the  correspondence  de- scribed  here  is  eorrecl).  [1~ is  hoped  that~ the  informM  at- 
count  of  the  semantics  of  the  abstract  "object  language" 

* Part  I[  of  this  paper,  which  gives  bite  FormM  Presenta- tion  of  the  Correspondence,  will  appear  in  the  March,  1965  issue 
of  the  Communications of the ACM. Present  address:  Univac  Division  of  Sperry  Rand  Corpora- 

lion,  Systems  Programming  Research,  New  York,  New  York. * This  view  is  expanded  in  [10]. 

Vo lu n, e  8  / N um ber   2  / February,  1965  Con mutn ie atio ns  of  the  ACM  89 

will  t)e enough to justify the choice of correspondence in all 
but  a  few details. 

LONG-TERM PROSPECTS 

There  at'(', two  ways  in  which  this  work  might  be  rele- 
vant  to  the job of providing software. (1)  Formal  syntax  has  been  used  to  practical  advan- 

tage by language designers and  implementers. There might 
be analogous  advantages  in  formal semantics. (2)  If several languages are being used concurrently by 

the  users  of a  computer,  a  common  formal  basis  for  them 
might  help  in  intermixing  them  (e.g.  referring in  one  lan- 
guage  to  program  that  originated  in  another). 

Clearly,  significance in  these  fields  depends  on the  possi- 
bility  of  applying  to  other  languages  the  technique  illus- 
trated  here  in  respect  to  ALGOL 60.  So  far  only  sketchy 

trials  have been  made,  since even for ALGOL 60 the present 
state  of the  investigation  is not  satisfactory.  Discussion  of 
otimr  languages  is  largely  beyond  the  scope of  this  paper, 

but  the  sketchy trials  confirm  what  will  be obvious  to  the 
present  reader---that  the  method  is  at  its  best  with  lm> guages  that,  rely  mainly  on  elaborate  "descriptive"  forms, 

and  at,  its  worst  with  those  that  rely  mainly  on  elaborate 

"imperative"  forlns.  Thus  it  favours  what  currently  tend 
to  be  called  "advanced"  languages---those  with  good  deft- 

nition  facilities,  localized  naming,  and  reeursive  structure 
of right-hand  sides and  programs.  It  has little value with  a 

fixed-format, absolute-address  language  that  makes  exten- 
sive  use  of  sequencing  and  of state-indicators  that  modify 
the  effect  of  subsequently  executed  instructions. 

SHORT-TERM AlMS 

In  [MEE]  it was shown how certain features of program- 
mint  languages  can  be  modeled  in  a  modified  form  of 
Church's  X-notation.  More  precisely,  a  model  language, 
based  on  X-calculi,  and  called applicative  expressions (AEs) 

was  described  in  abstract  terms,  that  is  to  say,  independ- 
ently  of  any  particular  written  representation.  It  was 
shown  how  AEs  provide facilities essentially  equivalent  to 
auxiliary  definitions,  conditional  expressions  and  recur- 

sion,  and  that  with  a  suitable  choice of written  representa- 

tion  these facilities take  on a  familiar appearance.  Further- 

more,  an abstract  machine,  called the SECD-machine,  was 
described  capable  of  "interpreting"  AEs.  Still  more  pre- 
cisely, there is a Jhmily  of languages  and  a  matching family 

of machines,  each  characterized  by an  "environment,"  i.e. 
a  set  of  named  objects  that  are  related  to  one  another  by 
rules  concerning  the  results  of  applying  them  one  to  an- 

other'.  The present  paper' is based  on a  development of this 
scheme,  intended  to  incorporate  ALGOL 60. 

The  attempt  to  fit ALGOL 60  into  the  A E /S EC D  frame- 
work  can  be  considered  from  two  sides.  On  the  one  hand, 
for someone familiar with ALGOL 60 it  may  clarify some of 
the  features  of  AEs.  Firstly,  the  analysis  of  ALGOL 60  in 

terms of AEs illustrates  the distinction made in [MEE],  be- 
tween  "applicative  structure"  and  "syntactic  sugar." 

90  Commu nications  of  the  ACM 

Secondly,  we  shall  give  many  examples  of  the  usc~ of Al,;s 

as a  descriptive  tool, and  in  particular  some  that  exhibit in 
AEs  features  that  correspond  (o  the  sequencing  control of 

conventional  programming  la ,guages..  lit  emer,,'es.  , ~,  lhat  the 

choice of  an  AE  from  a  certain  ('lass  of  similar  AEs is 
rather  like  the  choice  of  an  order  for  a  set  ot7  assign- 

ments,  and  tlmt  the  issue  of  whether  or  itol.  this  choice 
affects  the  outcome  has  an  analogy  in  terms  ot' AEs. 

For example, it follows from the definition of tim "value" 

of an  AE  that 

~(a  ~  O)(J,  1/a) 

and 

g ( a   =< 0)(X(  ).a 2,a(  ).1).~)(  ) 
are  not  necessarily  equivalent;  if  a  =  0 the  first  is  u> 

defined.  This  difference is  reflected  in  ihe  behavior  of the 
SECD-maehine.  In  evaluating  the  first  it  attempts  to 

evaluate bolh a  2 and  l/a,  whereas in evaluating  the second, 
both  X(  )-expressions  are  evaluated  but  only  one  of  thdr 

bodies.  The  use  of  X,  and  in  particular  (to  avoid  an  ir- 

relevant  bound  variable)  of  h ( ) ,   to  delay  and  possibly 

avoid  evaluation  is  exploited  repeatedly  in  our'  model of 

ALGOl, 60.  A function  that  requires  an  argument-list  of 
length  zero  is  called  a  none-adic  function. On  the  other  hand,  AEs  illunfinate  the  structure  of 

ALGOL 60. Firstly,  the  definitive  description  of  ALGOL 60  is  split 

into  sections  headed  "syntax"  and  "semantics."  The  syn- 
tax  is  described  formally,  the  semantics  raainly  by  nm'ra~ 
tive.  This  paper  provides a  way  of formalizing some of the 

semantics  by  associating  semantic  features  of  AL(~OL 60 
with  syntactic  features of AEs.  (More  precisely, we  should 

say structural features of AEs,  since AEs  have  an  existence 

independent  of  any  specific  written  representation.) 

Secondly,  the  analysis  leads  to  a  classification  of  the 
grammatical  units  of  ALGOL 60  that  provides  a  unified 

framework  for  such  features  as  (i)  the  fact.  lhat  array 

bounds  are  necessarily specified in  terms  of  nonlocals  (and 
hence,  for  instance,  cannot  use  a  procedure  declared  ill 

parallel);  and  (it)  the  commonly  observed  similarity  be- 
tween  procedures  and  actual  parameters  called  by  name. 

More  generally  it  shows  that  many  features  of  AL(~OL 60, 
including  call  by  name,  declarations,  o wn ,  for-lists,  and 
labels,  have  parallels  in  a  language  that  lacks  assignment, 
arid  are  hence  not  essentially  related  to  "imperative"  lar~- 

guages.  Also,  mainly  by  default,  it  suggests  a  new  view of 
ow n 2 Thirdly, the analysis brings out certain respects  in which 

ALGOL 60  is  "incomplete,"  in  that  it  provides  differing fa- 

cilities  in  situations  that  are  closely analogous.  It  dictates 
what  extensions  (and  small  changes)  are  required  to  re- 

move this incompleteness.  Whether or not  "eomplel(mess," 

in the  technical  sense  that  emerges below,  is a  desirable at- 

2 Developed in  [10]. 

Volume 8  / Number 2  / February, 1965 

ll'il)ul(~  el  p  '()gralni~lits~  l~mgttag(. ~  will  liot  be  discussed 
dirocily  ill  1,his p:~por  t)(,yo~ld  lho  following  i.'elli{~rks. 

In  ils  hi, vor  i  l c, ali  })c said  tSal,  given  (:olnplel(mess,  many 
Of  lho  prol)os~ls  for  ('xl(:~i/si()llS thai)are  put  forward  with 
r(~fel'ei~oe  go  ctirro/~ t pr()graitu~iing  ]angtiages  become  mere 

s!/ntaclic  pr<)pos~fls,  i.(< proposals  for wriling  in al:l allegedly 

illoFe  eonvellieiit  way  sonic  particular  k, ind  of  expression 
that  is  ~fli'eady  ii~  the  langu'~ge.  There  is  art  important 
(lualifiem  ion  io  ti~is:  such  a  proposal  niight  have  some  coo- 

lion/it  ovorlones;  i.c,.  il;  might  be  a  sy'ntactic  proposal  Dliat 
helps  the  machine  to  recognize  when special  "cheap"  tech- 
~tiques  arc  appropriate,  or  it;  nfight  deter  the  user  from 
writing  forms  of  expression  that  at'(:  expensive  to  imple- 

ment. The  above  c/aim  for  complete  languages  sounds  like one 

ellen  made  to  rebut  a  proposed  language  ext ensi on-- "g ou 

can  do  that  already  merely  by  writing  .... "  The  question 

therofor(~ arises  whether  a  complete  language  forestalls  its 
extensions  in  a n y   more  significant  sense  th a n   do  Turing 

machines,  M a r k e r   algorithms,  built-in  instruction  codes 
of  gei~eral-purpose  computers,  or  programming  languages 
wiih  Am~oL-like  procedure  facilities.  We  shall  not  pursue 

this  questior~  here. 

Fourthly,  the  analysis  of A LCOL 60  in  terms  of AEs  sug- 
gests  a  new  way  of  comparing  various  run-time  setups  for 
ALGOL 60,  and  displays  the  interactions  between  run-time 

selup  and  l he  exlensions  mentioned  above. 

hn lper ativ e  A p p l i c a t i v e   Ex pr ess io ns  

We  now  describe  the  abstract  language  used  later  to 
model ALto-eL 60.  We  give a  formal account of its structure 

(i.e.  its  "abstract  syniax,"  to  use  McCarthy's  phrase  [5]) 
trod an  informal account  of its  semantics--very much what 

the  oftieial description does for ALGOL 60.  The  semantics of 
this absl tact  language  are described in  terms of art abstract 
machine  for  interpreting  it.  This  language  consists  of  ex- 
pressions  we  call  imperative  AEs  (IAEs),  and  tim  machine 
is  called  the  sha'~'ing  machine.  The  IAE/sharing  machine 
system  is  a  development,  of  the  A E / S E C D   system  de- 
scribed  in  [MEE].  However  there  is  art  important  way  in 
which  the  relationship  of  IAEs  to  the  sharing  machine 
differs  from  that  of  AEs  to  the  SECD-machine.  The  se- 

manlics  of' AEs  can  1)e specified  formally without  recourse 
to  a  machine.  In  fact. this  specification provides a  criteriolt 
for .iudging  the  "correctness" of a  machine that  purports  to 
evahmte  AEs.  The   SECD-machine  satisfies  this  criterion 

but  it  is  not  the  only  (abstract)  machine  to  do  so.  With 
IAEs  on  (,lie other  hand  it  appears  impossible  to  avoid 
specifying  semantics  in  terms  of  a  machine. 

A  relationship  was  established  in  [MEE]  between  AEs 
and  certain  informally  introdu('ed  pieces  of  notation;  for 
example,  we  ('onsider 

X  w he r e   x  =  Z 
as  a  way  of  writing  the  operator/operand  combination 

whose  operand  is  Z  and  whose  operator  is  a  X-expression 

Volum e8   /  NiJmber  2  / February ,  1965 

whose  bound  variable  is  x and  whose  X-body is  X;  this  is 

the  AE  thai:  in  a  rnore  rigid  notation  is  written 

{xz.x} [z] 
In  this  paper  we  use  another  piece  of  "syntactic  sugar" 
for  the  same  AE  structure,  namely, 

l et   x  = Z;  X 
or,  letting  layout  obviate  punctuation, 

le t  x  =  Z 

X 

Here  is  a  typical  form  of  AE,  presented  both  informally 
and  formally. 

leta  =  A and  b  =  B 

and f(x,  y)  =  F 
let  tee  g(x)  =  G 

and  h(y,  z)  =  H 
let  k(u,  v)(x)  =  K X 

{x(a, b, f). {X(g, h). 

{Xk.X} {X(u, v).Xz.K}) [ YX (e,  h). (Xx.(L  x (y,  z).H} } 
[A, B, X(x, y).F] 

The only consideration in choosing between le t   and  w he r e  
will  be  the  relative  eonvenienee  of  writing  an  auxiliary 
definition before or after  the  expression it  qualifies. 

The  use  of comlnas  for denoting  lists,  ~  for  conditional 
expressions,  arid  le t   arid  w he r e   for  auxilia W  definitions, 
provides a  way of representing  AEs  on  paper,  i.e.  one  par- 

titular  "syntax"  for' AEs.  Though this syntax has not  been 
rigorously  defined,  enough  has  been  said  to  ensure  that 
each  formula  could  be  rewritten  in  a  rigid,  prefixed  oper- 
ator,  fully bracketed  notation  (rewritten,  that  is to  say,  in 

at  least  one  way  arid  possibly  several  equivalent  ways). 
Another way of saying this is that if we know how to trans- 

late  ALGOL 60  into  a  language  based  on  just  operator/ 
operand eombination, conditional expressions and auxiliary 
definitions  (including  function  definitions  and  recursive 
definitions)  then  we  effectively  know  how  to  translme 

ALGOL 60 into  AEs.  We  shall  use  this  fact to  make  the  in- 
formal  discussion  here  less  technical  than  it  otherwise 

would  be. In  the  formulas  of  [MEE],  AEs  play  two  independent 

roles.  First  they are part  of the  subject  matter in the  sense 
that  certain  subexpressions  denote  AEs.  Second  they  are 
the  language  in use,  since all the  expressions are  to  be  con- 
sidered  as  written  presentations  of  AEs.  This  dual  role  is 
maintained  in  the  present  paper.  It  is  fortuitous  in  the 

sense  that  we  might  have  used  some  other  means  of  ex- 
pressing what  we have  to say about  AEs,  or we might: have 
chosen  some  other  topic  and  nevertheless  have  used  AEs. 
However,  the  coincidence is designed  in  the  sense  that  our 

interest  in  AEs  springs  partly  from  their  success  in  de- 

scribing  their  own  features. 

A  GENERALIZATION OF  JUMPS 

We  introduce  into  the  SECl)-maehine  an  operation  de- 
noted  by  'J',  that  is  applicable  to  funclions,  or  more  pre- 

C omm un icatio ns   of  the  ACM  91. 

cisely  Co  closures,  attd  modifies  their  subsequent  exit 

behavior. For  example,  consider  a  definition  of j' as  follows: 

f(z)  ....  g(-.-,  - . - ) . , ,  w he r e   g  =  JX(u,  v). 
where  Cite subexpression  g ( . . . ,   "  ')  may  occur  at  any 
X-depth  within  the  right-hand  side,  and  itt  any  context. 
If  during  an  application  of f  this  subexpression  is  evalu- 
ated,  its  value  will  immediately  become  the  result  pro- 
duced  by  f.  This  is  relniniscent  of  art  alarnt  exit  from  a 
subroutine.  In  fact  the  generalization  of  labels  to  permit 

arguments  may  be  a  useful  way  of  providing  for  alarm 
exits  in  At, GeL-like  languages. 

I*'urlher,  to define precisely the  meaning of 'J',  we extend 
the  class  of  possible  results  of  evaluation  by  inCroducing 
a  new  kind  of  object,  a  bundle  of  information  called  a 

"program-closure."  When  J  is  applied  to  a  oh)sure  it 
transforlns  int;o  a  program-closure. 

The  resulting  program-closure,  like  a  closure,  includes 
the  current  environment  (for  subsequeItt  installation)  and 
an  expression  (for subsequenC  evaluation).  I{owever it also 
includes the  current  dump,  and  when  the bundle eventually 
comes  to  be  activated,  this  dump  is  also  installed.  This 
process  is to  be contrasted  with  the  activation  of a  closure, 
in  which  the  dump  is  used  to  record  the  current  state  in 
order  that  it  may  be  resumed  later. 

We  call  an  expression  of  the  form 

a(xr,.S) 
a  "progrmn@oint. ''3  IloughIy  speaking,  ALGOl, 60'S  labels 
are  a  special  case  of  program-points.  They  are  paramete> 
less,  and  the  Kbody is typically a  functional  product  whose 
terms  correspond  to  the  statements  following  the  label. 

Moreover,  references  to  both  closures  and  program-clos- 
ures  are  restricted  in  AL(~OL 60  in  a  way  that  prevents 
them  from  being  carried  outside  the  scope  in  which  they 
are  produced.  (In  LISP  [4]  references  to  closures  are  free 

of  this  restriction,  hence  the  need  for  a  chained  stack. 

However  program-closures  art  more  severely  constrained 
in  that  they  cannot  t)e  carried  into  an  inner  scope.) 

INTROI)UCING.  COY/MANI)S  INTO  A  FUNCTIONAL  SCHEME 

Any  att em pt   to  tit  most current  programming languages 
into  the  A E / S E C I )   scheme  involves  the  questions:  Are 
commands  to  be  construed  as  subexpressions  and,  if  so, 
what  do  they  denote?  In  particular,  what  does  an  assign- 

merit  denote  and  what  does  a  jump  denote?  We  postpone 
these  questions  here  (although  claiming  to  leave  them 
rather  more  clearly  formed  than  we  found  them)  by  using 
another  family  of  languages  similar  to  the  one  associated 

with  the  A E / S E C D   system but  differing as follows. 

The  notion  of AE  is  extended  to  comprise  one  new  for- 
m a t   that  models  assignment.  We  characterize  the  en- 

a [  think  this term is due to Peter N~mr. 
92  C o m m u n i c a t i o n s   of  the  ACM 

larged  se~  as  t'olkms. 
AiD. h~perativ,~  applicative  e*prcssi.o~ (IA E)  is either'  ~m ident'tfier, 

or t~ X-ea:pression  (Xezp) and co:asist.s of its  boundva'riable part  (by),  which  is  :~. lisg.~strueture  of idmlti. 

tiers,  a~,d its  X-body  (bodg), which  is  an  IAE, 
or  an  assiqner,  which  consists  of i{;s leflhandside  (lhs),  which  is 

a:a IAI!], and its  riohthan&ide  (rhs),  which  is  an  IAE, 

or a combination,  which  consists of its operator  (rater),  whielh is an  iliA]'], :rod 

its  operand  (rar~d), which  is  aa  IAE. 
We  adopt,  informally,  the  following  notatioH  for  as- 
signers, 

lhs  c= rhs 

This extension  of the  notion  of all expression  brings in its 
train  the  problem of extending  the  notion  of tile  meaning o~' 
an expression.  The  next  subsection  is an  informal  appr0aell 

to  this  Cask.  I t   is  hoped  a  more  exact  account  will  be set 
forth  for  publicalioa  elsewhere,  and  Chat  enough  is  said 
here  to define all buC the  details  of the  main  purpose of this 

pN:)er--explainirlg  ALGOL 60  in  terms  of  IAEs. 

THE  SHARING  ~[ACIHNE 

In  [MEE]  we described  an abstract  machine,  the  SECD- 
machine,  capable of evaluating  an  AE.  Although  the value 
of an  AE  was defined  independently  of this  machine,  it was 
given  a  more  definite  status  by  being  backed  up  by 
specific  machine.  The  notion  of  the  meaning  of  an  IAE, 
on  the  other  hand,  is completely dependent  on  an  abstract 

machine,  the  "sharing  mactfine,"  for  executiTtg  IAEs  -the 
word  "execute"  seems  more  appropriate  than  "evaluate" 
irt the  case of IAEs.  The  sharing  machine  is an  elaboration 
attd  an  ext.ension  of  the  SECD-maehine.  The  elaboration 
is  concerned  with  modeling  the  fact  that   distinct  state- 
positions  having  equal  occupants  might  "share"  the  same 

representation  and  hence  get  updated  collectively.  The 
extension  is  concerned  with  the  execution  of  the  two new 
feaCures,  namely assigners attd ,l  (covered  above), 

The  Transition  Rule  oj" the Sharing  Machine.  The  main 
features  of  the  elaboration  are  the  following  four  specific 
rules governing whether  or not  two state  positions  "share." 
For,  each  state  of  the  sharing  machine  is  characterized by 
an  SECD-state  together  with  an  equivalence  relation, 
namely  "sharing,"  among  its  component-positions.  In the  : 

straightforward  computer  representation,  each equivalence 
class  corresponds  to  an  address.  For  each  slep  we  must 
say  how  this  equivalence  relation  changes. 

When  at, identifier is scanned,  the  stack  head  is left shar- 
ing  with  the  environment  position  holding  the  identifier's 
value.  Also wheu  a  closure  is apt)lied ,  the  youngest  level of 

tlte  new  environnmnt  shares  wiCh  any  sm'viving  "co- 
sharers"  of  the  old  stack-head  (i.e.  the  argument).  As a 
eonsequen('.e of  these  two  provisions a  function  can achieve 
nonlocal  effects  by  assigning  to  its  formals  (i.('.  argunle~ts 

Volume  8  /  N , . n l , e r   2  /  Febr,,arY, 1965 

m'(: c~Jlcd  by  "siz~q)h~ m~.l,m" [8]  rechristened  "reference" 

Jut (]1)[, [I 15 this  is  tim  tl~ode used  for arguments  of Ii~oa'rRAN " 
fum:li(ms).  'Fh(T  ~l, ls()e~lsure  that  no  special  provision  is 

re>coted for s(:mmil,g  m,  id(mli~ier  when  it  occurs  as  the  lhs 
o.1' nit  ~ssigamr.  Since  (:.Ira classitic~,~t;ion of identifiers  into 
(:o~sta, nis  and  variables  is  t~ot reNected  in  the  behavior  of 

t;h(,  machin%  cot~slm,ls  are  not  ir~vulnerable  1;o resetting. 

A  l lfir(1 rule  is  lhal  wh(m  a  closure  is  applied,  the  eom- 
poHet~{,s of older  levels (ff  tlm  r~(,w e n v i r o nl ne nt   share  with 
corresponding  cemponenls of  the ettvironment  from which 
it  was  derive(1.  As  :~ cons(,(tuetme  of  this  provision,  a  func- 

tiot~  can  achieve  noldo(',td  effects  by  assigning  to  its  free 
iclet/liiiers  (inclu(tir~g  (o  constants). 

I/ourthly,  whert  a  control  string  is  exhausted  the  new 
sl;ack-head  is  left  sharing  with  any  surviving  co-sharers  of 

the  old  stack-head.  This  provision ensures  that  an  appliea- 
lion  of a  funclion  cart be appropriate  as a  lhs,  e.g. 

{x:,,.  'i]'  (:~  =  0)  (x,  b)}[a]  ~=  --. ( x () .  <.~ ) ()   ~  ... ..  

characterized  by  (a)  the  result  produced  by  applying  it  to 
each  abstract  object  that  is amenable  to  it,  and  (b)  the  re- 

sult  yielded by  subjecting  it  to  each  abstract  object  that  is applicable  to  it. 

With  [AEs  the  situation  can  be very much  more compli- 
cated.  For  each  case of application  the  question arises,  not, 

merely  what  result  is  loaded  onto  the  stack,  but  also,  for 
each  possible  pattern  of  sharing  throughout  the  current 
state,  how it is changed,  tIowever,  in  the case of the primi- 
tives  we  use  to  model  ALGOL 60,  it  is  possible  to  overlook 

most  of this  complication.  All but  two  are  straightforward 
functions without side-effects. The  two exceptions are sepa- 
rate,  and  assignandhold,  which  is  a  dressed-up  version  of 

the  assigner  format.  For  present  purposes  we  can  roughly 
say that  the  meaning of an  IAE  has two aspects,  a  descrip- 
tive  and  an  imperative  aspect,  of which  one  or  other  may 
be  unimportant.  The  descriptive aspect  corresponds to the 
value,  or denotation,  of art AE.  The imperative aspect cor- 

responds  to the  change  of machine state  caused  by execut- ing the  IAE. 

7'he  Function  "separate".  There  is  a  function  separate 
that  (mables  us  to  avoid  nonlocal  effects at  will.  Th at   is to 
say,  suppose  tim  c, urrent  stack-head  has  been  obtained  by 
loading some environ men t  component  (e.g.  the  value of an 

identifier  of  subscripted  identifier);  then  if  it  is  later  in- 
corporated  in  a  new  environment  the  above-mentioned 

provisions  ensure  (:hat  any  assignment  to  its  new  position 
will  also  reset  its  old  position.  This  is  avoided  if it  is  sub~ 
jetted  to  separate  before  incorporation  in  a  new  environ- 

menl.  (There  are  other  suggestive  names  for separate  that 
are  rejected  here  since  ti~eir  suggestiveness  does  not  en- 

tirely  avoid  misleading:  copy  is  used  in  Lisp  [4]  to  mean 
copying  all  components  "down  to  the  level of"  atoms,  i.e. 
components  named  by variables  (as  opposed to  constants), 
whereas  we  postulate  that  separate  insulates  every  com- 
ponent  from  future  resetting;  v a l u e   as  used  in  ALGOL 60 
coincides  with  separate  in  the  ease  of  operands  that  are 
suitable  lhs's,  but  has  acquired  too  many  mutually  in- 
con~patible  connotations  in  discussing  three  relationships 

that  we  wish  to  delineate  clearly,  namely  the  relation  be- 
tween expressions and  their denotations,  between functions 
and  their  resulls,  and  between  slate-positions  and  their 
occupants.) 

Executing  an  assigner.  The  lhs  and  rhs  of  an  assigner 
can  be  evaluated  in  the  same  way  as  each  other.  The  only 
difference  is  that,  (o  be  appropriate  on  the  lhs,  an  IAE 
nnts{  denote  some  previously produced  object,  for example 
a  named  object  or  component  of  a  named  objec|.  Every 

intermediate  result  of  evaluation  occupies  a  certain  posi- 
tion  i~  the  curret,l  s(ate  of  the  machine;  hence  a  lhs  ex- 
pressi(m  detern~ines  a  state-pnsition.  Scanning  an  assigner 
resets  this  stale  position  and  also  every  state-position 
sharing  wilh  it;  it  leaves  a  nugatory  result  on  the  stack, 

.a m el y   nullist. 

51'Ire "meanb~g"  of  an  [A E.  In  the  A E / S E C D   system, 
each  A I!]  denotes  an  abstract  object  that  is  completely 

ALGOL 60 AS SUG~RED IAEs 

The  sharing machine  provides a  precise  criterion for the 
correctness  of  the  correspondence  between  ALGOL 60  and 
IAEs,  namely  that  they  should  have  corresponding effects 
when executed in corresponding enviromnents. On account 
of the absence of specified input/output  facilities in ALGOL 
60,  the meaning of this  criterion is less clear with regard  to 
whole programs  than  it is with regard to subbloeks,  operat- 
ing  on,  and  producing,  the  values  of  declared  variables. 
However,  input/output  devices  can  be  modeled as  named 
lists,  with  special,  rather  restricted  functions  associated. 
Reading  is  modeled  by  a  procedure  (or  function)  that 
operates  on  a  list,  resets  it  by  removing  some  initial  seg- 
ment,  and  also  resets  other  variables  with  values  derived 
from  the  initial  segment  (or,  if a  function,  produces  these 
values  as  its  result).  Writing  is  modeled  by  a  procedure 
that,  operates  on  a  list,  and  appends  a  new  final  segment 

derived  from  other  variables.  (Alternatively,  a  purely 
functional  approach  can  be  contrived  by  including  the 
transformed  list  among  the  results.)  So no  new principle  is 
raised  by  input/output,  nor hence  by  whole programs. 

We  give  later  a  forinal  presentation  of  a  function  that 
associates an IAE  with  each ALGOL 60 program.  This func- 
tion  is intended  to  satisfy the  criterion  stated  above.  Dis- 
covering  whether  it  does  or  not  is  a  task  that  can  be  ap- 
proached  in  two  ways:  either  experimentally,  using  an 
implementation  of  the  sharing  machine;  or  with  pen  and 
paper,  developing a  proof.  The length  of what  one  accepts 
as a  satisfactory proof will  depend  on his intuitive  grasp  of 
component ideas used in the formalization.  - 

This formalization determines  the  "syntax"  of ALGOL t30 
in  the  special  sense  explained  above.  The  identifiers  oc- 
curring  free  in  the  IAEs  that  model  ALaOL  60,  will  be  the 

"constants"  of  AL(~OL 60  in  our  special  sense.  T h e y   con> 
prise  the  nine  standard  hmction  identifiers,  the  score or  so 

Vol,,nc  8  /  Numl}er 2  /  Fel,r,ary,  1965  Conummications  of the  ACM  93 

of such  symbols  as  + ,   <  arid  A,  the  mnnerical,  Boolean 
and  character-string  constants,  ~  handful  of  functions  to 
deal  with  AL(~OL 60'S  array  and  iteration  facilities,  and 
another  handful  that  are  so  unproblem-oriented  that  they 
are  probably  implicit  in  any  tolerable  language  (in  the 

sense  that  they  would  be  needed  were  it  subjected  to  the 

treatment that ALGOL 60 gets here). 

By  saying  what  each  constant  denotes,  we  shall  be  say- 
ing  what  are  the  "primitiw~s"  of  ALGOl, 60.  The  closure 4 

under  application  and  abstraction  of  this  set  of primitives 
is  the  "universe  of  discourse"  of  AL(~OL 60.  Actually,  the 
syntax of ALGOL 60 is such that  some IAEs have no written 
representation,  and  even  such  thai)  some  meml:)ers  of  the 
universe  of  diseoursc  (for  example  flmction-produeing 
f un cti on s )   are  not  d eno t ed  by  arty  text. 

I n t b rm a l   P re s e n t a t i o n   o f   t h e  C o r r es p o n d en ce  

We  now  give  a  detailed  but  infornlal  description  of  a 
correspondence between expressions of Ar~eOL 60 and  IAEs. 

The  interest  of  this  particular  correspondence  is  that  it  is 

"correct"  in  the  sense  put  forward  above;  i.e.  correspond- 
ing  expressions  executed  in  corresponding  environments 
have  corresponding  outcomes.  Subsequently  we  formalize 

the  correspondence.  However  the  informal  treatment  in- 
eludes  some  material  not  covered  by  the  formalization, 
namely a description of the "basic AL(mL 60 environment", 

i.e.  the  primitive  objects  whose  names  appear  in  the  IAEs 
that  model  ALGOL 60.  If  out'  formalization  were  to  not 
merely  specify  the  correspondence  but  also  prove  its  c o l  
rectness,  then  it  would  have  to  include  a  formM  specifica- 

tion  of  these  primitives. 

There  is  often  considerable  choice  of  IAEs  to  model  a 
particular ALGOL 60 expression.  This  is true even when  the 
primitives and  the  "constants"  that  name  theln  have  been 
chosen. In particular there is a  conflict between using IAEs 

that  correspond  naturally  in  each  individual  ease,  and 
using  a  uniform  and  easily  specified  rule.  For  this  reason 
the  illustrations  in  our  informal  account  sometimes  de- 
viate from the general  rule presented  it* the  formal account 

that  follows it. 

BIcIEF OUTLINE 

Table  1 gives  a  rough  indication  of  the  correspondence. 
There are two featureg of ALaOL 60 that  give rise  to par- 
tieularly clumsy IAEs. 

1.  Own identifiers declared other  than  in the head  of the 
body of a  globally declared  procedure. 

2.  Conditional  statements  that  are  entered  unnaturally 
(i.e.  by  a  go  to)  and  exited  naturally  (i.e.  other  than  by 
a  go  to). 

THE  DOMAIN  OF  REFERENCE  OF  ALGOL  60 

The  corres'pondence given  in  this  paper  associates  with 
each  ALGOL 60  text an  IAE  whose principal  significance is 

4 In  the  usual  algebraic  sense,  not  the  special  sense  attributed to  this  word  by me  here  and in  [MEE]. 

either denotational or state-transformational.  If the former 
it  denotes  either  an  integer,  a  real  (we  postulate  two  dis- 

jtmet  classes  of  absl?ract  objects---so  3  and  3.0  are  not 

equivalent),  a  truth-value  or  a  character-string;  or  a  list, 
array  or  function.  State-transformational  IAEs  model 
statements  and  labels;  a  switch  is  related  to  such  IAEs  it: 
much  the  same  way  as  a  vector  is  related  to  numerical 

expressions. Declarations  are  considered  as  giving  initial  values  to 

the  local  identifiers.  For  instance  integer  and  real  identi- 
tiers  are  initialized  respectively  to  integer  zero  and  real 

zero.  A  Boolean  is  initialized  to  false.  Switches  and  pro- 
eedures  are  initialized  to  vectors  and  functions  respec- 
tively  (and  not  subsequently  reset). Lists  are  characterized  by  the  following  structure  deft- 

nition. 

A  list  is  either  null, or  else  it  has  a  head  (h), 

and  a  tail  (t)  which  is  a  list. 

TABLE  1 

IA Es 
Identifiers 
ALGOL  50 
Identifiers,  operator  symbols, 

also  sonm  special  words  and 
configurations Local  identifiers 

FormM  parameters 
Function  designator,  sub- 

scripted  w~rial)le,  and  pro- 

cedure  statement 
Procedure 
Actual  parameter  called  by 

naffle Occurrence  of  a  formal  called 

by  name VMue  part,  of  a  procedure  dee- 
laration 
Specification  part 

Block 

Statement 

Compound  statement 
Label 
Labeled  seglnent  of  program 
go  t o-- st atement 
Switch 

Conditional  expression  or 

statement 

Variables  bound  in  a  X-expres- sion occurring  as  opert~tor 
Variables  bound  in  a  X-expres- 

sion  occurring  as  opcrand 
Operator/operand  combination 

X-expression (  )-expression 

Application  to  null  operand 

list Auxiliary  definition  qualifying 

the  procedure  body,  rede- 

fining some  of  the  formals Auxiliary  definition  qualifying 

the  procedure  body,  redefin- 

ing  sot,m  of  tile  formals 
Combination  whose  operator  is 

the  block-body,  and  whose 
operand  denotes  the  (pos- 
sibly  concocted)  initial  val- 
ues  of  the  locals 
Expression  denoting  a  none- adie  function,  changing  the 

enviromnent  by  side-effects Functional  product  of  none- 

adie  functions Identifier  defined  by  a  none- 
adic  program  point 
Program  point  whose  body,  de- 

notes  a  none-adic  function 
Last  (i.e.  outer)  term  of a  time- 

tional  product Vector  of  progranl  closures 

Selection  of  an  item  from  a listing 

:I 

6( 

!e 

0[ 

:i 

eu 

i 
94  Communications  of  tile  ACM  Volume  8  / Number  2  / Febrnarv.  1965 

I~  our  model  every  procedm'e,  switch  and  array  operates 
<m a  list  of  zero  or  more  argume~tts.  An  expression  that, 
del~otes a  lisl  irl terms of subexpressions denoting  each item 
o~ tile  list  is called  a  listing.  For' example, 

(a+b,  c+d,  c+f) (a+b,  c+d) 
!millist(a+b)  or  tt(a+b) () 

arc listings.  In  [MEE]  the  first of these  was  considered  as  a 
convenient  way  of  writing 

p/'4i:I: (a + b) (prefix (c q- d) (prefix (e + f) 0 ) ) 
This, coupled with  the  fact  that  operands  are evaluated  be- 
fore  el)craters,  ensures  that  the  items  of  a  listing  are 
(,valuated  in  tile  right-to-left  order.  Hence  in  transcribing 
from  AL(;OI, 60  to  IAEs  tire  order  of  the  items  of  every 

listi~g  (including  the  implicit  listings  of  operands  of  + ,  
=,  eic.)  must  be  reversed.  This  minor  complication  is 
avoided here by adopting  a  different arralysis of listings,  by 

which 

(a'+b,  c+d,  e-f-f) 
is (:(msidered  as  a  convenient  way  of writing 

s~ Uix (e+ f) (sujlix (c+d)  (su fflx(a-f-b ) 0)) 
(1)  mighl  alternatively  have  been  avoided  by  varying  the 
cvahlatiou  me(:hanism  so  as  to  evaluate  operators  before 
op(~rands. In  view of the  limited  form of operalor  occurring 
i!~  AL(;OL  (i0  such  a  change  would  have  few  other  reper- vus:dons. ) 

There is no fealure of the eorrespondence  that  "explains" 
ilw  [eft-lo-right  rule  of  ALGOL 60.  IIl  this  respec.t  the 
('or~'e('tness  of  tire  model  depends  on  a  similar  rule  for 
IAEs.  We  can  put  this  another  way.  The  correspondence 
pr(stmted  i~  this  paper  "explains"  semantic  features  of 
:\L(~o~, 60  i~  lerms  of  syntactic ,  or  more  precisely  strue- 

luraI,  feaiures  of  IAEs.  But  the  left-to-right  rule  is  a 
s<naniic  feature of ALGOL 60  that  relies for  its explanation 
o~  a  se~antie  feature  of  IAEs.  The  semantic  feature  we 

us~  is  that  operands  are  evaluated  before  operators.  (A 
logically  more  economieal  approach  would  use  merely 
1he  faci  that  an  operand  to  a  X-expression  is  evaluated before  its  X-body.  Thus  in  evaluating  ( X x. a2 + x2) ( b +e ) , 

ihe  subexpression  b+e  is  evaluated  before  a 2,  whether 
~he  machine  evaluates  an  operand  before,  after  or  eon- ~urrently  with  its  operator.) 

A~  array  is  considered  as  a  function  whose  domain  is  a 
s~hset  of  the  set  of  integer-lists.  I t   is  initialized  with  the 
appropriate  domain  (not  subsequently,altered)  and  with all  its  elements equal.  Thus 

exp(mdtoarray((O,  m),  (0,  n)) (a) 
det~otes  an  0 n + l )   X  (n-t-l)  array  each  of  whose  ele- 
ments is a.  An own array  is initialized  with  the  appropriate 
dimensionality  but  with  array  bounds  ( - - ~ ,   - t - ~ ) .  

Volume 8  /  Numl)er  2  /  F eb rua ry ,  1965 

These  are  "pared  down"  to  finite  vMues  at  the  first  entry 

to  the  array's  block.  Thus  if A  is a  two-dimensional  array 
then 

parearray( (O, m),  (0,  n) ) (a,  A) 
denotes  an  (m-t-l)  X  (n-l-l)  array  whose  elements  are 
the  same  as  those  of  A  insofar  as  their'  domains  overlap, 
and  otherwise  a. 

A  switch  is  initialized  by  the  function  arrangeasarray, 
that,  transforms  a  given  list  structure  into  an  array  of 
given  domain,  e.g. 

arrangeasarray( (O, 2),  (0, 3))((a,  b,  c, d),  (e, f , g, h),  (i, j,  k,  l) ) 
denotes  a  3X4  array  whose  elements  (row  by  row)  are 
a,  b,  c,  .  .  . ,  k,  l. 

Folk-LIsTs 

Let us use the  term "control-list"  to  mean  the  list of suc- 
cessive  values  assigned  to  the  controlled  vm'iable  during 
one execution of a  for~statement.  The point  of departure of 
our  treatment  of  for-statements  is  that  a  for-list  might 
roughly  be said  to  "d eno te "  the  control-list,  with  each :/br- 
list-element  denoting  one  segment  of  it.  This  suggests  the 
following incorrect  rendering. 

for v :=  a  ste p  b  un til  c,  forty, d,  concatenate  (step(a,  b,  c), 

e while  p  unitlist  (d), 
do  T  while(e,  p)), T) 

where jbr,  concatenate,  step  and  while  are defined as follows. ~ 

reefor(v,S,  7')  =  if  -7  nu llSt hen  [v  :=  hS; 

7'; for (v, t,g, T)] 

ree  concatenate  S  =  null  S  --~  (  ) null(hS)  ~  concatenate  (tS) 

else  --~ h2S :concatenate (t (hS) :tS) reestep(a,b,c) 
=  (a  -  e)  X  sign(b)  >  0  --~ (  ) else 

-)  a:step(a+b,  b,  c) 
rec  while(e,  p)  =  p  --~ c:while(e,  p) else  ---,  (  ) 

However,  these  definitions  fail  to  reflect  the  sequence  of 
execution  prescribed  for  AL(~OL 60.  When  interpreted  by 
the  sharing  machine  they  would  lead  to  an  attempt  to 
evaluate  the  entire  control-list  before  the  first  iteration  of 
the  loop.  The  inadequacy  of  this  approach  is  especially 
flagrant  in  the  case  of  while.  We  therefore  consider  for- 
list-elements  as  denoting  not  lists  but  a  particular  kind  of 
function,  called  here  a  stream,  that  is  like  a  list  but  has 
special  properties  related  to  the  sequencing  of  evaluation. 
Principally,  the  items  of  an  intermediately  resulting 
stream  need  never  exist  simultaneously.  So  streams  might 
have  practical  advantages  when  a  list  is  subjected  to  a 
cascade  of editing  processes. 6 

Following  [MEE],  an  infixed  colon  indicates  prefixing.  T hus 
"x:L"  is  equivalent  to  "prefix  x  L." 6 It  appears  that  in  stream-transformers  we  have  a  functional 

analogue  of  what  Conway  [12]  calls  "co-routines." 

Co mm un ica tion s  of   the   ACM  95 

ftowever,  the  user  of  a  purely  functional  system  (i.e. 
AE/SI)X?D  rather  titan  iAE/sharing  machine)  would  have 
no  way  of telling whether his  intern lediately resulting  lists 
were  in  fact  being  streamed  or  not,  since  the  only  differ- 
enccs  in  outcome  arc  concerned  with  the  amount  of  store 

used,  or  the  range  of  jobs  possible  with  a  given  size  of 
store.  On  the  other  hand,  the  introduction  of  imperatives 
makes  it  possible  to  write  list-expressions  whose  outcome 
is  affected  by  whether  they  arc  represented  as  streams  or 

not.  Hence  it) t)ecomes necessary  to  introduce  a  new  sat  of 
identifiers  that  play  tile  same  role  for  streams  that  h,  t, 

etc.  play  fort' lists.  The  next  subsection  is  concerned  with 

these  operations. 

STREAMS 

There  is  a  relationship  t)etween lists  and  functions  that 
is used here in modeling for-statements  (and would be used 
to  model  input/output  if ALGOL 60  included such).  In  this 
relationship  a  nonnull  list; L  is  mirrored  by  a  none-adic 
function  S  that  produces  a  2-list  consisting  of  (1)  the 
head  of  L,  and  (2)  the  function  mirroring  the  tail  of L. 

The  common  functions,  etc.  associated  with  lists  are 

mirrored as follows. 

wullist  X(). (  ) null (b)  null (S (  )  ) 
head(L)  1st(S(  )  ) lail(L)  2nd(S(  )  ) 

pr~fix(x)(L)  X( ).(x, S) cons(x,  L)  x( ).(*, S) 

unitli.st(x)  x(  ).(x,x( ).()) 

lit  is  easy  to  see  tihat  the  first  five  expressions  on  the 
right  satisfy  tim four relationships that  characterize "nullist, 
null,  h,  t  and  prefix. 

null (nullist)  null (  {  X (). (  )  }  [ ]) -qnull(pr~fix  xL)  --nnull({X(  ).(x,S) }[ ]) 

h(prefixxL)  =  x  lst({X( ).(x,S)}[ ])  =  x t(p,'efix xL)  =  L  2nd({X(  ).(x,S)}[ l)  =  S 

This  correspondence  serves  two  related  purposes.  It 
enables  us  to  perform  operations  on  lists  (such  as  generat- 
ing  them,  mapping  them,  concatenating  them)  without 

using  an  " e x t ens i ve , "   item-by-item  representation  of  the 
intermediately resulting lists;  and  it enables  us to postpone 
the  evaluation  of the  expressions  specifying the  items  of a 
list  until  they  arc  actually  needed.  The  second  of  these  is 

what  interests  us here. 

The  expressions  that  make  use  of  this  technique  can  be 
made  slightly  clearer  by  using  the  following definitions. 

nullist*  =  X( ).( ) null*(S)  =  null(S()) 
h*(S)  =  1st(S()) U(S)  =  2rut(S()) 

However,  the  analogous  definilions  for  the  constructors 

cannot  be used  since  they would  not  preserve the  sequenc- 

96  Communications  of  the  ACM 

ing of ewfiuation.  The  best  that  can be done is to  introduce 
a  new  syntactic  device  whereby  for  any  two  expressions L, 

M 

L:*M  stands for  X().(L,M) 

We  now  define  functions  that  correctly  mirror  A.LC0L 
60'S  three  kinds  of for-list-eleme~lt. 

tee  step*(a,  b,  c)  = X().[(a'-c')  X  sign(b')  >  0]  -,  (  ) 

else  ~  [a',  step*(X(  ).a'+b',  b,  c)] where  a',  b',  c'  =  a(  ),b(  ),c(  ) 
unitlist*(a)  =  a(  )  :* nullist* ree  while*(e,  p)  =  X(  ).p'  ~  [e', while*(e,  p)] 

else  --~  (  ) where  #,  p'  =  e(),  p(  ) 

The  matelfing  definitions  for  concatenate*  and  Jbr*  should 

be  obvious. The  above formulas reflect certain  choices of AL(;OL 60'S 

designers,  e.g. (a)  that  all  parameters  are  evaluated  "when  they  are 

corme to,"  rather  than  e.g.  evaluating  the  parameters  of a 
step-element  (arithmetic  progression)  all  together; 

(b)  that  the  decision  whether  the  current  iteration  is 
the  last  is taken after  it,  not  before it; 

(c)  that  arty resetting of the  controlled variable  during 
the  execution of the for-body affects its subsequent  values. 

That  is  to  say,  had  different choices  been  made  in these 
matters,  then  a  different  IAE,  or  different  definitions  of 
tile  auxiliary  functions  involved,  would  have  been  needed 

to  mirror  for-statements. 

TYPES 

Roughly  speaking our  model deMs with  types  "]nterpre- 
tivcly."  Specifiers  in  ALGOL 60  affect  the  prescribed  out- 
come  of  a  program  only  by  causing  transfer  between  real 
and  integer,  or  by  rejecting  an  argument  outside  the 
specified  class.  We  suppose  that  associated  with  each 
specifiable  (:lass  there  is  a transfer  function  whose  range 

is  within  that  class.  For  instance, float  is  defined  for  num- 
bers,  i.e. for reals and  integers, and  leaves reals unchanged; 
similarly  with  unfloat,  which  is  prescribed  in  the  Ar~oo~, 60 

report  to  be  defined  by 

unfloat(x)  =  entier(x  q-  0.5) 
The  transfer  function  for  truthvalues  is  merely  a  very 
limited  form  of  the  identity  function  that  is  defined  by 

rejectallbuttruthvalues(x)  =  Boolean(x) --~ x 
(Here  B oole an  designates  the  class--or  predicate,  we  do 
not  distinguish--whose  members  are  the  trutllvalues.  A 
conditional  expression  none  of  whose  conditions  hold  is 

taken  as  undefined.)  More  generally  we  define  a  functiortl 
in  as  follows: 

in(A)  (x)  =  A (x)  -~ x 

Volume  8  / Number  2  / February,  1965 

ro&i ior~S 

ho~# 

so  ~hat  if  ..t  is  tt  (:lass  the(,  i'nA  is  a  filter  that  rejects  non- 

members  of  A.  For  example  bz(Boolean)  is  the  function rejectal~bullrutkvalue.s" 

defined  above.  So  the  transfer  func- 
tions  for Booleatls  and  strings  are  respectively  in(Boolean) 
and  in(string). 

The  ftm(',tion  defined  by 

/loat,es.lt  (f)  (:~:)  =/teat  (f (:r  )  ) 
transforms  any  number  producing  function  into  a  real- 
produ(:ing  function.  (This  definition  exploils  the  fact  that 
we  consider  any  function  as  operating  on  a  sz:ngle argument 
allbeit  a  list.)  More  generally,  it'  t  is  the  transfer  function 
for  some  class  A,  then  the  traHsfer  function  for  A-pro- 
ducers  is  Bt,  where  B  (Curry's  combinator  B  [2]) is  de- fined 

by 

Bq?:  =  t@c) 
~  60  So  for  instance  Bfloat  is  the  function  floatresult  defined 

above.  The  transfer  functions  for  type-procedures  are 
y a   therefore  Bfloal,  Burtfloat  and  B(in(Boolean)).  Since  ar- 

0i:  rays  are  treated  as  functions  these  also  serve  as  transfer 

ftllletions  for  arrays. 
o~}  Imperatives  arc  treated  as  nullist-producing  furmtions; 

so  it  would  appear  that  the  best  we  can  do  f e r n   transfer 
2i'i~:  function  for  lahels  is  B(bt(null)).  H e nc e   t he   transfer  fune- 

]t1~  (.ions  for  nontype  procedures  and  for  switches  (which  are 
;|le!  considered  as  arrays  whose  elements  are  program-closures) 

is  B(B(in(null))). 
M~,  The  effect  of  the  at)eve  provisions  for  checking  argu- 

ments  is  tht~t  a  mismatched  procedure,  array,  label  or 
switch  is not  itself immediately  rejected.  Instead  it  is modi- 
fied  so  that  any  result  it  produces,  whenever  and  if  ever  it 
is  applied,  is  rejected.  Hence  our  model  is  overtolerant  in 
pr~  that  a  mismatch  will  not  lead  to  rejection  if  the  procedure 

at1*:-  is  never  applied,  or  if  it  is  exited  unnaturally  and  thus 
tea  evades  producing  a  result.  Furthermore,  a  label  denotes  a 

t,~i,:  program-closure  and  so  even  when  its  result,  namely a,5:  nullist, 

is  produced,  the  context  is  never  resumed  and  so 
n~:  the  cheek  never  occurs.  Hence  tile  identity  function  serves 
tli  equally  well  as  transfer  function. 

ed: 

i; 

THE  CONSTANTS  AND  PRIMITIVES  OF  ALGOL 60 

The  correspondence  given  in  this  paper  associates  with 
each  ALGOL 60  text  an  I A E   in  which  the  identifiers  occur- 
ring  free are  drawn  fi'om the  following  three  groups. 

Group  I  consists  of  the  arithmetical,  Boolean  and  string  con-- 
slants.  An arithmetical constant is an unsigned number as defined 
in  the  AlmoL 60  report,  and  designates  an  integer  or a  (rationM) 
real.  However  the  integers  also  include  ' - ~ '   and  '+ co ',  used  in 

the  initiM array  bounds of own arrays.  The  Boolean constants are 

' t r ue '   and  'false'  and  designate  the  truthvMues.  The  string 
constants  are  certain  character-strings whose  first and  last items 

are  '  ~  ' and  '  "  '  , respectively; such a  constant designates the 
string obtained by  removing its  first and  last  items.  (It  would be 

possible  to  avoid  an  infinity  of  primitives  by  considering  each 
written  tmmbcr  and  each  charaeter-string  as  having  internal 
applicative structure. These might conveniently use such nmnber- 

Volume 8  / N u m be r   2  / F ebr ua r y,   1965 

fornling  and  string-forming  functions  as:  decimal(re,n)=  lOre +  n;  qttoge(s)  =  concatenate(u'  r  ,  ~,  'u'  "  ').) 

Group  2  consists  of  symbols  and  identifiers  whose  meaning  ~s 
laid down  in the ALGOL 60 report, and  also  a  number of identifiers 

coined by  us  and explained above.  We assunm that  any  collisions 
between  these  coinages  and  Ar~aor,  60 identifiers  are  avoided  by 
some  device  such  as  the  use  of  a  different  typeface,  e.g.  italic 
instead  of  roman. 

+,  - ,   X , / ,   +,  T,  +~r,  -~z,  <,  =<,  =,  ~,  >,  ~,   -~,  A,  V, 

abs,  sign,  sqrt,  sin,  cos,  a,'etan,  In,  exp,  e'ngier 
The  infixed  operators  are  taken  as  (applying  to  2-lists,  either  2- 

nulnbcr-lists  or  2-Boolean-lists. Numerical  functions  are  applic- 
able to both reals, and integers; if n  andfloat(n)  are both amenable 
to  a  fimetion  then  they  yield  the  same  result.  The  coinages  are 

for,  concatenate*,  step*,  anitlist*,  wh.ile*,  expandtoarray, 

arrange~asarray,  parearray,  float,  .w~tJtoal~ [n>  real,  integer, 

Boolean,  string, atom 
Gro~tp  3  consists  of  names  for  very  basic  objects. 

null,  nullist,  suffi.x,  {f,  B,  K,  [,  Y,  separate,  assignandhold 
null  is the  predicate  that  tests  whether a  list  has  zero length. 

nullist  is  a  list  of  length zero. 

s'u~x  makes  a  list  one  longer,  e.g. 

s'aflix(x) (a,b,c)  =  (a,b,c,x} 
if  satisfies  the  following: 

if( true)  =  1st 
if(false)  =  2nd 
B  forms  a  functional  product 

B(t)(f)  =  hx.tff(z)) 
It  is  used  lit  dclaying  transfer  functions  for  type  t)roeedures 

and  formals called  by  name. 
K  produces  "constant  functions" 

K  (x)  (:/)  =  x 
So  for instance  K3  is  a  function  whose result  is  3 for  any  argu- 
ment;  it  is  used  to  tidy  up  assignments. 
I  is the identity function, defined by [  (x)  =  x 

it  plays  tim  role  of  dummy  statenlents. 
Y  is  the  "fixed-point finder."  In  so  fat' as  it  is  reasonably  repre- 

sentable it can be defined by 

Y(F)  =  let  z  = separale(nullisl) 

let  z'  =  F(z) 
2nd( (z~z')   ,z) 
This  definition  relies  on  the  fact  that  when  a  function-trans- 

former is applied to  the  (arbitrarily chosen) argument nMlist, 

rejection  does  not  occur  unless,  or  until,  the  argumcnt  is 
actually  applied. 
separate  avoids unwanted side-effects; it  is used  when parameters 

are  called by  value. 
assigmtndhold  is  defined by 

assignandhold(x)  (y)  = let  x  = real  y  -~ float x 

integer  y  --~ unfloat  a: 
Boolean  y  --~ in(Boolean)x 
2nd((y~x),x) 

In  this  subsection  and  the  four  preceding  ones  we  have 
characterized  the  abstract  objects  comprising  the  "domain 
of  reference"  that  our  analysis  imputes  to  AL(~OL 60.  T he  
characterization  has  been  partly  formM  and  partly  in- 
formal,  taking  for  granted  such  things  as  numbers,  propo- 
sitional  relations,  ere?  Ia  the  next  subsection we  turn  to the 

main  (.epic  of  this  paper,  namely  how  ekLGOL 60  texts  can 
be construed  as  IAEs  referring  to  these  abstract  objects. 

r In  [9], BShm  is  concerned with  the  formal  treatment  of  this 
topic. 

C o mm u n i c a t i o n s   of  the  ACM  97 

ILI,USTI{ATIONS  OF  THE  (JORRESI?ONI)ENCE 

l';aci~  example  bek)w  illustrates  the  correspondence  be- 
1we(',t  a pariicular  fealuve  of  MX;OL 60  and  a  p~rticular 
f(~alm'e of  IAEs.  That  is  to  say,  each  example  illustrates  a 
rule  tk)r eliminating  a  particular  feature  of  ALGOL 60  in 

(('rms  nf  IAEs.  In order  (o  turn  a  piece of Aix~oL  60  into  all 

IAE  it  will  usually  be  necessary  to  make  marw  successive 
applications  (if  (hesc  rules.  Ii,1 some  of  the  examples  the 

lr.at~sformalion  iulo  an  IMi;  has  been  only  partiMly  per- 
for,ned  lo  [)el,ler  emphasize  the  particular  poin(~  being 
made  by  th('  examt)l('. So  (he  right-hand  half  of aft illustra- 
lion  nla.y  not  always  c(mtail~  au  [AE,  but,  it  always  con- 
lains  somelhing  ihat  is  nearer  to  one  of  the  four  forms  of 

I:\E  lh:m  the  h,fl-hm~d,  A[:a~L  60  expression. 

[deat(fic:r.~.  Exeepl;  for  the  (realment  of  individual  oc- 
curr(~,mes  ()f  idenlifiers,  the  correspondence  is  context  in- 
depend(~n[.  Th(,,  IAE  corresponding  to  each  occurrence  of 
an  Aid(at[,  60  i(le,difier  dep(mds  oft  (he  way  the  identifier 

is declared  or  otherwise  introduced,  as  follows. 

I.  Whe,,eve,'  a  local  declared  to  identify  a  type  pro- 
cedure  occurs  as  a  leftdumd  side  wilhin  its  declaration,  it 

is  tel)laced  by  a  vm'iant  i(lcntifier,  indicated  here  by  dote- 
ruling  it  with  an  aslevisk.  We  call  this  the  result variant  of lhe  procedure  i(le~lilier. 

2.  Every  ocem'r(qme  of  a  formal  not  specified  by  value, 
or  of  a  h)cal  dechu'ed  (.o  identify  a  parameterless  pro- 
cedure,  is  (pt'ovided  I  does  no( apply)  modified  by  attach- 

ing an  emply op(!rand  listing  to  i(. This  is indicated  hero by 
a ,   empt.y  bracket  pair.  Thus  we  t rea(  actual  parameters 
ca/led  by  t,tttue,  and  l)arant(~t(wh~ss  procedures,  as  Ii()ll(}- adie  hmctio,s. 

3.  ()wns m'e {;rea{ed as globally declared  and  are  replaced 
by  variams  to  a v c d   collision  between  two  (:lcclara.tions  of 
the  same  identifier.  These  wwianIs  ~r(~ eMled  own  variants 
of  the  identifier  appearing  in  (:he (cxt  and  are  indicated 
here  by  decorating  il.  with  (me  or  more  daggers.  (This  is 
one  of  the  two  (msat;isfacl;ory  fealures  of  (;he  correspond- 
enee  between  A L(am 60 and  IAEs.  Which  party  is to  blame is  a  (tuesliot~  we  return  Io  later.) 

[[ere  is  an  example  of  these  substitutions, 
begin  begin own  iul:eger  a;  ow~t  integer  ai; 

real  proeedurefOc,y,g);  own  real  aH; value x;  real  :c;  real  procedure  f(x,y,g); 

begin  value  x,y,g; own  real  a;  begin 

:~,:=*+g(y)+a;  y(  ):=z+g(  )(y(  )  )+act; .f:-=k(f,(l,f(z,Y,J) )  f*:=k(f,g(  ),f(x,y(),j)) 
end  e,~d real  proee(lure  h;  real  procedure  h(  )  ; 

h:=k(f,j,h);  h*:=k(f,j,h( )); a:=fO,h,f)  at:=f(at,h (),f) 
end  end 

With  the  exception  of  these  provisions  each  subsequent 
example  is  self-contained;  timt  is  to  say-  the  given  bit  of 
AL,OL  60  corresponds  to  the  givea  IA E  whatever  its 

context  (provided  it  is  grouped  sensibly--for  instance, 

98  Comntunieations  of  the  ?kC~t,| 

not  every  occurrence  of  the  charael~er-striug  ' a / b '   i~t 
Ai:OOL  60  corresponds  Io  (he  IAE  " + ( ,, ,   b )"  -witness 

' c X a + b X d ' ) .  Variables.  The  (,rea(ment~  of  individual  idea(fliers  has 

already  been  explained.  In  s u m m a r y  

Iformal called  by name  x(  ) {type  procedure  as  lhs  x* 

x  Jparameterless  procedure  x( ) ~own  identifier  xt,x +), etc. 

if ~ tb 
~0 tb( 

*k se 

/;lo, 
~d~0se 
i  id~0s( 
(strMghtforward  z  i L?as~ I 

If  all  the  identifiers  i~lvolved  are  straighlforward  the  { c0flc0 
treatment  of  subscripted  idetttifiers  and  funet, ion  desig-  ~ eedtlr '  itliiia; 
nators  is  as  follows. A  [  i  +  j  ,  k} A l l + j ,   k)  nle~lt~ 

f(a;+y,  Z)  f(k(  ).X@-y, X().Z)  )d'[ Tt  'e.~. 
le  transformation  of  actuM  parameters  into  none-adie  ~' array 
functions  is  associated  with  the  possibility  that  a  pro-  0at,1 

ccdure  might  call  its  formMs  by  name.  It  is  conqfiemcnted  locals by  a  peculiarity  in  the  treatment  of  proeedure  decla'a- 

Heat tions  as  noted  below,  de~JI 
If  the  identifiers  involved  are  all  formals  called  by  name 
then  the  transcription  (o  .t~  r~s is  ihey 

A(  )(i(  )  + . i ( ) ,   :c())  "self 

~leeO f(  )(x(  ).x(  )  + y ( ) ,  x(  ).~())  d~,~ 

cleel~ In  the  las(~ example,  'X(  ).z(  )'  can  be  replaced  by  2'.  h~ 
future  illustrations  all  occurrences  of'  identifiers  are  as-  a~ia, 
sumed  to  be  straightforward  unless  the  reason  for  non- 
s(,raightforwardness  is  contained  in  the  example.  Any  ~0~ B 
nonstraightforwardaess  would  involve  superimposing  the 
appropriate  treatment  on  any  other  transformations  that are.  needed,  are 

Expressions.  tile3 ii0~) 

a  +  b  +  (su.Nz  b (suEz a  ()))  I)r0, 
In  future  illustrations  (as  in  previous  ones)  the  trcatmet/t  ?l~( 
of argument  lists,  as  also  usually  of  infixed  operators,  will  beg be  taken  for  granted. 

--a  +  b  +(--M(a),  b) 
The  symbol  --M designates  the  monadic  function  %egate."  L /  ,}. 

a+ b-c+ d  +  ( - (+ (a,b),c),d) 

This  example  shows  how  "left  association"  is  reflected  ' 12. 

(as  opposed  to  the  left-to-right  rule  which  is  quite  in- 
dependent).  The  following  examples  show  how  the  "pre- cedence"  rules  are  reflected. 

cXa+bXd  +  (X (c.,a),  X  (b,d)) 
a-b/c  ~  d  - (a,/(b,  T (c,d)))  'l'I iol 
aTb /c-d  -(/(~   (a,b),  c),  d)  ~0] 
pAqVrAs  V(A (p,q),  Aft,s))  (~1 

Conditional  expressions  use  the  funeti(m  if,  such  that  /'e 

if  true  =  1st  i~ if  false  ~  2rid 

Volume  8  / Number  2  / February,  19~i5  I~ 

ifp  Ih,m  a  else  b  (V  p)  (k(  ).a,  ,all.b)() 
So  (b(,  ('valu:~,ti<)J~ (>l' tl)(~ :/bov(~ /AI,;  irlVOlVeS selecting  ()n(~ 
from  a  lisl  <>l' lw()  i~()H(>~Mic [un(:li()ns  arm  tlmll  applying 
the  s(q('('i(,d  (m(,  t() the  mtllis[. 

li&c/,.w.  Eacll  (t(,(:/~rali()tl  is  (~or~sirued as  a  definition 
whos(~ (l(qi,~(,(~ consist s  of  (me  or  more  local  i(tc,d.ifi(~rs and 
whose  (t(,IiHic~s  (h,t~ol(>s  i~fitial values  for  (henl.  In  the 
case  of  lypc  atl(l  arrtty  (hwAarations  die  initiM  value  is 
conco(.~(~<l  with  z(,r()s.  It~  (he  (:ase  of  switches  and  pro- 
ccdur(!s  th(? (l(~tiMel~s is  alr(~a(ty  in Mx;()L  60.  (In  fact  the 
initial  vaha~  is  ~)cver  changed  since  there  are  no  assign- 

ments  I(>  swil(:h  and  pro(:e(ture  ideatitiers.) 

Array  decl:~rations  are  ini(ializcd  in  terms  of  nonlocals 
(e.g.  a  procedure  identifier  declared  in  parallel  with  an 
array  carmel  be  used  in  the  array  bound  expressions). 
On  the  other  hand  swilches  and  procedures  may  refer  to 
locals,  i.c.  to  arrays,  reMs,  etc.,  and  also  to  each  other. 

ttence  tsrray  defiuiiions  (tualify  switch  and  procedure 
definiiions  (as  well  as  tit(,  blo('k  body).  Whereas  switch 
and  proce(ha'e  delinitiotts  do  nol  quMify array  definitions, 
they  do  qualify  themselves;  that  is  to  say  they  may  be 

"sclf-referetdial,"  i.e.  "circular"  or  "recursive."  We 
accordingly  speak  of  "recursive"  and  "nonrecursive" 
definiiions  or  declarations.  This  dichotomy  leaves  type 
declarations  uncommitted  since  they  contain  no  initializ- 
ing  expressiom  If  {hey  (lid  it  would  be  difficult  to  meeh- 
allize  sclf-referet~tial  :initializations  (e.g.  tee  x  =  x~--k }); 
SO  We  class  (,tleIll  as  nortrecursive. 

1)efinitions  can  also  arise  front  the  block-body----their 
definees  being  (he  labels  that  are  local  to  tim  block.  These 
are  defit~ed  itt  terms  of  locals,  inehtding  each  other,  and 

they  m ay  be  referred  to  by  procedure  and  switch  declara- 
tions.  Hence  labels  ,nust  be  grouped  with  switches  and 
procedures  as  a  single  simultaneously  re('ursive definition. 
The  overall  treatment  of  a  block  is  therefore  as  follows. 

begin  real  a;  let:  a  = qst 

array  A  6~  ;  and  A  = ~2 
procedure  t" 4,a  ;  let  tee  P  = ~a 

switch  S  r&  ;  and  S  = 44 
c~  ;  andL  =  q~6 
L:  c~  ;  andM  =  c7 M:  c7  c~ 

i.e. 

{X(a,A). {X (  I',S,L,M).@,} 

[ YX (P,S,L,M). (6~,0.,,0~,00] } 
[c~,6d 

q'he  d(qailed  structure  of  the  4's  is  ttle  subject  of  the 
followi~g  sections.  In  the  last  example,  and  in  some  that 
follow,  the  [AE  was  prese, d('d  twice,  in  a  less  and  more 
formal  ~aota/iou.  This  emphttsizes  the  fact  that  the  cor- 

respon(hmce  being  illustrated  is  between  ALl, eL  60  texts 
and  (.,erlmn  abstract  ()t)jects,  not  written  representations  of 
them. 

l'seudoblocks.  ~Fhere  are  three  contexts  that  may  or 
may  not  be  occupied  by  blocks,  but  are  in  any  case  like 
bloeks  in  the  treatment  of  labels.  These  contexts  are  pro- 
cedure-bodies,  tbr-bodies  and  whole  programs.  We  call 

them  pseudoblo&s.  Whole  programs  must  also  be  qualified 
by a  conglomeration of all  the  own-declarations that,  occur 
in  the  program.  Their  role  in  a pseudobloek  is  the  same  as 
that  of  the  nonrecursive  declarations  in  a  block. Declarations. 

real  x  let  x  =  sepa~nte (0.0) 
integer  i,  j  let  i  = separate  (0) and  j  = separate  (0) 

Boolean  p  let  p  = separate  (false) 
By initializing every local identifier,  IAEs  impute  meaning 
to  certain  ALl,eL  60-like  programs  to  which  the  ALGOL 60 
report  prescribes  no  lneaning.  The  use  of separale  prevents 
subsequent  assignments  from  altering  the  environmental 
objects designated  by  '0.0',  '0' and  'false'. 

real  array  all:j,  k:l]  let  a  = expandtoarmy((i,j), (k,1)) (o.o) 

integer  array  a,  b,  c[i:jll  let  (a,b,c)  = (separate  A,  separate  A, 

separate  A) 
where  A  = expandtoarray 

(u (i,j)) (0) 
array  a,  b,  ell:n],  d[l:r,l:s]  let  ((a,b,c),u(d))  = ((separate  A,  separate  A, 

separate  A) 
where  A  = expandtoarray (u  (1,n)) (z), 

unitlist  (separate  A) 
where  A  = expandtoarray 

((1,r),  (1,8)) (x)) 

where  x  = 0.0 
switch  S  :=  L,  M,  N  let  S  = arrangeasarray  lull,3)) (L,M,N) 

A  procedure  declaration  is  treated  as  a  definition  whose defiifiens  is a  X-expression.  Our  treatment  of actual  param- 
eters  matches  that  of  formals  called  by  name.  So  if  a formal  is  called  by  value  the  procedure  body  needs  some 
decoration. 
procedure  f@,y,z);  let  f(x,y,z)  =  let  x  = separate@()) 

value  x,  z;  and  z  =  separate (z()) 

i.e.  let f  = X(x,y,z). {x(x,z).cl 

[separate (x (  ) ),  separate (z (  )  )  ] 
If  separate were  omitted  the effect  would  be  that of  "calling 

by  simple  name." Specifiers  also  involve  decorating  the  body. 

procedure  f(x,r,p)  ;  let  f(x,r,p)  = 

wdue  x,  r,  p;  let  x  = separate@()) 
real  x;  and  r  =  sepmute(r()) 
integer  r;  and  p  = separate(p()) 
Boolean  p;  let  x  = float(x) 
S(x+r,  p)  and  r  = unfloat(r) 

and  p  = in(Boolean)  (p) S(x(  ).x+r,  x().p) 

~olume  8  / Numl)er  2  / Fel)ruary,  1965  Communications  of  the  ACM  99 

T he  specification  of  a  formal  called  by  name  involves 
preparing  to  transfer  its  result. 

procedure  f(x,r,s,P);  let  f(x,r,s,P)  = value  x;  let  z  =  separate@()) 

real  x;  let  x  =  float(x) integer  r;  and  r  =  Bu,nfloal(r) 
string  s;  and  s  =  13(in  string)(s) real  procedure  P;  attd  P  =  B(13float)(P) 
p(x+~.,  .9  t'(  )(x(  ),z+r(),  x(  ).,X )) 
This  treatment  of  procedures  as  arguments  might  be  clari- 
fied  by  observing  that  it  suggests  a  particular  extension  of 
ALGOL 60,  by  which,  for  example 

if a<b  then  sin  else  cos 

would  be a  permissible  actual  parameter.  There  would  then 
be  a  nalural  sense  in  which  one  might  distinguish  calling 
procedures  by  name  or  value. 

This  extension  raises  a  special  question  concerning 
parame&rless  proce(hlres,  sitice  at  first  sight  the  designers 
of  AL(~OL 60  appear  to  have  forestalled  it  by  giving  an  in- 
compatible  meaning  to  calling  a  parameterless  procedure 
by  value.  However,  the  situation  is  saved  by  other  limita- 
tions  it,  AL(a)L 60.  For,  it  uses  the  identifier  of a  parameter- 
less  procedure,  say  'p',  as  an  abbreviation  for  its  result, 

i.e.  for  'p(  )'.  It:  is  thus  ilnpossiblc  in  ALGOL  60  tO  refer 

to  a  parameterless  procedure  except  in  the  context;  of  ap- 
plying  it.  T hu s   all  "genuine"  cases  of  procedtn'es  as  argu- 
menis  are  called  by  name.  And,  as  it  happens,  for  all  such 
operands  that  ALGOL 60  allows  (namely  identifiers)  calling 

by  name  and  calling  by  value  have  the  same  outcome,  since 
proc(~dure  identifiers  camtot  be  assigned  to  in  ALGOL 60. 

A  parameterless  procedure  gives  rise  to  an  I A E   with  an explicit 

null  opcrand  listing,  as  in 

procedure  p; a  :=  b  let  p  =  X( ).(a  :=  b) 

Th e  aext  example  shows  how  a  type  procedure  can  be matched  1)y  an  I A E. 

real  procedure  f(y) value  y; 

f  :=  aNy'~  2  +  bXy  +  c 

let  f(y)  =  2*M [(f*  :=  aye+by+c), 

f*l where  y  =  separate(y()) 

where  f*  =  0.0 
Notice  the  way  in  which  the  I A E   distinguishes  the  two 
roles  played  by  the  type  procedure  identifier.  I t  is  il- 
lmninating  to  compare  the  above  expression  with  the  fol- lowing  equivalent: 

letf(y)  =  ay ~ +  by  +  c 
There  are  two  provisions  needed  in  general  for  rendering 
AIXrOL  60  that  are  otiose  in  this  particular  example:  (i) 

the  ability  to  reassign  to  the  result  variable  and  to  include 
assignments  to  other  variables,  arid  (it)  the  ability  to  call p ar am eter s  by  name. 

Slatements.  Each  statement  is  rendered  as  a  0-list- 
transformer,  i.e.  a  none-adic  function  producing  the  nullist 
for  its  result.  I t  achieves  by side-effects  a  transformation  of the  currenl  state  of  evaluation. 

Since  the  execution  of  the I A E   assigner  f o rm at   makes no  !  thee 
provision  for  type  transfer,  assignment  statements  are  beinl 
rendered  in  terms  of  assignandhold. 

a  :=  b-{-c  x( ).K(  ) (assignandhold(b+c)  (at) a[i,j,k]  :=  b/c  X( ).K()(assignandhold(b+c)(a(i,j,]c))) 

T h e  operator  K(  )  is  needed  to  ensure  that  an  assignment 
produces  nullist. 

a  :=  b  :=  c  :=  d+e  X( ).a  := assignandhold(assig'mt~thold(d+e)c)b 

Comp ound   sta(ements  are  considered  as  functional 
products  (which  we  indicate  informally  by  infixed  dots). 

begin  R; S;  T  end  X( ).T(S(R())) i.e.  T.S.R 

I t  should  be  observed  that  the  dot  notation,  e.g.  in 

T ( x )   .S ( u ,  v, w ) . g ,   is  used  here  as  an  abbrevia.tion  fora 
X(  )-expression,  and  not,  for 

I~(R(rx) (S(u,  ,~, w) ) (R)  (1) 
For,  while  (1)  and 

x(  ).T(:~)(S(u,  ,,, w)(~c()))  (2) 
are  equivalent  AEs,  they  are  not  equivalent  IAEs.  hi 

fact  the  execution  of  (1)  involves  the  execution  of 
S ( u , v ,   w)  and  T ( x ) ,  whereas  in  (2)  they  will  not  be 
executed  until  (if  ever)  the  resulting  function  is  applied. 

D u m m y   statements  are  construed  as  compounds  con- 
taining  no  items. 

begirt  end  X(  ).(  ) 

For - statem en ts  involve  several  auxiliary  definitions, already  explained. 

for  v  :=  a  step  b  until  c, d, 

e  while  p do  S 

for (v, concatenate* 

(step*(X(  ).a,  X( ).b,  X().c), unidisH (X ( ) .d), 
whilc*(X(  ).e,  X().p)), S) 

l?rocedure  statements  are  treated  as  function  designa- 
tors  occurring  as  terms  in  the  functional  product. 

S;  P(x,y);  7'  T.P(x,y).S 

In  a  conditional  statement  the  tr eatment  for  conditional 
expressions  is  superimposed  on  that  for  statements. 

if  p  then  begin  P;  Q end  if(p)(x().x().Q(p()), else  begin  R;  S  end  X(  ).X(  ),S([~())) 

() 
Here  some  abbreviation  is  possible,  n amely 

if(p) (x( ).Q(P(  )), x( ),s(~())) 

Bu t  this  is  not  always  so.  For  example  in 
if  p  then  P(x,y)  if(p)(X(  ).P(X(  ).x,  X(),y), else  R(u,v)  X(  ).R(X(  ).u,  X().v)) 

() 
Volume  8  /  Number  2  /  February,  1965 

i  01 see0] 

ifp 

L~ 
h'0n~ 
iS re, 
t0 s', 
ad 

~oih 
iS "e 
a pr 
pr0c 

pr0e if 

L'., 

..f( 

It n 
hate 
pr0g 
hene 

TI 
NIlI] it 

in one 

tI0~ 
cedu 
dose 

eedu 
dim 

A.s 
by t 
llatu 

f0rn: 

0t 
00118 
ALG( tile 

] 
gl0b; 
(luir( TI 

had 
bloel ail~( 

Z~r0 
of t:t 

8 I %k 

lO0  Comnmnications  of  the  ACM  f01/, 

a  ~::  tile  eorresponding  f~bbreviation  would  result  in  both  arms mi:,~  bei~g  exeeut:ed. 

:  ()tie-armed  conditionals  are  filled  out  with  d u mmy  

S~'COlld  gI'lllS ; 

if  p  then  begin  P;  Q end  if(p)(X(  ).Q(P()),  I) 
g~,  l,c~bela and  J'ump.s'.  The  treatment  of  jumps  springs 

from  the  observation  that  the  symbol  'go  to '   in  AL(~OL 60 
is  redundant,  and  could  be  ignored  by  a  processor.  That  is 
{~)  say,  there  is  a  considerable  similarity  between  labels 
grad  the  identifiers  of  parameterless  not,type  procedures. 
i{i}  I~  is  possible  to  use  the  same  "calling  mechanism"  for 
..o;!~  t,oih,  leaving  any  differenees  lo  be  made  by  the  thing  that, 

is  "called."  Thus  there  is  a  natural  meaning  to  be  given  to 
a  program  that,  at,  different  |in-ms,  substitutes  labels  and 

procedures  for  the  same  formal,  e.g. 

el:2  pr(  eedure  P; 
ria  if  p  then  go  to  M; 

L:.. 

.... f(P)  .,.f(L)... 

l i  might  therefore  be  supposed  ~hat  labels  can  be  elimi- 
~mled  formally  by  considering  each  labelled  segment  of 
pl'ogram  as  a  t)arameterless  procedure  declaration  (and 
7e,  helme  as  a  definition  whose  definiens  is  a  X()-expression). 
?,  The  present  purpose  is semantic  specification,  not  cheap 

~.~  rulming.  So  this  device  is  not  invalidated  by  the  fael  that 

i~  involves  aeeumulating  a  pile  of  "resmnption  points," 
o~le  for  every  exeeuted  jump,  that  are  never  taken  up. 

tlowever,  the  device  only  yietds  a  valid  treatment  of  pro- 
(>(lure  exits  at  the  cost  of  abandoning  the  facility  for 

(:losed  subroutines  that  is  embodied  in  Arx;o,,  60's  pro- 
:i~  c(~(lm'es.  We  are  thus  le(l s to  "program-poinls."  Labels  are 

eliminated  in  favour  of  program-point  declarations. 

As  mentioned  earlier,  a  further  complication  is presented 
by  lhe  possibility  that  a  statement  (:art  t)e  entered  un- 
~:miurally  and  then  exited  naturally  This  is  met  by  the, 
{:'orma[  treatment  below. 

Oum  ldent'~iers.  The  treatment  of  o w n   ,.'s can  best  be 
('~msidered  as  involving  a  preliminary  transforlnatiou  of 

.\~(:~OL 60,  which  eliminates  o w n   declarations  except  in 
t he  head  of  a  whole  program  or  the  head  of  the  body  of  a 
~lobally  declared  procedure.  This  transformation  may  re- 
quire  systematic  changes  of  identifiers  to  avoid  collisions. 

The  treatment  of  o w n ' s   would  have  been  more  elegant, 
had  they  been.  associated  with  procedures  instead  of  with 
blocks,  and  had  their  active  life  been  prescribed  as  cote> 
ruinous  with  the  life of their  procedure  (which  may  include 
zero  of more activations  of the  procedure).  One consequence 
()f  this  would  have  been  that  two  nesting  activations  of  a 

s In  [11]  van Wijngaarden meets this  point by using  an  explieib )k "  : ~  as an  extra  parameter  to each  procedure. 

procedure  would  share  their  ow n 's   or  not,  accorditLg  as 
they  were  activations  of  the  same  life  of  {lie  procedure  or 
of  two  nesting  lives.  This  meaning  of own   almost  exactly 
coincides  wilh  lhe  generally  accepted  meaning,  if  o w n ' s  
are  restricted  to  the  heads  of  (he  bodies  of  procedures declared  in  the  head  of  the  whole  program.'-' 

C o n c l u s i o n  

Oile  little  SUl/g use  of  ALGOL 60  has  been  as  a  standard 
with  which  to  describe  and  compare  olher  languages.  Its 
suitability  for  this  role  arose  fi'om  being  described  with 

remarkable  precision,  and  from  its  greater  power  and 
elegmme,  so  that  its  own  idiosyneraeies  and  limila|ious 
did  not  overshadow  those  of the  languages  being  measm'ed against  it. 

The  language  of  IAEs  is  put  forward  here  for  eonsidera 
lion  as  a  further  step  in  this  direction,  and  the  supporting 
evidence  is  a  detailed  mapping  of  A[~(a)L 60  into  IAEs.  So 
far  in  this  paper  we  have  Iaid  the  groundwork  for  the 
mapping,  namely  a  description  of  the  "primitive  objects" 
it  refers  to,  and  we  have  given  specific  instances  of  ils 
application.  The  remainder  of  lhe  paper  is  devole(t  lo  its formal  characterization. 

REFEI~ENCES 
1.  BArtRON,  I).  W.,  BUXTON,  J.  N.,  H~t. lt'rI,l.',y,  1).  F.,  Nlxox.  F,., +~ml) STI{ACItE'(, C.  The  night features  nf  ('1+1,. Co+~+p++t, +1+ 

6, 2 (July  1963), 134-143. 2.  C[~[tlCC, H.  B.,  AND  FE'~'S,  l{.  Combinalortl  Logic,  l'~d.  1. 
North  [lolL'm(1, Amsterd~un, 1:)58. B.  LANDtN, P.  J.  The  mechanical  ewdu:tt.i<m of  expressions. 
Comput.  J.  6,  4  (Jim. 1964), 308--320. (1.  McCAwrJt~y, J.,  :ET  Ai,.  L[SI'  ;l.5  l'rogrammer's  Mamml. 
MIT,  Cambridge,  1962. 5.  ---~-.  Towards  a  nmtlmmatica!  science  of  e(mq)utation. 

IF[P Munich Conference  1962. North tIolland,  Amsterd:LIn. 1963. 
6.  Na~;i~, P.,  ET AL.  Revised  lleport  (m  the  Algorithmic  I,at~ gu~:~ge ALGOL 60.  Comm. ACM  6,  l  (Jan.  1963), 1-17. 
7.  ROSENBLOOM, 1 ).  The Elements of Mathemalical Lofic.  I)ow~r, New York,  1950. 
~,  STRACtIEY,  C.~  ANI) WILKES,  M,  V.  Sonic  proposals  for  im proving  the  efficiency  of  ALGOl,  6(I. (;cram. ACM  4,  11 

(Nov,  1961),  488-49l. 9.  BOHM, C.  The  CUCH as  a  formal  and descriptive  language. 
Presented  at  IF[P  Working  Conf,,  Baden,  Sept.  19(;k 10.  LANDIN,  P.J.  A formal  dcseription  of AL(R)L 60.  l'r(~s(q~ted 
at  IFIP Workiltg  Conf.,  Baden,  Sept.  1964. 11.  VAN  WIJNGAARDI~N, A.  Recursive  definition  of  symax  and 
semantics.  Presented  at  IFIP Working  Conf.,  Baden,  Sept. 1964. 
12.  C()NWAY, N'[. ]!'~.  I)csign  of  a  separable  trartsition..diagram compiler. Comm.  ACM 6, 7 (July 1963), 396-408. 

9 For  fuller  discussion  of  the  present  approach  to  labcls  ~nd own's  see  [10l. 

~, ohtmc  8  /  Number  2  /  February,  1965  Communications  of  the  ACM  10/ 