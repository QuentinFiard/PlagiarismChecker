

N. D'ORDRE :

UNIVERSIT 'E PARIS XI
UFR SCIENTIFIQUE D'ORSAY

TH`ESE
Pr'esent'ee
Pour obtenir
Le GRADE de DOCTEUR EN SCIENCES

DE L'UNIVERSIT 'E PARIS XI ORSAY

PAR

Fr'ed'eric BLANQUI

Sujet :

Th'eorie des Types et R'ecriture

Soutenue le 28 septembre 2001
devant la Commission d'examen compos'ee de :

Mr Thierry COQUAND

Mr Gilles DOWEK
Mr Herman GEUVERS
Mr Jean-Pierre JOUANNAUD

Mme Christine PAULIN

Mr Miklos SANTHA

Le 19 mars 1998 est une date importante pour au moins deux raisons. La premi`ere
est personnelle. La seconde est que, ce jour-l`a, Jean-Pierre Jouannaud accepta de me
prendre comme stagiaire de DEA pour "'etendre au Calcul des Constructions une
nouvelle version du Sch'ema G'en'eral" qu'il avait 'ebauch'ee avec Mitsuhiro Okada.
Cela ne signifiait pas encore grand chose pour moi. Cependant, l'id'ee d'avoir `a 'etudier
`a la fois le *-calcul et la r'ecriture, et bien s^ur leur interaction, m'enthousiasma. C'est
de cet enthousiasme que r'esulte ce travail.

C'est pourquoi je commencerais par remercier Jean-Pierre Jouannaud, pour
l'honneur qu'il m'a fait, la confiance, l'aide, les conseils et les encouragements qu'il
m'a prodigu'es tout au long de ces trois ann'ees de th`ese. Il m'a appris beaucoup et
je lui en serai toujours reconnaissant.

Je remercie 'egalement Mitsuhiro Okada pour les discussions que nous avons eues
ensemble et le soutien qu'il m'a apport'e. Ce f^ut un grand honneur pour moi d'avoir
eu la possibilit'e de travailler avec lui. J'esp`ere que nous aurons de nombreuses autres
collaborations fructueuses.

Je remercie 'egalement Maribel Fern'andez qui m'a beaucoup aid'e au d'ebut de
ma th`ese en co-encadrant avec Jean-Pierre Jouannaud mon stage de DEA.

Je remercie 'egalement Gilles Dowek qui m'a encourag'e dans mon travail et m'a
aid'e en plusieurs occasions importantes. Son travail a 'et'e pour moi (et est encore !)
une source importante de r'eflexion et d'inspiration.

Je remercie 'egalement Daria Walukiewicz avec qui j'ai eu de nombreuses discussions tr`es fructueuses. Je la remercie vivement pour avoir lu en d'etail une bonne
partie de cette th`ese et pour m'avoir aid'e `a corriger quelques erreurs ou impr'ecisions.

Je remercie 'egalement toutes les personnes de l''equipe D 'EMONS du LRI et de
l''equipe Coq de l'INRIA Rocquencourt (nouvellement baptis'ee LogiCal), en particulier Christine Paulin et Claude March'e qui m'ont aid'e `a plusieurs reprises. Ces deux
'equipes constituent un lieu privil'egi'e de recherche dans une ambiance tr`es agr'eable.

Je remercie 'egalement les rapporteurs de cette th`ese, Thierry Coquand et Herman Geuvers, pour l'int'er^et qu'ils ont port'e `a mon travail et les remarques qu'ils
m'ont faites pour l'am'eliorer.

Enfin, je remercie 'egalement les membres du jury et le pr'esident du jury pour
l'honneur qu'ils me font d'examiner ce travail.

Table des mati`eres
1 Introduction 7

1.1 Historique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.2 Motivations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
1.3 Travaux ant'erieurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
1.4 Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
1.5 Plan de la th`ese . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

2 Pr'eliminaires 25
3 Syst`emes de Types Modulo (TSM) 29

3.1 D'efinition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
3.2 Propri'et'es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
3.3 TSM stables par substitution . . . . . . . . . . . . . . . . . . . . . . 36
3.4 TSM logiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

4 Syst`emes de Types `a R'eduction (RTS) 41

4.1 D'efinition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
4.2 RTS logiques et fonctionnels . . . . . . . . . . . . . . . . . . . . . . . 43
4.3 RTS logiques et injectifs . . . . . . . . . . . . . . . . . . . . . . . . . 45
4.4 RTS confluents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

5 Syst`emes de Types Alg'ebriques (ATS) 53
6 Conditions de Normalisation Forte 59

6.1 Classification des termes . . . . . . . . . . . . . . . . . . . . . . . . . 59
6.2 Types inductifs et constructeurs . . . . . . . . . . . . . . . . . . . . . 60
6.3 Sch'ema G'en'eral . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66

6.3.1 R'ecriture d'ordre sup'erieur . . . . . . . . . . . . . . . . . . . 66
6.3.2 D'efinition du sch'ema . . . . . . . . . . . . . . . . . . . . . . . 68
6.4 Conditions de normalisation forte . . . . . . . . . . . . . . . . . . . . 75

7 Exemples de CAC 81

7.1 Calcul des Constructions Inductives . . . . . . . . . . . . . . . . . . 81
7.2 Calcul des Constructions Inductives + R'ecriture . . . . . . . . . . . 91
7.3 D'eduction Naturelle Modulo . . . . . . . . . . . . . . . . . . . . . . . 93

5

6
8 Correction des conditions de normalisation forte 95

8.1 Espace des termes interpr'et'es . . . . . . . . . . . . . . . . . . . . . . 95
8.2 Candidats de r'eductibilit'e . . . . . . . . . . . . . . . . . . . . . . . . 97
8.3 Sch'ema d'interpr'etation des types . . . . . . . . . . . . . . . . . . . 101
8.4 Interpr'etation des symboles de pr'edicat constants . . . . . . . . . . . 107
8.5 Ordre de r'eductibilit'e . . . . . . . . . . . . . . . . . . . . . . . . . . 114
8.6 Interpr'etation des symboles de pr'edicat d'efinis . . . . . . . . . . . . 117

8.6.1 Syst`emes primitifs . . . . . . . . . . . . . . . . . . . . . . . . 117
8.6.2 Syst`emes positifs, petits et simples . . . . . . . . . . . . . . . 117
8.6.3 Syst`emes r'ecursifs, petits et simples . . . . . . . . . . . . . . 118
8.7 Correction des conditions de normalisation forte . . . . . . . . . . . 118

9 Futures directions de recherche 127

Bibliographie 129
Index 140

Chapitre 1
Introduction

Qu'est-ce que bien programmer ? Outre le fait d''ecrire des programmes compr'ehensibles et exploitables par d'autres personnes, il s'agit avant tout de parvenir `a
'ecrire des programmes sans erreur. Mais comment savoir si un programme n'a pas

d'erreur ? En le d'emontrant. Autrement dit, bien programmer n'ecessite de faire des
math'ematiques.

Mais comment savoir si la d'emonstration que le programme n'a pas d'erreur n'a
elle-m^eme pas d'erreur ? En 'ecrivant une d'emonstration qui peut ^etre v'erifi'ee par
une machine. Autrement dit, bien programmer n'ecessite de faire des math'ematiques
formelles.

C'est `a cela que nous nous int'eressons dans cette th`ese : d'efinir un syst`eme formel
dans lequel on puisse programmer et montrer qu'un programme est correct.

Mais il ne faut pas croire que le travail se trouve multipli'e par deux : programmer
et d'emontrer. En fait, d'une d'emonstration qu'une sp'ecification est correcte, on peut
extraire un programme sans erreur ! Cela est d^u `a la terminaison de "l''elimination
des coupures" en logique intuitionniste d'ecouverte par G. Gentzen en 1933 [55].

Plus pr'ecis'ement, nous allons consid'erer une classe particuli`ere de syst`emes formels, les syst`emes de types. Nous allons 'etudier les propri'et'es des syst`emes de types
lorsqu'on y ajoute des d'efinitions par r'ecriture. La r'ecriture est un paradigme de
calcul simple et g'en'eral `a base de r`egles telles que x + 0 ! x, c'est-`a-dire, si j'ai une
expression de la forme x + 0, alors je peux la simplifier en x.

Mais pour qu'un tel syst`eme serve `a prouver la correction de programmes, il
faut s'assurer que lui-m^eme est correct, c'est-`a-dire, qu'on ne puisse pas y montrer
n'importe quoi. C'est pourquoi nous allons donner des conditions sur les d'efinitions
et montrer que ces conditions assurent la correction du syst`eme.

Avant cela, revenons un peu en arri`ere et voyons comment sont apparus les
syst`emes de types, quels r'esultats ont d'ej`a 'et'e obtenus et quelles sont nos contributions (r'esum'ees dans le Sous-chapitre 1.4).

7

8 CHAPITRE 1. INTRODUCTION
1.1 Historique

Ce sous-chapitre n'a pas la pr'etention de fournir un aper,cu historique absolument
rigoureux. Nous souhaitons seulement rappeler les concepts de base sur lesquels
repose notre travail (types, *-calcul, etc.) et montrer comment celui-ci s'inscrit dans
la continuation de travaux visant `a introduire toujours plus de calcul dans la logique
ou, dualement, `a introduire toujours plus de logique dans la programmation. Nous
prendrons donc certaines libert'es avec le formalisme utilis'e.

Le lecteur rompu `a ces notions (en particulier le Calcul des Constructions et
le Calcul des Constructions Inductives) peut aller directement au Sous-chapitre 1.2
suivant o`u nous pr'esentons nos motivations pour l'ajout dans le Calcul des Constructions de r'ecriture aussi bien au niveau des objets qu'au niveau des pr'edicats.

La Th'eorie des ensembles

Un des premiers syst`emes formels qui permettent de d'ecrire l'ensemble des
math'ematiques est la th'eorie des ensembles de E. Zermelo (1908) 'etendue plus tard
par A. Fraenkel (1922). Il a 'et'e suivi par la th'eorie des types de A. Whitehead et
B. Russell (1911) [119], aussi appel'ee logique d'ordre sup'erieur . Ces deux syst`emes
formels ont 'et'e introduits pour r'epondre `a l'incoh'erence de la th'eorie des ensembles
de G. Cantor (1878).

En logique du premier ordre, dans laquelle est g'en'eralement exprim'ee la th'eorie
des ensembles de E. Zermelo et A. Fraenkel, les objets du discours sont d'efinis `a
partir de constantes et de symboles de fonctions (0; +; : : : ). Ensuite, des symboles
de pr'edicats (2, . . .), les connecteurs logiques (.; ^; ), : : : ) et les quantificateurs
universels et existentiels (8; 9) permettent d'exprimer des propositions sur ces objets.

Un des axiomes de la th'eorie des ensembles de G. Cantor est l'axiome de compr'ehension qui dit que toute proposition d'efinit un ensemble :

(9x)(8y) y 2 x , P (y)
`A partir de cet axiome, on peut exprimer le paradoxe de Russell (1902). En
prenant P (x) = x =2 x, on peut d'efinir l'ensemble R des x qui n'appartiennent pas
`a eux-m^emes. Alors, R 2 R , R =2 R et on peut d'eduire que toute proposition est
vraie. Pour rem'edier `a ce probl`eme, E. Zermelo a propos'e de restreindre l'axiome
de compr'ehension de la mani`ere suivante :

(8z)(9x)(8y) y 2 x , y 2 z ^ P (y)
c'est-`a-dire que, d'esormais, on ne pourra d'efinir par compr'ehension que des sousensembles d'ensembles pr'ec'edemment d'efinis.

La Th'eorie des types

En th'eorie des types, l'id'ee n'est pas de restreindre l'axiome de compr'ehension
mais d'interdire des expressions comme x =2 x ou x 2 x, en restreignant l'application
d'un pr'edicat `a un objet. Pour cela, on associe `a chaque symbole de fonction et `a

1.1. HISTORIQUE 9
chaque symbole de pr'edicat (sauf le symbole d'appartenance) un type de la mani`ere
suivante :

- `a une constante, on associe le type ',
- `a une fonction prenant un argument, on associe le type ' ! ',
- `a une fonction prenant deux arguments, on associe le type ' ! ' ! ',
- . . .
- `a une proposition, on associe le type o,
- `a un pr'edicat prenant un argument, on associe le type ' ! o,
- `a un pr'edicat prenant deux arguments, on associe le type ' ! ' ! o,
- . . .

Alors, on peut appliquer une fonction f prenant n arguments `a des objets
t1; : : : ; tn si le type de f est ' ! : : : ! ' ! ' et chacun des ti est de type '. Et
on peut 'ecrire que des objets t1; : : : ; tn v'erifient un pr'edicat P `a n arguments si le
type de P est ' ! : : : ! ' ! o et chacun des ti est de type '.

Enfin, on consid`ere qu'un ensemble n'est plus un objet (une expression de type
') mais un pr'edicat (une expression de type ' ! o). Et, pour repr'esenter x 2 E,
qui signifie que x v'erifie E, on 'ecrira Ex (application de E `a x). Ainsi, on v'erifie
ais'ement qu'il n'est pas possible d'exprimer le paradoxe de Russell : on ne peut pas
'ecrire xx pour repr'esenter x 2 x car il faudrait que x soit `a la fois de type ' ! o et

de type '. Par la suite, on 'ecrira t : o/ pour signifier que t est de type o/ .

Maintenant, pour repr'esenter les entiers naturels, il y a plusieurs possibilit'es.
Mais il est toujours n'ecessaire de poser un axiome d'infinit'e pour ' et de pouvoir
exprimer l'ensemble des entiers naturels comme le plus petit ensemble contenant
z'ero et stable par incr'ementation. Pour cela, il faut pouvoir quantifier sur des ensembles, c'est-`a-dire sur des expressions de type ' ! o et non plus seulement sur des
expressions de type '.

C'est l`a que le terme de logique d'ordre sup'erieur prend tout son sens. D'esormais,
on ne va plus se restreindre aux expressions d'objets et de pr'edicats d'ecrites pr'ec'edemment, on va consid'erer l'ensemble des expressions que l'on peut former par
application en respectant les types, quels que soient ceux-ci :

- On d'efinit l'ensemble des types simples comme le plus petit ensemble T contenant

', o et oe ! o/ d`es lors que oe et o/ appartiennent `a T .

- On d'efinit l'ensemble des termes de type o/ comme le plus petit ensemble contenant

les constantes de type o/ et les applications tu d`es lors que t est un terme de type
oe ! o/ et u un terme de type oe.

Enfin, on introduit une notation explicite pour d'esigner les fonctions et les ensembles, la *-abstraction , et on inclut dans les constantes les connecteurs et quantificateurs en leur assignant les types suivants : . : o ! o ! o, ^ : o ! o ! o,
8o/ : (o/ ! o) ! o, . . .Par exemple, si ' d'esigne l'ensemble des entiers naturels, on
peut d'esigner le pr'edicat "est pair" (de type ' ! o) par l'expression pair = *x :
':9'(*y : ':x = 2 \Theta  y) qu'on abr'egera par *x : ':9y : ':x = 2 \Theta  y. Le langage des termes
ainsi obtenu s'appelle le *-calcul simplement typ'e , not'e *!.

10 CHAPITRE 1. INTRODUCTION

Mais que dire de pair 2 et 9y : ':2 = 2 \Theta  y ? La seconde expression s'obtient en
substituant x par 2 dans le corps de pair. Cette op'eration de substitution s'appelle
la fi-r'eduction . De mani`ere g'en'erale, *x : o/: t appliqu'e `a u se fi-r'eduit en le terme t
o`u x est substitu'e par u : *x : o/: t u !fi tfx 7! ug.

Il est assez naturel de consid'erer ces deux expressions comme d'enotant la m^eme
proposition. C'est pourquoi on rajoute l'axiome de conversion suivant :

P , Q si P !fi Q
On aboutit alors `a la th'eorie des types de A. Church (1940) [28].

Dans une telle th'eorie, il est possible de quantifier sur l'univers des propositions
lui-m^eme : 8P : o:P ) P . Autrement dit, une proposition peut ^etre d'efinie en
quantifiant sur l'ensemble des propositions, y compris elle-m^eme. Si on autorise de
telles quantifications, on dit que la th'eorie est impr'edicative , sinon on dit qu'elle est
pr'edicative .

Les math'ematiques comme langage de programmation

La fi-r'eduction correspond au processus d''evaluation d'une fonction. Lorsqu'on
a une fonction f d'efinie par une expression f (x) et qu'on veut sa valeur en 5 par
exemple, on va substituer x par 5 dans f (x) et simplifier l'expression obtenue jusqu'`a
obtenir la valeur de f (5).

On peut alors se demander quelles fonctions on peut ainsi d'efinir dans la th'eorie
des types de A. Church. En fait, bien peu. Sur les entiers de Peano (i.e. en prenant 0 : ' pour z'ero et s : ' ! ' pour la fonction successeur), on ne peut exprimer
que des fonctions constantes et des fonctions qui ajoutent une constante `a l'un de
leurs arguments. Sur les entiers de A. Church, o`u n est repr'esent'e par le terme
*x : ':*f : ' ! ':f : : : f x avec n occurrences de f , H. Schwichtenberg [105] montra
qu'on ne peut exprimer que des polyn^omes 'etendus (plus petit ensemble de fonctions
clos par composition et contenant la fonction nulle, la fonction successeur, les projections, l'addition, la multiplication, la fonction caract'eristique de f0g et la fonction
caract'eristique de N n f0g).

Bien s^ur, il est possible de montrer l'existence de nombreuses fonctions, c'est-`adire de prouver une proposition de la forme (8x)(9y) P xy o`u le pr'edicat P repr'esente
le graphe de la fonction. Dans la th'eorie des types intuitionniste par exemple (i.e.
sans l'axiome du tiers-exclu P . :P ), il est possible de montrer l'existence de toutes
les fonctions primitives r'ecursives. Mais on ne dispose pas de terme f : ' ! ' qui
nous permette de calculer les puissances de 2 par exemple, c'est-`a-dire, tel que
f n !fi : : : !fi 2n.

La repr'esentation des d'emonstrations

G. Frege et D. Hilbert ont propos'e de repr'esenter une d'emonstration d'une
proposition Q comme une suite P1; : : : ; Pn de propositions telles que Pn = Q et,
pour chaque i, soit Pi est un axiome, soit Pi est une cons'equence des propositions pr'ec'edentes par modus ponens (de P et P ) Q on peut d'eduire Q) ou par

1.1. HISTORIQUE 11
g'en'eralisation (de P (x) avec x quelconque on peut d'eduire (8x)P (x)). Cependant,
pour faire de telles d'emonstrations, il est n'ecessaire de consid'erer de nombreux
axiomes, ind'ependants de toute th'eorie, qui expriment le sens des connecteurs logiques.

Plus tard, en 1933, G. Gentzen [55] a propos'e un nouveau syst`eme de d'eduction
o`u les axiomes logiques sont remplac'es par des r`egles d'introduction et d''elimination
des connecteurs et quantificateurs :

(axiome)

\Gamma ; P; \Gamma 0 ` P

(^-intro)

\Gamma  ` P \Gamma  ` Q

\Gamma  ` P ^ Q

(^-'elim1)

\Gamma  ` P ^ Q

\Gamma  ` P

(^-'elim2)

\Gamma  ` P ^ Q

\Gamma  ` Q

()-intro)

\Gamma ; P ` Q

\Gamma  ` P ) Q

()-'elim)

\Gamma  ` P ) Q \Gamma  ` P

\Gamma  ` Q

(9-intro)

\Gamma  ` P (t)

\Gamma  ` (9x)P (x)

(9-'elim)1

\Gamma  ` (9x)P \Gamma ; P ` Q

\Gamma  ` Q

. . .

o`u \Gamma  est un ensemble de propositions (les hypoth`eses). Un couple \Gamma  ` Q form'e d'un
ensemble de propositions \Gamma  et d'une proposition Q s'appelle un s'equent . Alors, une
d'emonstration d'un s'equent \Gamma  ` Q est un arbre dont la racine est \Gamma  ` Q, les noeuds
sont des instances des r`egles de d'eduction et les feuilles sont des applications de la
r`egle (axiome).

L''elimination des coupures

G. Gentzen a remarqu'e que certaines d'emonstrations peuvent ^etre simplifi'ees.
Par exemple, cette d'emonstration de Q :

\Gamma ; P ` Q

()-intro)
\Gamma  ` P ) Q \Gamma  ` P

()-'elim)
\Gamma  ` Q

fait un d'etour qui peut ^etre 'elimin'e. Il suffit de remplacer dans la preuve de \Gamma ; P `
Q les feuilles (axiome) donnant \Gamma ; P; \Gamma 0 ` P par la preuve de \Gamma  ` P o`u \Gamma  est
remplac'e par \Gamma ; \Gamma 0. En fait, `a tout endroit o`u il y a une coupure , c'est-`a-dire une r`egle
d'introduction suivie d'une r`egle d''elimination du m^eme connecteur, il est possible
de simplifier la d'emonstration. Il montra alors le r'esultat remarquable suivant : le
processus d''elimination des coupures termine.

Ainsi, toute proposition d'emontrable admet une d'emonstration sans coupure.
Or, en logique intuitionniste, toute preuve sans coupure d'une proposition (9x)P (x)
doit n'ecessairement se terminer par une r`egle d'introduction dont la pr'emisse est
de la forme P (t). Donc, le processus d''elimination des coupures fournit le t'emoin t
de la proposition d'existence. Autrement dit, toute fonction dont on peut prouver
l'existence est calculable.

1x ne doit appara^itre ni dans \Gamma  ni dans Q.

12 CHAPITRE 1. INTRODUCTION

Si on peut exprimer les d'emonstrations elles-m^emes comme des objets de la
th'eorie, il devient alors possible d'exprimer bien plus de fonctions que celles permises
par le *-calcul simplement typ'e.

L'isomorphisme de Curry-de Bruijn-Howard

En 1958, Curry [38] a remarqu'e qu'aux types du *-calcul simplement typ'e on
peut faire correspondre les propositions form'ees `a partir de l'implication seulement
(il identifie ! et )) et qu'`a un terme de type o/ on peut faire correspondre une
preuve de la proposition correspondant `a o/ . Autrement dit, le *-calcul simplement
typ'e permet de repr'esenter les preuves de la logique propositionnelle minimale. Pour
cela, `a chaque proposition P on associe une variable particuli`ere xP de type P . Alors,
on d'efinit le *-terme associ'e `a une preuve par r'ecurrence sur la taille de la preuve :

- une preuve de \Gamma  ` P obtenue par (axiome) est repr'esent'ee par la variable xP ;
- une preuve de \Gamma  ` P ) Q obtenue par ()-intro) `a partir d'une preuve ss de

\Gamma ; P ` Q est repr'esent'ee par le terme *xP : P: t o`u t repr'esente ss ;

- une preuve de \Gamma  ` Q obtenue par ()-'elim) `a partir d'une preuve ss de \Gamma  ` P ) Q

et d'une preuve ss0 de \Gamma  ` P est repr'esent'ee par le terme tu o`u t repr'esente ss et
u repr'esente ss0.

L'ensemble de *-termes ainsi obtenus peut ^etre d'efini directement de la mani`ere
suivante. On appelle environnement un ensemble \Gamma  de couples x : P form'es d'une
variable x et d'un type P (repr'esentant une proposition). Alors, un terme t est de
type P (une preuve de P ) dans l'environnement \Gamma  si \Gamma  ` t : T peut ^etre d'eduit des
r`egles d'inf'erence suivantes :

(axiome)

\Gamma ; x : P; \Gamma 0 ` x : P

()-intro)

\Gamma ; x : P ` t : Q

\Gamma  ` *x : P: t : P ) Q

()-'elim)

\Gamma  ` t : P ) Q \Gamma  ` u : P

\Gamma  ` tu : Q

En 1965, W. W. Tait [110] a remarqu'e que la fi-r'eduction correspond `a l''elimination des coupures. En effet, si on annote l'exemple de coupure donn'e pr'ec'edemment,
on obtient :

\Gamma ; x : P ` t : Q

()-intro)
\Gamma  ` *x : P: t : P ) Q \Gamma  ` u : P

()-'elim)
\Gamma  ` *x : P: t u : Q

Si on fi-r'eduit *x : P: t u en tfx 7! ug, on obtient exactement le terme correspondant `a la preuve sans coupure de \Gamma  ` Q. Ainsi, l'existence d'une preuve sans
coupure correspond `a la normalisation faible de la fi-r'eduction, c'est-`a-dire, `a l'existence, pour tout *-terme typable t, d'une s'equence de fi-r'eductions aboutissant `a un

1.1. HISTORIQUE 13
terme fi-irr'eductible (on dit encore en forme normale ). C'est pourquoi la normalisation occupe une place si importante dans l''etude des syst`emes de types.

En 1968, N. de Bruijn [39] a propos'e un syst`eme de types d'ependants 'etendant
le *-calcul simplement typ'e et dans lequel il est possible d'exprimer les propositions
et les preuves de toute la logique intuitionniste du premier ordre. Ce syst`eme a
'et'e `a la base d'un des tous premiers programmes informatiques de d'emonstration

formelle : AUTOMATH. Un type d'ependant est tout simplement une fonction qui, `a
un objet, associe une expression de type. Il permet de repr'esenter les pr'edicats et les
quantifications sur des objets. En 1969, W. A. Howard [67] a consid'er'e un syst`eme
similaire mais sans le consid'erer comme un syst`eme logique `a part enti`ere.

Dans un syst`eme avec types d'ependants, la bonne formation des types d'epend
de la bonne formation des termes. Il est donc n'ecessaire de consid'erer des environnements avec des variables de types et de rajouter des r`egles assurant la bonne
formation des types et des environnements (l'ordre des variables y 'etant d'esormais
important). Enfin, il est n'ecessaire de rajouter une r`egle de conversion qui permette
d'identifier les propositions fi-'equivalentes. On aboutit alors `a un ensemble de r`egles
de typage semblables `a celles de la Figure 1.1 (il s'agit l`a d'une pr'esentation moderne
qui n''emergera qu'`a la fin des ann'ees 80).

Dans ce syst`eme, ? est le type des propositions et des ensembles du discours
(entiers naturels, etc.) et 2 celui des types de pr'edicat (dont fait partie ?). Par
exemple, l'ensemble des entiers naturels nat a le type ?, le pr'edicat pair a le type
(n : nat)? qu'on abr`ege par nat ! ? car n n'appara^it pas dans ? (produit non
d'ependant) et nat ! ? a le type 2. Partant de la r`egle (ax), les r`egles (var) et
(weak) permettent de construire des environnements bien form'es. La r`egle (prod*!) permet de former des propositions et la r`egle (prod-*P) des types de pr'edicats.
Dans le cas d'une proposition, si le produit n'est pas d'ependant (x n'appara^it pas
dans U ), il s'agit d'une implication ; sinon il s'agit d'une quantification. Autrement
dit, en l'absence de la r`egle (prod-*P), on retrouve le *-calcul simplement typ'e. La
r`egle (abs) permet de former une fonction (si s = ?) ou un pr'edicat (si s = 2). Enfin,
la r`egle (app) permet l'application d'une fonction ou d'un pr'edicat `a son argument.
Autrement dit, les r`egles (abs) et (app) g'en'eralisent les r`egles ()-intro) et ()-'elim)
du *-calcul simplement typ'e.

Du point de vue de la programmation, les types d'ependants permettent d'accro^itre l'information sur les donn'ees et donc de r'eduire les erreurs. Par exemple, on
peut d'efinir le type (list n) des listes d'entiers de longueur n en d'eclarant list : nat !
?. Alors, la liste vide nil a le type (list 0) et la fonction cons qui ajoute un entier x
en t^ete d'une liste ` de longueur n a le type nat ! (n : nat)(list n) ! (list (s n)).
On peut ainsi chercher `a v'erifier si une liste ne d'epasse pas une certaine longueur
(d'epassement d'indice dans un tableau).

14 CHAPITRE 1. INTRODUCTION
centering

Fig. 1.1 - R`egles de typage de *P

(ax)

` ? : 2

(var)

\Gamma  ` T : s 2 f?; 2g

\Gamma ; x : T ` x : T

(weak)

\Gamma  ` t : T \Gamma  ` U : s 2 f?; 2g

\Gamma ; x : U ` t : T

(prod-*!)

\Gamma  ` T : ? \Gamma ; x : T ` U : ?

\Gamma  ` (x : T )U : ?

(prod-*P )

\Gamma  ` T : ? \Gamma ; x : T ` U : 2

\Gamma  ` (x : T )U : 2

(abs)

\Gamma ; x : T ` u : U \Gamma  ` (x : T )U : s 2 f?; 2g

\Gamma  ` *x : T: u : (x : T )U

(app)

\Gamma  ` t : (x : U )V \Gamma  ` u : U

\Gamma  ` tu : V fx 7! ug

(conv)

\Gamma  ` t : T T $\Lambda fi T 0 \Gamma  ` T 0 : ?

\Gamma  ` t : T 0

Les d'efinitions inductives

En logique d'ordre sup'erieur, le principe de r'ecurrence associ'e aux entiers naturels ne peut ^etre d'emontr'e qu'`a partir d'une d'efinition impr'edicative de ceux-ci.
Autrement dit, si on souhaite rester dans un cadre pr'edicatif, il est n'ecessaire de
poser le principe de r'ecurrence comme un axiome.

C'est pourquoi, en 1971, P. Martin-L"of [83] a 'etendu le calcul de N. de Bruijn
en y incluant des expressions pour repr'esenter des types inductifs et leurs principes
de r'ecurrence associ'es. Par exemple, le type des entiers naturels est repr'esent'e par
le symbole nat : ?, z'ero par 0 : nat, la fonction successeur par s : nat ! nat et une
preuve par r'ecurrence d'un pr'edicat P : nat ! o par recP : P 0 ! (8n : nat:P n !
P s(n)) ! 8n : nat:P n. Dans la r`egle de conversion (conv), `a la fi-r'eduction, P.
Martin-L"of ajoute la '-r'eduction qui correspond aux coupures de r'ecurrence :

(conv)

\Gamma  ` t : T T $\Lambda fi' T 0 \Gamma  ` T 0 : ?

\Gamma  ` t : T 0
Dans le cas de nat, ces r`egles qui d'efinissent la '-r'eduction sont celles du syst`eme
T de K. G"odel [63] :

1.1. HISTORIQUE 15

recP (p0; ps; 0) !' p0
recP (p0; ps; s(n)) !' ps n recP (p0; ps; n)

o`u p0 est une preuve de P 0 et ps une preuve de 8n : nat:P n ! P s(n). `A partir de
ces r`egles, en prenant P = *x : nat:nat, il est possible de d'efinir des fonctions sur les
entiers naturels comme par exemple l'addition ou la multiplication :

x + y = recP (y; *u:*v:s(v); x)
x \Theta  y = recP (0; *u:*v:v + y; x)

Pour s'en convaincre, posons f = *u:*v:s(v) et montrons que 2 + 2 se r'ecrit en
4 : 2 + 2 = rec(2; f; 2) !' f 2 rec(2; f; 1) !fi s(rec(2; f; 1)) !' s(f 2 rec(2; f; 0)) !fi
s(s(rec(2; f; 0))) !' s(s(2)) = 4.

En fait, dans cette th'eorie, il est possible d'exprimer par un terme toute fonction dont l'existence est prouvable en arithm'etique intuitionniste d'ordre sup'erieur
pr'edicative (et ces fonctions sont 'egalement celles qui sont exprimables dans le
syst`eme T de K. G"odel).

Le polymorphisme

Le probl`eme de l''elimination des coupures en arithm'etique intuitionniste d'ordre
sup'erieur impr'edicative a 'et'e r'esolu par J.-Y. Girard [61] en 1971. Pour cela, il
a introduit un syst`eme de types polymorphes F ! (J. Reynolds [103] a introduit
ind'ependamment un syst`eme similaire restreint aux quantifications du second ordre).
Un type polymorphe est une fonction qui, `a un type, associe une expression de type.
Et pour repr'esenter les preuves des propositions impr'edicatives, il faut 'egalement que
les termes eux-m^emes soient polymorphes, c'est-`a-dire qu'ils puissent ^etre appliqu'es
`a des expressions de types. Formellement, pour les quantifications de second ordre
(i.e. sur les propositions), cela se traduit par le remplacement dans les r`egles de la
Figure 1.1 de la r`egle (prod-*P) par la r`egle :

(prod-F)

\Gamma  ` T : 2 \Gamma ; x : T ` U : ?

\Gamma  ` (x : T )U : ?
qui permet par exemple de former le type (P : ?)P ! P qui correspond `a la proposition 8P : o:P ) P en logique d'ordre sup'erieur. Pour les quantifications d'ordre
sup'erieur, il faut rajouter la r`egle :

(prod-F!)

\Gamma  ` T : 2 \Gamma ; x : T ` U : 2

\Gamma  ` (x : T )U : 2
qui permet la formation de types de pr'edicats comme par exemple ? ! ? qui correspond `a o ) o en logique d'ordre sup'erieur.

Dans ce syst`eme, il est donc possible d'exprimer toute fonction dont l'existence
est prouvable en arithm'etique intuitionniste d'ordre sup'erieur impr'edicative.

Par ailleurs, du point de vue de la programmation, le polymorphisme permet
de formaliser les algorithmes g'en'eriques par rapport `a des types de donn'ees. Par
exemple, pour tout type A, on peut parler du type (list A) des listes d''el'ements de
type A en d'eclarant list : ? ! ?.

16 CHAPITRE 1. INTRODUCTION

En 1984, T. Coquand et G. Huet [34] ont alors d'efini et 'etudi'e un syst`eme,
le Calcul des Constructions (CC), qui fait la synth`ese entre le syst`eme de N. de
Bruijn et celui de J.-Y. Girard (il contient toutes les r`egles de formation du produit
pr'ec'edentes) et dans lequel il est possible d'exprimer l'ensemble de la th'eorie des
types (mais il ne permet pas d'exprimer plus de fonctions que F!). Ce syst`eme a
servi de base au programme de sp'ecification et de d'emonstration formelle Coq [52].

Les Syst`emes de Types Purs (PTS)

`A la fin des ann'ees 80, H. Barendregt [9] a remarqu'e que beaucoup des syst`emes
de types introduits dans les derni`eres d'ecennies (*!, *P, F, F!, CC, etc.) se distinguent seulement par les r`egles de formation du produit qui y sont autoris'ees. C'est
cela qui a conduit `a la pr'esentation des r`egles de typage que nous avons adopt'ees.
En consid'erant la r`egle de typage g'en'erale suivante param'etr'ee par deux sortes
s1; s2 2 f?; 2g :

(s1; s2)

\Gamma  ` T : s1 \Gamma ; x : T ` U : s2

\Gamma  ` (x : T )U : s2

il est possible d'avoir 4 r`egles diff'erentes ((?; ?) correspondant `a (prod-*!), (?; 2)
`a (prod-*P), (2; ?) `a (prod-F), et (2; 2) `a (prod-F!)) et donc de former, `a partir
de (?; ?), 8 syst`emes diff'erents que l'on peut organiser en un cube dont chaque
direction correspond `a la pr'esence ou non de types d'ependants (r`egle (?; 2)), de
types polymorphes (r`egle (2; ?)) ou de constructeurs de type (r`egle (2; 2)) (voir
Figure 1.2).

Fig. 1.2 - Cube de Barendregt

\Gamma 

\Gamma 

\Gamma 

\Gamma \Gamma 

\Gamma 

\Gamma 

\Gamma 

\Gamma \Gamma 

\Gamma 

\Gamma 

\Gamma 

\Gamma \Gamma 

\Gamma 

\Gamma 

\Gamma 

\Gamma \Gamma `

6

-
*!
(?; ?) types simples

LF, *P
(?; 2) types d'ependants

(2; 2) constructeurs de types
(2; ?) types polymorphes
F

F! CC

- *! d'esigne le *-calcul simplement typ'e de A. Church [28],
- LF (Logical Framework) d'esigne le syst`eme de R. Harper, F. Honsell et G. Plotkin

[66],

- *P d'esigne le syst`eme AUTOMATH de N. de Bruijn [39],

1.1. HISTORIQUE 17

- F et F! d'esignent respectivement le *-calcul polymorphe du second ordre et

d'ordre sup'erieur de J.-Y. Girard [62],

- CC d'esigne le Calcul des Constructions de T. Coquand et G. Huet [35].

Cela va conduire S. Berardi [18] et J. Terlouw [112] `a une 'etude plus syst'ematique
des syst`emes de types en fonction des types exprimables, jusqu'`a la d'efinition par
H. Geuvers et M.-J. Nederhof des Syst`emes de Types Purs (PTS) [57] qui sont des
syst`emes de types param'etr'es par :

- un ensemble de sortes S repr'esentant les diff'erents univers du discours (f?; 2g

dans le Cube),

- un ensemble d'axiomes A ` S2 repr'esentant comment ces univers sont inclus les

uns dans les autres (f(?; 2)g dans le Cube) et la r`egle :

(ax)

` s1 : s2

((s1; s2) 2 A)

- un ensemble de r`egles de formation du produit B ` S3 repr'esentant les quantifications possibles (f(?; ?; ?); (?; 2; 2); (2; ?; ?); (2; 2; 2)g dans le Cube) et la r`egle :

(prod)

\Gamma  ` T : s1 \Gamma ; x : T ` U : s2

\Gamma  ` (x : T )U : s3

((s1; s2; s3) 2 B)

Le Calcul des Constructions Inductives (CIC)

On a vu que le Calcul des Constructions est un syst`eme tr`es puissant dans
lequel il est possible d'exprimer beaucoup de fonctions. Cependant, ces fonctions ne
peuvent pas toujours ^etre d'efinies de la mani`ere que l'on veut. Par exemple, il ne
semble pas possible d'y programmer la fonction pr'ed'ecesseur sur les entiers naturels
de fa,con `a ce que son 'evaluation se fasse toujours en temps constant [62]. Ce n'est
pas le cas dans le syst`eme de P. Martin-L"of o`u les entiers naturels et leur principe
de r'ecurrence sont des objets `a part enti`ere du syst`eme alors que, dans le Calcul des
Constructions, ils sont d'efinis de mani`ere impr'edicative.

C'est pourquoi, en 1988, T. Coquand et C. Paulin ont propos'e le Calcul des
Constructions Inductives (CIC) [36] qui fait la synth`ese entre le Calcul des Constructions et la th'eorie des types de P. Martin-L"of et permet ainsi de programmer plus
efficacement. En 1994, B. Werner [118] a montr'e la terminaison de l''elimination des
coupures dans ce syst`eme. (En 1993, T. Altenkirch [2] a 'egalement montr'e cette
propri'et'e mais pour une pr'esentation du calcul avec jugements d''egalit'e.)

Mais, m^eme dans ce syst`eme, certains algorithmes ne sont toujours pas exprimables. L. Colson [29] a montr'e par exemple que, si on utilise une strat'egie
d''evaluation d'appel par valeur (r'eduction des arguments d'abord), la fonction minimum de deux entiers naturels ne peut pas ^etre impl'ement'ee par un programme
dont le temps d''evaluation est proportionnel au minimum des deux entiers.

18 CHAPITRE 1. INTRODUCTION
1.2 Motivations

Nous avons dit au tout d'ebut que la r'ecriture est un paradigme de calcul simple
et g'en'eral bas'e sur la donn'ee de r`egles de r'ecriture . Cette notion est bien s^ur tr`es
ancienne mais elle a vraiment commenc'e `a ^etre 'etudi'ee dans les ann'ees 70 `a partir
des travaux de D. Knuth et D. Bendix [17]. Ces derniers ont 'etudi'es la r'ecriture pour
d'eterminer si, dans une th'eorie 'equationnelle donn'ee, une 'equation est valide ou non.
Ensuite, la r'ecriture a 'et'e rapidement utilis'ee comme paradigme de programmation
[96, 65, 53, 69, 90] puisque toute fonction semi-calculable peut ^etre d'efinie par des
r`egles de r'ecriture.

Voyons l'exemple des op'erations arithm'etiques sur les entiers naturels d'efinis `a
partir de 0 pour z'ero et s pour la fonction successeur :

0 + x ! x
s(x) + y ! s(x + y)

0 \Theta  x ! 0
s(x) \Theta  y ! (x \Theta  y) + y

Ces r`egles d'efinissent compl`etement l'addition et la multiplication : partant de
deux entiers quelconques p et q (exprim'es `a partir de 0 et s), p+q et p\Theta q se r'ecrivent
en un nombre fini d''etapes en un terme qui ne peut plus se r'ecrire, c'est-`a-dire en
un entier repr'esentant la valeur de p + q et p \Theta  q respectivement.

R'ecriture d'ordre sup'erieur

On peut 'egalement envisager des d'efinitions par r'ecriture qui utilisent des param`etres de fonctions ou des abstractions : c'est la r'ecriture dite d'ordre sup'erieur
par opposition `a la r'ecriture du premier ordre qui n'utilise pas de param`etres fonctionnels ou d'abstractions. Par exemple, la fonction map qui `a une fonction f et une
liste d'entiers (a1; : : : ; an) associe la liste (f (a1); : : : ; f (an)) peut ^etre d'efinie par les
r`egles suivantes :

map(f; nil) ! nil
map(f; cons(x; `)) ! cons(f x; map(f; `))

o`u nil est la liste vide et cons la fonction qui ajoute un 'el'ement `a la t^ete d'une liste.

Ainsi, les r`egles qui d'efinissent les r'ecurseurs des types inductifs (la '-r'eduction)
sont un cas particulier de r'ecriture d'ordre sup'erieur.

D'efinitions plus faciles

On peut voir que de telles d'efinitions sont bien plus naturelles et faciles `a 'ecrire
que celles `a base de r'ecurseurs de la th'eorie des types de P. Martin-L"of ou du Calcul
des Constructions Inductives. Par exemple, la d'efinition de la fonction ^ sur les
entiers naturels n'ecessite deux niveaux de r'ecursion :

*x:rec(x; *y:true; *nzy:rec(y; f alse; *n0z0:zn0; y))
tandis que la d'efinition par r'ecriture est :

0 ^ y ! true
s(x) ^ 0 ! f alse
s(x) ^ s(y) ! x ^ y

1.2. MOTIVATIONS 19
D'efinitions plus efficaces

D'un point de vue calculatoire, les d'efinitions par r'ecriture peuvent ^etre rendues
plus efficaces en ajoutant des r`egles. Par exemple, avec une d'efinition par r'ecurrence
sur son premier argument, n + 0 n'ecessite n + 1 'etapes de calcul. En ajoutant la
r`egle n + 0 ! n, cela ne prend plus qu'une 'etape.

Cependant, il peut devenir plus difficile de s'assurer que, pour toute s'equence
d'arguments, la d'efinition conduit toujours, en un nombre fini d''etapes (propri'et'e de
normalisation forte ), `a un r'esultat unique (propri'et'e de confluence ), qu'on appelle
la forme normale de l'expression de d'epart.

Types quotients

Jusqu'`a maintenant nous avons toujours parl'e des entiers naturels mais jamais
des entiers relatifs qui, pourtant, occupent une place tout aussi importante. Une
mani`ere de repr'esenter les entiers relatifs est d'ajouter aux c^ot'es de 0 et s une
fonction pr'ed'ecesseur p. Ainsi, p(p(0)) repr'esente \Gamma 2. Malheureusement, dans ce
cas, un nombre peut avoir plusieurs repr'esentations : p(s(0)) ou s(p(0)) repr'esentent
tous les deux 0. En fait, les entiers relatifs sont les classes d''equivalences modulo les
'equations p(s(x)) = x et s(p(x)) = x.

Cependant, il est possible d'orienter ces 'equations en un syst`eme de r'ecriture
confluent et fortement normalisant : p(s(x)) ! x et s(p(x)) ! x, chaque nombre
ayant ainsi une forme normale unique. On voit donc que la r'ecriture nous permet de
mod'eliser des types quotients de mani`ere interne sans avoir recours `a des extensions
suppl'ementaires [13].

Plus de termes typables

L'introduction de r'ecriture dans un syst`eme de types d'ependants peut permettre
de typer davantage de termes, donc de formaliser davantage de propositions. Dans
le Calcul des Constructions Inductives, consid'erons le type listn : nat ! ? des listes
d'entiers naturels de longueur n avec les constructeurs niln : listn(0) pour la liste
vide et cons : nat ! (n : nat)listn(n) ! listn(s(n)) pour ajouter un 'el'ement en
t^ete d'une liste. Soit alors la fonction appn : (n : nat)listn(n) ! (n0 : nat)listn(n0) !
listn(n + n0) de concat'enation de deux listes. Tout comme + a 'et'e d'efini `a l'aide du
r'ecurseur associ'e `a nat (par r'ecurrence sur son premier argument), appn peut ^etre
d'efini `a l'aide du r'ecurseur associ'e `a listn (par r'ecurrence sur son premier argument).
Mais alors les propositions suivantes ne sont pas typables alors qu'elles sont a priori
tout `a fait acceptables :

appn(n; `; 0; `0) = `
appn(n + n0; appn(n; `; n0; `0); n00; `00) = appn(n; `; n0 + n00; appn(n0; `0; n00; `00))

Dans la premi`ere r`egle, le membre gauche est de type listn(n + 0) et le membre
droit de type listn(n). On peut montrer par r'ecurrence que n + 0 est 'egal `a n mais
n + 0 n'est pas fi'-convertible `a n car + a 'et'e d'efini par r'ecurrence sur son premier
argument. On ne peut donc pas appliquer la r`egle de conversion (conv) pour typer
l''egalit'e.

20 CHAPITRE 1. INTRODUCTION

Dans la seconde r`egle, le membre gauche est de type listn((n + n0) + n00) et le
membre droit de type listn(n + (n0 + n00)). De m^eme, bien qu'on puisse montrer que
(n + n0) + n00 soit 'egal `a n + (n0 + n00) (associativit'e de +), ces deux termes ne sont
pas fi'-convertibles. On ne peut donc pas appliquer la r`egle de conversion pour typer
l''egalit'e.

Cela nous montre les limitations des d'efinitions `a l'aide de r'ecurseurs. L'utilisation de la r'ecriture, et en particulier de la r'ecriture associative et commutative,
c'est-`a-dire en rempla,cant dans la r`egle de conversion (conv) la '-r'eduction par une
relation de r'eduction !R engendr'ee par un ensemble R a priori quelconque de
r`egles de r'ecriture d'efinies par l'utilisateur :

(conv)

\Gamma  ` t : T T $\Lambda fiR T 0 \Gamma  ` T 0 : ?

\Gamma  ` t : T 0

,

les 'egalit'es pr'ec'edentes deviennent typables.

Preuves 'equationnelles automatiques

Une autre motivation pour vouloir introduire de la r'ecriture dans les syst`emes de
types est que cela facilite consid'erablement les preuves 'equationnelles, ce pourquoi a
'et'e introduite la r'ecriture. En effet, dans le cas d'un syst`eme confluent et fortement

normalisant, pour v'erifier que deux termes sont 'egaux, il suffit de v'erifier qu'ils ont
la m^eme forme normale.

De plus, dans la mesure o`u l''egalit'e de deux termes est d'ecidable, il n'est pas
n'ecessaire de garder la trace des 'etapes de r'ecriture qui ont men'e `a l''egalit'e puisqu'on
peut refaire le calcul `a volont'e. Cela permet de r'eduire la taille des preuves et donc
de pouvoir traiter des preuves de tailles plus importantes.

Int'egration de proc'edures de d'ecision

On peut 'egalement imaginer d'efinir des pr'edicats par r'ecriture ou avoir des r`egles
de simplification sur les propositions, g'en'eralisant ainsi les d'efinitions par 'elimination
forte du Calcul des Constructions Inductives [99]. Par exemple, on peut envisager
l'ensemble de r`egles de la Figure 1.3 [68] o`u xor ("ou" exclusif) et ^ sont consid'er'es
comme des symboles commutatifs et associatifs, et o`u ? repr'esente la proposition
toujours fausse et ? la proposition toujours vraie (en consid'erant une constante I
de type ?).

Fig. 1.3 - Proc'edure de d'ecision pour les tautologies propositionnelles classiques

P xor ? ! P
P xor P ! ?

P ^ ? ! P
P ^ ? ! ?
P ^ P ! P
P ^ (Q xor R) ! (P ^ Q) xor (P ^ R)

:P ! P xor ?
P . Q ! (P ^ Q) xor P xor Q
P ) Q ! (P ^ Q) xor P xor ?
P , Q ! (P xor Q) xor ?

J. Hsiang [68] a montr'e que ce syst`eme est confluent et fortement normalisant,
et qu'une proposition P est une tautologie (i.e. est toujours vraie) si P se r'eduit

1.3. TRAVAUX ANT 'ERIEURS 21
sur ?. Cet ensemble de r`egles constitue donc une proc'edure de d'ecision pour les
tautologies propositionnelles classiques.

Ainsi, la r'ecriture (au niveau type) permet la formalisation et l'int'egration de
proc'edures de d'ecision. En effet, du fait de la r`egle de conversion (conv), si P est une
tautologie alors I, la preuve canonique de ?, en est une preuve. Autrement dit, si la
relation de typage est d'ecidable, pour savoir si une proposition P est une tautologie,
il suffit de proposer I comme preuve au programme de v'erification.

Enfin, on peut 'egalement envisager des r`egles de simplification de l''egalit'e sur
les entiers naturels comme celles de la Figure 1.4 o`u + et \Theta  sont associatifs et
commutatifs, et = est commutatif.

Fig. 1.4 - R`egles de simplification de l''egalit'e sur les entiers naturels

x + 0 ! x
x + s(y) ! s(x + y)

x \Theta  0 ! 0
x \Theta  s(y) ! (x \Theta  y) + x
x \Theta  (y + z) ! (x \Theta  y) + (x \Theta  z)

x = x ! ?
s(x) = s(y) ! x = y

s(x) = 0 ! ?
x + y = 0 ! x = 0 ^ y = 0
x \Theta  y = 0 ! x = 0 . y = 0

1.3 Travaux ant'erieurs

Les premiers travaux sur la combinaison *-calcul typ'e et r'ecriture (du premier
ordre) sont d^us `a V. Breazu-Tannen en 1988 [23] qui a montr'e que la combinaison
du *-calcul simplement typ'e avec de la r'ecriture du premier ordre est confluente
si la r'ecriture est confluente. En 1989, V. Breazu-Tannen et J. Gallier [24], et M.
Okada [97] ind'ependamment, ont montr'e que la normalisation forte 'egalement est
pr'eserv'ee. Ces r'esultats ont 'et'e 'etendus par D. Dougherty [44] `a tout ensemble
"stable" de *-termes non typ'es.

En 1991, J.-P. Jouannaud et M. Okada [72] ont 'etendu le r'esultat de V. BreazuTannen et J. Gallier `a la r'ecriture d'ordre sup'erieur sous la condition que les r`egles
d'ordre sup'erieur v'erifient le Sch'ema G'en'eral , une g'en'eralisation du sch'ema de
r'ecursion primitive. Avec de la r'ecriture d'ordre sup'erieur, la normalisation forte
devient plus difficile `a montrer car, dans ce cas, il y a interaction entre r'ecriture et
fi-r'eduction, ce qui n'est pas le cas avec de la r'ecriture du premier ordre.

En 1993, M. Fern'andez [51] a 'etendu la m'ethode de J.-P. Jouannaud et M.
Okada au Calcul des Constructions en se restreignant `a de la r'ecriture au niveau
objet et `a des symboles de fonction simplement typ'es. Les m'ethodes utilis'ees pour
la r'ecriture du premier ordre et les syst`emes de types non d'ependants [24, 44] ne
peuvent pas s'appliquer car, dans ce cas-l`a, la r'ecriture n'est pas seulement une
addition syntaxique : en 'etant rajout'e `a la fi-r'eduction dans la r`egle de conversion
(conv), la r'ecriture est une composante `a part enti`ere du typage ; en particulier, elle
permet de typer davantage de termes.

D'autres m'ethodes pour montrer la normalisation forte des syst`emes de r'ecriture
d'ordre sup'erieur ont 'egalement vu le jour. En 1996, J. van de Pol [115] a 'etendu

22 CHAPITRE 1. INTRODUCTION
`a l'ordre sup'erieur l'utilisation d'interpr'etations strictement d'ecroissantes sur un
domaine bien ordonn'e. Et, en 1999, J.-P. Jouannaud et A. Rubio [74] ont 'etendu
`a l'ordre sup'erieur la m'ethode RPO (Recursive Path Ordering) [100, 41]. Cette
m'ethode (HORPO) est plus puissante que le Sch'ema G'en'eral puisqu'elle consiste `a
d'efinir un ordre sur les termes de mani`ere r'ecursive.

Dans tous ces travaux, m^emes ceux concernant le Calcul des Constructions, les
symboles de fonction sont toujours simplement typ'es. C'est T. Coquand [31] en 1992
qui a initi'e l''etude de la r'ecriture avec des symboles d'ependants et polymorphes. Il a
'etudi'e la compl'etude des d'efinitions par r'ecriture en pr'esence de types d'ependants.

Pour la normalisation forte, il a propos'e un sch'ema plus g'en'eral que celui de J.-P.
Jouannaud et M. Okada, car permettant des d'efinitions par r'ecursion sur des types
inductifs strictement positifs [36]), sans que toutefois ce sch'ema implique la normalisation. En 1996, E. Gim'enez [60] a d'efini une restriction de ce sch'ema pour laquelle il
a montr'e la normalisation forte. En 1999, J.-P. Jouannaud, M. Okada et moi-m^eme
[22, 21] avons 'etendu le Sch'ema G'en'eral afin de traiter les types strictement positifs
mais en conservant des symboles simplement typ'es. Enfin, en 2000, D. Walukiewicz
[117] a 'etendu au Calcul des Constructions le HORPO de J.-P. Jouannaud et A.
Rubio avec des symboles d'ependants et polymorphes.

Mais il reste toujours un point commun entre tous ces travaux : la r'ecriture est
toujours restreinte au niveau objet.

En 1998, G. Dowek, T. Hardin et C. Kirchner [47] ont propos'e une nouvelle
approche de la d'eduction pour la logique du premier ordre : la D'eduction Naturelle
Modulo une congruence j sur les propositions. Ce syst`eme de d'eduction consiste `a
remplacer les r`egles de la D'eduction Naturelle par des r`egles 'equivalentes modulo
j. Par exemple, la r`egle ()-'elim) est remplac'ee par :

()-'elim-modulo)

\Gamma  ` R \Gamma  ` P

\Gamma  ` Q

si R j P ) Q

Ils ont montr'e que la th'eorie des types simples et la th'eorie des ensembles
skol'emis'ee peuvent ^etre vues comme des th'eories du premier ordre modulo une certaine congruence utilisant des substitutions explicites [1]. Et G. Dowek et B. Werner
[48] ont donn'e diff'erentes conditions assurant l''elimination des coupures dans un tel
syst`eme.

1.4 Contributions

Notre principale contribution est d''etablir un ensemble de conditions tr`es g'en'erales pour assurer la normalisation forte du Calcul des Constructions 'etendus avec de
la r'ecriture au niveau des types [19]. `A titre d'exemples, nous montrons que nos
conditions sont v'erifi'ees par un important sous-syst`eme du Calcul des Constructions
Inductives (CIC) et par la D'eduction Naturelle Modulo une large classe de th'eories
'equationnelles.

D'une certaine mani`ere, notre travail peut ^etre vu comme une extension de la
D'eduction Naturelle Modulo au Calcul des Constructions, o`u la congruence consid'e1.4. CONTRIBUTIONS 23
r'ee non seulement inclut de la r'ecriture du premier ordre mais 'egalement de la
r'ecriture d'ordre sup'erieur puisque, dans le Calcul des Constructions, fonctions et
pr'edicats peuvent ^etre appliqu'es `a des fonctions et `a des pr'edicats.

Notre travail peut donc servir de base `a une puissante extension des syst`emes
de sp'ecification et d'aide `a la d'emonstration actuels comme Coq [52] ou LEGO [81]
qui ne permettent que des d'efinitions par r'ecursion. En effet, la normalisation forte
non seulement assure la coh'erence logique du syst`eme (si les symboles consid'er'es
sont coh'erents) mais aussi la d'ecidabilit'e de la v'erification de type, c'est-`a-dire, du
probl`eme consistant `a savoir si un terme est une preuve d'une proposition ou non.

Pour r'ealiser une telle extension, plut^ot que de r'ecrire compl`etement le noyau de
ces syst`emes pour prendre en compte la r'ecriture, il peut ^etre int'eressant de faire
appel `a des applications sp'ecialis'ees comme CiME [30], ELAN [77] ou Maude [90].

Enfin, en terme d'extraction de programmes `a partir de preuves de correction
[98], on peut envisager d'extraire les programmes vers des langages `a base de r'ecriture
et ainsi de parvenir `a des programmes extraits plus efficaces.

Consid'erer une forme de r'ecriture au niveau des types n'est pas tout `a fait nouveau : c'est l'"'elimination forte" dans le Calcul des Constructions Inductives, c'est`a-dire la d'efinition de pr'edicats par r'ecurrence sur des types inductifs. La nouveaut'e
ici est de ne pas se restreindre `a des d'efinitions par r'ecurrence mais de consid'erer un
ensemble a priori quelconque de r`egles de r'ecriture fournit par l'utilisateur. Or, les
preuves de normalisation avec 'elimination forte de B. Werner [118] ou T. Altenkirch
[2] utilisent de mani`ere essentielle le fait qu'il s'agisse de d'efinitions par r'ecurrence.

Par ailleurs, aucune des m'ethodes utilis'ees dans le cas de r'ecriture du premier
ordre [24, 4, 44] ne peut s'appliquer. Cela tient `a plusieurs raisons. Premi`erement,
nous consid'erons des r'ecritures d'ordre sup'erieur et celles-ci, contrairement aux
r'ecritures du premier ordre, interagissent avec la fi-r'eduction. Deuxi`emement, la
r'ecriture est int'egr'ee `a la r`egle de conversion du syst`eme de types ce qui fait que
davantage de termes peuvent ^etre typ'es.

Pour 'etablir nos conditions et montrer la normalisation forte, nous avons adapt'e
la m'ethode des candidats de r'eductibilit'e de Tait et Girard [62] 'egalement utilis'ee
par F. Barbanera, M. Fern'andez et H. Geuvers [7, 6, 5] pour la r'ecriture au niveau
objet, et par B. Werner et T. Altenkirch pour l''elimination forte. Cependant, tous
utilisent comme candidats des ensembles de *-termes purs (non typ'es) et, mis `a part
T. Altenkirch, ils utilisent tous des langages ou des syst`emes de types interm'ediaires.
En nous appuyant sur un travail de T. Coquand et J. Gallier [33], nous utilisons des
candidats faits de termes bien typ'es et n'utilisons aucun langage interm'ediaire. Nous
obtenons ainsi une preuve plus simple et plus courte pour un r'esultat plus g'en'eral.

Signalons 'egalement trois autres contributions.
Pour permettre le filtrage sur des symboles d'efinis et la d'efinition de types quotients `a l'aide de r`egles de r'ecriture sur les constructeurs [70] (ce qui n'est pas
possible dans le Calcul des Constructions Inductives), nous consid'erons une notion
de "constructeur" plus g'en'erale que celle qui est g'en'eralement retenue pour les types
inductifs (voir le Sous-chapitre 6.2).

24 CHAPITRE 1. INTRODUCTION

Nous donnons des conditions pour assurer qu'une r`egle de r'ecriture pr'eserve le
typage dans un PTS quelconque (voir le Chapitre 5). Ces conditions sont bien plus
g'en'erales que celles employ'ees jusqu'`a maintenant. En particulier, elles permettent
d''eliminer de nombreuses non-lin'earit'es d^ues au typage, ce qui est un gain tr`es
important en terme d'efficacit'e d'une part et de facilit'e `a montrer la confluence
d'autre part.

Nous 'etablissons un corpus de propri'et'es (Chapitres 3 et 4) pour les Syst`emes
de Types Purs (PTS) o`u, dans la r`egle de conversion (conv), la fi-conversion est
remplac'ee par une relation a priori quelconque. Nous factorisons ainsi de nombreuses d'emontrations fa^ites avec des relations particuli`eres et 'etablissons quelques
propri'et'es nouvelles.

1.5 Plan de la th`ese

Chapitre 3 : Nous 'etudions les propri'et'es de base des Syst`emes de Types Purs
dont la relation de conversion au niveau des types est abstraite. Nous appelons de
tels syst`emes des Syst`emes de Types Modulo (TSM).

Chapitre 4 : Nous 'etudions les propri'et'es d'une classe particuli`ere de TSM,
ceux dont la relation de conversion est engendr'ee par une relation de r'eduction et
que nous appelons les Syst`emes de Types `a R'eduction (RTS). Un probl`eme essentiel
dans ces syst`emes est de s'assurer que la relation de r'eduction pr'eserve le typage.

Chapitre 5 : Nous donnons des conditions suffisantes pour assurer la pr'eservation du typage dans les RTS dont la relation de r'eduction est engendr'ee par des
r`egles de r'ecriture et que nous appelons les Syst`emes de Types Alg'ebriques (ATS).

Chapitre 6 : `A partir de ce chapitre, nous consid'erons un Syst`eme de Types
Alg'ebrique particulier, le Calcul des Constructions Alg'ebriques (CAC). Nous donnons des conditions suffisantes pour assurer la normalisation forte d'un tel calcul.

Chapitre 7 : Nous donnons quelques exemples importants de syst`emes de types
v'erifiant nos conditions de normalisation forte. Parmi ces syst`emes, on trouve un
sous-syst`eme avec 'elimination forte du Calcul des Constructions Inductives qui est
`a la base du syst`eme Coq [52] et la D'eduction Naturelle Modulo une large classe de
th'eories 'equationnelles.

Chapitre 8 : Nous 'etablissons la correction de nos conditions de normalisation
forte en prenant tout particuli`erement soin d'indiquer les conditions utilis'ees. Un
index permet de retrouver les endroits pr'ecis o`u sont utilis'ees chacune des conditions.

Chapitre 9 : Nous terminons par l''evocation de plusieurs directions de recherche
qui pourrqient permettre d'am'eliorer nos conditions de normalisation forte.

Chapitre 2
Pr'eliminaires

Dans ce chapitre, nous d'efinissons la syntaxe des syst`emes que nous 'etudierons
ensuite et rappelons quelques notions 'el'ementaires sur le *-calcul, les Syst`emes de
Types Purs (PTS) (voir [10] pour plus de d'etails) et les relations. Cette syntaxe 'etend
simplement celle des PTS en y ajoutant des symboles (nat, 0, +, *, . . .) devant ^etre
appliqu'es `a autant d'arguments que leur arit'e le sp'ecifie (voir la Remarque 10 pour
une discussion `a propos de cette notion).

D'efinition 1 (*-syst`eme sort'e) Un *-syst`eme sort'e est donn'e par :

- un ensemble de sortes S,
- une famille F = (F sn)s2Sn*0 d'ensembles de symboles ,
- une famille X = (X s)s2S d'ensembles infinis d'enombrables de variables ,
tels que ces ensembles soient tous disjoints les uns des autres. Un symbole f 2 F sn
est dit d'arit'e fff = n et de sorte s. Par la suite, on notera l'ensemble des symboles
de sorte s par F s et l'ensemble des symboles d'arit'e n par Fn.

D'efinition 2 (Termes) L'ensemble T des termes d'un *-syst`eme sort'e est le plus
petit ensemble tel que :

- les sortes et les variables sont des termes ;
- si x est une variable et t; u sont des termes alors le produit d'ependant (x : t)u et

l'abstraction [x : t]u sont des termes ;

- si t et u sont des termes alors l'application tu est un terme ;
- si f est un symbole d'arit'e n et t1; : : : ; tn sont des termes alors f (t1; : : : ; tn) est un

terme (certains symboles comme +, \Theta , . . .pourront ^etre not'es de mani`ere infixe).

Variables libres et variables li'ees

Une variable x qui se trouve dans le champs d'une abstraction [x : T ] ou d'un
produit (x : T ) est dite li'ee . Comme il est de coutume, elle peut-^etre remplac'ee par
toute autre variable, mais `a condition que celle-ci soit de m^eme sorte. C'est ce qu'on
appelle l'ff-'equivalence . Une variable qui n'est pas li'ee est dite libre . Nous d'esignons
par FV(t) l'ensemble des variables libres d'un terme t et par FVs(t) l'ensemble des
variables libres de sorte s. Un terme ne contenant aucune variable libre est dit clos .

25

26 CHAPITRE 2. PR 'ELIMINAIRES
Nous utiliserons parfois la notation U ! V pour d'esigner un produit (x : U )V o`u
x =2 FV(V ) (produit non-d'ependant).

Vecteurs

Par la suite, nous utiliserons souvent des vecteurs (~t; ~u; : : : ) pour d'esigner des
s'equences de termes (ou d'autres choses). La taille d'un vecteur ~t est not'ee j~tj. Par
exemple, [~x : ~T ]u d'esigne le terme [x1 : T1] : : : [xn : Tn]u o`u n = j~xj.

D'efinition 3 (Positions dans un terme) Pour d'esigner les sous-termes d'un terme, on utilise un syst`eme de positions . Formellement, l'ensemble Pos(t) des positions
d'un terme t est le plus petit ensemble de mots sur l'alphabet des entiers positifs tel
que :

- Pos(s) = Pos(x) = f"g,
- Pos((x : t)u) = Pos([x : t]u) = Pos(tu) = 1 \Delta  Pos(t) [ 2 \Delta  Pos(u),
- Pos(f (~t)) = f"g [

S

fi \Delta  Pos(ti) j 1 ^ i ^ fff g,

o`u " d'esigne le mot vide et \Delta  la concat'enation. Alors, on d'esigne par tjp le sous-terme
de t `a la position p et par t[u]p le terme obtenu en rempla,cant tjp par u dans t. La
relation "est sous-terme de" est not'ee \Delta .

'Etant donn'es un terme t et un symbole f , on notera par Pos(f; t) l'ensemble des

positions p o`u tjp est de la forme f (~t). De m^eme, si x est une variable, on notera par
Pos(x; t) l'ensemble des positions p telles que tjp est une occurrence libre de x.

D'efinition 4 (Substitution) Une substitution ` est une application de X dans T
de domaine dom(`) = fx 2 X j x` 6= xg fini. Appliquer une substitution ` `a un
terme t consiste `a remplacer les variables libres de t par leur image (en prenant soin
que les variables li'ees soient distinctes des variables libres). Le r'esultat est not'e t`.
On d'esigne par doms(`) les variables du domaine qui sont de sorte s, par f~x 7! ~tg
la substitution qui `a xi associe ti, et par ` [ fx 7! tg la substitution qui `a x associe
t et `a y 6= x associe y`.

Relations

Nous rappelons maintenant quelques d'efinitions 'el'ementaires `a propos des relations. 'Etant donn'e une relation binaire ! sur les termes :

-  est l'inverse de !,
- !+ est la plus petite relation transitive contenant !,
- !\Lambda  est la plus petite relation r'eflexive et transitive contenant !,
- $\Lambda  est la plus petite relation r'eflexive, transitive et sym'etrique contenant !,
- # est la relation binaire !\Lambda  \Lambda  (t # u s'il existe v tel que t !\Lambda  v et u !\Lambda  v).

Si t ! t0, on dit que t se r'ecrit en t0. Si t !\Lambda  t0, on dit que t se r'eduit en t0.
La relation ! est stable par contexte si u ! u0 implique t[u]p ! t[u0]p pour tout
terme t et position p 2 Pos(t).

La relation ! est stable par substitution si t ! t0 implique t` ! t0` pour toute
substitution `.

27
La fi-r'eduction (resp. j-r'eduction ) est la plus petite relation stable par contexte
et substitution contenant [x : U ]t u !fi tfx 7! ug (resp. [x : U ]tx !j t si x =2 FV(t)).
Un terme de la forme [x : U ]t u (resp. [x : U ]tx avec x =2 FV(t)) est un fi-radical
(resp. j-radical ).

Normalisation

La relation ! est faiblement normalisante si, pour tout terme t, il existe un
terme irr'eductible t0 en lequel t peut se r'eduire. On dit alors que t0 est une forme
normale de t. La relation ! est fortement normalisante (bien fond'ee, noeth'erienne)
si, quelque soit t, toutes les r'eductions issues de t sont finies.

Confluence

La relation ! est localement confluente si, d`es qu'un terme t se r'ecrit en deux
termes distincts u et v, alors u # v. Enfin, ! est confluente si, d`es qu'un terme t se
r'eduit en deux termes distincts u et v, alors u # v.

Il est assez facile de voir que si ! est localement confluente et fortement normalisante alors ! est confluente [94], et que si ! est confluente et faiblement normalisante alors chaque terme t admet une forme normale unique not'ee t #. (Le symbol
# d'esigne ici une relation unaire postfix'ee, ce qui permet de le diff'erencier de son
autre utilisation.)

Ordres lexicographiques et multi-ensembles

'Etant donn'e des ordres ?1; : : : ; ?n sur des ensembles E1; : : : ; En, nous d'esignons

par (?1; : : : ; ?n)lex l'ordre lexicographique construit sur E1 \Theta  : : : \Theta  En `a partir de
?1; : : : ; ?n. Rappelons que, pour n = 2, nous avons (x; y)(?1; ?2)lex(x0; y0) si x ?1 x0
ou, x =1 x0 et y ?2 y0.

Soit E un ensemble. Un multi-ensemble M sur E est une application de E dans
N, M (x) d'esignant le nombre de fois o`u x "appara^it" dans M . Nous noterons par
M(E) l'ensemble des multi-ensembles finis sur E (i.e. `a domaine fini).

Soit ? un ordre sur E. L'extension multi-ensemble de ? est l'ordre ?mul sur
M(E) 'egal `a la fermeture transitive de la relation O/ d'efinie par : M [ fxg O/ N [
fy1; : : : ; yng (n * 0) si, pour tout i, x ? yi (x est remplac'e par un nombre fini,
'eventuellement nul, d''el'ements plus petits).

Une propri'et'e importante de ces extensions est qu'elles pr'eservent la bonne fondation. Pour plus de d'etails sur ces notions, le lecteur est invit'e `a consulter [43, 3].

28 CHAPITRE 2. PR 'ELIMINAIRES

Chapitre 3
Syst`emes de Types Modulo
(TSM)

Dans ce chapitre, nous consid'erons une extension des PTS avec des symboles de
fonctions et une r`egle de conversion (conv) o`u $\Lambda fi est remplac'ee par une relation de
conversion C a priori quelconque.

Il y a d'ej`a eu diff'erentes extensions des PTS, en particulier :
- En 1989, Z. Luo [80] a 'etudi'e une extension du Calcul des Constructions avec

une hi'erarchie cumulative de sortes (? OE 2 = 20 OE 21 OE : : : ), le Calcul des
Constructions 'Etendu (ECC) : C est le plus petit pr'e-ordre contenant $\Lambda fi, OE et
compatible avec le produit (U 0 C U et V C V 0 implique (x : U )V C (x : U 0)V 0).

- En 1993, H. Geuvers [56] a 'etudi'e les PTS avec j-r'eduction : C = $\Lambda fij.
- En 1993, M. Fern'andez [51] a 'etudi'e une extension du Calcul des Constructions

avec r'ecriture d'ordre sup'erieur `a la Jouannaud-Okada [72], le *R-cube : C = !\Lambda fiR
[ \Lambda fiR.

- En 1994, E. Poll et P. Severi [101] ont 'etudi'e les PTS avec abr'eviations (let x=

... in ...) : C = $\Lambda fi [ $\Lambda ffi o`u !ffi est le remplacement d'une abr'eviation par sa
d'efinition, celle-ci pouvant ^etre donn'ee dans un environnement quelconque.

- En 1994, B. Werner [118] a 'etudi'e une extension du Calcul des Constructions avec

types inductifs, le Calcul des Constructions Inductives (CIC) : C = $\Lambda fij' o`u !'
est la r'eduction associ'ee aux sch'emas d''elimination des types inductifs.

- Entre 1995 et 1998, G. Barthe et ses coauteurs [14, 15, 16, 12] consid`erent diff'erentes extensions du Calcul des Constructions ou des PTS avec des relations de
conversion plus ou moins abstraites souvent bas'ees sur la r'ecriture `a la JouannaudOkada [72], 'etendant ainsi les travaux de M. Fern'andez [51].

Dans ces travaux, des propri'et'es de base bien connues des PTS sont red'emontr'ees
du fait de l'introduction de nouvelles constructions ou d'une nouvelle relation de
conversion C. C'est pourquoi il nous a paru utile d''etudier les propri'et'es des PTS
dot'es d'une relation de conversion C abstraite.

29

30 CHAPITRE 3. SYST `EMES DE TYPES MODULO

Le besoin n'est pas nouveau puisque cela a d'ej`a 'et'e partiellement entreprit dans
des d'eveloppements formels :

- En 1994, R. Pollack [102] prouve formellement dans LEGO [81], une impl'ementation de ECC avec types inductifs, que la v'erification de type dans ECC (sans
type inductif) est d'ecidable (en supposant bien s^ur que le calcul est fortement
normalisant). La v'erification de type consiste `a dire si, dans un environnement \Gamma 
donn'e, un terme t est de type T (i.e. une preuve de T ). Ce faisant, il montre de
nombreuses propri'et'es des PTS en consid'erant une relation de conversion C = ^
r'eflexive, transitive et stable par substitution et contexte.

- En 1999, B. Barras [11] prouve formellement dans Coq [52], une autre impl'ementation de ECC avec types inductifs, que la v'erification de type dans Coq (avec
types inductifs cette fois-ci) est d'ecidable (l`a encore en supposant que le calcul est
fortement normalisant). Pour cela, il montre 'egalement de nombreuses propri'et'es
des PTS en consid'erant une relation de conversion C = ^ r'eflexive, transitive et
stable par substitution et contexte. En fait, il consid`ere une extension des PTS avec
un sch'ema de r`egles de typage pour pouvoir introduire de nouvelles constructions
de mani`ere g'en'erique (abr'eviations, types inductifs, sch'emas d''elimination).

Ainsi, d'un c^ot'e, nous faisons moins d'hypoth`eses sur la relation de conversion C
que n'en font R. Pollack ou B. Barras. Cela est justifi'e par le fait que, dans le travail
de M. Fern'andez [51] par exemple, pour pouvoir 'etablir que la r'eduction pr'eserve le
typage, il est indispensable que la relation de conversion ne soit pas transitive. D'un
autre c^ot'e, le typage de nos symboles de fonction n'est pas aussi g'en'eral que celui
de B. Barras.

3.1 D'efinition
D'efinition 5 (Environnement) Un environnement \Gamma  est une liste de couples
xi : Ti constitu'es d'une variable xi et d'un terme Ti. On notera par ; l'environnement vide, par E l'ensemble des environnements et par xi\Gamma  le terme Ti associ'e
`a la variable xi dans \Gamma . L'ensemble des variables libres d'un environnement \Gamma  est
FV(\Gamma ) =

S

fFV(x\Gamma ) j x 2 dom(\Gamma )g. Le domaine d'un environnement \Gamma  est l'ensemble des variables auxquelles \Gamma  associe un terme. 'Etant donn'es deux environnements \Gamma  et \Gamma 0, \Gamma  est inclus dans \Gamma 0, not'e \Gamma  ` \Gamma 0, si tous les 'el'ements de \Gamma  apparaissent
dans \Gamma 0 dans le m^eme ordre.

D'efinition 6 (Assignement de type) Un assignement de type est une application o/ de F dans T qui, `a un symbole f d'arit'e n, associe un terme clos o/f de la

forme (~x : ~T )U o`u j~xj = n. Nous noterons par \Gamma f l'environnement ~x : ~T .

D'efinition 7 (TSM) Un Syst`eme de Types Modulo (TSM) est un *-syst`eme sort'e
(S; F ; X ) avec :

- un ensemble d'axiomes A ` S2,
- un ensembles de r`egles de formation du produit B ` S3,

3.1. D 'EFINITION 31

- un assignement de type o/ ,
- une relation de conversion C ` T 2.
Un fiTSM (resp. jTSM) est un TSM tel que #fi` C (resp. #j` C).

D'efinition 8 (Typage) La relation de typage d'un TSM est la plus petite relation
ternaire ` ` E \Theta  T \Theta  T d'efinie par les r`egles d'inf'erence de la Figure 3.1. Par rapport
aux PTS, nous avons une nouvelle r`egle, (symb), pour typer les symboles et, dans
la r`egle de conversion (conv), nous consid'erons la relation abstraite C au lieu de la
fi-conversion. Un terme t est typable s'il existe un environnement \Gamma  et un terme T
tels que \Gamma  ` t : T (T est le type de t dans \Gamma ). Un environnement \Gamma  est valide s'il
existe un terme typable dans \Gamma . Dans la r`egle (symb), la pr'emice "\Gamma  valide" n'est
donc utile que si f est d'arit'e nulle (n = 0).

- T = ft 2 T j 9\Gamma  2 E; 9T 2 T ; \Gamma  ` t : T g est l'ensemble des termes typables,
- Ts0 = fT 2 T j 9\Gamma  2 E; \Gamma  ` T : sg est l'ensemble des pr'edicats de sorte s,
- Ts1 = ft 2 T j 9\Gamma  2 E; 9T 2 T ; \Gamma  ` t : T et \Gamma  ` T : sg est l'ensemble des objets

de sorte s,

- E = f\Gamma  2 E j 9t; T 2 T ; \Gamma  ` t : T g est l'ensemble des environnements valides.

Remarque 9 (Conversion)

Il pourrait para^itre plus naturel de d'efinir (conv) de mani`ere sym'etrique en
rajoutant dans les pr'emices, \Gamma  ` T : s ou \Gamma  ` T : s0. Nous avons choisi de consid'erer
cette r`egle-l`a pour deux raisons. Premi`erement, c'est ainsi qu'elle est d'efinie dans les
textes de r'ef'erence sur les PTS [57, 10]. Deuxi`emement, d'un point de vue pratique,
cela 'evite un test suppl'ementaire. Toutefois, nous verrons dans le Lemme 37 que,
pour beaucoup de TSM, nous avons \Gamma  ` T : s0. Nous d'esignerons par `s la relation
de typage d'efinie par les m^emes r`egles d'inf'erence que ` except'e (conv) que nous
rempla,cons par :

(conv')

\Gamma  ` t : T \Gamma  ` T : s \Gamma  ` T 0 : s

\Gamma  ` t : T 0

(T C T 0)

Nous montrons l''equivalence entre `s et ` dans le Lemme 43.

Dans le m^eme ordre d'id'ee, dans les TSM dits complets (8s1; s2 2 S; 9s3 2
S; (s1; s2; s3) 2 B), la r`egle (abs) peut ^etre remplac'ee par :

(abs')

\Gamma ; x : T ` u : U

\Gamma  ` [x : T ]u : (x : T )U

(U =2 S ou 9s 2 S; (U; s) 2 A)

Enfin, nous d'esignerons par `w la relation de typage d'efinie par les m^emes r`egles
d'inf'erence que ` except'e (weak) que nous rempla,cons par :

(weak')

\Gamma  ` t : T \Gamma  ` U : s

\Gamma ; x : U ` t : T

(x 2 X s n dom(\Gamma ); t 2 X [ S)

c'est-`a-dire, o`u l'affaiblissement est restreint aux variables et aux sortes (t 2 X [ S).
Nous montrerons l''equivalence entre `w et ` dans le Lemme 19.

32 CHAPITRE 3. SYST `EMES DE TYPES MODULO

Fig. 3.1 - R`egles de typage des TSM
(ax)

` s1 : s2

((s1; s2) 2 A)

(symb)

` o/f : s \Gamma  valide
\Gamma  ` t1 : T1fl : : : \Gamma  ` tn : Tnfl

\Gamma  ` f (~t) : U fl

(f 2 F sn;
o/f = (~x : ~T )U;

fl = f~x 7! ~tg)

(var)

\Gamma  ` T : s

\Gamma ; x : T ` x : T

(x 2 X s n dom(\Gamma ))

(weak)

\Gamma  ` t : T \Gamma  ` U : s

\Gamma ; x : U ` t : T

(x 2 X s n dom(\Gamma ))

(prod)

\Gamma  ` T : s1 \Gamma ; x : T ` U : s2

\Gamma  ` (x : T )U : s3

((s1; s2; s3) 2 B)

(abs)

\Gamma ; x : T ` u : U \Gamma  ` (x : T )U : s

\Gamma  ` [x : T ]u : (x : T )U

(app)

\Gamma  ` t : (x : U )V \Gamma  ` u : U

\Gamma  ` tu : V fx 7! ug

(conv)

\Gamma  ` t : T \Gamma  ` T 0 : s0

\Gamma  ` t : T 0

(T C T 0)

Remarque 10 (Arit'e)

Enfin, on peut se demander pourquoi les symboles sont dot'es d'une arit'e fixe alors
qu'en g'en'eral, dans le *-calcul, il est d'usage de consid'erer des constantes d'ordre
sup'erieur. Bien s^ur, cela ne constitue pas une restriction puisqu'`a un symbole f
d'arit'e n et de type (~x : ~T )U , on peut toujours associer un "double" curryfi'e f c
de m^eme type mais d'arit'e nulle d'efini par la r`egle f c ! [~x : ~T ]f (~x). De plus, en
pratique, on peut toujours dissimuler `a l'utilisateur l'existence de cette arit'e en jexpansant si f n'est pas suffisamment appliqu'e, et en compl'etant par des applications
si f est trop appliqu'e. Cependant, on aurait une pr'esentation plus simple o`u la r`egle
(symb) serait r'eduite `a :

(symb')

` o/f : s

` f : o/f

(f 2 F s)

`A notre connaissance, mis `a part les travaux de Jouannaud et Okada [73] et
de G. Barthe et ses coauteurs [14, 15, 16, 12], la plupart des autres travaux sur

3.2. PROPRI 'ET 'ES 33
la combinaison *-calcul typ'e et r'ecriture [23, 24, 51] ne font pas usage d'une arit'e
pour le typage des symboles. Nous avons choisi d'utiliser une telle notion pour des
raisons purement techniques. Avec la m'ethode que nous employons pour montrer la
normalisation forte, nous avons besoin qu'une application uv ne soit pas un radical
de r'ecriture (voir le Chapitre 5 pour l'explication de ces notions et le Lemme 121,
cas T = (x : U )V , (b), (R3) pour l'utilisation de cette propri'et'e). L'introduction
d'une arit'e nous permet de distinguer syntaxiquement entre l'application du *-calcul
et l'application d'un symbole. On peut se demander si cette notion est vraiment
indispensable.

D'efinition 11 (Substitution bien typ'ee) 'Etant donn'es deux environnements
valides \Gamma  et \Delta , une substitution ` est bien typ'ee entre \Gamma  et \Delta  , ` : \Gamma  ! \Delta , si, pour
tout x 2 dom(\Gamma ), \Delta  ` x` : x\Gamma `.

Par exemple, dans la r`egle (symb), nous avons fl : \Gamma f ! \Gamma  o`u, rappelons-le,
\Gamma f = ~x : ~T .

3.2 Propri'et'es

Dans ce sous-chapitre et le suivant, on passe en revue un certain nombre de
propri'et'es bien connues des PTS (sauf le Lemme 22) qui sont vraies pour tous
les TSM. Mis `a part le nouveau cas (symb) que nous d'etaillerons `a chaque fois,
les preuves sont identiques aux preuves habituelles dans le cas des PTS. Le fait que
dans (conv), $\Lambda fi soit remplac'e par une relation quelconque C n'a aucune importance.
Pour plus de d'etails, nous renvoyons le lecteur `a [57, 10, 56].

Lemme 12 (Variables libres) Soit un environnement \Gamma  = ~x : ~T . Si \Gamma  ` t : T
alors :

(a) les xi sont des variables deux `a deux distinctes,
(b) pour tout i, FV(Ti) ` fx1; : : : ; xi\Gamma 1g,
(c) FV(t) [ FV(T ) ` dom(\Gamma ).

Preuve. Par r'ecurrence sur \Gamma  ` t : T . Nous ne d'etaillons que le nouveau cas
(symb). (a) et (b) sont satisfaits par hypoth`ese de r'ecurrence. Voyons (c) maintenant.
Par hypoth`ese de r'ecurrence, FV(o/f ) = ; et, pour tout i, FV(ti) ` dom(\Gamma ). Donc
FV(f (~t)) ` dom(\Gamma ). De m^eme, FV(U fl) ` dom(\Gamma ) car FV(U ) ` f~xg et fl = f~x 7! ~tg.

\Xi 

Lemme 13 (Sous-termes) Si un terme est typable alors tous ses sous-termes sont
typables.

Preuve. Par r'ecurrence sur \Gamma  ` t : T . Dans le cas (symb), par hypoth`ese de
r'ecurrence, pour tout i, tous les sous-termes de ti sont typables. Donc, tous les
sous-termes de f (~t) sont typables. \Xi 

Lemme 14 (Environnement) Soit \Gamma  = ~x : ~T un environnement valide.

34 CHAPITRE 3. SYST `EMES DE TYPES MODULO

(a) Si xi est de sorte s alors x1 : T1; : : : ; xi\Gamma 1 : Ti\Gamma 1 ` Ti : s.
(b) Pour tout i, x1 : T1; : : : ; xi : Ti ` xi : Ti.

Preuve. Par (var), (b) est une cons'equence imm'ediate de (a). On montre (a)
par r'ecurrence sur \Gamma  ` t : T . Dans le cas (symb), comme \Gamma  est valide, il existe v et
V tel que \Gamma  ` v : V . Donc, par hypoth`ese de r'ecurrence, (a) est v'erifi'e. \Xi 

Le lemme suivant correspond `a une forme d'ff-'equivalence sur les variables d'un
environnement.

Lemme 15 (Remplacement) Si \Gamma ; y : W; \Gamma 0 ` t : T , y 2 X s et z 2 X s n dom(\Gamma ; y :
W; \Gamma 0) alors \Gamma ; z : W; \Gamma 0fy 7! zg ` tfy 7! zg : T fy 7! zg.

Preuve. Par r'ecurrence sur \Gamma ; y : W; \Gamma 0 ` t : T . Soit ` = fy 7! zg, \Delta  = \Gamma ; y : W; \Gamma 0
et \Delta 0 = \Gamma ; z : W; \Gamma 0`. Dans le cas (symb), par hypoth`ese de r'ecurrence, nous avons
\Delta 0 valide et, pour tout i, \Delta 0 ` ti` : Tifl`. Donc, par (symb), \Delta 0 ` f (~t`) : U fl`. \Xi 

Lemme 16 (Affaiblissement) Si \Gamma  ` t : T et \Gamma  ` \Gamma 0 2 E alors \Gamma 0 ` t : T .

Preuve. Par r'ecurrence sur \Gamma  ` t : T . Dans le cas (symb), par hypoth`ese de
r'ecurrence, nous avons \Gamma 0 valide et, pour tout i, \Gamma 0 ` ti : Tifl. Donc, par (symb),
\Gamma 0 ` f (~t) : U fl. \Xi 

Lemme 17 (Transitivit'e) Soient \Gamma  et \Delta  deux environnements valides. Si \Gamma  ` t : T
et, pour tout x 2 dom(\Gamma ), \Delta  ` x : x\Gamma , ce qu'on notera par \Delta  ` \Gamma , alors \Delta  ` t : T .

Preuve. Par r'ecurrence sur \Gamma  ` t : T . Dans le cas (symb), par hypoth`ese de
r'ecurrence, nous avons \Delta  valide et, pour tout i, \Delta  ` ti : Tifl. Donc, par (symb),
\Delta  ` f (~t) : U fl. \Xi 

Lemme 18 (Permutation faible) Si \Gamma ; y : A; z : B; \Gamma 0 ` t : T et \Gamma  ` B : s alors
\Gamma ; z : B; y : A; \Gamma 0 ` t : T .

Preuve. Soit \Delta  = \Gamma ; y : A; z : B; \Gamma 0 et \Delta 0 = \Gamma ; z : B; y : A; \Gamma 0. D'apr`es le lemme de
transitivit'e, il suffit de montrer que \Delta 0 est valide et que \Delta 0 ` \Delta . Et pour cela, il suffit
de montrer que \Delta 0 est valide. Par le lemme d'environnement, nous avons \Gamma  ` A : s0
et, par hypoth`ese, nous avons \Gamma  ` B : s. Donc, par affaiblissement, \Gamma ; z : B; y : A est
valide. Supposons que \Gamma 0 = ~x : ~T et posons \Delta i = \Gamma ; y : A; z : B; x1 : T1; : : : ; xi : Ti
et \Delta 0i = \Gamma ; z : B; y : A; x1 : T1; : : : ; xi : Ti. Montrons par r'ecurrence sur i que \Delta 0i est
valide. Nous avons montr'e que \Delta 00 est valide. Supposons que \Delta 0i soit valide. Par le
lemme d'environnement, \Delta i ` Ti+1 : si+1. Comme \Delta 0i ` \Delta i, \Delta 0i ` Ti+1 : si+1 et \Delta 0i+1
est valide. Donc, \Delta 0 est valide et \Delta 0 ` t : T . \Xi 

Lemme 19 ('Equivalence de `w et `) `w = `.

Preuve. Tout d'abord, il est clair que `w ` `. Il suffit donc de montrer la
r'eciproque, par r'ecurrence sur \Gamma  ` t : T . Le seul cas un peu ennuyeux est bien s^ur
celui de (weak). De \Gamma  ` t : T et \Gamma  ` U : s, nous d'eduisons \Gamma ; x : U ` t : T . Par
hypoth`ese de r'ecurrence, nous avons \Gamma  `wt : T et \Gamma  `wU : s. Il faut alors modifier

3.2. PROPRI 'ET 'ES 35
la preuve de \Gamma  `wt : T en rajoutant x : U aux endroits appropri'es de fa,con `a obtenir
une preuve de \Gamma ; x : U `wt : T . Voir Lemme 4.4.21 page 102 dans [56]. \Xi 

Maintenant, voyons ce que l'on peut dire des d'erivations de \Gamma  ` t : T et de la
forme de T en fonction de t. Pour cela, nous allons introduire des relations li'ees `a la
r`egle (conv).

D'efinition 20 (Relations de conversion)

- T C\Gamma  T 0 ssi T C T 0 et il existe s0 tel que \Gamma  ` T 0 : s0,
- T C \Gamma  T 0 ssi T C T 0 et il existe s et s0 tels que \Gamma  ` T : s et \Gamma  ` T 0 : s0,
- \Gamma  C \Gamma 0 ssi \Gamma  = ~x : ~T , \Gamma 0 = ~x : ~T 0 et, soit j~xj = 0, soit il existe j tel que

Tj C x1 :T1;::: ;xj\Gamma 1:Tj\Gamma 1 T 0j et, pour tout i 6= j, Ti = T 0i .

Nous avons C \Gamma  ` C\Gamma  mais, contrairement `a C \Gamma  , C\Gamma  n'est pas d'efini de mani`ere
sym'etrique. Cela est d^u `a l'asym'etrie de la r`egle (conv) qui demande \Gamma  ` T 0 : s0
mais pas \Gamma  ` T : s. Toutefois, nous verrons dans le Lemme 37 que, pour beaucoup
de TSM, ces deux relations sont 'egales.

Lemme 21 (Inversion) Supposons que \Gamma  ` t : T .

- Si t = s alors il existe s0 tel que (s; s0) 2 A et s0 C\Lambda \Gamma  T .
- Si t = f (~t), f 2 F s, o/f = (~x : ~T )U et fl = f~x 7! ~tg alors ` o/f : s, fl : (~x : ~T ) ! \Gamma 

et U fl C\Lambda \Gamma  T .

- Si t = x 2 X s alors \Gamma  ` x\Gamma  : s et x\Gamma  C \Lambda \Gamma  T .
- Si t = (x : U )V alors il existe (s1; s2; s3) 2 B tel que \Gamma  ` U : s1, \Gamma ; x : U ` V : s2 et

s3 C\Lambda \Gamma  T .

- Si t = [x : U ]v alors il existe V tel que \Gamma ; x : U ` v : V et (x : U )V C \Lambda \Gamma  T .
- Si t = uv alors il existe V et W tels que \Gamma  ` u : (x : V )W , \Gamma  ` v : V et

W fx 7! vg C\Lambda \Gamma  T .

Preuve. Une d'erivation de typage se termine toujours par une r`egle distincte
de (weak) et (conv) suivie d'une s'equence 'eventuellement nulle d'applications de
(weak) ou (conv). On obtient ainsi le terme `a quoi T doit ^etre convertible. Pour les
jugements de typage, il suffit de faire un affaiblissement pour les exprimer dans \Gamma .\Xi 

Lemme 22 (Conversion pour les environnements) Si \Gamma  ` t : T et \Gamma  C \Gamma 0 alors
\Gamma 0 ` t : T .

Preuve. Nous avons \Gamma  = ~x : ~T , \Gamma 0 = ~x : ~T 0, j tel que Tj C x1 :T1;::: ;xj\Gamma 1:Tj\Gamma 1 T 0j
et, pour tout i 6= j, Ti = T 0i . Par transitivit'e, il suffit de prouver que, pour tout i,
\Gamma 0 ` xi : Ti. Soit n = j~xj, \Gamma 1 = x1 : T1; : : : ; xj\Gamma 1 : Tj\Gamma 1 et \Gamma 2 = xj+1 : Tj+1; : : : ; xn : Tn.
Nous proc'edons par r'ecurrence sur la taille de \Gamma 2.

Si \Gamma 2 est vide, \Gamma  = \Gamma 1; xj : Tj et \Gamma 0 = \Gamma 1; xj : T 0j. Puisque \Gamma  est valide, \Gamma 1 est
valide et, pour tout i ! j, \Gamma 1 ` xi : Ti. Puisque Tj C \Gamma 1 T 0j, il existe s et s0 tels que
\Gamma 1 ` Tj : s et \Gamma 1 ` T 0j : s0. Par (weak), on obtient, pour tout i ! j, \Gamma 0 ` xi : Ti,
et par (var), on obtient \Gamma 0 ` xj : T 0j. De \Gamma 1 ` Tj : s, on obtient aussi, par (weak),
\Gamma 0 ` Tj : s. Donc, par (conv), \Gamma 0 ` xj : Tj.

36 CHAPITRE 3. SYST `EMES DE TYPES MODULO

Supposons maintenant que \Gamma 2 = \Gamma 3; xn : Tn. Posons \Delta  = \Gamma 1; xj : Tj; \Gamma 3 et \Delta 0 =
\Gamma 1; xj : T 0j; \Gamma 3. Par hypoth`ese de r'ecurrence, pour tout i ! n, \Delta 0 ` xi : Ti. Puisque
\Gamma  est valide, il existe s tel que \Delta  ` Tn : s. Par transitivit'e, on obtient \Delta 0 ` Tn : s.
Donc, par (var), on obtient \Gamma 0 ` xn : Tn, et par (weak), \Gamma 0 ` xi : Ti. \Xi 

3.3 TSM stables par substitution
D'efinition 23 (TSM stable par substitution) Un TSM est stable par substitution si sa relation de conversion C est stable par substitution.

Lemme 24 (Substitution) Si C est stable par substitution, \Gamma  ` t : T et ` : \Gamma  ! \Delta 
alors \Delta  ` t` : T `.

Preuve. Par r'ecurrence sur \Gamma  ` t : T . Dans le cas (symb), par hypoth`ese de
r'ecurrence, nous avons \Delta  ` ti` : Tifl`. Donc, par (symb), \Delta  ` f (~t`) : U fl`. \Xi 

Corollaire 25 Si C est stable par substitution, \Gamma ; x : U; \Gamma 0 ` t : T et \Gamma  ` u : U alors
\Gamma ; \Gamma 0fx 7! ug ` tfx 7! ug : T fx 7! ug.

Preuve. Cela revient `a montrer que ` = fx 7! ug est une substitution bien
typ'ee de \Gamma ; x : U; \Gamma 0 `a \Gamma ; \Gamma 0`. Proc'edons par r'ecurrence sur la taille de \Gamma 0. Si \Gamma 0
est vide, c'est imm'ediat car \Gamma  est valide et \Gamma  ` u : U . Supposons maintenant que
\Gamma 0 = \Gamma 00; y : V . Posons \Delta  = \Gamma ; x : U; \Gamma 00 et \Delta 0 = \Gamma ; \Gamma 00`. Par hypoth`ese de r'ecurrence,
` : \Delta  ! \Delta 0. Puisque \Delta  ` V : s, par substitution, on obtient \Delta 0 ` V ` : s. Donc, par
(var), \Delta 0; y : V ` ` y : V `. Maintenant, soit z 2 dom(\Delta ). Comme \Delta  ` z : z\Delta , par
substitution, \Delta 0 ` z : z\Delta `. Alors, par (weak), \Delta 0; y : V ` ` z : z\Delta `. \Xi 

Corollaire 26 Si C est stable par substitution, `1 : \Gamma 0 ! \Gamma 1 et `2 : \Gamma 1 ! \Gamma 2 alors
`1`2 : \Gamma 0 ! \Gamma 2.

Preuve. Soit x 2 dom(\Gamma 0). Puisque `1 : \Gamma 0 ! \Gamma 1, par substitution, on obtient
\Gamma 1x ` x`1 : x\Gamma 0`1, et puisque `2 : \Gamma 1 ! \Gamma 2, par substitution encore, on obtient
\Gamma 2 ` x`1`2 : x\Gamma 0`1`2. \Xi 

D'efinition 27 (Sorte maximale) Une sorte s est maximale si aucune sorte s0
v'erifie (s; s0) 2 A.

Lemme 28 (Correction des types) Si C est stable par substitution et \Gamma  ` t : T
alors, soit T est une sorte maximale, soit il existe une sorte s telle que \Gamma  ` T : s.
Autrement dit, T =

S

fTs0 [ Ts1 j s 2 Sg.

Preuve. Par r'ecurrence sur \Gamma  ` t : T . Dans le cas (symb), nous avons ` o/f : s.
Par inversion, il existe s0 tel que \Gamma f ` U : s0. Comme fl : \Gamma f ! \Gamma , par substitution,
\Gamma  ` U fl : s0. \Xi 

Lemme 29 (Inversion pour les TSM stables par substitution) Supposons
que \Gamma  ` t : T .

3.4. TSM LOGIQUES 37

- Si t = s alors il existe s0 tel que (s; s0) 2 A et s0 C\Lambda \Gamma  T .
- Si t = f (~t), f 2 F s, o/f = (~x : ~T )U et fl = f~x 7! ~tg alors ` o/f : s, fl : (~x : ~T ) ! \Gamma 

et U fl C \Lambda \Gamma  T .

- Si t = x 2 X s alors \Gamma  ` x\Gamma  : s et x\Gamma  C \Lambda \Gamma  T .
- Si t = (x : U )V alors il existe (s1; s2; s3) 2 B tel que \Gamma  ` U : s1, \Gamma ; x : U ` V : s2 et

s3 C\Lambda \Gamma  T .

- Si t = [x : U ]v alors il existe V tel que \Gamma ; x : U ` v : V et (x : U )V C \Lambda \Gamma  T .
- Si t = uv alors il existe V et W tels que \Gamma  ` u : (x : V )W , \Gamma  ` v : V et

W fx 7! vg C \Lambda \Gamma  T .

Preuve. Seuls les cas t = f (~t) et t = uv ont 'et'e modifi'es, en rempl,cant C\Gamma  par
C \Gamma  .

- t = f (~t). Par inversion, ` o/f : s, fl : (~x : ~T ) ! \Gamma  et U fl C\Lambda \Gamma  T . Par inversion encore,

il existe s0 tel que ~x : ~T ` U : s0. Donc, par substitution, \Gamma  ` U fl : s0 et U fl C \Lambda \Gamma  T .

- t = uv. Par inversion, il existe V et W tel que \Gamma  ` u : (x : V )W , \Gamma  ` v : V et

W fx 7! vg C\Lambda \Gamma  T . Par correction des types, il existe s tel que \Gamma  ` (x : V )W : s. Par
inversion, il existe s0 tel que \Gamma ; x : V ` W : s0. Donc, par substitution, \Gamma  ` W fx 7!
vg : s0 et W fx 7! vg C \Lambda \Gamma  T . \Xi 

3.4 TSM logiques

Nous introduisons maintenant une importante classe de TSM pour laquelle la
fi-r'eduction pr'eserve le typage.

D'efinition 30 (TSM logique) Un TSM est logique si sa relation de conversion
est compatible avec le produit :

(x : T )U C \Lambda \Gamma  (x0 : T 0)U 0 implique T C \Lambda \Gamma  T 0 et U C \Lambda \Gamma ;x:T U 0fx0 7! xg.

T C \Lambda \Gamma  T 0 signifie qu'il existe une s'equence de termes ~T telle que T = T0 C \Gamma  T1
. . .Tn\Gamma 1 C \Gamma  Tn = T 0. Ainsi, il n'y a aucune raison a priori de prendre U C \Lambda \Gamma ;x:T
U 0fx0 7! xg plut^ot que U C \Lambda \Gamma ;x:Ti U 0fx0 7! xg avec i 6= 0. En effet, comme T C \Lambda \Gamma  T 0,
d'apr`es le Lemme de conversion pour les environnements, ce choix n'a pas d'importance.

La compatibilit'e avec le produit n'est pas une condition nouvelle et appara^it
dans tous les travaux cit'es pr'ec'edemment mais, `a notre connaissance, elle n'a jamais
fait l'objet d'une d'enomination particuli`ere.

Tous les TSM cit'es au d'ebut de ce chapitre sont logiques. Dans le cas o`u C =$\Lambda 
avec ! une relation de r'eduction confluente, il est clair que C est compatible avec le
produit. Montrer cette propri'et'e quand on ne dispose pas de la confluence est plus
d'elicat. C'est le cas des PTS avec j-r'eduction [56] ou du *R-cube [51], une extension
du Calcul des Constructions avec r'ecriture d'ordre sup'erieur `a la Jouannaud-Okada
au niveau objet.

38 CHAPITRE 3. SYST `EMES DE TYPES MODULO
Lemme 31 (Correction de la fi-r'eduction) Dans un fiTSM logique, si \Gamma  ` t : T
et t !fi t0 alors \Gamma  ` t0 : T .

Preuve. Nous dirons qu'un environnement ~x : ~T se fi-r'ecrit en un environnement
~x0 : ~T 0, not'e ~x : ~T !fi ~x0 : ~T 0, si ~x = ~x0 et, soit j~xj = 0, soit il existe j tel que Tj !fi T 0j

et, pour tout i 6= j, Ti = T 0i . Nous prouvons simultan'ement que :

(a) si t !fi t0 alors \Gamma  ` t0 : T ,
(b) si \Gamma  !fi \Gamma 0 alors \Gamma 0 ` t : T ,

par r'ecurrence sur \Gamma  ` t : T .

(ax) ` s1 : s2 ((s1; s2) 2 A)

Aucune fi-r'eduction n'est possible dans s1 ou dans \Gamma  = ;.

(symb)

` o/f : s \Gamma  valide \Gamma  ` t1 : T1fl : : : \Gamma  ` tn : Tnfl

\Gamma  ` f (~t) : U fl

(f 2 F sn;
o/f = (~x : ~T )U;

fl = f~x 7! ~tg)

(a) Si f (~t) !fi t0 alors t0 = f (~t0) avec j tel que tj !fi t0j et, pour tout i 6= j,

ti = t0i. Par hypoth`ese de r'ecurrence, nous avons, pour tout i, \Gamma  ` t0i : Tifl.
Soit fl0 = f~x 7! ~t0g. Nous avons U fl0\Lambda   fiU fl et, pour tout i, Tifl !\Lambda fi Tifl0.
Comme #fi` C, U fl0 C U fl et Tifl C Tifl0. Si nous prouvons que chaque Tifl0
est typable par une sorte dans \Gamma  alors, par (conv), nous avons \Gamma  ` t0i : Tifl0
et, par (symb), \Gamma  ` t0 : U fl0. Il suffit alors de montrer que U fl est typable par
une sorte dans \Gamma  pour pouvoir appliquer `a nouveau (conv) et conclure que
\Gamma  ` t0 : U fl.

Commen,cons par v'erifier que U fl est typable par une sorte. Nous avons
` o/f : s. Par inversion, fl : (~x : ~T ) ! \Gamma  et il existe s0 tel que ~x : ~T ` U : s0.
Par substitution, il vient donc \Gamma  ` U fl : s0.

Maintenant, nous allons montrer que chaque Tifl0 est typable par une sorte.
Pour cela, il suffit de montrer que fl0 : (~x : ~T ) ! \Gamma . En effet, puisque `
o/f : s, par inversion, chaque Ti est typable par une sorte dans \Gamma i\Gamma 1 = x1 :
T1; : : : ; xi\Gamma 1 : Ti\Gamma 1. Montrons donc par r'ecurrence sur i que fl0 : \Gamma i ! \Gamma .

Pour i = 0, il n'y a rien `a prouver. Supposons donc que fl0 : \Gamma i ! \Gamma . Alors
fl0 : \Gamma i+1 ! \Gamma  si \Gamma  ` t0i+1 : Ti+1fl0. Nous savons que \Gamma  ` t0i+1 : Ti+1fl, que
Ti+1fl !\Lambda fi Ti+1fl0 et qu'il existe s tel que \Gamma i ` Ti+1 : s. Donc, par substitution,
\Gamma  ` Ti+1fl0 : s et, par (conv), \Gamma  ` t0i+1 : Ti+1fl0.

(b) Si \Gamma  !fi \Gamma 0 alors, par hypoth`ese de r'ecurrence, \Gamma 0 est valide et \Gamma 0 ` ti : Tifl.

Donc, par (symb), \Gamma 0 ` f (~t) : U fl.

(var)

\Gamma  ` T : s

\Gamma ; x : T ` x : T

(a) Aucune fi-r'eduction n'est possible dans x.
(b) Il y a deux cas, selon que la fi-r'eduction ait lieu dans \Gamma  ou dans T :

- \Gamma  !fi \Gamma 0. Par hypoth`ese de r'ecurrence, \Gamma 0 ` T : s. Donc, par (var), \Gamma 0; x :

T ` x : T .

3.4. TSM LOGIQUES 39

- T !fi T 0. Par hypoth`ese de r'ecurrence, \Gamma  ` T 0 : s. Donc, par (var), \Gamma ; x : T 0 `

x : T 0. Comme #fi` C, T 0 C T . Comme \Gamma  ` T : s, par (conv), \Gamma ; x : T 0 ` x : T .

(weak)

\Gamma  ` t : T \Gamma  ` U : s

\Gamma ; x : U ` t : T

(a) Si t !fi t0 alors, par hypoth`ese de r'ecurrence, \Gamma  ` t0 : T . Comme \Gamma  ` U : s,

par (weak), \Gamma ; x : U ` t0 : T .

(b) Il y a deux cas, selon que la fi-r'eduction a lieu dans \Gamma  ou dans U :

- \Gamma  !fi \Gamma 0. Par hypoth`ese de r'ecurrence, \Gamma 0 ` t : T et \Gamma 0 ` U : s. Donc, par

(weak), \Gamma 0; x : U ` t : T .

- U !fi U 0. Par hypoth`ese de r'ecurrence, \Gamma  ` U 0 : s. Donc, par (weak),

\Gamma ; x : U 0 ` t : T .

(prod)

\Gamma  ` T : s1 \Gamma ; x : T ` U : s2

\Gamma  ` (x : T )U : s3

((s1; s2; s3) 2 B)

(a) Il y a deux cas selon que la fi-r'eduction ait lieu dans T ou U :

- T !fi T 0. Par hypoth`ese de r'ecurrence, \Gamma  ` T 0 : s1 et \Gamma ; x : T 0 ` U : s2.

Donc, par (prod), on obtient \Gamma  ` (x : T 0)U : s3.

- U !fi U 0. Par hypoth`ese de r'ecurrence, \Gamma ; x : T ` U 0 : s2. Donc, par (prod),

\Gamma  ` (x : T )U 0 : s3.

(b) Si \Gamma  !fi \Gamma 0 alors, par hypoth`ese de r'ecurrence, \Gamma 0 ` T : s1 et \Gamma 0; x : T ` U : s2.

Donc, par (prod), \Gamma 0 ` (x : T )U : s3.

(abs)

\Gamma ; x : T ` u : U \Gamma  ` (x : T )U : s

\Gamma  ` [x : T ]u : (x : T )U

(a) Il y a deux cas selon que la fi-r'eduction ait lieu dans T ou dans u :

- T !fi T 0. Par hypoth`ese de r'ecurrence, \Gamma ; x : T 0 ` u : U et \Gamma  ` (x : T 0)U : s.

Par (abs), \Gamma  ` [x : T 0]u : (x : T 0)U . Comme (x : T 0)U  fi(x : T )U et #fi` C,
(x : T 0)U C (x : T )U . Comme \Gamma  ` (x : T )U : s, par (conv), \Gamma  ` [x : T 0]u : (x :
T )U .

- u !fi u0. Par hypoth`ese de r'ecurrence, \Gamma ; x : T ` u0 : U . Comme \Gamma  ` (x :

T )U : s, par (abs), \Gamma  ` [x : T ]u0 : (x : T )U .

(b) Si \Gamma  !fi \Gamma 0 alors, par hypoth`ese de r'ecurrence, \Gamma 0; x : T ` u : U et \Gamma 0 ` (x :

T )U : s. Donc, par (abs), \Gamma 0 ` [x : T ]u : (x : T )U .

(app)

\Gamma  ` t : (x : U )V \Gamma  ` u : U

\Gamma  ` tu : V fx 7! ug

(a) Il y a trois cas selon que la fi-r'eduction ait lieu dans t, dans u ou au sommet

de tu :

- t !fi t0. Par hypoth`ese de r'ecurrence, \Gamma  ` t0 : (x : U )V . Comme \Gamma  ` u : U ,

par (app), \Gamma  ` t0u : V fx 7! ug.

40 CHAPITRE 3. SYST `EMES DE TYPES MODULO

- u !fi u0. Par hypoth`ese de r'ecurrence, \Gamma  ` u0 : U . Par (app), \Gamma  ` tu0 :

V fx 7! u0g. Comme V fx 7! u0g\Lambda   fiV fx 7! ug et #fi` C, V fx 7!
u0g C V fx 7! ug. Par inversion, il existe s tel que \Gamma  ` V fx 7! ug : s.
Donc, par (conv), \Gamma  ` tu0 : V fx 7! ug.

- t = [x : U 0]v et tu !fi vfx 7! ug. Par inversion, il existe V 0 tel que \Gamma ; x : U 0 `

v : V 0 et (x : U 0)V 0 C \Lambda \Gamma  (x : U )V . Par compatibilit'e avec le produit, U 0 C \Lambda \Gamma  U
et V 0 C \Lambda \Gamma ;x:U V . Par conversion de l'environnement, \Gamma ; x : U ` v : V 0 et, par
(conv), \Gamma ; x : U ` v : V .

(b) Si \Gamma  !fi \Gamma 0 alors, par hypoth`ese de r'ecurrence, \Gamma 0 ` t : (x : U )V \Gamma 0 ` u : U .

Donc, par (app), \Gamma 0 ` tu : V fx 7! ug.

(conv)

\Gamma  ` t : T T C T 0 \Gamma  ` T 0 : s0

\Gamma  ` t : T 0
(a) Si t !fi t0 alors, par hypoth`ese de r'ecurrence, \Gamma  ` t0 : T . Comme T C T 0 et

\Gamma  ` T 0 : s0, par (conv), \Gamma  ` t0 : T 0.

(b) Si \Gamma  !fi \Gamma 0 alors, par hypoth`ese de r'ecurrence, \Gamma 0 ` t : T et \Gamma 0 ` T 0 : s0. Donc,

par (conv), \Gamma 0 ` t : T 0. \Xi 

Chapitre 4
Syst`emes de Types `a R'eduction
(RTS)

Maintenant, nous allons 'etudier le cas des TSM dont la relation de conversion C
est de la forme # avec ! une relation de r'eduction. Nous appellerons de tels syst`emes
des Syst`emes de Types `a R'eduction (RTS). Except'e ECC [80], semble-t-il, qui utilise
une notion de sous-typage, les syst`emes cit'es pr'ec'edemment sont des RTS, soit par
ce qu'ils sont d'efinis comme tels [51, 14], soit parce qu'ils sont d'efinis avec C =$\Lambda 
et ! confluente, ce qui est 'equivalent [99, 56, 118, 101]. L''etude g'en'erale de tels
syst`emes est justifi'ee par le fait que, dans [51], la preuve que la r'eduction pr'eserve
le typage repose sur le fait que C soit de la forme #. Enfin, pour ECC, on peut se
demander s'il n'y a pas un RTS 'equivalent.

Les preuves des Lemmes 41, 47, 50 et 52 sont largement inspir'ees de celles donn'ees
par H. Geuvers et M.-J. Nederhof [57] ou H. Geuvers [56].

4.1 D'efinition
D'efinition 32 (RTS) Un pr'e-RTS est un TSM dont la relation de conversion C
est de la forme # o`u ! d'esigne une relation stable par substitution et contexte. La
relation ! est appel'ee relation de r'eduction du pr'e-RTS. Un pr'e-RTS est confluent
si sa relation de r'eduction est confluente. Un pr'e-RTS est admissible si sa relation
de r'eduction pr'eserve le typage : \Gamma  ` t : T et t ! t0 impliquent \Gamma  ` t0 : T . On dit
alors que c'est un RTS .

Tout pr'e-RTS v'erifie les propri'et'es 'el'ementaires suivantes :

Lemme 33 La relation C est :

- stable par substitution : T C T 0 implique T ` C T 0`.
- stable par contexte : T C T 0 implique C[T ]p C C[T 0]p.
- sym'etrique : T C T 0 implique T 0 C T .
- pr'eserve les sortes : s C s0 implique s = s0.

41

42 CHAPITRE 4. SYST `EMES DE TYPES `A R 'EDUCTION

Dans ECC, la relation de conversion C n'est pas sym'etrique et ne pr'eserve pas les
sortes. Il serait int'eressant de chercher `a reformuler certaines des propri'et'es ci-apr`es
dans le cadre plus g'en'eral des Syst`emes de Types purs Cumulatifs (CTS) dont fait
partie ECC. Pour cela, nous renvoyons le lecteur aux travaux de Z. Luo [80], R.
Pollack [102] et Barras [11].

La pr'eservation du typage peut ^etre 'etendue aux types, aux environnements et
aux substitutions :

D'efinition 34 Une substitution ` se r'ecrit en une substitution `0, ` ! `0, s'il existe
x tel que x` ! x`0 et, pour tout y 6= x, y` = y`0. Un environnement \Gamma  = ~x : ~T se
r'ecrit en un environnement \Gamma 0, \Gamma  ! \Gamma 0, si \Gamma 0 = ~x : ~T 0 et il existe i tel que Ti ! T 0i
et, pour tout j 6= i, Tj = T 0j.

Lemme 35 Dans un RTS :

(a) si \Gamma  ` t : T et T ! T 0 alors \Gamma  ` t : T 0,
(b) si ` : \Gamma  ! \Delta  et ` ! `0 alors `0 : \Gamma  ! \Delta ,
(c) si \Gamma  ` t : T et \Gamma  ! \Gamma 0 alors \Gamma 0 ` t : T .

Preuve.
(a) Par correction des types, soit T = s soit \Gamma  ` T : s. Le cas T = s n'est pas

possible puisque s n'est pas r'eductible. Donc, \Gamma  ` T : s et, par pr'eservation du
typage, \Gamma  ` T 0 : s. Donc, par (conv), \Gamma  ` t : T 0.

(b) Par r'ecurrence sur la taille de \Gamma . Si \Gamma  est vide, c'est imm'ediat. Supposons alors

que \Gamma  = \Gamma 0; x : T . Puisque ` : \Gamma 0 ! \Delta , par hypoth`ese de r'ecurrence, `0 : \Gamma 0 ! \Delta .
Il suffit alors de prouver que \Delta  ` x`0 : T `0. Comme ` : \Gamma  ! \Delta , nous avons
\Delta  ` x` : T `. Par pr'eservation du typage, \Delta  ` x`0 : T `. D'apr`es le lemme
d'environnement, il existe s tel que \Gamma  ` T : s. Par substitution, \Delta  ` T ` : s.
Puisque T ` !\Lambda  T `0, T ` C T `0 et, par pr'eservation du typage, \Delta  ` T `0 : s. Donc,
par (conv), \Delta  ` x`0 : T `0.

(c) Supposons que \Gamma  = \Gamma 1; x : T; \Gamma 2 et \Gamma 0 = \Gamma 1; x : T 0; \Gamma 2. Par le lemme d'environnement, \Gamma 1 ` T : s. Par pr'eservation du typage \Gamma 1 ` T 0 : s. Donc \Gamma  C \Gamma 0 et, par le
lemme de conversion des environnements, \Gamma 0 ` t : T . \Xi 

Lemme 36 (Inconvertibilit'e des sortes maximales) Dans un RTS, si s C\Lambda \Gamma  T
alors s C \Lambda \Gamma  T . Donc, si s est maximale alors T = s.

Preuve. Par cas sur le nombre de conversions entre s et T . Si s = T , c'est
imm'ediat. Supposons alors que s C\Gamma  T 0 C\Lambda \Gamma  T . Par d'efinition de C\Gamma , il existe s0 tel que
\Gamma  ` T 0 : s0. Comme C =# et s est irr'eductible, T 0 !\Lambda  s. Par pr'eservation du typage,
\Gamma  ` s : s0 et s C \Lambda \Gamma  T . \Xi 

On obtient ainsi l''equivalence entre les relations de conversion C\Gamma  et C \Gamma  , et un
raffinement du lemme d'inversion pour les RTS.

Lemme 37 ('Equivalence de C\Gamma  et C \Gamma  ) Dans un RTS, C\Gamma  = C \Gamma  .

4.2. RTS LOGIQUES ET FONCTIONNELS 43

Preuve. Tout d'abord, nous avons C \Gamma  ` C\Gamma . Montrons la r'eciproque. Supposons
que T C\Gamma  T 0. Comme il existe t tel que \Gamma  ` t : T , par correction des types, soit T est
une sorte maximale, soit il existe s tel que \Gamma  ` T : s. D'apr`es le lemme pr'ec'edent, T
ne peut pas ^etre une sorte maximale. Donc, il existe s tel que \Gamma  ` T : s et T C \Gamma  T 0.

\Xi 

D'efinition 38 (Sorte r'eguli`ere) Une sorte s est r'eguli`ere si, pour tout (s1; s2; s)
2 B, s2 = s. Un TSM est r'egulier si toutes ses sortes sont r'eguli`eres.

La plupart des PTS que l'on peut rencontrer dans la litt'erature sont r'eguliers.
Pour ces syst`emes, il est souvent fait usage de l'abr'eviation (s1; s2) 2 B pour
(s1; s2; s2) 2 B [57, 10].

Lemme 39 (Inversion pour les RTS) Supposons que \Gamma  ` t : T .

- Si t = s alors il existe s0 tel que (s; s0) 2 A et s0 C \Lambda \Gamma  T .
- Si t = f (~t), f 2 F s, o/f = (~x : ~T )U et fl = f~x 7! ~tg alors ` o/f : s, fl : (~x : ~T ) ! \Gamma 

et U fl C \Lambda \Gamma  T . De plus, si s est r'eguli`ere alors \Gamma  ` U fl : s.

- Si t = x 2 X s alors \Gamma  ` x\Gamma  : s et x\Gamma  C \Lambda \Gamma  T .
- Si t = (x : U )V alors il existe (s1; s2; s3) 2 B tel que \Gamma  ` U : s1, \Gamma ; x : U ` V : s2 et

s3 C \Lambda \Gamma  T .

- Si t = [x : U ]v alors il existe V tel que \Gamma ; x : U ` v : V et (x : U )V C \Lambda \Gamma  T .
- Si t = uv alors il existe V et W tels que \Gamma  ` u : (x : V )W , \Gamma  ` v : V et W fx 7!

vg C \Lambda \Gamma  T . De plus, si \Gamma  ` (x : V )W : s et s est r'eguli`ere alors \Gamma  ` W fx 7! vg : s.

Preuve. Les modifications des cas t = s et t = (x : U )V d'ecoulent de l'inconvertibilit'e des sortes maximales. Il ne nous reste donc plus qu'`a montrer les propri'et'es
suppl'ementaires dans le cas o`u on a une sorte r'eguli`ere. La propri'et'e pour t = f (~t)
d'ecoule, par it'eration, de celle pour t = uv.

Supposons que \Gamma  ` (x : V )W : s. Par inversion, il existe (s1; s2; s3) 2 B tel que
\Gamma ; x : V ` W : s2 et s3 C \Lambda \Gamma  s. Par pr'eservation des sortes, s3 = s. Par r'egularit'e,
s2 = s3. Donc, \Gamma ; x : V ` W : s et, par substitution, \Gamma  ` W fx 7! vg : s. \Xi 

4.2 RTS logiques et fonctionnels
D'efinition 40 (TSM fonctionnel) Un ensemble de r`egles B est fonctionnel si
(s1; s2; s3) 2 B et (s1; s2; s03) 2 B impliquent s3 = s03. Un TSM est fonctionnel si A
est une relation fonctionnelle et B est fonctionnel.

La plupart des PTS que l'on peut rencontrer dans la litt'erature sont fonctionnels.
Par ailleurs, dans un TSM r'egulier, B est fonctionnel. Donc, pour qu'un TSM r'egulier
soit fonctionnel, il suffit que A soit une relation fonctionnelle.

Lemme 41 (Convertibilit'e des types) Dans un RTS logique et fonctionnel, si
\Gamma  ` t : T et \Gamma  ` t : T 0 alors T C \Lambda \Gamma  T 0.

Preuve. Par r'ecurrence sur t. Nous suivons les notations du lemme d'inversion.

44 CHAPITRE 4. SYST `EMES DE TYPES `A R 'EDUCTION

- t = s. Par inversion, il existe s01 et s02 tels que (s; s01) 2 A, (s; s02) 2 A, s01 C \Lambda \Gamma  T et

s02 C \Lambda \Gamma  T 0. Par fonctionnalit'e, s01 = s02. Donc, par sym'etrie, T C \Lambda \Gamma  T 0.

- t = f (~t). Par inversion, U fl C \Lambda \Gamma  T et U fl C \Lambda \Gamma  T 0. Donc, sym'etrie, T C \Lambda \Gamma  T 0.
- t = x. Par inversion, x\Gamma  C \Lambda \Gamma  T et x\Gamma  C \Lambda \Gamma  T 0. Donc, par sym'etrie, T C \Lambda \Gamma  T 0.
- t = (x : U )V . Par inversion, il existe (s1; s2; s3) 2 B et (s01; s02; s03) 2 B tels que

\Gamma  ` U : s1, \Gamma  ` U : s01, \Gamma ; x : U ` V : s2, \Gamma ; x : U ` V : s02, s3 C \Lambda \Gamma  T et s03 C \Lambda \Gamma  T 0.
Par hypoth`ese de r'ecurrence, s1 C \Lambda \Gamma  s01 et s2 C \Lambda \Gamma ;x:U s02. Par pr'eservation des sortes,
s1 = s01 et s2 = s02. Donc, par fonctionnalit'e, s3 = s03 et, par sym'etrie, T C \Lambda \Gamma  T 0.

- t = [x : U ]v. Par inversion, il existe V et V 0 tels que \Gamma ; x : U ` v : V , \Gamma ; x : U ` v : V 0,

(x : U )V C \Lambda \Gamma  T et (x : U )V 0 C \Lambda \Gamma  T 0. Par hypoth`ese de r'ecurrence, V C \Lambda \Gamma ;x:U V 0. Par
stabilit'e par contexte, (x : U )V C \Lambda \Gamma  (x : U )V 0. Donc, par sym'etrie, T C \Lambda \Gamma  T 0.

- t = uv. Par inversion, il existe V , V 0, W et W 0 tels que \Gamma  ` u : (x : V )W , \Gamma  ` u :

(x : V 0)W 0, W fx 7! vg C \Lambda \Gamma  T et W 0fx 7! vg C \Lambda \Gamma  T 0. Par hypoth`ese de r'ecurrence,
(x : V )W C \Lambda \Gamma  (x : V 0)W 0. Par compatibilit'e avec le produit, W C \Lambda \Gamma ;x:V W 0. Par
substitution et stabilit'e par substitution, W fx 7! vg C \Lambda \Gamma  W 0fx 7! vg. Donc, par
sym'etrie, T C \Lambda \Gamma  T 0. \Xi 

Lemme 42 (Correction de la conversion) Dans un RTS logique et fonctionnel,
si \Gamma  ` T : s et T C \Gamma  T 0 alors \Gamma  ` T 0 : s.

Preuve. Par d'efinition de C \Gamma  , il existe s0 tel que \Gamma  ` T 0 : s0. Comme C = #,
il existe U tel que T !\Lambda  U et T 0 !\Lambda  U . Par pr'eservation du typage, \Gamma  ` U : s et
\Gamma  ` U : s0. Par convertibilit'e des types et pr'eservation des sortes, s = s0 et \Gamma  ` T 0 : s.

\Xi 

Lemme 43 ('Equivalence entre `s et `) Dans un RTS, `s = `.

Preuve. Tout d'abord, il est imm'ediat que `s ` `. Montrons la r'eciproque par
r'ecurrence sur \Gamma  ` t : T . Le seul cas ennuyeux est bien s^ur (conv). Par hypoth`ese de
r'ecurrence, nous avons \Gamma  `st : T et \Gamma  `sT 0 : s0. Il est facile de v'erifier que les lemmes
de substitution et de correction des types sont aussi valables pour `s. Ainsi, par
correction des types, soit T est une sorte maximale, soit il existe s0 tel que \Gamma  `sT : s0.
Si s0 est une sorte maximale alors T 0 !\Lambda  s0 et s0 est typable, ce qui est exclu. Donc,
\Gamma  `sT : s0. Par convertibilit'e des types et pr'eservation des sortes, s = s0 et, par
(conv'), \Gamma  `st : T 0. \Xi 

Lemme 44 (ff-'Equivalence) Dans un RTS logique et fonctionnel, si (x : T )U C \Gamma 
(x0 : T 0)U 0 alors x et x0 sont de la m^eme sorte et (x0 : T 0)U 0 est ff-'equivalent `a
(x : T 0)U 0fx0 7! xg.

Preuve. Supposons que x soit de sorte s et x0 de sorte s0. Par d'efinition de
C \Gamma  , nous avons \Gamma  ` (x : T )U : s3 et \Gamma  ` (x0 : T 0)U 0 : s03. Par inversion, nous avons
\Gamma ; x : T ` U : s1 et \Gamma ; x0 : T 0 ` U 0 : s01. Par le Lemme d'environnement, nous
avons \Gamma  ` T : s et \Gamma  ` T 0 : s0. Par correction de la conversion et pr'eservation des
sortes, s = s0. Donc x et x0 sont de m^eme sorte et (x0 : T 0)U 0 est ff-'equivalent `a
(x : T 0)U 0fx0 7! xg. \Xi 

4.3. RTS LOGIQUES ET INJECTIFS 45
Lemme 45 (Sorte maximale) Dans un RTS logique et fonctionnel, si s est une
sorte maximale et \Gamma  ` t : s alors t est de la forme (~x : ~t)s0. De plus, si t C \Lambda \Gamma  t0 alors
t0 est de la forme (~y : ~t0)s0 avec j~yj = j~xj.

Preuve. Montrons la premi`ere assertion par cas sur t. Remarquons tout d'abord
qu'il n'existe aucun s0 tel que \Gamma  ` s : s0. Sinon, par inversion, il existerait s00 tel que
(s; s00) 2 A et s00 C \Lambda \Gamma  s0, ce qui est exclu puisque s est maximale.

- t = f (~t). Soit o/f = (~x : ~T )U et fl = f~x 7! ~tg. Par inversion, il existe s0 tel que

\Gamma  ` U fl : s0 et U fl C \Lambda \Gamma  s. Par correction de la conversion, \Gamma  ` s : s0. Ce cas est donc
impossible.

- t = x 2 X s

0

. Par inversion, \Gamma  ` x\Gamma  : s0 et x\Gamma  C \Lambda \Gamma  s. Par correction de la conversion,

\Gamma  ` s : s0. Ce cas est donc impossible.

- t = [x : U ]v. Par inversion, il existe V et s0 tel que \Gamma ; x : U ` v : V , \Gamma  ` (x : U )V : s0

et (x : U )V C \Lambda \Gamma  s. Par correction de la conversion, \Gamma  ` s : s0. Ce cas est donc
impossible.

- t = uv. Par inversion, il existe V , W et s0 tel que \Gamma  ` W fx 7! ug : s0 et

W fx 7! ug C \Lambda \Gamma  s. Par correction de la conversion, \Gamma  ` s : s0. Ce cas est donc
impossible.

Il ne reste plus que les cas t = (x : U )V et t = s0. Donc t doit ^etre de la forme
(~x : ~t)s0.

Montrons maintenant la deuxi`eme assertion. Par correction de la conversion,
\Gamma  ` t0 : s. D'apr`es la premi`ere assertion, t0 est de la forme (~y : ~t0)s00. Par compatibilit'e
avec le produit et ff-'equivalence, et quitte `a 'echanger les r^oles de t et t0, on peut
supposer que ~y = ~x~z et ~t0 = ~t~u. Ainsi, s0 C \Lambda \Gamma 0 (~z : ~u)s00 o`u \Gamma 0 = ~x : ~t. Prouvons
alors par r'ecurrence sur le nombre de conversions entre s0 et (~z : ~u)s00 que j~zj = 0 et
s0 = s00. Si s0 = (~z : ~u)s00, c'est imm'ediat. Supposons alors que s0 C 0\Gamma  v C \Lambda \Gamma 0 (~z : ~u)s00.
Par correction de la conversion, \Gamma 0 ` v : s. Donc, d'apr`es la premi`ere assertion, v est
de la forme (~z0 : ~u0)s000. Comme C =# et s0 est irr'eductible, v !\Lambda  s0. Donc j~z0j = 0 et
s000 = s0. Ainsi, v = s0 et, par hypoth`ese de r'ecurrence, j~zj = 0 et s00 = s0. \Xi 

4.3 RTS logiques et injectifs
D'efinition 46 (TSM injectif ) Un ensemble de r`egles B est injectif si (s1; s2; s3) 2
B et (s1; s02; s3) 2 B implique s2 = s02. Un TSM est injectif si A est une relation
fonctionnelle et injective et B est fonctionnel et injectif.

Dans un TSM r'egulier, B est fonctionnel et injectif. Donc, pour qu'un TSM
r'egulier soit fonctionnel, il suffit que A soit une relation fonctionnelle et injective.

Lemme 47 (S'eparation) Dans un RTS logique et injectif, si s1 6= s2 alors, pour
tout i 2 f0; 1g, Ts1i " Ts2i = ;.

Preuve. Montrons que t 2 Ts1i " Ts2i implique s1 = s2, par r'ecurrence sur t.
Cas i = 0. Il existe \Gamma j tel que \Gamma j ` t : sj.

46 CHAPITRE 4. SYST `EMES DE TYPES `A R 'EDUCTION

- t = s. Par inversion, il existe s0j tel que (s; s0j) 2 A et s0j C \Lambda \Gamma j sj. Par fonctionnalit'e, s01 = s02. Notons s0 par la sorte s01 = s02. Alors s0 C \Lambda \Gamma j sj. Donc, par
pr'eservation des sortes, s1 = s2 = s0.
- t = f (~t), f 2 F s et o/f = (~x : ~T )U . Soit \Gamma  = ~x : ~T et fl = f~x 7! ~tg. Par

inversion, ` o/f : s, fl : \Gamma  ! \Gamma j et U fl C \Lambda \Gamma j sj. Par inversion encore, il existe s0 tel

que \Gamma  ` U : s0. Par substitution, \Gamma j ` U fl : s0. Par correction de la conversion,
\Gamma j ` sj : s0. Par inversion et pr'eservation des sortes, (sj; s0) 2 A. Donc, par
injectivit'e, s1 = s2.

- t = x 2 X s. Par inversion, \Gamma j ` x\Gamma j : s et x\Gamma j C \Lambda \Gamma j sj. Par correction de la

conversion, \Gamma j ` sj : s. Par inversion et pr'eservation des sortes, (sj; s) 2 A.
Donc, par injectivit'e, s1 = s2.

- t = (x : U )V . Par inversion, il existe (s1j ; s2j ; s3j ) 2 B tel que \Gamma j ` U : s1j ,

\Gamma j; x : U ` V : s2j et s3j C \Lambda \Gamma j sj. Par hypoth`ese de r'ecurrence, s11 = s12 et s21 = s22.
Donc, par fonctionnalit'e, s31 = s32. Notons s la sorte s31 = s32. Alors, s C \Lambda \Gamma j sj et,
par pr'eservation des sortes, s1 = s2 = s.

- t = [x : U ]v. Par inversion, il existe Vj et s4j tel que \Gamma j; x : U ` v : Vj, \Gamma j `

(x : U )Vj : s4j et (x : U )Vj C \Lambda \Gamma j sj. Par inversion encore, il existe (s1j ; s2j ; s3j ) 2 B
tel que \Gamma j ` U : s1j , \Gamma j; x : U ` Vj : s2j et s3j C \Lambda \Gamma j s4j . Par pr'eservation des
sortes, s3j = s4j . Par hypoth`ese de r'ecurrence, s11 = s12 et s21 = s22. Donc, par
fonctionnalit'e, s31 = s32. Notons s la sorte s31 = s32 = s41 = s42. Par correction de
la conversion, \Gamma  ` sj : s. Par inversion et pr'eservation des sortes, (sj; s) 2 A.
Donc, par injectivit'e, s1 = s2.

- t = uv. Par inversion, il existe Vj et Wj tels que \Gamma j ` u : (xj : Vj)Wj, \Gamma j ` v : Vj

et Wjfxj 7! vg C \Lambda \Gamma j sj. Soit \Gamma 0j = \Gamma j; xj : Vj et `j = fxj 7! vg. Par correction

des types, il existe s0j tel que \Gamma j ` (xj : Vj)Wj : s0j. Par hypoth`ese de r'ecurrence
sur u, s01 = s02. Posons s0 = s01 = s02. Par inversion, il existe (s1j ; s2j ; s3j ) 2 B tel
que \Gamma j ` Vj : s1j , \Gamma 0j ` Wj : s2j et s3j C \Lambda \Gamma j s0. Par pr'eservation des sortes, s3j = s0.
Par hypoth`ese de r'ecurrence sur v, s11 = s12. Donc, par injectivit'e, s21 = s22.
Posons s00 = s21 = s22. Comme `j : \Gamma 0j 7! \Gamma j, par substitution, \Gamma j ` Wj`j : s00.
Par correction de la conversion, \Gamma j ` sj : s00. Par inversion et pr'eservation des
sortes, (sj; s00) 2 A. Donc, par injectivit'e, s1 = s2.

Cas i = 1. Il existe \Gamma j et Tj tels que \Gamma j ` t : Tj et \Gamma j ` Tj : sj.

- t = s. D'apr`es le cas i = 0, il existe s0 tel que s0 C \Lambda \Gamma j Tj. Par correction de la

conversion, \Gamma j ` s0 : sj. Par inversion et pr'eservation des sortes, (s0; sj) 2 A.
Donc, par fonctionnalit'e, s1 = s2.

- t = f (~t). D'apr`es le cas i = 0, il existe s0 tel que \Gamma j ` Tj : s0. Par convertibilit'e

des types et pr'eservation des sortes, s1 = s2 = s0.

- t = x 2 X s. D'apr`es le cas i = 0, \Gamma j ` Tj : s. Donc, par convertibilit'e des types

et pr'eservation des sortes, s1 = s2 = s.

- t = (x : U )V . D'apr`es le cas i = 0, il existe s tel que s C \Lambda \Gamma j Tj. Par correction de

la conversion, \Gamma j ` s : sj. Par inversion et pr'eservation des sortes, (s; sj) 2 A.
Donc, par fonctionnalit'e, s1 = s2.

4.3. RTS LOGIQUES ET INJECTIFS 47

- t = [x : U ]v. D'apr`es le cas i = 0, il existe s tel que \Gamma j ` Tj : s. Par convertibilit'e

des types et pr'eservation des sortes, s1 = s2 = s.

- t = uv. D'apr`es le cas i = 0, il existe s00 tel que \Gamma j ` Tj : s00. Par convertibilit'e

des types et pr'eservation des sortes, s1 = s2 = s0. \Xi 

Lemme 48 (Classification) Dans un RTS logique et injectif, soit (s1; s2) 2 A et
Ts10 ` Ts21 , soit (s1; s2) =2 A et Ts10 " Ts21 = ;.

Preuve. Si (s1; s2) 2 A, il est clair que Ts10 ` Ts21 . Montrons alors que t 2
Ts10 " Ts21 implique (s1; s2) 2 A, par r'ecurrence sur t. Soient \Gamma , \Gamma 0 et T tels que
\Gamma  ` t : s1, \Gamma 0 ` t : T et \Gamma 0 ` T : s2.

- t = s. Par inversion, il existe s01 et s02 tels que (s; s01) 2 A, s01 C \Lambda \Gamma  s1, (s; s02) 2 A

et s02 C \Lambda \Gamma 0 T . Par pr'eservation des sortes, s01 = s1. Par fonctionnalit'e, s01 = s02. Par
correction de la conversion, \Gamma  ` s02 : s2. Donc, par inversion et pr'eservation des
sortes, (s02; s2) 2 A et (s1; s2) 2 A.

- t = f (~t). Soit o/f = (~x : ~T )U et fl = f~x 7! ~tg. Par inversion, il existe s01 et s02

tels que \Gamma  ` U fl : s01, U fl C \Lambda \Gamma  s1, \Gamma 0 ` U fl : s02 et U fl C \Lambda \Gamma 0 T . Par correction de la
conversion, \Gamma  ` s1 : s01 donc, par inversion et pr'eservation des sortes, (s1; s01) 2 A.
Par s'eparation, s01 = s02. Par correction de la conversion, \Gamma 0 ` T : s02. Donc, par
s'eparation, s02 = s2 et (s1; s2) 2 A.

- t = x 2 X s. Par inversion, \Gamma  ` x\Gamma  : s, x\Gamma  C \Lambda \Gamma  s1, \Gamma 0 ` x\Gamma 0 : s et x\Gamma 0 C \Lambda \Gamma 0 T . Par

correction de la conversion, \Gamma  ` s1 : s. Par inversion et pr'eservation des sortes,
(s1; s) 2 A. Par correction de la conversion, \Gamma 0 ` T : s. Donc, par s'eparation,
s = s2 et (s1; s2) 2 A.

- t = (x : U )V . Par inversion, il existe (sa; sb; sc) et (s0a; s0b; s0c) 2 B tels que \Gamma  `

U : sa, \Gamma ; x : U ` V : sb, sc C \Lambda \Gamma  s1, \Gamma 0 ` U : s0a, \Gamma 0; x : U ` V : s0b et s0c C \Lambda \Gamma 0 T .
Par pr'eservation des sortes, sc = s1. Par correction de la conversion, \Gamma 0 ` s0c : s2.
Par inversion et pr'eservation des sortes, (s0c; s2) 2 A. Par s'eparation, sa = s0a et
sb = s0b. Donc, par fonctionnalit'e, sc = s0c et (s1; s2) 2 A.

- t = [x : U ]v. Par inversion, il existe V , s, V 0 et s0 tels que \Gamma ; x : U ` v : V ,

\Gamma  ` (x : U )V : s, (x : U )V C \Lambda \Gamma  s1, \Gamma 0; x : U ` v : V 0, \Gamma 0 ` (x : U )V 0 : s0 et
(x : U )V 0 C \Lambda \Gamma 0 T . Par correction de la conversion, \Gamma  ` s1 : s et \Gamma 0 ` T : s0.
Par inversion et pr'eservation des sortes, (s1; s) 2 A. Par s'eparation s0 = s2.
Par inversion encore, il existe (sa; sb; sc) et (s0a; s0b; s0c) 2 B tels que \Gamma  ` U : sa,
\Gamma ; x : U ` V : sb, sc C \Lambda \Gamma  s, \Gamma 0 ` U : s0a et \Gamma 0; x : U ` V 0 : s0b et s0c C \Lambda \Gamma 0 s0. Par
pr'eservation des sortes, sc = s et s0c = s0. Par s'eparation, sa = s0a et sb = s0b.
Donc, par fonctionnalit'e, sc = s0c et (s1; s2) 2 A.

- t = uv. Par inversion, il existe V , W , s, V 0 et W 0 et s0 tels que \Gamma  ` u : (x : V )W ,

\Gamma  ` W fx 7! vg : s, W fx 7! vg C \Lambda \Gamma  s1, \Gamma 0 ` u : (x : V 0)W 0, \Gamma 0 ` W 0fx 7! vg : s0 et
W 0fx 7! vg C \Lambda \Gamma 0 T . Par correction de la conversion, \Gamma  ` s1 : s et \Gamma 0 ` T : s0. Par
inversion et pr'eservation des sortes, (s1; s) 2 A. Par s'eparation, s = s0 et s0 = s2.
Donc, (s1; s2) 2 A. \Xi 

48 CHAPITRE 4. SYST `EMES DE TYPES `A R 'EDUCTION
Remarque 49 (Classes de typage)

Avec le lemme de correction des types, nous avons vu qu'un terme typable est
n'ecessairement dans l'un des ensembles Tsi o`u i 2 f0; 1g et s 2 S. Avec les lemmes
de s'eparation et de classification pr'ec'edents, on peut d'ecrire avec pr'ecision les liens
entre ces ensembles.

Dans un TSM injectif, l'ensemble des axiomes A est n'ecessairement une r'eunion
disjointe de "cha^ines" maximales, c'est-`a-dire d'ensembles A0 tels que :

- si (s1; s2) 2 A0 et (s2; s3) 2 A alors (s2; s3) 2 A0,
- si (s2; s3) 2 A0 et (s1; s2) 2 A alors (s1; s2) 2 A0.

Par exemple, dans le cas o`u A est fini, une cha^ine maximale est de la forme
f(s1; s2), (s2; s3), . . ., (sn; sn+1)g avec s1; : : : ; sn distincts deux `a deux. Pour une
telle cha^ine, on obtient les n classes de typage Ts11 , Ts21 , . . ., Tsn1 , plus les deux
classes T

sn+1

1 et T

sn+1
0 si sn+1 est distinct des autres si. Finalement, une sorte s qui

ne fait partie d'aucun axiome donne lieu `a deux classes, Ts1 et Ts0.

4.4 RTS confluents

Ci-apr`es, nous montrons des r'esultats de d'ependance des types par rapport aux
variables ou aux symboles. Le premier r'esultat, la d'ependance par rapport aux
variables, est plus connu sous le nom de Lemme de Renforcement. Nous pr'esentons
une preuve de ce lemme dans le cas d'un RTS fonctionnel (et confluent) inspir'ee
de celle de H. Geuvers et M.-J. Nederhof [57]. L. S. van Benthem Jutting [114] a
montr'e que tout PTS v'erifie cette propri'et'e. Il serait int'eressant d'examiner cette
preuve pour l'adapter aux RTS.

Lemme 50 (D'ependance par rapport aux variables) Dans un RTS confluent
et fonctionnel,
si \Delta ; z : V; \Delta 0 ` t : T et z =2 FV(\Delta 0; t) alors il existe T 0 tel que T !\Lambda  T 0 et
\Delta ; \Delta 0 ` t : T 0.

Preuve. Par r'ecurrence sur \Delta ; z : V; \Delta 0 ` t : T .
(ax) Impossible.
(symb) Soit \Gamma  = \Delta ; z : V; \Delta 0. Montrons que U fl lui-m^eme fait l'affaire. Par hypoth`ese de r'ecurrence, pour tout i, il existe T 0i tel que Tifl !\Lambda  T 0i et \Delta ; \Delta 0 `
ti : T 0i . Montrons que fl : \Gamma f ! \Delta ; \Delta 0. Soit fli = fx1 7! t1; : : : ; xi 7! tig et
\Gamma i = x1 : T1; : : : ; xi : Ti. Montrons que fli : \Gamma i ! \Delta ; \Delta 0 par r'ecurrence sur i. Pour
i = 0, il n'y a rien `a montrer. Supposons alors que fli : \Gamma i ! \Delta ; \Delta 0 et montrons que
fli+1 : \Gamma i+1 ! \Delta ; \Delta 0. Comme ` o/f : s, par inversion, pour tout j, il existe sj tel que
\Gamma j\Gamma 1 ` Tj : sj. Ainsi, par le lemme d'environnement, FV(Tj) ` fx1; : : : ; xj\Gamma 1g.
Donc, pour tout j ^ i + 1, Tjfli+1 = Tjfli. Ainsi, fli+1 : \Gamma i ! \Delta ; \Delta 0 et il ne nous
reste plus qu'`a montrer que \Delta ; \Delta 0 ` ti+1 : Ti+1fli. Nous avons \Delta ; \Delta 0 ` ti+1 : T 0i+1.
Comme \Gamma i ` Ti+1 : si+1 et fli : \Gamma i ! \Delta ; \Delta 0, par substitution, \Delta ; \Delta 0 ` Ti+1fli : si+1.
Donc, par (conv), \Delta ; \Delta 0 ` ti+1 : Ti+1fli et fli+1 : \Gamma i+1 ! \Delta ; \Delta 0. Finalement,
fl = fln : \Gamma f ! \Delta ; \Delta 0. Comme \Gamma f ` U : s, par substitution, \Delta ; \Delta 0 ` U fl : s.

4.4. RTS CONFLUENTS 49

(var) Soit \Gamma  = \Delta ; z : V; \Delta 0. Par hypoth`ese de r'ecurrence, \Delta ; \Delta 0 ` T : s. Donc, par

(var), \Delta ; \Delta 0; x : T ` x : T .

(weak) Si z = x, T lui-m^eme fait l'affaire puisque \Gamma  ` t : T . Sinon, soit \Gamma  = \Delta ; z :

V; \Delta 0. Par hypoth`ese de r'ecurrence, il existe T 0 tel que T !\Lambda  T 0, \Delta ; \Delta 0 ` t : T 0 et
\Delta ; \Delta 0 ` U : s. Donc, par (weak), \Delta ; \Delta 0; x : U ` t : T 0.

(prod) Soit \Gamma  = \Delta ; z : V; \Delta 0. Par hypoth`ese de r'ecurrence, \Delta ; \Delta 0 ` T : s1 et

\Delta ; \Delta 0; x : T ` U : s2. Donc, par (prod), \Delta ; \Delta 0 ` (x : T )U : s3.

(abs) Soit \Gamma  = \Delta ; z : V; \Delta 0. Par hypoth`ese de r'ecurrence, il existe U 0 tel que U !\Lambda  U 0

et \Delta ; \Delta 0; x : T ` u : U 0. Montrons que \Delta ; \Delta 0 ` (x : T )U 0 : s. Alors, par (abs),
\Delta ; \Delta 0 ` [x : T ]u : (x : T )U 0. Comme \Gamma  ` (x : T )U : s, par inversion, il existe
(s1; s2; s) 2 B tel que \Gamma  ` T : s1 et \Gamma ; x : T ` U : s2. Comme z =2 FV(T ),
par hypoth`ese de r'ecurrence, \Delta ; \Delta 0 ` T : s1. Comme \Delta ; \Delta 0; x : T ` u : U 0, par
correction des types, soit U 0 = s0 soit \Delta ; \Delta 0; x : T ` U 0 : s0. Supposons que U 0 = s0.
Comme \Gamma ; x : T ` U : s2, par pr'eservation du typage, \Gamma ; x : T ` U 0 : s2. Donc
(s0; s2) 2 A et \Delta ; \Delta 0; x : T ` U 0 : s2. Si maintenant \Delta ; \Delta 0; x : T ` U 0 : s0 alors, par
convertibilit'e des types, s0 = s2. Ainsi, dans tous les cas, \Gamma ; x : T ` U 0 : s2. Donc,
par (prod), \Delta ; \Delta 0 ` (x : T )U 0 : s.

(app) Soit \Gamma  = \Delta ; z : V; \Delta 0. Par hypoth`ese de r'ecurrence, il existe U 01, U 02 et V tels

que U !\Lambda  U 01, U !\Lambda  U 02, V !\Lambda  V 0, \Delta ; \Delta 0 ` t : (x : U 01)V 0 et \Delta ; \Delta 0 ` u : U 02.
Par confluence, il existe U 00 tel que U 01 !\Lambda  U 00 et U 02 !\Lambda  U 00. Par pr'eservation du
typage, \Delta ; \Delta 0 ` t : (x : U 00)V 0 et \Delta ; \Delta 0 ` u : U 00. Donc, par (app), \Delta ; \Delta 0 ` tu :
V 0fx 7! ug.

(conv) Par hypoth`ese de r'ecurrence, il existe T 00 tel que T !\Lambda  T 00 et \Delta ; \Delta 0 ` t : T 00.

Par confluence, il existe T 000 tel que T 00 !\Lambda  T 000 et T 0 !\Lambda  T 000. Par pr'eservation du
typage, \Delta ; \Delta 0 ` t : T 000. \Xi 

Corollaire 51 Dans un RTS confluent et fonctionnel, si \Delta ; z : V; \Delta 0 ` t : T et
z =2 FV(\Delta 0; t; T ) alors \Delta ; \Delta 0 ` t : T .

Preuve. D'apr`es le lemme, il existe T 0 tel que T !\Lambda  T 0 et \Delta ; \Delta 0 ` t : T 0. Par
correction des types, soit T est une sorte maximale et T 0 = T , soit \Delta ; z : V; \Delta 0 ` T : s.
Alors, d'apr`es le lemme, \Delta ; \Delta 0 ` T : s. Donc, par (conv), \Delta ; \Delta 0 ` t : T . \Xi 

Lemme 52 (Permutation forte) Si \Gamma ; y : A; z : B; \Gamma 0 ` t : T et y =2 FV(B) alors
\Gamma ; z : B; y : A; \Gamma 0 ` t : T .

Preuve. Soit \Delta  = \Gamma ; y : A; z : B; \Gamma 0 et \Delta 0 = \Gamma ; z : B; y : A; \Gamma 0. D'apr`es le lemme
de transitivit'e, il suffit de montrer que \Delta 0 est valide et que \Delta 0 ` \Delta . Et pour cela,
il suffit de montrer que \Delta 0 est valide. Par le lemme d'environnement, nous avons
\Gamma  ` A : s et \Gamma ; y : A ` B : s0. D'apr`es le lemme pr'ec'edent, \Gamma  ` B : s0. Donc, \Gamma ; z : B
est valide et, par affaiblissement, \Gamma ; z : B; y : A aussi. Supposons que \Gamma 0 = ~x : ~T et
posons \Delta i = \Gamma ; y : A; z : B; x1 : T1; : : : ; xi : Ti et \Delta 0i = \Gamma ; z : B; y : A; x1 : T1; : : : ; xi : Ti.
Montrons par r'ecurrence sur i que \Delta 0i est valide. Nous avons montr'e que \Delta 00 est
valide. Supposons que \Delta 0i soit valide. Par le lemme d'environnement, \Delta i ` Ti+1 : si+1.
Comme \Delta 0i ` \Delta i, \Delta 0i ` Ti+1 : si+1 et \Delta 0i+1 est valide. Donc, \Delta 0 est valide et \Delta 0 ` t : T .

\Xi 

50 CHAPITRE 4. SYST `EMES DE TYPES `A R 'EDUCTION
D'efinition 53 (Compatibilit'e par rapport `a un pr'e-ordre) Soit * un pr'e--
ordre sur F . 'Etant donn'e un symbole g, nous d'esignerons par `g la relation de
typage du RTS dont les symboles sont strictement inf'erieurs `a g.

- ! est compatible avec * si, pour tout symbole g et tout terme t; t0, d`es lors que

tous les symboles de t sont strictement inf'erieurs `a g et que t ! t0, alors tous les
symboles de t0 sont strictement inf'erieurs `a g.

- o/ est compatible avec * si, pour tout g, tous les symboles de o/g sont inf'erieurs ou

'egaux `a g.

Lemme 54 (D'ependance par rapport aux symboles) Soit un RTS confluent
et fonctionnel et * un pr'e-ordre sur F tel que ! et o/ soient compatibles avec *. Si
\Gamma  ` t : T et les symboles de \Gamma  et t sont strictement inf'erieurs `a g alors il existe T 0
tel que T !\Lambda  T 0 et \Gamma  `g t : T 0.

Preuve. Par r'ecurrence sur \Gamma  ` t : T .
(ax) Imm'ediat.
(symb) Montrons que \Gamma  `g f (~t) : U fl. Par hypoth`ese de r'ecurrence, pour tout i, il

existe T 0i tel que Tifl !\Lambda  T 0i et \Gamma  `g ti : T 0i . Montrons que fl : \Gamma f ! \Gamma  dans `g. Soit
fli = fx1 7! t1; : : : ; xi 7! tig et \Gamma i = x1 : T1; : : : ; xi : Ti. Montrons que fli : \Gamma i ! \Gamma 
par r'ecurrence sur i. Pour i = 0, il n'y a rien `a montrer. Supposons alors que
fli : \Gamma i ! \Gamma  et montrons que fli+1 : \Gamma i+1 ! \Gamma . Comme o/ est compatible avec *, par
hypoth`ese de r'ecurrence, `g o/f : s. Par inversion, pour tout j, il existe sj tel que
\Gamma j\Gamma 1 `g Tj : sj. Ainsi, par le lemme des variables libres, FV(Tj) ` fx1; : : : ; xj\Gamma 1g.
Donc, pour tout j ^ i + 1, Tjfli+1 = Tjfli. Ainsi, fli+1 : \Gamma i ! \Gamma  et il ne nous reste
plus qu'`a montrer que \Gamma  `g ti+1 : Ti+1fli. Nous avons \Gamma  `g ti+1 : T 0i+1. Comme
\Gamma i `g Ti+1 : si+1 et fli : \Gamma i ! \Gamma , par substitution, \Gamma  `g Ti+1fli : si+1. Donc, par
(conv), \Gamma  `g ti+1 : Ti+1fli et fli+1 : \Gamma i+1 ! \Gamma . Finalement, fl = fln : \Gamma f ! \Gamma .
Comme \Gamma f `g U : s, par substitution, \Gamma  `g U fl : s.

(var) Par hypoth`ese de r'ecurrence, \Gamma  `g T : s. Donc, par (var), \Gamma ; x : T `g x : T .
(weak) Par hypoth`ese de r'ecurrence, il existe T 0 tel que T !\Lambda  T 0, \Gamma  `g t : T 0 et

\Gamma  `g U : s. Donc, par (weak), \Gamma ; x : U `g t : T 0.

(prod) Par hypoth`ese de r'ecurrence, \Gamma  `g T : s1 et \Gamma ; x : T `g U : s2. Donc, par

(prod), \Gamma  `g (x : T )U : s3.

(abs) Par hypoth`ese de r'ecurrence, il existe U 0 tel que U !\Lambda  U 0 et \Gamma ; x : T `g u : U 0.

Montrons que \Gamma  `g (x : T )U 0 : s. Alors, par (abs), \Gamma  `g [x : T ]u : (x : T )U 0. Comme
\Gamma  ` (x : T )U : s, par inversion, il existe (s1; s2; s) 2 B tel que \Gamma  ` T : s1 et
\Gamma ; x : T ` U : s2. Par hypoth`ese de r'ecurrence, \Gamma  `g T : s1. Comme \Gamma ; x : T `g u :
U 0, par correction des types, soit U 0 = s0 soit \Gamma ; x : T `g U 0 : s0. Supposons que
U 0 = s0. Comme \Gamma ; x : T ` U : s2, par pr'eservation du typage, \Gamma ; x : T ` U 0 : s2.
Donc (s0; s2) 2 A et \Gamma ; x : T `g U 0 : s2. Si maintenant \Gamma ; x : T `g U 0 : s0 alors, par
convertibilit'e des types, s0 = s2. Ainsi, dans tous les cas, \Gamma ; x : T `g U 0 : s2. Donc,
par (prod), \Gamma  `g (x : T )U 0 : s.

(app) Par hypoth`ese de r'ecurrence, il existe U 01, U 02 et V tels que U !\Lambda  U 01, U !\Lambda 

U 02, V !\Lambda  V 0, \Gamma  `g t : (x : U 01)V 0 et \Gamma  `g u : U 02. Par confluence, il existe U 00 tel

4.4. RTS CONFLUENTS 51

que U 01 !\Lambda  U 00 et U 02 !\Lambda  U 00. Par pr'eservation du typage, \Gamma  `g t : (x : U 00)V 0 et
\Gamma  `g u : U 00. Donc, par (app), \Gamma  `g tu : V 0fx 7! ug.

(conv) Par hypoth`ese de r'ecurrence, il existe T 00 tel que T !\Lambda  T 00 et \Gamma  `g t : T 00.

Par confluence, il existe T 000 tel que T 00 !\Lambda  T 000 et T 0 !\Lambda  T 000. Par pr'eservation du
typage, \Gamma  `g t : T 000. Comme ! est compatible avec *, les symboles de T 000 sont
strictement inf'erieurs `a g. \Xi 

52 CHAPITRE 4. SYST `EMES DE TYPES `A R 'EDUCTION

Chapitre 5
Syst`emes de Types Alg'ebriques
(ATS)

Maintenant, nous allons 'etudier le cas des RTS dont la relation de r'eduction est
engendr'ee par la fi-r'eduction et des r`egles de r'ecriture. Avant cela, il convient de
bien d'efinir ce qu'on entend par r'ecriture dans un contexte de typage fort et d'ordre
sup'erieur comme c'est le cas dans les syst`emes de types.

Au premier ordre, c'est-`a-dire dans une alg`ebre de termes du premier ordre, une
r`egle de r'ecriture est g'en'eralement d'efinie comme un couple l ! r de termes tels
que l ne soit pas une variable et les variables qui apparaissent dans r apparaissent
'egalement dans l (sinon la r'ecriture ne termine pas). Ensuite, on dit qu'un terme t

se r'ecrit en t0 `a la position p s'il existe une substitution oe telle que tjp = loe (on dit
que tjp "filtre" l) et t0 = t[roe]p (tjp = loe est remplac'e dans t par roe). Nous renvoyons
le lecteur vers [43, 3] pour plus de d'etails sur la r'ecriture du premier ordre.

Ici, nous allons consid'erer un m'ecanisme de r'ecriture tr`es similaire en restreignant
les membres gauches des r`egles `a appartenir `a l'alg`ebre des termes engendr'ee par
F et X . Par contre, les membres droits pourront ^etre quelconques. C'est un cas
particulier de Combinatory Reduction System (CRS) 1 de W. Klop [78] pour lequel
il n'est pas n'ecessaire d'utiliser du filtrage d'ordre sup'erieur `a la Klop ou `a la Miller
[91, 95].

Cependant, nous avons montr'e dans [20] que le crit`ere de terminaison que nous
allons pr'esenter dans le chapitre suivant peut s'adapter, dans le cadre du *-calcul
simplement typ'e, `a la r'ecriture avec filtrage d'ordre sup'erieur `a la Klop ou `a la Miller.
Il serait donc int'eressant de chercher `a d'efinir une notion de r'ecriture avec filtrage
d'ordre sup'erieur en pr'esence de types polymorphes et d'ependants, et d''etudier si nos
conditions de terminaison peuvent 'egalement s'adapter `a cette notion de r'ecriture.

D'efinition 55 (Termes alg'ebriques) Un terme est alg'ebrique s'il est une variable ou s'il est de la forme f (~t) avec tous les ti eux-m^emes alg'ebriques. Nous
d'esignerons par T (F ; X ) l'ensemble des termes alg'ebriques b^atis `a partir de F et

1Pour cela, il suffit de traduire [x: T ]u par \Lambda (T; [x]u), (x: T )U par \Pi (T; [x]U) et uv par @(u; v),
o`u \Lambda , \Pi  et @ sont des symboles d'arit'e 2 et [ ] est l'op'erateur d'abstraction des CRS.

53

54 CHAPITRE 5. SYST `EMES DE TYPES ALG 'EBRIQUES
X , et par T(F; X ) l'ensemble des termes alg'ebriques typables.
D'efinition 56 (R'ecriture) Une r`egle de r'ecriture est une paire l ! r constitu'ee
de deux termes l et r tels que l est un terme alg'ebrique diff'erent d'une variable et
FV(r) ` FV(l). Une r`egle l ! r est lin'eaire-gauche si aucune variable n'appara^it
plus d'une fois dans l.

'Etant donn'e un ensemble R de r`egles de r'ecriture, la R-r'eduction !R est la

plus petite relation stable par substitution et contexte contenant R. Un terme de la
forme loe avec l ! r 2 R et oe une substitution est un R-radical .

'Etant donn'e un ensemble de symboles G, nous d'esignerons par RG l'ensemble

des r`egles qui d'efinissent un symbole de G, c'est-`a-dire l'ensemble des r`egles dont le
symbole de t^ete du membre gauche est un symbole de G.

Un symbole f est dit constant si Rffg = ;, sinon il est dit (partiellement) d'efini .
Nous d'esignerons par CF l'ensemble des symboles constants et par DF l'ensemble
des symboles d'efinis.

D'efinition 57 (ATS) Un ATS est un pr'e-RTS dont la relation de r'eduction ! est
de la forme !R [ !fi avec R un ensemble de r`egles de r'ecriture.

Maintenant que nous avons introduit notre notion de r'ecriture, nous pouvons
nous demander `a quelles conditions celle-ci est correcte vis-`a-vis de la relation de
typage.

Au premier ordre, dans les alg`ebres sort'ees, pour que la r'ecriture pr'eserve la
sorte des termes, il suffit que, dans toutes les r`egles, le membre gauche et le membre
droit aient la m^eme sorte.

Transpos'ee dans les syst`emes de types, cette condition donne : il existe un environnement \Gamma  et un type T tel que \Gamma  ` l : T et \Gamma  ` r : T . Cette condition est celle qui
a 'et'e retenue dans tous les travaux pr'ec'edents combinant *-calcul typ'e et r'ecriture.

Cependant, cette condition pr'esente un inconv'enient important. En pr'esence de
types polymorphes ou d'ependants, elle conduit `a des r`egles fortement non lin'eaires.
Cela a deux cons'equences importantes. Premi`erement, la r'ecriture est fortement
ralentie `a cause des tests d''egalit'e n'ecessaires. Deuxi`emement, il est plus difficile de
montrer la confluence en pr'esence de r`egles non lin'eaires.

Prenons l'exemple de la concat'enation de deux listes polymorphes dans le Calcul
des Constructions (S = f?; 2g, A = f(?; 2)g et B = f(s1; s2; s3) 2 S3 j s2 = s3g) :

- list 2 F 21 avec o/list = ? ! ? le constructeur de type des listes polymorphes,
- nil 2 F ?1 avec o/nil = (A : ?)list(A) la liste vide,
- cons 2 F ?3 avec o/cons = (A : ?)A ! list(A) ! list(A) la fonction ajoutant un

'el'ement en t^ete d'une liste,

- app 2 F ?3 avec o/app = (A : ?)list(A) ! list(A) ! list(A) la fonction de concat'enation de deux listes.

Une d'efinition naturelle de app est :
- app(A; nil(A); `0) ! `0
- app(A; cons(A; x; `); `0) ! cons(A; x; app(A; `; `0))

55
Cette d'efinition v'erifie bien la condition. Il suffit de prendre \Gamma  = A : ?; x :
A; ` : list(A); `0 : list(A) et T = list(A). Mais on peut se demander s'il est bien
n'ecessaire de faire le test d''egalit'e quand on veut appliquer la seconde r`egle. En
effet, si app(A; cons(A0; x; `); `0) est bien typ'e, alors, par inversion, cons(A0; x; `) est
de type list(A) et, par inversion encore, list(A0) est convertible `a list(A). Ainsi, autoriser la r'eduction m^eme si A0 est diff'erent de A ne semble pas poser de probl`eme
puisque list(A0) est convertible `a list(A).

En fait, ce qui est important, ce n'est pas que le membre gauche d'une r`egle
soit typable, c'est que si une instance du membre gauche est typable alors l'instance
correspondante du membre droit a le m^eme type. Nous exprimons cela en disant
qu'il doit exister un environnement \Gamma  dans lequel typer le membre droit, et une
substitution ae qui envoie les variables du membres gauches n'appartenant pas `a \Gamma 
sur des termes typables dans \Gamma . Ainsi, on peut consid'erer les r`egles suivantes :

- app(A; nil(A0); `0) ! `0
- app(A; cons(A0; x; `); `0) ! cons(A; x; app(A; `; `0))

en prenant \Gamma  = A : ?; x : A; ` : list(A); `0 : list(A) et ae = fA0 7! Ag. Dans [19],
nous donnons 5 conditions, (S1) `a (S5), qui doivent ^etre v'erifi'ees par la r`egle l ! r,
\Gamma  et ae. Supposons que l = f (~l), o/f = (~x : ~T )U et fl = f~x 7! ~lg. Alors, (S1) est
dom(ae) ` FV(l) n dom(\Gamma ) et (S2) est \Gamma  ` lae : U flae. Bien que ces deux premi`eres
conditions soient souvent r'ealis'ees, elles ne sont pas n'ecessaires pour montrer la
pr'eservation du typage. C'est pourquoi, dans la d'efinition suivante, elles ne figurent
pas. Cependant, nous verrons que (S2) est n'ecessaire pour montrer la normalisation
forte (voir D'efinition 81).

D'efinition 58 (R`egle bien typ'ee) Une r`egle l ! r est bien typ'ee s'il existe un
environnement \Gamma  et une substitution ae tels que, si l = f (~l), o/f = (~x : ~T )U et

fl = f~x 7! ~lg alors :

(S3) \Gamma  ` r : U flae,
(S4) pour tout \Delta , oe et T , si \Delta  ` loe : T alors oe : \Gamma  ! \Delta ,
(S5) pour tout \Delta , oe et T , si \Delta  ` loe : T alors, pour tout x, xoe # xaeoe.

Par la suite, nous 'ecrirons (l ! r; \Gamma ; ae) 2 R pour signifier que l ! r, \Gamma  et ae v'erifient
les hypoth`eses pr'ec'edentes.

Un exemple, utilisant un type d'ependant, nous est fourni par la concat'enation
de deux listes de longueurs donn'ees et la fonction map qui, `a une fonction f et une
liste a1 : : : an, associe la liste f (a1) : : : f (an) :

- T 2 F 20 avec o/T = ? une constante de type,
- nat 2 F 20 avec o/nat = ? le type des entiers naturels,
- 0 2 F ?0 avec o/0 = nat la constante z'ero,
- s 2 F ?1 avec o/s = nat ! nat la fonction successeur,
- + 2 F ?2 avec o/+ = nat ! nat ! nat l'addition sur nat,

56 CHAPITRE 5. SYST `EMES DE TYPES ALG 'EBRIQUES

- listn 2 F 21 avec o/listn = nat ! ? le constructeur de types des listes de longueur

n,

- niln 2 F ?0 avec o/niln = listn(0) la liste vide,
- consn 2 F ?3 avec o/consn = T ! (n : nat)listn(n) ! listn(s(n)) la fonction ajoutant un 'el'ement en t^ete d'une liste,

- appn 2 F ?4 avec o/appn = (n : nat)listn(n) ! (n0 : nat)listn(n0) ! listn(n + n0) la

fonction de concat'enation de deux listes,

- mapn 2 F ?3 avec o/mapn = (T ! T ) ! (n : nat)listn(n) ! listn(n) la fonction qui,

`a une fonction f : T ! T et une liste a1 : : : an, associe la liste f (a1) : : : f (an),

o`u +, appn et mapn sont d'efinies par :

- +(0; n0) ! n0
- +(s(n); n0) ! s(n + n0)
- appn(0; `; n0; `0) ! `0
- appn(p; consn(x; n; `); n0; `0) ! consn(x; n + n0; appn(n; `; n0; `0))
- mapn(f; 0; `) ! `
- mapn(f; p; consn(x; n; `)) ! consn(f x; n; mapn(f; n; `))
- mapn(f; p; appn(n; `; n0; `0)) ! appn(n; mapn(f; n; `); n0; mapn(f; n0; `0))

Pour la seconde r`egle de appn, on peut prendre \Gamma  = x : T; n : nat; ` : listn(n); n0 :
nat; `0 : listn(n0) et ae = fp 7! s(n)g. Cela nous 'evite d'avoir `a v'erifier que p est
convertible `a s(n).

Pour la troisi`eme r`egle de mapn, on peut prendre \Gamma  = f : T ! T; n : nat; ` :
listn(n); n0 : nat; `0 : listn(n0) et ae = fp 7! n + n0g. Cela nous 'evite d'avoir `a v'erifier
que p est convertible `a n + n0.

Le lecteur pourra trouver d'autres exemples dans le Sous-chapitre 7.2.

Lemme 59 (Correction de la r'ecriture) Si R est un ensemble de r`egles bien
typ'ees alors !R pr'eserve le typage.

Preuve. Nous proc'edons comme pour la correction de !fi. Nous ne d'etaillons
que le cas (symb) :

(symb)

` o/f : s \Gamma  valide \Gamma  ` t1 : T1fl : : : \Gamma  ` tn : Tnfl

\Gamma  ` f (~t) : U fl

(f 2 F sn;
o/f = (~x : ~T )U;

fl = f~x 7! ~tg)

Soit (l ! r; \Gamma 0; ae) 2 R avec l = f (~l), o/f = (~x : ~T )U et fl0 = f~x 7! ~lg. Supposons
que t = loe et montrons que \Gamma  ` roe : U fl. Par (S4), oe : \Gamma 0 ! \Gamma . Par (S3),
\Gamma 0 ` r : U fl0ae. Donc, par substitution, \Gamma  ` roe : U fl0aeoe. Par (S5), pour tout x,
xaeoe et xoe ont un r'eduit commun que nous appellerons tx. Donc, en r'eduisant
successivement dans U fl0aeoe chaque xaeoe `a tx, et dans U fl0oe chaque xoe 'a tx aussi,
on obtient U fl0aeoe # U fl0oe. Mais U fl0oe = U fl et, par inversion, il existe s0 tel que
\Gamma  ` U fl : s0. Donc, par (conv), \Gamma  ` roe : U fl0oe. \Xi 

Th'eor`eme 60 (Admissibilit'e) Un ATS logique dont toutes les r`egles de r'ecriture
sont bien typ'ees est un RTS, i.e. sa relation de r'eduction pr'eserve le typage.

57
Preuve. Pour !fi, cela d'ecoule du fait que l'ATS est logique. Pour !R, cela
d'ecoule de la correction de la r'ecriture. \Xi 

Comment s'assurer que les conditions (S3), (S4) et (S5) sont bien remplies ? Dans
toute leur g'en'eralit'e, elles sont s^urement ind'ecidables. D'une part, on ne sait pas si
` et # sont d'ecidables et, d'autre part, dans (S4) et (S5), nous quantifions arbitrairement sur \Delta , oe et T . Il est donc n'ecessaire de faire des hypoth`eses suppl'ementaires.
Nous envisageons successivement les trois conditions ci-apr`es.

Voyons (S3). En pratique, les symboles et les r`egles qui les d'efinissent sont souvent rajout'es les uns apr`es les autres (ou par paquets, mais l'argument qui suit peut
se g'en'eraliser). Soit (F ; R) un syst`eme dans lequel ` est d'ecidable (par exemple, un
syst`eme fonctionnel, confluent et fortement normalisant), f =2 F et Rf un ensemble
de r`egles d'efinissant f et dont tous les symboles appartiennent `a F 0 = F [ff g. Alors,
dans (F 0; R), ` est 'egalement d'ecidable. On peut donc chercher `a v'erifier (S3) dans
ce syst`eme. Cela ne nous para^it pas une grande restriction : il serait surprenant que
le typage d'une r`egle n'ecessite l'utilisation de la r`egle elle-m^eme !

Nous consid'erons maintenant (S4).
D'efinition 61 (Type canonique et type d'eriv'e) Soit t un terme de la forme loe
avec l = f (~l) alg'ebrique, o/f = (~x : ~T )U et fl = f~x 7! ~lg. Nous dirons que U floe est le
type canonique de t.

Soit p 2 Pos(l) avec p 6= ". Nous d'efinissons le type de tjp d'eriv'e de t , o/ (t; p), de
la mani`ere suivante :

- si p = i alors o/ (t; p) = Tifloe,
- si p = iq et q 6= " alors o/ (t; p) = o/ (ti; q).

Le type de tjp d'eriv'e de t ne d'epend en fait que du terme juste au-dessus de tjp
dans t.

Le lemme suivant nous montre que le type canonique de t et le type de tjp d'eriv'e
de t sont bien des types pour t et tjp respectivement.

Lemme 62 Soit t un terme de la forme loe avec l = f (~l) alg'ebrique et \Gamma  ` t : T , V
le type canonique de t et p 2 Pos(l) avec p 6= ". Dans un TSM quelconque, \Gamma  ` t : V
et \Gamma  ` tjp : o/ (t; p).

Preuve. De \Gamma  ` t : T , par inversion, on obtient imm'ediatement \Gamma  ` t : V .
Voyons \Gamma  ` tjp : o/ (t; p) maintenant. Comme p 6= ", nous avons p = qi, tjq de la forme

g(~koe) avec g(~k) alg'ebrique et tjq typable dans \Gamma . Supposons que o/g = (~x : ~T )U et
fl = f~x 7! ~kg. Alors, o/ (t; p) = Tifloe et, par inversion, \Gamma  ` tjp : Tifloe. \Xi 

Lemme 63 (S4) Soit l ! r une r`egle et \Gamma  un environnement. Si, pour tout x 2
dom(\Gamma ), il existe px 2 Pos(x; l) tel que o/ (l; px) = x\Gamma , alors (S4) est v'erifi'ee.

Preuve. Supposons \Delta  ` loe : T . Comme l est alg'ebrique, par inversion, \Delta  ` xoe :
o/ (loe; px) = o/ (l; px)oe = x\Gamma oe. \Xi 

58 CHAPITRE 5. SYST `EMES DE TYPES ALG 'EBRIQUES

Pour (S5), par contre, nous n'avons pas de r'esultat g'en'eral. Par le Lemme d'inversion, (S5) se ram`ene `a un probl`eme d'unification modulo #\Lambda . La confluence de ! (qui
implique #\Lambda =#) peut donc ^etre tr`es utile. Malheureusement, il y a peu de r'esultats
g'en'eraux sur la confluence de !R [ !fi (voir la discussion apr`es la D'efinition 91).
Par contre, on peut facilement montrer que la confluence locale est pr'eserv'ee.

Lemme 64 (Confluence locale) Si !R est localement confluente sur T (F; X )
alors !=!R [ !fi est localement confluente sur T .

Preuve. Nous 'ecrirons t !p t0 pour dire qu'il existe u tel que tjp ! u et
t0 = t[u0]p (r'eduction `a la position p). Supposons que t !p t1 et t !q t2 et montrons
par r'ecurrence sur t qu'il existe t0 tel que t1 !\Lambda  t0 et t2 !\Lambda  t0. Il y a trois cas :

ffl p et q n'ont pas de pr'efixe commun. Les r'eductions en p et q peuvent se faire en

parall`ele : t1 !q t01, t2 !p t02 et t01 = t02.

ffl p = ip0 et q = iq0. On peut conclure par hypoth`ese de r'ecurrence sur tji.
ffl p = " ou q = ". Quitte `a 'echanger les r^oles de p et q, on peut supposer que p = ".

Il y a alors deux cas :

- t = [x : V ]u v et t1 = ufx 7! vg. On peut distinguer trois sous-cas :

ffi q = 11q0 et V !q

0

V 0. Alors t0 = t1 convient.

ffi q = 12q0 et u !q

0

u0. Alors t0 = u0fx 7! vg convient.

ffi q = 2q0 et v !q

0

v0. Alors t0 = ufx 7! v0g convient.

- t = loe, l ! r 2 R et t1 = roe. Il existe un terme alg'ebrique u de taille maximale

et une substitution ` tels que t = u` et x` = y` implique x = y (u et `
sont uniques au choix des variables pr`es et u a les m^emes non-lin'earit'es que t).
Comme les membres gauches des r`egles sont alg'ebriques, u = loe0 et oe = oe0`.
Maintenant, on peut distinguer deux sous-cas :

ffi q 2 Pos(u). Comme les membres gauches des r`egles sont alg'ebriques, nous

avons u !R roe0 et u !R v. Par confluence locale de !R sur T (F ; X ), il existe
u0 tel que roe0 !\Lambda  u0 et v !\Lambda  u0. Ainsi, t1 = roe0` !\Lambda  u0` et t2 = v` !\Lambda  u0`.

ffi q = q1q0 et ujq1 = x. Soit q2; : : : ; qn les positions des autres occurrences de x

dans u. Si on r'eduit t2 `a chaque position qiq0, on obtient un terme de la forme
loe0`0 o`u `0 est la substitution 'egale `a ` sauf en x o`u elle est 'egale au r'eduit de
x`. Il suffit alors de prendre t0 = roe0`0. \Xi 

Chapitre 6
Conditions de Normalisation
Forte

Dans ce chapitre, nous allons donner des conditions de normalisation forte pour
les ATS bas'e sur le Calcul des Constructions.

D'efinition 65 (CAC) Un Calcul des Constructions Alg'ebriques (CAC) est un
ATS (S; F ; X ; A; B; o/; R) tel que S = f?; 2g, A = f(?; 2)g et B = f(s1; s2; s3) 2
S3 j s2 = s3g.

Un CAC est un ATS injectif et r'egulier.

6.1 Classification des termes

D'apr`es les lemmes de s'eparation et de classification, les termes typables sont
divis'es en trois classes disjointes : T20 , T21 et T?1. Pour les d'esigner, nous allons
introduire des notations plus explicites.

D'efinition 66 (Classes de typage)

- Soit K = T20 la classe des types de pr'edicats .
- Soit P = T21 la classe des pr'edicats .
- Soit O = T?1 la classe des objets .

Qu'un terme appartienne `a l'une de ces trois classes peut ^etre facilement d'ecid'e
en introduisant les classes syntaxiques suivantes :

D'efinition 67 (Classes syntaxiques)

ffl La classe syntaxique K des types de pr'edicats :

- ? 2 K,
- si x 2 X , T 2 T et K 2 K alors (x : T )K 2 K.
ffl La classe syntaxique P des pr'edicats :

- X 2 ` P,

59

60 CHAPITRE 6. CONDITIONS DE NORMALISATION FORTE

- si x 2 X , T 2 T et P 2 P alors (x : T )P 2 P et [x : T ]P 2 P,
- si P 2 P et t 2 T alors P t 2 P,
- si F 2 F 2n et t1; : : : ; tn 2 T alors F (~t) 2 P.
ffl La classe syntaxique O des objets :

- X ? ` O,
- si x 2 X , T 2 T et u 2 O alors [x : T ]u 2 O,
- si u 2 O et t 2 T alors ut 2 O,
- si f 2 F ?n et t1; : : : ; tn 2 T alors f (~t) 2 O.

Lemme 68 Les classes syntaxiques sont deux `a deux disjointes et chaque classe de
typage est incluse dans la classe syntaxique qui lui correspond : K ` K, P ` P et
O ` O.

Preuve. Que les classes syntaxiques soit deux `a deux disjointes d'ecoule imm'ediatement de leur d'efinition. Montrons que si \Gamma  ` t : T alors t appartient `a la classe
syntaxique correspondant `a sa classe de typage, par r'ecurrence sur \Gamma  ` t : T . Nous
suivons les notations des r`egles de typage.

(ax) Comme A = f(?; 2)g, nous avons n'ecessairement s1 = ? et s2 = 2. Or,

? 2 K " K.

(symb) Par inversion et r'egularit'e, \Gamma  ` U fl : s. Donc, si f 2 F ? alors f (~t) 2 O " O,

et si f 2 F 2 alors f (~t) 2 P " P.

(var) Si x 2 X ? alors x 2 O " O, et si x 2 X 2 alors x 2 P " P.
(weak) Par hypoth`ese de r'ecurrence.
(prod) Par r'egularit'e, U et (x : T )U ont le m^eme type. On peut donc conclure par

hypoth`ese de r'ecurrence sur U .

(abs) Par inversion et r'egularit'e, (x : T )U et U ont le m^eme type. On peut donc

conclure par hypoth`ese de r'ecurrence sur u.

(app) Par inversion et r'egularit'e, V fx 7! ug et (x : U )V ont le m^eme type. On peut

donc conclure par hypoth`ese de r'ecurrence sur t.

(conv) Par correction de la conversion, T et T 0 ont le m^eme type. On peut donc

conclure par hypoth`ese de r'ecurrence. \Xi 

6.2 Types inductifs et constructeurs

Jusqu'`a maintenant, nous n'avons fait que tr`es peu d'hypoth`eses sur les symboles
et les r`egles qui les d'efinissent. Or N. P. Mendler [89] a montr'e que dans le *-
calcul simplement typ'e, si un type et ses constructeurs ne v'erifient pas une certaine
condition de positivit'e, alors autoriser des d'efinitions par r'ecursion sur de tels types
permet de d'efinir des termes bien typ'es qui ne sont pas normalisants. Il a 'egalement
montr'e que, r'eciproquement, si tous les types sont positifs alors les d'efinitions par
r'ecursion sont fortement normalisantes.

6.2. TYPES INDUCTIFS ET CONSTRUCTEURS 61

N. P. Mendler dit qu'un type de base T appara^it positivement dans un type U
si toutes les occurrences de T dans U sont `a gauche d'un nombre pair de !. Enfin,
il dit qu'un type T est positif si T appara^it positivement dans le type de chacun des
arguments de ses constructeurs. Ainsi, les types usuels tels que le type des entiers
naturels ou le type des listes d'entiers naturels sont des types positifs.

Voyons un exemple de type T non positif. Soit U un type. Supposons que T ait
pour constructeur le symbole c de type (T ! U ) ! T . Alors, T n'est pas positif car
T appara^it `a une position n'egative dans T ! U . Consid'erons maintenant la fonction
p de type T ! (T ! U ) d'efinie par la r`egle p(c(x)) ! x. Si on prend ! : T ! U =
*x:p(x)x, alors on v'erifie ais'ement que !c(!) : U n'est pas normalisant :

!c(!) !fi p(c(!))c(!) !R !c(!) !fi : : :
Dans le cas o`u U = ?, on peut interpr'eter cela comme le Th'eor`eme de Cantor,
`a savoir : il n'y a pas de surjection d'un ensemble T dans l'ensemble de ses parties
T ! ?. Dans cette interpr'etation, p est l'injection naturelle entre T et T ! ?.
Dire que p est surjective est 'equivalent `a dire (avec l'axiome du choix) qu'il existe
c tel que p ffi c soit l'identit'e, c'est-`a-dire, tel que p(c(x)) ! x. Dans [46], G. Dowek
montre qu'une telle hypoth`ese est incoh'erente. Ici, nous montrons le lien avec la
non-normalisation des types non-positifs.

N. P. Mendler donne 'egalement une condition, la positivit'e forte, dans le cas de
types d'ependants et polymorphes. Une notion similaire mais plus restreinte, la positivit'e stricte, est utilis'ee par T. Coquand et C. Paulin pour le Calcul des Constructions Inductives [36]. Enfin, le travail de N. P. Mendler a 'et'e 'etendu par R. Matthes
[85, 86].

Nous introduisons ci-apr`es la notion plus g'en'erale de structure inductive admissible . En particulier, nous ne consid'ererons pas qu'un constructeur soit constant :
il sera possible d'avoir des r`egles de r'ecriture sur les constructeurs 'egalement. Cela
nous permettra d'avoir des types quotients tels que le type int des entiers relatifs
qu'on peut d'efinir de la mani`ere suivante :

- int 2 F 20 avec o/int = ? le type des entiers relatifs,
- 0 2 F ?0 avec o/0 = int la constante z'ero,
- s 2 F ?1 avec o/s = int ! int la fonction successeur,
- p 2 F ?1 avec o/p = int ! int la fonction pr'ed'ecesseur,
o`u s et p sont d'efinis par :

- s(p(x)) ! x
- p(s(x)) ! x

D'efinition 69 (Constructeurs) Soit C un symbole de pr'edicat constant. Un symbole f est constructeur de C si o/f est de la forme (~y : ~U )C(~v) avec fff = j~yj. Nous
d'esignerons par Co(C) l'ensemble des constructeurs de C.

Notre notion de constructeur non seulement inclut les constructeurs habituels,
constants, mais 'egalement tout symbole permettant de produire des termes de type
C. Par exemple :

62 CHAPITRE 6. CONDITIONS DE NORMALISATION FORTE

- + 2 F ?2 avec o/+ = int ! int ! int la fonction d'addition sur int,
- \Theta  2 F ?2 avec o/\Theta  = int ! int ! int la fonction de multiplication sur int,

ou, dans le cas des listes polymorphes :

- app 2 F ?3 avec o/app = (A : ?)list(A) ! list(A) ! list(A) la fonction de concat'enation.

Remarquons que, si un symbole de pr'edicat doit avoir des constructeurs, alors
son arit'e ne peut pas ^etre prise n'importe comment :

D'efinition 70 (Arit'e maximale) Nous dirons qu'un symbole de pr'edicat F est
d'arit'e maximale si o/F = (~x : ~T )? et ffF = j~xj.

Lemme 71 Soit C un symbole de pr'edicat constant et c un constructeur de C.
Dans un CAC logique, si ` o/C : 2 et ` o/c : s alors s = ? et C est d'arit'e maximale.

Preuve. Supposons que o/C = (~x : ~V )W et o/c = (~y : ~U )C(~v). Posons fl = f~x 7!
~vg. Comme 2 est une sorte maximale et ` o/C : 2, d'apr`es le lemme sur les sortes

maximales, W est de la forme (~x0 : ~V 0)?. Maintenant, de ` o/c : s, par inversion et
r'egularit'e, on d'eduit que \Gamma c ` C(~v) : s, \Gamma c ` C(~v) : W fl et W fl C \Lambda \Gamma c s. Comme
\Gamma c ` W fl : 2, par correction de la conversion, \Gamma c ` s : 2 et, par inversion, s = ?.
Donc, d'apr`es le lemme sur les sortes maximales, j~x0j = 0 et W = ?. \Xi 

D'efinition 72 (Structure inductive) Une structure inductive est donn'ee par :

ffl un pr'e-ordre *C sur CF 2 dont la partie stricte, ?C, est bien fond'ee ;
ffl pour chaque symbole de pr'edicat constant C, un ensemble Ind(C) ` f1; : : : ; ffC g

dit des positions inductives de C tel que si o/C = (~x : ~T )? et i 2 Ind(C) alors
xi 2 X 2 ;

ffl pour chaque constructeur c, un ensemble Acc(c) ` f1; : : : ; ffcg dit des positions

accessibles de c.

Les positions accessibles permettent de d'esigner les arguments des constructeurs
qu'on veut utiliser dans les membres droits des r`egles de r'ecriture. Les positions
inductives permettent de d'esigner les param`etres en lesquels un constructeur de
type doit ^etre monotone.

D'efinition 73 (Positions positives et n'egatives) Soit T 2 T n O. L'ensemble
des positions positives de T , Pos+(T ), et l'ensemble des positions n'egatives de T ,
Pos\Gamma (T ), sont simultan'ement d'efinis par r'ecurrence sur la structure de T de la
mani`ere suivante :

- Pos+(s) = Pos+(F (~t)) = Pos+(X) = ",
- Pos\Gamma (s) = Pos\Gamma (F (~t)) = Pos\Gamma (X) = ;,
- Posffi((x : V )W ) = 1:Pos\Gamma ffi(V ) [ 2:Posffi(W ),
- Posffi([x : V ]W ) = 1:Pos(V ) [ 2:Posffi(W ),
- Posffi(V u) = 1:Posffi(V ) [ 2:Pos(u),

6.2. TYPES INDUCTIFS ET CONSTRUCTEURS 63

- Posffi(V U ) = 1:Posffi(V ),
- Pos+(C(~t)) = f"g [

S

fi:Pos+(ti) j i 2 Ind(C)g,

- Pos\Gamma (C(~t)) =

S

fi:Pos\Gamma (ti) j i 2 Ind(C)g,

o`u ffi 2 f\Gamma ; +g, \Gamma + = \Gamma , \Gamma \Gamma  = + (r`egle habituelle des signes). L'ensemble des
positions neutres de T est Pos0(T ) = Pos+(T ) " Pos\Gamma (T ). L'ensemble des positions
non-neutres de T est Pos6=0(T ) = (Pos+(T ) [ Pos\Gamma (T )) n Pos0(T ).

Les positions positives et n'egatives ne forment pas deux ensembles disjoints. Leur
intersection forme les positions neutres. Par exemple, toutes les positions de u dans
V u ou toutes les positions de V dans [x : V ]W sont neutres. Nous verrons dans le
Sous-chapitre 8.3 que ces sous-termes ne prennent pas part 'a l'interpr'etation d'un
type.

Dans [19], nous donnons 6 conditions, (I1) `a (I6), pour d'efinir ce qu'est une
structure inductive admissible. Mais il est en fait possible d''eliminer la condition
(I1) en modifiant l'eg`erement la condition (I2). C'est pourquoi, dans la d'efinition
suivante, (I1) ne figure pas et (I2) est plac'e apr`es (I6).

D'efinition 74 (Structures inductives admissibles) Une structure inductive
est admissible si, pour tout pr'edicat constant C, pour tout constructeur c de type
(~y : ~U )C(~v) et pour tout j 2 Acc(c) :

(I3) 8D 2 CF 2; D =C C ) Pos(D; Uj) ` Pos+(Uj) (les symboles 'equivalents `a C

doivent ^etre `a des positions positives),

(I4) 8D 2 CF 2; D ?C C ) Pos(D; Uj) ` Pos0(Uj) (les symboles plus grands que

C doivent ^etre `a des positions neutres),

(I5) 8F 2 DF 2; Pos(F; Uj) ` Pos0(Uj) (les symboles de pr'edicat d'efinis doivent

^etre `a des positions neutres),

(I6) 8 Y 2 FV2(Uj); 9 'Y ^ ffC ; v'Y = Y (toute variable de pr'edicat de Uj doit ^etre

param`etre de C),

(I2) 8 Y 2 FV2(Uj); 'Y 2 Ind(C) ) Pos(Y; Uj) ` Pos+(Uj) (toute variable de

pr'edicat de Uj qui est param`etre inductif de C doit ^etre `a une position positive).

Par exemple, Ind(list) = f1g, Acc(nil) = f1g et Acc(cons) = f1; 2; 3g forme une
structure inductive admissible. Soit maintenant :

- tree 2 F 20 avec o/tree = ? le type des arbres `a branchement fini et
- node 2 F ?1 avec o/node = list(tree) ! tree son constructeur.

Comme 1 2 Ind(list), Ind(tree) = ; et Acc(node) = f1g forme une structure
inductive admissible.

Autoriser des symboles plus grands ou d'efinis n'a pas d'importance du moment
qu'ils n'apparaissent qu'`a des positions neutres car les sous-termes neutres ne sont
pas pris en compte dans l'interpr'etation d'un type.

64 CHAPITRE 6. CONDITIONS DE NORMALISATION FORTE

La condition (I6) signifie que les arguments-pr'edicats d'un constructeur doivent
^etre des param`etres du type dont il est le constructeur. Une condition similaire

appara^it dans les travaux de M. Stefanova [108] ("safeness") et D. Walukiewicz
[117] ("?-dependancy"). Par contre, dans le Calcul des Constructions Inductives
(CIC) [99], il n'y a pas de telle restriction. Cependant, en examinant les r`egles de
typage des sch'emas d''elimination, il appara^it qu'aucune fonction int'eressante ne
peut ^etre d'efinie sur un type ne v'erifiant pas cette condition.

Prenons comme exemple le type des listes h'et'erog`enes non vide (nous suivons la
syntaxe CIC) :

- listh = Ind(X : ?)fC1jC2g o`u C1 = (A : ?)(x : A)X et C2 = (A : ?)(x : A)X ! X,
- endh = Constr(1; listh),
- consh = Constr(2; listh).

La r`egle de typage du sch'ema d''elimination non d'ependant (Nodep?;?) est :

\Gamma  ` ` : listh \Gamma  ` Q : ? \Gamma  ` f1 : C1flisth; Qg \Gamma  ` f2 : C2flisth; Qg

\Gamma  ` Elim(`; Q)ff1jf2g : Q

o`u C1flisth; Qg = (A : ?)(x : A)Q et C2flisth; Qg = (A : ?)(x : A)listh ! Q ! Q.
Ainsi, Q, f1 et f2 doivent ^etre typables dans \Gamma . Le r'esultat de f1 ou f2 ne peut donc
pas d'ependre de A ou de x. Cela signifie qu'il est possible de calculer la longueur
d'une telle liste par exemple, mais qu'on ne peut pas en extraire un 'el'ement. Or, la
longueur d'une telle liste est une information qui peut s^urement ^etre obtenue sans
utiliser une telle structure de donn'ees.

Parmi l'ensemble des symboles de pr'edicat appartenant `a une structure inductive, on peut distinguer diff'erentes cat'egories.

D'efinition 75 (Pr'edicats primitifs, basiques et strictement positifs)
Un symbole de pr'edicat constant C est :

- primitif si, pour tout D =C C, pour tout constructeur d de type o/d = (~y : ~U )D( ~w)

et pour tout j 2 Acc(d), Uj est soit de la forme E(~t) avec E !C D et E primitif,
soit de la forme E(~t) avec E =C D.

- basique si, pour tout D =C C, pour tout constructeur d de type o/d = (~y : ~U )D( ~w)

et pour tout j 2 Acc(d), si E =C D appara^it dans Uj alors Uj est de la forme
E(~t).

- strictement positif si, pour tout D =C C, pour tout constructeur d de type o/d =

(~y : ~U )D( ~w) et pour tout j 2 Acc(d), si E =C D appara^it dans Uj alors Uj est de
la forme (~z : ~V )E(~t) et aucune occurrence de D0 =C D n'appara^it dans les Vi.

Il est ais'e de voir qu'un pr'edicat primitif est basique et qu'un pr'edicat basique
est strictement positif. Le type listn des listes de longueur n est primitif. Le type
list des listes polymorphes est basique mais non-primitif.

6.2. TYPES INDUCTIFS ET CONSTRUCTEURS 65

Les pr'edicats strictement positifs sont les pr'edicats qui sont autoris'es dans le
Calcul des Constructions Inductives. Comme exemple, on peut citer le type des
arbres bien fond'es ou ordinaux de Brouwer1 :

- ord 2 F 20 avec o/ord = ? le type des ordinaux de Brouwer,
- 0 2 F ?0 avec o/0 = ord l'ordinal z'ero,
- s 2 F ?1 avec o/s = ord ! ord l'ordinal successeur,
- lim 2 F ?1 avec o/lim = (nat ! ord) ! ord l'ordinal limite.

Un autre exemple nous est donn'e par l'alg`ebre de processus qui utilise un op'erateur de choix \Sigma  d'ependant de la donn'ee qui lui est fournie [107] :

- data 2 F 20 avec o/data = ? le type des donn'ees,
- proc 2 F 20 avec o/proc = ? le type des processus,
- ffi 2 F ?2 avec o/ffi = proc ! proc ! proc la mise en s'equence de deux processus,
- + 2 F ?2 avec o/+ = proc ! proc ! proc la mise en parall`ele de deux processus,
- ffi 2 F ?0 avec o/ffi = proc le processus bloquant (deadlock en anglais),
- \Sigma  2 F ?1 avec o/\Sigma  = (data ! proc) ! proc le choix d'un processus selon une

donn'ee.

Un dernier exemple est celui des formules du calcul des pr'edicats du premier
ordre :

- term 2 F 20 avec o/term = ? le type des termes,
- f orm 2 F 20 avec o/form = ? le type des formules,
- . 2 F ?2 avec o/. = f orm ! f orm ! f orm le "ou" de deux formules,
- : 2 F ?1 avec o/: = f orm ! f orm le "non" d'une formule,
- 8 2 F ?1 avec o/8 = (term ! f orm) ! f orm la quantification universelle.

Pour l'instant, nous n'interdisons pas d'avoir des pr'edicats positifs non stricts.
Toutefois, dans le sous-chapitre suivant, nous verrons que, dans leur 'etat actuel, les
conditions sur les r`egles de r'ecriture ne permettent pas de d'efinir des fonctions sur
des pr'edicats positifs non stricts.

Les types positifs non stricts peuvent pourtant ^etre utiles comme nous le montre
cette exemple d'affichage en largeur des labels d'un arbre binaire `a l'aide de continuations [87] :

- tree 2 F 20 avec o/tree = ? le type des arbres binaires,
- L 2 F?1 avec o/L = nat ! tree le constructeur "feuille",
- N 2 F ?3 avec o/N = nat ! tree ! tree ! tree le constructeur "noeud",

1Un terme de type ord de la forme lim(f) ne correspond pas forc'ement `a un ordinal limite.
Toutefois, si on choisit bien les fonctions f, on peut repr'esenter un certain segment initial des
ordinaux d'enombrables.

66 CHAPITRE 6. CONDITIONS DE NORMALISATION FORTE

- list 2 F 20 avec o/list = ? le type des listes d'entiers,
- nil 2 F ?0 avec o/nil = list la liste vide,
- cons 2 F ?2 avec o/cons = nat ! list ! list l'ajout d'un 'el'ement en t^ete,

- cont 2 F 20 avec o/cont = ? le type des continuations,
- D 2 F?0 avec o/D = cont,
- C 2 F ?1 avec o/C = ((cont ! list) ! list) ! cont les constructeurs de continuations,

- @ 2 F ?2 avec o/@ = cont ! (cont ! list) ! list l'application sur les continuations

d'efinie par :

- @(D; g) ! g D
- @(C(f ); g) ! f g

- ex 2 F ?1 avec o/ex = cont ! list l'it'erateur sur les continuations d'efini par :
- ex(D) ! nil
- ex(C(f )) ! f [k : cont]ex(k)

- br 2 F?2 avec o/br = tree ! cont ! cont,
- br fst 2 F ?1 avec o/br fst = tree ! list la fonction d'affichage en largeur des labels

d'efinie par :

- br fst(t) ! ex(br(t; D))
- br(L(x); k) ! C([g : cont ! list]cons(x; @(k; g)))
- br(N (x; s; t); k) ! C([g : cont ! list]cons(x; @(k; [m : cont]g br(s; br(t; m))))

Il est connu qu'une telle d'efinition est fortement normalisante car elle peut ^etre
cod'ee dans le *-calcul polymorphe [85, 86]. Cependant, il n'est pas clair comment
d'efinir une condition syntaxique, un sch'ema, qui permette d'assurer la normalisation d'une telle d'efinition. En effet, dans le membre droit de la seconde r`egle de
ex, ex n'est explicitement appliqu'e `a aucun argument plus petit que f . Mais il ne
pourra ^etre appliqu'e qu'`a des sous-termes de r'eduits de f . Malheureusement, pas
tous les sous-termes d'un terme calculable ne sont a priori calculables (voir le Paragraphe 6.3.2).

6.3 Sch'ema G'en'eral
6.3.1 R'ecriture d'ordre sup'erieur

Nous allons maintenant nous int'eresser aux r`egles de r'ecriture. Quelles conditions
peuvent nous permettre d'assurer la normalisation forte de !=!R [ !fi ? Depuis
les travaux de V. Breazu-Tannen et J. Gallier [24] et M. Okada [97] sur le *-calcul
simplement typ'e et le *-calcul polymorphe, puis les travaux de F. Barbanera [4] sur
le Calcul des Constructions et de D. Dougherty [44] sur le *-calcul pur, il est bien
connu que l'ajout de r'ecriture du premier ordre au niveau objet `a un *-calcul typ'e

6.3. SCH 'EMA G 'EN 'ERAL 67
pr'eserve la normalisation forte. Cela vient du fait que la r'ecriture du premier ordre
ne peut pas cr'eer de nouveaux fi-radicaux. Nous montrerons que ce r'esultat, sous
certaines conditions, s''etend 'egalement `a la r'ecriture au niveau des pr'edicats.

Cependant, il y a de nombreuses fonctions tr`es utiles dont la d'efinition par
r'ecriture ne rentre pas dans ce contexte de la r'ecriture de premier ordre, soit par
ce que certains de ses arguments ne sont pas de type primitif (la fonction app de
concat'enation de deux listes polymorphes), soit par ce que leur d'efinition exploite les
possibilit'es offertes par l'ordre sup'erieur. C'est le cas par exemple de la fonction map
qui, `a une fonction f (argument d'ordre sup'erieur) et une liste a1 : : : an d''el'ements,
associe la liste f (a1) : : : f (an) :

- map 2 F ?4 avec o/map = (A : ?)(B : ?)(A ! B) ! list(A) ! list(B),
- map(A; B; f; nil(A0)) ! nil(B)
- map(A; B; f; cons(A0; x; `)) ! cons(B; f x; map(A; B; f; `))
- map(A; B; f; app(A0; `; `0)) ! app(B; map(A; f; `); map(A; f; `0))

C'est 'egalement le cas des r'ecurseurs ou principes de r'ecurrence qu'on peut
associer aux pr'edicats inductifs (le r'ecurseur 'etant une version non d'ependante du
principe de r'ecurrence). Voyons par exemple le cas du r'ecurseur sur nat qui peut
nous permettre de d'efinir des fonctions par r'ecurrence (mais, bien s^ur, on pr'ef'erera
donner une d'efinition directement `a l'aide de r`egles de r'ecriture !) :

- natrec 2 F ?4 avec o/natrec = (A : ?)A ! (nat ! A ! A) ! nat ! A,
- natrec(A; x; f; 0) ! x
- natrec(A; x; f; s(n)) ! f n natrec(A; x; f; n)
- plus 2 F ?0 avec o/plus = nat ! nat ! nat l'addition sur les entiers d'efini `a l'aide

du r'ecurseur :

- plus ! [p : nat][q : nat]natrec(nat; p; [q0 : nat][r : nat]s(r); q)
et du principe de r'ecurrence sur nat, qui nous permet de repr'esenter des preuves
par r'ecurrence sur les entiers :

- natind 2 F ?4 avec o/natind = (P : nat ! ?)P 0 ! ((n : nat)P n ! P s(n)) ! (n :

nat)P n,

- natind(P; h0; hs; 0) ! h0
- natrec(P; h0; hs; s(n)) ! hs n natind(P; h0; hs; n)

Les m'ethodes utilis'ees dans les travaux pr'ec'edemment cit'es ne peuvent pas ^etre
appliqu'ees `a notre calcul car, d'une part, contrairement `a la r'ecriture du premier
ordre, la r'ecriture d'ordre sup'erieur peut cr'eer des fi-radicaux, et d'autre part, la
r'ecriture est incluse dans la r`egle de conversion (conv) ce qui permet `a davantage de
termes d'^etre typ'es.

Mais il existe d'autres m'ethodes, valables dans le *-calcul simplement typ'e seulement ou dans des syst`emes de types plus riches, pour montrer la terminaison de ce
type de d'efinitions :

68 CHAPITRE 6. CONDITIONS DE NORMALISATION FORTE

ffl Le Sch'ema G'en'eral , initialement formul'e par J.-P. Jouannaud et M. Okada [72]

pour le *-calcul polymorphe et 'etendu au Calcul des Constructions par F. Barbanera, M. Fern'andez et H. Geuvers [7], est essentiellement une extension du sch'ema
de r'ecursion primitive : dans le membre droit d'une r`egle f (~l) ! r, les appels `a f
doivent se faire sur des sous-termes strictes de ~l. Il permet de traiter des d'efinitions
au niveau objet de symboles simplement typ'es d'efinis sur des types primitifs. Il
a ensuite 'et'e reformul'e et 'etendu aux types simples strictement positifs par J.-P.
Jouannaud, M. Okada et moi-m^eme pour le *-calcul simplement typ'e [22] et le
Calcul des Constructions [21].

ffl Le Higher-Order Recursive Path Ordering (HORPO) de J.-P. Jouannaud et A.

Rubio [74] 2 est une extension aux termes du *-calcul simplement typ'e de l'ordre
RPO [100, 42] utilis'e au premier ordre. Il a 'et'e r'ecemment 'etendu par D. Walukiewicz [117] au Calcul des Constructions avec des symboles de type polymorphe
et d'ependant, mais toujours au niveau objet et sur des types basiques. Le Sch'ema
G'en'eral peut ^etre vu comme une version non-r'ecursive de HORPO.

ffl Il est 'egalement possible de chercher une interpr'etation pour chacun des symboles

de telle sorte que l'interpr'etation d'un terme d'ecroisse strictement quand on lui
applique une r`egle. Cette m'ethode, introduite par J. van de Pol pour le *-calcul
simplement typ'e [115], 'etend `a l'ordre sup'erieur la m'ethode des interpr'etations
connue au premier ordre. C'est donc une m'ethode tr`es puissante mais difficile `a
utiliser en pratique, d'une part parce que les interpr'etations sont bien s^ur ellesm^emes d'ordre sup'erieur, et d'autre part parce qu'elle est tr`es peu modulaire :
rajouter de nouvelles r`egles ou de nouveaux symboles n'ecessite de trouver une
nouvelle interpr'etation et de red'emontrer sa stricte monotonie.

Pour traiter la r'ecriture au niveau des pr'edicats, avec des symboles de type polymorphe et d'ependant et des types strictement positifs, nous avons choisi d''etendre
la m'ethode du Sch'ema G'en'eral. C'est cette extension que nous allons pr'esenter dans
le reste de ce sous-chapitre.

Cependant, le Sch'ema G'en'eral ne repr'esente qu'une partie des conditions de
normalisation forte, celle concernant la r'ecriture d'ordre sup'erieur. Comme dans les
travaux pr'ec'edents [72, 7], une autre partie des conditions concerne la r'ecriture du
premier ordre que nous 'etendons ici au niveau des types.

6.3.2 D'efinition du sch'ema

`A vrai dire, les conditions que nous allons pr'esenter ci-apr`es ne se comprennent
pleinement qu'`a la lumi`ere de la m'ethode employ'ee pour montrer la normalisation
forte, `a savoir la m'ethode de Tait et Girard des candidats de r'eductibilit'e [111, 62].
Grosso modo, cette m'ethode consiste `a associer un ensemble de termes fortement
normalisables, les termes calculables , `a chaque type et `a montrer que tout terme
bien typ'e appartient `a l'ensemble associ'e `a son type.

2Signalons 'egalement les travaux pr'ec'edents de C. Loria-Saenz et J. Steinbach [79], O. Lysne et
J. Piris [82] et J.-P. Jouannaud et A. Rubio [75].

6.3. SCH 'EMA G 'EN 'ERAL 69

L'id'ee du Sch'ema G'en'eral est alors de d'efinir, `a partir d'un membre gauche de
r`egle f (~l), un ensemble de termes dont on peut prouver la calculabilit'e si les li sont
eux-m^emes calculables. Nous appelons cet ensemble la cl^oture calculable de f (~l).
Pour montrer la terminaison d'une d'efinition, il suffit alors de v'erifier que, pour
chaque r`egle, le membre droit appartient `a la cl^oture calculable du membre gauche.

Pour construire la cl^oture calculable, dans un premier temps, nous d'efinissons,
parmi les sous-termes des li, un sous-ensemble dont les 'el'ements sont calculables si
les li sont calculables. Nous appellerons ces sous-termes les sous-termes accessibles .
Nous ne consid'erons qu'un sous-ensemble car pas tous les sous-termes d'un terme
calculable sont a priori calculables. Alors, nous construirons la cl^oture calculable en
appliquant `a ces sous-termes accessibles des op'erations pr'eservant la calculabilit'e.

Pour pouvoir d'efinir des fonctions int'eressantes, parmi ces op'erations, on doit
trouver celle consistant `a appliquer des arguments `a f (r'ecursivit'e). Se pose alors le
probl`eme d'avoir un ordre bien fond'e dans lequel les arguments d'ecroissent strictement. La relation sous-terme strict \Lambda  (en fait restreinte aux sous-termes accessibles
pour pr'eserver la calculabilit'e) est suffisante pour traiter toutes les d'efinitions sur
des types basiques. Dans l'exemple de map, ` et `0 sont des sous-termes stricts accessibles de app(A0; `; `0). Par contre, sur les types strictement positifs, cela n'est pas
suffisant comme le montre la d'efinition suivante d'une "addition" sur les ordinaux
de Brouwer :

- + 2 F ?2 avec o/+ = ord ! ord ! ord,
- +(x; 0) ! x
- +(x; s(y)) ! s(+(x; y))
- +(x; lim(f )) ! lim([n : nat] + (x; f n))

Un autre exemple nous est donn'e par les r`egles de simplification de l'alg`ebre de
processus proc [107] :

- +(p; p) ! p
- +(p; ffi) ! p
- . . .
- ffi(\Sigma (f ); p) ! \Sigma ([d : data] ffi (f d; p))

C'est pourquoi, dans la suite, nous utiliserons deux ordres distincts. Le premier,
?1, servira pour les arguments de type basique. Le second, ?2, servira pour les
arguments de type strictement positif.

Enfin, pour apporter plus de souplesse dans la comparaison des arguments des
fonctions, `a chaque symbole, nous associerons un statut qui d'ecrit comment comparer deux s'equences d'arguments `a l'aide d'une combinaison simple de comparaisons
lexicographiques et multi-ensembles [73].

D'efinition 76 (Relations d'accessibilit'e) Soit c un constructeur de type (~y :

~U )C(~v), ~u des arguments de c, fl = f~y 7! ~ug et j 2 Acc(c) une position accessible

de c. Alors :

70 CHAPITRE 6. CONDITIONS DE NORMALISATION FORTE

ffl uj : U est faiblement accessible modulo ae dans c(~u) : T , c(~u) : T \Lambda ae1 uj : U , si

T ae = C(~v)flae et U ae = Ujflae.

ffl uj : U est fortement accessible modulo ae dans c(~u) : T , c(~u) : T \Lambda ae2 uj : U , si

T ae = C(~v)flae, U ae = Ujflae et Uj est de la forme (~x : ~T )D( ~w).

Ces relations d'accessibilit'e vont nous servir `a d'efinir les ordres ?1 et ?2. Nous
avons \Lambda ae2 ` \Lambda ae1. Pour des raisons techniques, nous prenons en compte non seulement
les termes mais 'egalement leur type. Cela est d^u au fait que nous ne sommes en
mesure de montrer que deux types convertibles ont la m^eme interpr'etation que si
ces deux types sont calculables. Cela induit certaines restrictions sur les types des
symboles.

En effet, l'accessibilit'e impose l''egalit'e (modulo l'application de ae) entre les types
canoniques et les types d'eriv'es (voir D'efinition 61). Plus pr'ecis'ement, pour que
t : T \Lambda ae1 u : U , il faut que T soit 'egal (modulo ae) au type canonique de t et U au
type de u d'eriv'e de t. Si de plus u : U \Lambda ae1 v : V , on voit alors que U doit aussi ^etre
'egal (modulo ae) au type canonique de u.

D'efinition 77 (Pr'ec'edence) Une pr'ec'edence est un pr'e-ordre *F sur F dont la
partie stricte ?F est bien fond'ee. Nous noterons par =F sa relation d''equivalence
associ'ee.

D'efinition 78 (Statuts) Soit (xi)i*1 une famille de variables.

ffl Statut. Un statut est un terme lin'eaire de la forme lex(m1; : : : ; mk) avec k * 1

et chaque mi de la forme mul(xk1; : : : ; xkp) avec p * 1. L'arit'e d'un statut stat
est le plus grand indice i tel que xi appara^isse dans stat.

ffl Assignement de statuts. Un assignement de statuts est une application stat

qui, `a chaque symbole f d'arit'e n ? 0 et de type (~x : ~T )U , associe un statut
statf = lex( ~m) d'arit'e inf'erieure ou 'egale `a n tel que :

- si xi 2 FV(statf ) alors Ti est de la forme Cif (~u) avec Cif un symbole de pr'edicat

constant,

- si mi = mul(xk1 ; : : : ; xkp) alors Ck1f =C : : : =C C

kp

f .

ffl Positions strictement positives. Soit f un symbole de statut lex( ~m). Nous

noterons par SP (f ) l'ensemble des i tels que si mi = mul(xk1; : : : ; xkp) alors Ck1f

(et donc aussi Ck2f ; : : : ; C

kp

f ) est strictement positif.

ffl Compatibilit'e d'un assignement. Un assignement stat est compatible avec

une pr'ec'edence *F si :

- f =F g implique statf = statg et, pour tout i, Cif =F Cig.
ffl Ordre engendr'e par un statut. Soit ? un ordre sur les termes et stat = lex( ~m)

un statut d'arit'e n. L'extension par stat de ? aux s'equences de termes de longueur
au moins n est l'ordre ?stat d'efini par :

- ~u ?stat ~v si ~mf~x 7! ~ug (?m)lex ~mf~x 7! ~vg,
- mul(~u) ?m mul(~v) si f~ug ?mul f~vg.

6.3. SCH 'EMA G 'EN 'ERAL 71

Par exemple, avec stat = lex(mul(x2); mul(x1; x3)), ~u ?stat ~v si (fu2g; fu1; u3g)
(?mul)lex (fv2g; fv1; v3g). Une propri'et'e importante de l'ordre ?stat est qu'il est bien
fond'e d`es lors que ? est bien fond'e.

Nous allons maintenant d'efinir les ordres ?1 et ?2.

D'efinition 79 (Ordre sur les arguments d'un symbole) Soit (l ! r; \Gamma 0; ae)
une r`egle telle que l = f (~l), o/f = (~x : ~T )U , fl0 = f~x 7! ~lg et statf = lex( ~m). Nous
dirons que :

ffl t : T ?1 u : U si t : T (\Lambda ae1)+ u : U .
ffl t : T ?2 u : U si :

- t est de la forme c(~t) avec c un constructeur de type (~x : ~T )C(~v),
- u est de la forme x~u avec x 2 dom(\Gamma 0), x\Gamma 0 de la forme (~y : ~U )D( ~w) et D =C C,
- t : T (\Lambda ae2)+ x : V avec V ae = x\Gamma 0.
Maintenant, nous d'efinissons l'ordre ? sur les arguments de f (en fait les paires
argument-type u : U ). C'est une adaptation de ?statf o`u l'ordre utilis'e est soit
?1 soit ?2 selon que l'argument est `a une position strictement positive ou non.
Supposons que statf = lex(m1; : : : ; mk). Alors :

ffl ~u ? ~v si ~mf~x 7! ~ug (?1; : : : ; ?k)lex ~mf~x 7! ~vg,
ffl mul(~u) ?i mul(~v) si f~ug (?OE(i))mul f~vg avec OE(i) = 2 si i 2 SP (f ) et OE(i) = 1

sinon.

Par exemple, on v'erifie ais'ement que, dans la troisi`eme r`egle de l'addition sur
les ordinaux, lim(f ) : ord ?2 f n : ord. Pour cette r`egle, nous pouvons prendre
\Gamma 0 = x : ord; f : nat ! ord et l'identit'e pour ae. Alors, f 2 dom(\Gamma 0), o/ (lim(f ); 1)ae =
f \Gamma 0 = nat ! ord et lim(f ) : ord \Lambda ae2 f : nat ! ord.

D'efinition 80 (Cl^oture calculable) Soit R = (l ! r; \Gamma 0; ae) une r`egle telle que
l = f (~l), o/f = (~x : ~T )U et fl0 = f~x 7! ~lg. La cl^oture calculable de R relativement
`a une pr'ec'edence *F et un assignement de statuts stat compatible avec *F est la
plus petite relation ternaire `c ` E \Theta  T \Theta  T d'efinie par les r`egles d'inf'erence de la
Figure 6.1. Nous d'esignerons par `!c la restriction de `c aux r`egles diff'erentes de
(symb=).

On v'erifie ais'ement que si \Gamma  `c t : T alors \Gamma  = \Gamma 0; \Gamma 0. Et aussi que `c ` `s et
`!c ` `f .

Il est important de noter que la cl^oture calculable peut facilement ^etre 'etendue
en rajoutant de nouvelles r`egles d'inf'erence. Pour pr'eserver la normalisation forte, il
suffit alors de compl'eter la preuve du Th'eor`eme 146 o`u il est montr'e que les r`egles
de la cl^oture calculable pr'eservent bien la calculabilit'e.

D'efinition 81 (R`egle bien form'ee) Soit R = (l ! r; \Gamma 0; ae) une r`egle telle que
l = f (~l), o/f = (~x : ~T )U et fl0 = f~x 7! ~lg. La r`egle R est bien form'ee si :

- \Gamma 0 ` lae : U fl0ae,
- pour tout x 2 dom(\Gamma 0), il existe i tel que li : Tifl0 (\Lambda ae1)\Lambda  x : x\Gamma 0,
- dom(ae) " dom(\Gamma 0) = ;.

72 CHAPITRE 6. CONDITIONS DE NORMALISATION FORTE

Fig. 6.1 - Cl^oture calculable de (f (~l) ! r; \Gamma 0; ae)
(ax)

\Gamma 0 `c ? : 2

(symb!)

\Gamma 0 `c o/g : s \Gamma  valide pour `c
\Gamma  `c u1 : U1fl : : : \Gamma  `c un : Unfl

\Gamma  `c g(~u) : V fl

(g 2 F sn; g !F f;

o/g = (~y : ~U )V;
fl = f~y 7! ~ug; ` o/g : s)

(symb=)

\Gamma 0 `c o/g : s
\Gamma  `c u1 : U1fl : : : \Gamma  `c un : Unfl

\Gamma  `c g(~u) : V fl

(g 2 F sn; g =F f;

o/g = (~y : ~U )V;
fl = f~y 7! ~ug; ` o/g : s;

~l : ~T fl0 ? ~u : ~U fl)

(acc)

\Gamma 0 `c x\Gamma 0 : s

\Gamma 0 `c x : x\Gamma 0

(x 2 doms(\Gamma 0))

(var)

\Gamma  `c T : s

\Gamma ; x : T `c x : T

(x 2 X s n dom(\Gamma )

[ FV(l))

(weak)

\Gamma  `c t : T \Gamma  `c U : s

\Gamma ; x : U `c t : T

(x 2 X s n dom(\Gamma )

[ FV(l))

(prod)

\Gamma ; x : T `c U : s

\Gamma  `c (x : T )U : s

(abs)

\Gamma ; x : T `c u : U \Gamma  `c (x : T )U : s

\Gamma  `c [x : T ]u : (x : T )U

(app)

\Gamma  `c t : (x : U )V \Gamma  `c u : U

\Gamma  `c tu : V fx 7! ug

(conv)

\Gamma  `c t : T \Gamma  `c T : s \Gamma  `c T 0 : s

\Gamma  `c t : T 0

(T # T 0)

6.3. SCH 'EMA G 'EN 'ERAL 73

Par exemple, consid'erons la r`egle :

appn(p; consn(x; n; `); n0; `0) ! consn(x; n + n0; appn(n; `; n0; `0))
avec \Gamma 0 = x : T; n : nat; ` : listn(n); n0 : nat; `0 : listn(n0) et ae = fp 7! s(n)g (voir
Chapitre 5). Nous avons \Gamma 0 ` lae : listn(p + n0)ae. Pour x, nous avons consn(x; n; `) :
listn(p) \Lambda ae1 x : T . On v'erifie ais'ement que les conditions sont 'egalement v'erifi'ees
pour les autres variables.

D'efinition 82 (Syst`eme r'ecursif ) Soit R = (l ! r; \Gamma 0; ae) une r`egle telle que
l = f (~l), o/f = (~x : ~T )U et fl0 = f~x 7! ~lg. La r`egle R satisfait le Sch'ema G'en'eral
relativement `a une pr'ec'edence *F et un assignement de statuts stat compatible avec
*F si R est bien form'ee et si \Gamma 0 `c r : U fl0ae.

Un ensemble de r`egles R est r'ecursif s'il existe une pr'ec'edence *F et un assignement de statuts stat compatible avec *F pour lequel toute r`egle de R satisfait
le Sch'ema G'en'eral relativement `a *F et stat.

Au total, une r`egle (l ! r; \Gamma 0; ae) avec l = f (~l), o/f = (~x : ~T )U et fl0 = f~x 7! ~lg,
est bien typ'ee et bien form'ee si elle v'erifie les conditions suivantes :

- dom(ae) " dom(\Gamma 0) = ;,
- pour tout x 2 dom(\Gamma 0), il existe i tel que li : Tifl0 (\Lambda ae1)\Lambda  x : x\Gamma 0,
- \Gamma 0 ` lae : U fl0ae,
- \Gamma 0 `c r : U fl0ae,
- pour tout \Delta , oe et T , si \Delta  ` loe : T alors oe : \Gamma  ! \Delta ,
- pour tout \Delta , oe et T , si \Delta  ` loe : T alors, pour tout x, xoe # xaeoe.

Remarque 83 (D'ecidabilit'e)

A priori, du fait de la r`egle (conv) et de la condition ` o/g : s pour les r`egles
(symb!) et (symb=), la relation `c peut ne pas ^etre d'ecidable. Cependant, si on
suppose ` o/g : s et on restreint la r`egle (conv) `a un fragment confluent et fortement
normalisant de !, `c devient d'ecidable (avec un algorithme semblable `a celui pour
`). En pratique, les symboles et les r`egles qui les d'efinissent sont souvent rajout'es les
uns apr`es les autres (ou par paquets, mais l'argument qui suit peut se g'en'eraliser).

Soit (F; R) un syst`eme confluent et fortement normalisant, f =2 F et Rf un
ensemble de r`egles d'efinissant f et dont tous les symboles appartiennent `a F 0 =
F [ ff g. Alors, (F 0; R) est 'egalement confluent et fortement normalisant. On peut
donc chercher `a v'erifier si les r`egles de Rf v'erifie le Sch'ema G'en'eral avec la r`egle
(conv) restreinte au cas o`u T #fiR T 0. Cela ne nous para^it pas une grande restriction :
il serait surprenant que le typage d'une r`egle n'ecessite l'utilisation de la r`egle ellem^eme !

Avant de d'etailler un exemple, nous allons montrer quelques propri'et'es simples
qui nous faciliterons les preuves d'appartenance `a la cl^oture calculable. En effet,
pour montrer \Gamma 0 `c r : U fl0ae, sachant que par (S3) nous avons \Gamma 0 ` r : U fl0ae, on
peut se demander dans quelle mesure une d'erivation de \Gamma 0 ` r : U fl0ae peut ^etre
transform'ee en une d'erivation de \Gamma 0 `c r : U fl0ae. L'id'eal serait qu'il suffise que les
symboles de r soient inf'erieurs ou 'egaux `a f et que, dans le cas d'un appel r'ecursif, les

74 CHAPITRE 6. CONDITIONS DE NORMALISATION FORTE
arguments soient strictement plus petits. Nous montrons ci-apr`es quelques r'esultats
qui permettent de traiter les termes ne contenant que des symboles strictement
inf'erieurs `a f .

D'efinition 84 Une r`egle l ! r est compatible avec *F si tous les symboles de r
sont inf'erieurs ou 'egaux `a ceux de l. Un ensemble de r`egle R est compatible avec
*F si chacune des r`egles de R est compatible avec *F .

Il est facile de v'erifier que ! est compatible avec *F (D'efinition 53) si et seulement si R est compatible avec *F .

Lemme 85 Supposons R et o/ compatibles avec *F . Quitte `a renommer les variables de \Gamma , si \Gamma  `f t : T alors \Gamma 0; \Gamma  `!c t : T .

Preuve. Par r'ecurrence sur \Gamma  `f t : T . \Xi 

Lemme 86 (Substitution pour `c) Si \Gamma 0; \Gamma  `!c t : T et ` : \Gamma 0; \Gamma  ! \Gamma 0; \Gamma 0 dans `c
(resp. dans `!c ) alors \Gamma 0; \Gamma 0 `c t` : T ` (resp. \Gamma 0; \Gamma 0 `!c t` : T `).

Preuve. Par r'ecurrence sur \Gamma 0; \Gamma  `!c t : T . On proc`ede comme pour le Lemme 24.

\Xi 

Lemme 87 Si R et o/ sont compatibles avec *F , ! est confluente et les symboles
de \Gamma 0 sont inf'erieurs strictement `a f alors, pour tout x 2 doms(\Gamma 0), \Gamma 0 `!c x\Gamma 0 : s.

Preuve. Supposons que \Gamma 0 = ~y : ~U et que yi soit de sorte si. Montrons par
r'ecurrence sur i que, pour tout j ^ i, \Gamma 0 `!c Uj : sj. Si i = 0, c'est imm'ediat.
Supposons alors i ? 0. Par hypoth`ese de r'ecurrence, pour tout j ! i, \Gamma 0 `!c Uj : sj,
et il nous faut montrer \Gamma 0 `!c Ui : si.

Posons \Gamma  = y1 : U1; : : : ; yi\Gamma 1 : Ui\Gamma 1. Soit ~z une s'equence de i \Gamma  1 nouvelles
variables distinctes de ~y, ` = f~y 7! ~zg, `0 = f~z 7! ~yg et \Gamma 0 = ~z : ~U `. Par (S3), \Gamma 0 est
valide. Donc, par le lemme d'environnement, \Gamma  ` Ui : si. Comme les symboles de \Gamma  et
Ui sont strictement inf'erieurs `a f et ! est confluente, par le Lemme 54, \Gamma  `f Ui : si.
Par remplacement, \Gamma 0 `f Ui` : si. Alors, par le Lemme 85, \Gamma 0; \Gamma 0 `!c Ui` : si.

Montrons maintenant que `0 : \Gamma 0; \Gamma 0 ! \Gamma 0 dans `!c . Pour cela, il suffit de montrer
que, pour tout j ! i, \Gamma 0 `!c zj`0 : Uj``0, c'est-`a-dire, \Gamma 0 `!c yj : Uj. Or, par hypoth`ese
de r'ecurrence, pour tout j ! i, \Gamma 0 `!c Uj : sj. Donc, par (acc), \Gamma 0 `!c yj : Uj. Ainsi,
`0 : \Gamma 0 ! \Gamma 0 dans `!c et, par le Lemme 86, \Gamma 0 `!c Ui : si. \Xi 

Lemme 88 Si R et o/ sont compatibles avec *F , ! est confluente et \Gamma 0; \Gamma  `f t : T
alors \Gamma 0; \Gamma  `!c t : T .

Preuve. Par r'ecurrence sur la taille de \Gamma . Supposons que \Gamma 0; \Gamma  = ~y : ~U . Soit ~z
une s'equence de j~yj nouvelles variables distinctes de ~y, ` = f~y 7! ~zg, `0 = f~z 7! ~yg
et \Delta  = ~z : ~U `. Par remplacement, \Delta  `f t` : T `. Par le Lemme 85, \Gamma 0; \Delta  `!c t` : T `.
Montrons maintenant que `0 : \Gamma 0; \Delta  ! \Gamma 0; \Gamma  dans `!c afin de pouvoir appliquer le
Lemme 86.

Pour cela, il faut montrer que, pour tout x 2 dom(\Gamma 0; \Delta ), \Gamma 0; \Gamma  `!c x`0 : x(\Gamma 0; \Delta ).
Si x 2 dom(\Gamma 0), il faut montrer que \Gamma 0; \Gamma  `!c x : x\Gamma 0, et si x = zi 2 dom(\Delta ), il faut

6.4. CONDITIONS DE NORMALISATION FORTE 75
montrer que \Gamma 0; \Gamma  `!c yi : Ui. Autrement dit, il suffit de montrer que \Gamma 0; \Gamma  est valide
dans `!c . Si \Gamma  est vide, c'est imm'ediat car, d'apr`es le Lemme 87, \Gamma 0 est valide dans
`!c . Supposons maintenant que \Gamma  = \Gamma 0; y : U . Alors, \Delta  = \Delta 0; z : U `. Par le lemme
d'environnement, \Gamma 0; \Gamma 0 `f U : s. Par hypoth`ese de r'ecurrence, \Gamma 0; \Gamma 0 `!c U : s.
Donc, par (var), \Gamma 0; \Gamma  `!c y : U et \Gamma 0; \Gamma  est valide dans `!c . \Xi 

Un cas particulier utile du lemme est :
Corollaire 89 Si R et o/ sont compatibles avec *F et ! est confluente alors, pour
tout g ^F f , si ` o/g : s alors \Gamma 0 `!c o/g : s.

Preuve. Comme o/ est compatible avec *F et ! est confluente, par le Lemme 54,
`f o/g : s. Donc, par le Lemme 88, \Gamma 0 `!c o/g : s. \Xi 

Maintenant, nous sommes en mesure de d'etailler un exemple. Consid'erons la
r`egle :

appn(p; consn(x; n; `); n0; `0) ! consn(x; n + n0; appn(n; `; n0; `0))
avec \Gamma 0 = x : T; n : nat; ` : listn(n); n0 : nat; `0 : listn(n0) et ae = fp 7! s(n)g (voir
Chapitre 5). Prenons statappn = lex(mul(x2)) ; appn ?F consn; + ; consn ?F T et
+ ?F s; 0 ?F nat. Nous avons d'ej`a vu que cette r`egle est bien form'ee. Montrons
que \Gamma 0 `c r : listn(s(n)). R et o/ sont compatibles avec *F .

Pour appliquer (symb!), nous devons montrer ` o/consn : ?, \Gamma 0 `c o/consn : ?,
\Gamma 0 `c x : T , \Gamma 0 `c n + n0 : nat et \Gamma 0 `c appn(n; `; n0; `0) : listn(n + n0). Il est ais'e de
v'erifier que ` o/consn : ?. Alors, par le Corollaire 89, on en d'eduit que \Gamma 0 `c o/consn : ?.
\Gamma 0 `c x : T et \Gamma 0 `c n + n0 : nat d'ecoulent du Lemme 88. Reste `a montrer \Gamma 0 `c
appn(n; `; n0; `0) : listn(n + n0).

Pour appliquer (symb=), nous devons montrer ` o/appn : ?, \Gamma 0 `c o/appn : ?,
\Gamma 0 `c n : nat, \Gamma 0 `c ` : listn(n), \Gamma 0 `c n0 : nat, \Gamma 0 `c `0 : listn(n0) et consn(x; n; `) :
listn(s(n)) ?1 ` : listn(n). Il est ais'e de v'erifier que ` o/appn : ?. Alors, par le Corollaire 89, on en d'eduit que \Gamma 0 `c o/appn : ?. Nous avons d'ej`a montr'e que consn(x; n; `) :
listn(p) ?1 ` : listn(n). Les autres assertions d'ecoulent du Lemme 88.

6.4 Conditions de normalisation forte
D'efinition 90 (Syst`emes de r'ecriture) Soit G ` F . (G; RG ) est un syst`eme de
r'ecriture :

ffl du premier ordre si :

- G est constitu'e de symboles de pr'edicat d'arit'e maximale ou de constructeurs

de pr'edicats primitifs,

- toutes les r`egles de RG ont un membre droit alg'ebrique ;

ffl non-dupliquant si, pour toute r`egle de RG, aucune variable n'a plus d'occurrences

libres dans le membre droit que dans le membre gauche ;

ffl primitif si toutes les r`egles de RG ont un membre droit de la forme [~x : ~T ]g(~u)~v

avec g soit un symbole de G soit un symbole de pr'edicat primitif ;

76 CHAPITRE 6. CONDITIONS DE NORMALISATION FORTE

ffl simple s'il n'y a pas de paires critiques entre RG et R :

- pas de filtrage sur des symboles d'efinis,
- pas d'ambigu"it'e dans l'application des r`egles ;

ffl petit si, pour toute r`egle g(~l) ! r 2 RG et tout X 2 FV2(r), il existe ^X tel que

l^X = X ;

ffl positif si, pour tout symbole g 2 G et toute r`egle l ! r 2 RG, Pos(g; r) ` Pos+(r) ;
ffl s^ur si, pour toute r`egle (g(~l) ! r; \Gamma ; ae) 2 RG avec o/g = (~x : ~T )U et fl = f~x 7! ~lg :

- pour tout X 2 FV2( ~T U ), Xflae 2 dom2(\Gamma ),
- pour tout X; X0 2 FV2( ~T U ), Xflae = X0flae ) X = X0.

D'efinition 91 (Conditions de normalisation forte)

(A0) Toutes les r`egles sont bien typ'ees.
(A1) La relation ! = !R [ !fi est confluente sur T .
(A2) Il existe une structure inductive admissible.
(A3) Il existe une pr'ec'edence * sur DF 2 avec laquelle RDF2 est compatible 3 et

dont chaque classe d''equivalence modulo ', la relation d''equivalence associ'ee `a
*, forme un syst`eme qui est soit :

(p) primitif,
(q) positif, petit et simple,
(r) r'ecursif, petit et simple.

(A4) Il existe une partition F1 ] F! de DF (les symboles de premier ordre et les

symboles d'ordre sup'erieur ) telle que :4

(a) (F!; R!) est r'ecursif,
(b) (F!; R!) est s^ur,
(c) aucun symbole de F! n'appara^it dans les r`egles de R1,
(d) (F1; R1) est du premier ordre,
(e) si R! 6= ; alors (F1; R1) est non-dupliquant,
(f ) !R1 est fortement normalisante sur T(F1; X ).

La condition (A1) assure, entre autres choses, que le CAC est logique. Avec
(A0), cela implique qu'il est admissible, c'est-`a-dire, que la r'eduction pr'eserve le
typage (Th'eor`eme 60). On peut se demander dans quelle mesure la confluence est
n'ecessaire pour montrer la compatibilit'e avec le produit et donc, la correction de la
fi-r'eduction. H. Geuvers [56] parvient `a montrer cette propri'et'e pour C = $\Lambda fij alors
que !fij n'est pas confluente sur les termes mal typ'es. M. Fern'andez [51] parvient
'egalement `a montrer cette propri'et'e pour C = !\Lambda fiR [ \Lambda fiR avec !R une relation

de r'ecriture au niveau objet, sans faire d'hypoth`ese sur la confluence de !fiR. Mais
ce dernier r'esultat utilise de mani`ere essentielle le fait que la r'ecriture est cantonn'ee

3Voir D'efinition 84.
4Nous d'enoterons RF

1 par R1 et RF! par R!.

6.4. CONDITIONS DE NORMALISATION FORTE 77
aux objets. Il n'est pas clair comment ce r'esultat peut ^etre 'etendu `a la r'ecriture sur
les types.

On retiendra donc que les hypoth`eses (A1) et (A3) ne sont utiles qu'au cas o`u
il y a de la r'ecriture au niveau des types.

La condition (A1) peut para^itre difficile `a remplir car, bien souvent, on montre
la confluence `a partir de la normalisation forte et de la confluence (locale) des paires
critiques (r'esultat de D. Knuth et P. Bendix [17] pour le premier ordre, 'etendu `a
l'ordre sup'erieur par T. Nipkow [95]).

On sait que !fi est confluente et qu'il n'y a pas de paires critiques entre R et la
r`egle de fi-r'eduction car les membres gauches de R sont alg'ebriques.

F. M"uller [92] a montr'e dans ce cas que, si !R est confluente et toutes les r`egles
de R sont lin'eaires-gauches, alors !R [ !fi est confluente. Ainsi, la possibilit'e
que nous avons introduite dans les ATS de pouvoir lin'eariser certaines r`egles (substitutions ae) tout en assurant la pr'eservation du typage se r'ev`ele tr`es utile (voir
Chapitre 5).

Dans ce cas-l`a, et en supposant que !R1 soit fortement normalisante comme
c'est demand'e en (f), comment peut-on montrer la confluence de ! ? Dans le cas
o`u !R1 est fortement normalisante et non-dupliquante si R! 6= ;, on peut montrer
que !R1 [ !R! est aussi fortement normalisante (Th'eor`eme 144). Ainsi, il suffit
d'examiner les paires critiques de R.

Dans (A4), dans le cas o`u R! 6= ;, on demande `a ce que les r`egles de R1 ne
dupliquent pas de variables. En effet, au premier ordre d'ej`a, la normalisation forte
n'est pas une propri'et'e modulaire [113], m^eme avec des syst`emes confluents [50].
Par contre, elle est modulaire pour les syst`emes non-dupliquants disjoints [104].
Ici, R1 et R! ne sont pas disjoints mais d'efinis hi'erarchiquement : aucun symbole
de F! n'appara^it dans les r`egles de R1. Dans [40], N. Dershowitz rassemble de
nombreux r'esultats sur la modularit'e de la normalisation forte pour les syst`emes du
premier ordre, notamment dans le cas de syst`emes hi'erarchiquement d'efinis. Il serait
int'eressant d''etudier la modularit'e de la normalisation dans le cas de la r'ecriture
d'ordre sup'erieur et, en particulier, d'autres conditions que la non-duplication qui
nous emp^eche par exemple de consid'erer l'exemple suivant :

0=y ! 0
s(x)=y ! s((x \Gamma  y)=y)

0 \Gamma  y ! 0
s(x) \Gamma  0 ! s(x)
s(x) \Gamma  s(y) ! x \Gamma  y

qui est un syst`eme du premier ordre dupliquant et ne satisfaisant pas le Sch'ema
G'en'eral ; il ne peut donc ^etre plac'e ni dans R1 ni dans R!. E. Gim'enez [59] parvient
`a traiter cet exemple en utilisant le fait que le r'esultat de x \Gamma  y est plus petit que
s(x).

Dans (A3), la condition de petitesse pour les syst`emes r'ecursifs et positifs est
'equivalente dans le Calcul des Constructions Inductive `a la restriction de l''elimina78 CHAPITRE 6. CONDITIONS DE NORMALISATION FORTE
tion forte aux types inductifs "petits", c'est-`a-dire aux types dont les constructeurs
n'ont d'autres arguments-pr'edicats que ceux du type. Par exemple, le type list des
listes polymorphes est "petit" car, dans (A : ?)A ! list(A) ! list(A), le type de
son constructeur cons, A est un argument de list. Par contre, un type T ayant
un constructeur c de type ? ! T n'est pas petit. Ainsi, on ne peut pas d'efinir de
fonction f de type T ! ? avec la r`egle f (c(A)) ! A. Une telle r`egle n'est pas petite
et ne forme pas un syst`eme primitif non plus. D'une certaine mani`ere, les syst`emes
primitifs peuvent toujours ^etre vus comme des syst`emes petits car ils ne contiennent
pas de projections et les types primitifs n'ont pas d'arguments-pr'edicats.

Enfin, dans (A4), la condition de s^uret'e pour les symboles d'ordre sup'erieur signifie qu'on ne peut pas faire de filtrage ou tester l''egalit'e des arguments-pr'edicats
qui sont n'ecessaires au typage d'autres arguments. Dans son extension de HORPO
[74] au Calcul des Constructions, D. Walukiewicz [117] demande une condition similaire. Elle donne quelques exemples (pathologiques) de non normalisation d^us `a
la violation de cette condition comme J (A; A; a) ! a avec J : (A : ?)(B : ?)B ! A
ou J (A; A; a; b) ! b avec J : (A : ?)(B : ?)A ! B ! A. Par contre, la r`egle
map(A; A; [x : A]x; `) ! ` qui para^it bien inoffensive ne satisfait pas non plus cette
condition de s^uret'e.

Nous pouvons maintenant 'enoncer notre principal r'esultat :
TH'EOR`EME : Un CAC satisfaisant les conditions de la D'efinition 91 est admissible (i.e. la r'eduction pr'eserve le typage) et fortement normalisant.

La preuve de ce th'eor`eme essentiel fait l'objet du Chapitre 8. Il g'en'eralise les
r'esultats de M. Fern'andez [51] et de J.-P. Jouannaud, M. Okada et moi-m^eme [21].
Au Chapitre 7, nous donnons plusieurs exemples importants de CAC v'erifiant ces
conditions de normalisation forte : un sous-syst`eme avec 'elimination forte du Calcul
des Constructions Inductives (CIC) et la D'eduction Naturelle Modulo (NDM) de
nombreuses th'eories 'equationnelles.

Cependant, ces conditions ne permettent pas d'accepter la proc'edure de d'ecision
pour les tautologies propositionnelles classiques de la Figure 1.3. Voyons pourquoi :

- Nous n'avons pas consid'erer de r'ecriture modulo associativit'e et commutativit'e.
- Du fait que le syst`eme n'est pas lin'eaire-gauche, nous ne savons pas comment

montrer sa confluence quand il est combin'e avec fi.

- Le syst`eme n'est pas primitif puisqu'il y a des projections (P xor ? ! P ). Il est

r'ecursif (et positif aussi) et petit. Malheureusement, il n'est pas simple.

La r'ecriture modulo AC ne nous parait pas une extension tr`es difficile `a conduire.
Par contre, la confluence et la simplicit'e sont des probl`emes qui nous paraissent non
triviaux mais que nous esp'erons r'esoudre apr`es cette th`ese. Dans le Chapitre 9, nous
donnons encore d'autres directions de recherche mais ces trois-l`a sont assur'ement
les plus importantes.

6.4. CONDITIONS DE NORMALISATION FORTE 79

De la normalisation forte, rappelons-le, on peut d'eduire la d'ecidabilit'e de la
relation de typage, qui est la propri'et'e sur laquelle repose les syst`emes d'aide `a la
d'emonstration comme Coq [52] ou LEGO [81].

Th'eor`eme 92 (D'ecidabilit'e de `) Soit \Gamma  un environnement valide et T un terme
'egal `a 2 ou typable dans \Gamma . Dans un CAC satisfaisant les conditions de la D'efinition 91, v'erifier qu'un terme t est de type T dans \Gamma  est d'ecidable.

Preuve. \Gamma  'etant valide, il est possible de dire si t est typable ou non, et si t est
typable, il est possible d'inf'erer un type T 0 pour t. Comme les types sont convertibles,
il suffit ensuite de v'erifier que T et T 0 ont la m^eme forme normale. Nous renvoyons
le lecteur vers [32, 11] pour plus de d'etails. \Xi 

Remarque 93 (Coh'erence logique)

Dans le Calcul des Constructions pur (CC), il est assez ais'e de v'erifier que, dans
l'environnement vide, il ne peut y avoir de preuve de ? = (P : ?)P en forme normale
[10]. Donc, pour CC, la normalisation forte implique la coh'erence logique.

Malheureusement, dans un CAC, la situation n'est pas aussi simple. D'un point
de vue logique, avoir des symboles est 'equivalent `a travailler dans un environnement
non vide. Il se pourrait donc que les symboles et les r`egles qui les d'efinissent permettent de former une preuve de ? en forme normale. Dans [106], J. Seldin montre
la coh'erence des environnements "fortement coh'erents" 5 de mani`ere syntaxique.
Cependant, pour montrer la coh'erence d'environnements plus riches, il peut ^etre
n'ecessaire d'utiliser des outils s'emantiques.

5Un environnement \Gamma  est fortement coh'erent si, pour tout x 2 dom(\Gamma ), soit x\Gamma  est un type de
pr'edicat, soit x\Gamma  est fi-'equivalent `a un terme de la forme y~t.

80 CHAPITRE 6. CONDITIONS DE NORMALISATION FORTE

Chapitre 7
Exemples de CAC

7.1 Calcul des Constructions Inductives

Nous allons voir que nos conditions de normalisation forte nous permettent de
montrer la normalisation d'un sous-syst`eme important du Calcul des Constructions
Inductives (CIC) de B. Werner [118] qui sert de base au syst`eme de sp'ecification
et de d'emonstration Coq [52]. Mais, comme CIC est exprim'e dans un formalisme
diff'erent du n^otre, cela va nous demander un travail assez important, certes routinier,
pour traduire CIC et montrer que cette traduction pr'eserve le typage et r'efl'echit la
normalisation forte.

Afin de pouvoir typer les sch'emas d''elimination forte de mani`ere polymorphe,
ce qu'il n'est pas possible de faire dans le Calcul des Constructions, B. Werner se
place dans un syst`eme de types avec les sortes S = f?; 2; 4g, les axiomes A =
f(?; 2); (2; 4)g et les r`egles B = f(s1; s2; s3) 2 S3 j s1 2 f?; 2g; s2 = s3g (en fait, il
d'enote ? par Set, 2 par Type et 4 par Extern).

Ensuite, il ajoute des termes pour repr'esenter les types inductifs, leurs constructeurs et les d'efinitions par r'ecursion sur ces types :

ffl types inductifs : Un type inductif est d'enot'e par I = Ind(X : A)f ~Cg o`u les Ci

sont les types des constructeurs de I. Par exemple, N at = Ind(X : ?)fX; X ! Xg
repr'esente tout type isomorphe aux entiers naturels. Le terme A doit ^etre de la
forme (~x : ~A)? et les Ci de la forme (~z : ~B)X ~m avec X =2 FV( ~m). De plus, les
types inductifs doivent ^etre strictement positifs. Dans CIC, cela signifie que, si
Ci = (~z : ~B)X ~m alors, pour tout j, soit X n'appara^it pas dans Bj, soit Bj est de
la forme (~y : ~D)X~q et X n'appara^it ni dans ~D ni dans ~q.

ffl constructeurs : Le i-`eme constructeur d'un type inductif I est d'enot'e par

Constr(i; I). Par exemple, Constr(1; N at) repr'esente z'ero et Constr(2; N at) repr'esente la fonction successeur.

ffl d'efinitions par r'ecursion : Une d'efinition par r'ecursion sur un type inductif I

est d'enot'ee par Elim(I; Q; ~a; c) o`u Q est le type du r'esultat, ~a les arguments de
I et c un terme de type I~a. L''elimination forte (dans le cas o`u Q est un type de
pr'edicat) est restreinte aux types inductifs dits "petits", dont les constructeurs
n'ont pas d'autres arguments-pr'edicats que ceux du types. Plus pr'ecis'ement, un

81

82 CHAPITRE 7. EXEMPLES DE CAC

type inductif I = Ind(X : A)f ~Cg est petit si tous les types de ses constructeurs
sont petits et un type de constructeur C = (~z : ~B)X ~m est petit si f~zg " X 2 = ;
(cela signifie que les arguments-pr'edicats doivent faire partie de l'environnement
de typage \Gamma  ; ils ne peuvent pas faire partie de ~C).

Pour formuler la relation de r'eduction associ'ee `a Elim (appel'ee '-r'eduction et
not'ee !') et les r`egles de typage de ces constructions (Figure 7.1), il est n'ecessaire
d'introduire quelques d'efinitions pr'ealables.

'Etant donn'e un type de constructeur C, on d'efinit \Delta fI; X; C; Q; cg de la mani`ere

suivante :

- \Delta fI; X; X ~m; Q; cg = Q ~mc
- \Delta fI; X; (z : B)D; Q; cg = (z : B)\Delta fI; X; D; Q; czg si X =2 FV(B)
- \Delta fI; X; (z : B)D; Q; cg = (z : BfX 7! Ig)((~y : ~D)Q ~q (z~y)) ! \Delta fI; X; D; Q; czg si

B = (~y : ~D)X~q

La '-r'eduction est d'efinie par la r`egle :

Elim(I; Q; ~x; Constr(i; I0) ~z)f ~f g !' \Delta [I; X; Ci; fi; F unElim(I; Q; ~f )] ~z
o`u I = Ind(X : A)f ~Cg, F unElim(I; Q; ~f ) = [~x : ~A][y : I~x]Elim(I; Q; ~x; y)f ~f g et
\Delta [I; X; C; f; F ] est d'efini de la mani`ere suivante :

- \Delta [I; X; X ~m; f; F ] = f
- \Delta [I; X; (z : B)D; f; F ] = [z : B]\Delta [I; X; D; f z; F ] si X =2 FV(B)
- \Delta [I; X; (z : B)D; f; F ] = [z : BfX 7! Ig]\Delta [I; X; D; f z [~y : ~D](F ~q (z~y)); F ] si B = (~y :

~D)X~q

Enfin, dans la r`egle de conversion (conv), en plus de la fi-r'eduction et de la '-
r'eduction, B. Werner consid`ere la j-r'eduction : [x : T ]ux !j u si x =2 FV(u). Du fait
que !fij n'est pas confluente sur les termes mal typ'es1, consid'erer la j-r'eduction
cr'e'e de nombreuses difficult'es [56]. Pour ce qui nous concerne, comme la condition
(A1) ne peut pas ^etre v'erifi'ee en pr'esence de j-r'eduction, nous ne pouvons pas
consid'erer la j-r'eduction. Trouver une condition plus faible que (A1) qui soit v'erifi'ee
en pr'esence de j-r'eduction et permette de montrer la correction de la r'eduction et
la normalisation forte est un probl`eme que nous avons provisoirement laiss'e ouvert.

La '-r'eduction telle qu'elle est d'efinie dans CIC introduit de nombreux fi-radicaux, et les appels r'ecursifs `a Elim sont faits sur des variables li'ees qui seront
instanci'ees par des sous-termes stricts. Ainsi, d'une part, cela n'est pas tr`es efficace
car ces instanciations pourraient ^etre faites imm'ediatement apr`es la '-r'eduction, et
d'autre part, la forme actuelle du Sch'ema G'en'eral ne permet pas de traiter des
appels r'ecursifs sur des variables li'ees, m^eme si celles-ci ne sont instanciables que
par des sous-termes stricts.

C'est pourquoi nous n'allons pas montrer la normalisation forte de la relation !fi'
mais de la relation !fi'0 o`u !'0 est la relation de r'eduction dont un pas correspond
`a une '-r'eduction suivie d'une s'erie de fi-r'eductions pour 'eliminer les fi-radicaux
introduits par la '-r'eduction. C'est d'ailleurs cette relation de r'eduction qui est
impl'ement'ee dans le syst`eme Coq [52].

1Remarque d^ue `a R. Nederpelt [93] : [x: A]x fi [x : A]([y : B]y x) !j [y : B]y.

7.1. CALCUL DES CONSTRUCTIONS INDUCTIVES 83

Fig. 7.1 - R`egles de typage de CIC
(Ind)

A = (~x : ~A) ? \Gamma  ` A : 2 8i; \Gamma ; X : A ` Ci : ?

\Gamma  ` Ind(X : A)f ~Cg : A

(Constr)

I = Ind(X : A)f ~Cg \Gamma  ` I : T

\Gamma  ` Constr(i; I) : CifX 7! Ig

(?-Elim)

A = (~x : ~A) ? I = Ind(X : A)f ~Cg

\Gamma  ` Q : (~x : ~A)I~x ! ?
Ti = \Delta fI; X; Ci; Q; Constr(i; I)g
fl = f~x 7! ~ag 8j; \Gamma  ` aj : Ajfl \Gamma  ` c : I~a 8i; \Gamma  ` fi : Ti

\Gamma  ` Elim(I; Q; ~a; c)f ~f g : Q~ac

(2-Elim)

A = (~x : ~A) ? I = Ind(X : A)f ~Cg est petit

\Gamma  ` Q : (~x : ~A)I~x ! 2
Ti = \Delta fI; X; Ci; Q; Constr(i; I)g
fl = f~x 7! ~ag 8j; \Gamma  ` aj : Ajfl \Gamma  ` c : I~a 8i; \Gamma  ` fi : Tig

\Gamma  ` Elim(I; Q; ~a; c)f ~f g : Q~ac

(Conv)

\Gamma  ` t : T T $\Lambda fij' T 0 \Gamma  ` T 0 : s

\Gamma  ` t : T 0

D'efinition 94 ('0-r'eduction) La '0-r'eduction est la relation de r'eduction d'efinie
par la r`egle :

Elim(I; Q; ~x; Constr(i; I0) ~z)f ~f g !'0 \Delta 0[I; X; Ci; fi; Q; ~f ; ~z]
o`u I = Ind(X : A)f ~Cg et \Delta 0[I; X; C; f; Q; ~f ; ~z] est d'efini de la mani`ere suivante :

- \Delta 0[I; X; X ~m; f; Q; ~f ; ;] = f
- \Delta 0[I; X; (z : B)D; f; Q; ~f ; z~z] = \Delta 0[I; X; D; f z; Q; ~z] si X =2 FV(B)
- \Delta 0[I; X; (z : B)D; f; Q; ~f ; z~z] = \Delta 0[I; X; D; f z [~y : ~D]Elim(I; Q; ~q; z~y); Q; ~z] si B =

(~y : ~D)X~q

Nous pensons que la normalisation forte de !fi'0 implique celle de !fi'. Mais,
comme ce probl`eme ne nous para^it pas tr`es simple et n'est pas directement li'e `a
notre travail, nous en remettons la r'esolution `a plus tard.

Conjecture 95 Si !fi'0 est fortement normalisante alors !fi' est fortement normalisante.

D'efinition 96 (Type inductif admissible) Un type inductif I = Ind(X : A)f ~Cg
est admissible s'il v'erifie les conditions (I5), (I6) (adapt'ees `a la syntaxe CIC, une
'elimination forte 'etant consid'er'ee comme un symbole de pr'edicat d'efini) et la condition de s^uret'e suivante. Si A = (~x : ~A)? et Ci = (~z : ~B)X ~m alors :

84 CHAPITRE 7. EXEMPLES DE CAC

- 8xi 2 X 2; mi 2 X 2,
- 8xi; xj 2 X 2; mi = mj ) xi = xj.

D'efinition 97 (CIC\Gamma ) Le sous-syst`eme que nous allons consid'erer, CIC\Gamma , s'obtient en appliquant les restrictions suivantes :

ffl On exclut toute utilisation de la sorte 4 afin de rester dans le Calcul des Constructions.

ffl Dans la r`egle (Ind), au lieu de demander que I = Ind(X : A)f ~Cg soit typable

dans un environnement \Gamma  quelconque, on demande que I soit typable dans l'environnement vide car, dans CAC, les types des symboles doivent ^etre typables dans
l'environnement vide. De plus, on se restreint aux types admissibles en forme
normale.

La restriction `a \Gamma  = ; n'est pas une r'eelle restriction car tout type I = Ind(X :
A)f ~Cg typable dans un environnement \Gamma  = ~y : ~U peut ^etre remplac'e par un type
I0 = Ind(X0 : A0)f ~C0g 'equivalent : il suffit de prendre A0 = (~y : ~U )A, C0i = (~y :

~U )CifX 7! X0~yg et de remplacer I par I0~y et Constr(i; I) par Constr(i; I0)~y.

Cependant, on est amen'e `a modifier la d'efinition de type de constructeur petit
de la mani`ere suivante : un type de constructeur C d'un type I = Ind(X : A)f ~Cg
avec A = (~x : ~A)? est petit s'il est de la forme (~x : ~A)(~z : ~B)X ~m avec f~zg"X 2 = ;.

ffl Dans la r`egle (?-Elim), au lieu de demander que Q soit typable dans un environnement \Gamma  quelconque, on demande que Q soit typable dans l'environnement vide.
De plus, on demande explicitement que I et Ti = \Delta fI; X; Ci; Q; Constr(i; I)g
soient typables.

ffl Dans la r`egle (2-Elim), au lieu de demander ` Q : (~x : ~A)I~x ! 2, ce qui

n'est pas possible dans le Calcul des Constructions, on demande que Q soit de
la forme [~x : ~A][y : I~x]K avec ~x : ~A; y : I~x ` K : 2, et que fi soit de type Ti =
\Delta 0fI; X; Ci; ~xy; K; Constr(i; I)g o`u \Delta 0fI; X; C; ~xy; K; cg est d'efini de la mani`ere
suivante :

- \Delta 0fI; X; X ~m; ~xy; K; cg = Kf~x 7! ~m; y 7! cg,
- si B = (~y : ~D)X~q alors \Delta 0fI; X; (z : B)D; ~xy; K; cg = (z : BfX 7! Ig)((~y :

~D)Kf~x 7! ~q; y 7! z~yg) ! \Delta 0fI; X; D; ~xy; K; czg.

De plus, on demande que Q soit en forme normale, que Ti soit typable et que
les types inductifs qui apparaissent dans Q soient des sous-termes de I. Enfin,
comme conclusion, on prend \Gamma  ` Elim(I; Q; ~a; c)f ~f g : Kf~x 7! ~a; y 7! cg au lieu
de \Gamma  ` Elim(I; Q; ~a; c)f ~f g : Q~ac.

Demander que Q soit de la forme [~x : ~A][y : I~x]K n'est pas une tr`es grande
restriction car, comme l'a montr'e B. Werner (Corollaire 2.9 page 57 de [118]),
si \Gamma  ` Q : 2 alors il existe Q0 de la forme (~y : ~U )? tel que Q !\Lambda fi Q0. Ainsi, si

` Q : (~x : ~A)I~x ! 2 alors ~x : ~A; y : I~x ` Q~xy : 2. Donc, il existe Q0 de la forme
(~y : ~U )? tel que Q~xy !\Lambda fi Q0. Alors, [~x : ~A][y : I~x]Q~xy !\Lambda fi [~x : ~A][y : I~x]Q0 et [~x : ~A][y :

I~x]Q~xy !\Lambda j Q. Donc, par confluence, il existe Q00 de la forme [~x : ~A][y : I~x](~y : ~U 0)?
tel que Q !\Lambda fij Q00.

7.1. CALCUL DES CONSTRUCTIONS INDUCTIVES 85

Par contre, demander que les inductifs de Q soient des sous-termes de I est
une restriction plus s'ev`ere d^ue uniquement au fait qu'on se restreint au Calcul
des Constructions et qu'on ne peut donc pas typer le sch'ema d''elimination forte
de mani`ere polymorphe (c'est pourquoi B. Werner se place dans un PTS plus
g'en'eral).

ffl Dans la r`egle (conv), au lieu de demander T $\Lambda fij' T 0, on demande T $\Lambda fi'0 T 0 qui

est 'equivalent `a T #fi'0 T 0 puisque !fi'0 est confluente (CRS orthogonal).

Nous d'esignerons par !fi'0 la relation de r'eduction de CIC\Gamma , par N F l'ensemble des termes de CIC\Gamma  qui admettent une forme normale pour !fi'0 (unique par
confluence), par t # la forme normale de t, et par ` la relation de typage de CIC\Gamma 
(Figure 7.2).

Fig. 7.2 - R`egles de typage de CIC \Gamma 

(Ind)

A = (~x : ~A)? ` A : 2 8i; X : A ` Ci : ?

I = Ind(X : A)f ~Cg 2 N F est admissible

` I : A

(Constr)

I = Ind(X : A)f ~Cg \Gamma  ` I : T

\Gamma  ` Constr(i; I) : CifX 7! Ig

(?-Elim)

A = (~x : ~A) ? I = Ind(X : A)f ~Cg \Gamma  ` I : T

` Q : (~x : ~A)I~x ! ?
Ti = \Delta fI; X; Ci; Q; Constr(i; I)g ` Ti : ?
fl = f~x 7! ~ag 8j; \Gamma  ` aj : Ajfl \Gamma  ` c : I~a 8i; \Gamma  ` fi : Ti

\Gamma  ` Elim(I; Q; ~a; c)f ~f g : Q~ac

(2-Elim)

A = (~x : ~A) ? I = Ind(X : A)f ~Cg
Q = [~x : ~A][y : I~x]K 2 N F ~x : ~A; y : I~x ` K : 2

les inductifs de Q sont des sous-termes de I
Ti = \Delta 0fI; X; Ci; ~xy; K; Constr(i; I)g ` Ti : 2
fl = f~x 7! ~ag 8j; \Gamma  ` aj : Ajfl \Gamma  ` c : I~a 8i; \Gamma  ` fi : Ti

\Gamma  ` Elim(I; Q; ~a; c)f ~f g : Kf~x 7! ~a; y 7! cg

(Conv)

\Gamma  ` t : T T $\Lambda fi'0 T 0 \Gamma  ` T 0 : s

\Gamma  ` t : T 0

Th'eor`eme 98 Il existe un CAC \Upsilon  (de relation de typage `\Upsilon  et de relation de
r'eduction !) v'erifiant les conditions de normalisation forte de la D'efinition 91, et
une fonction h i qui, `a un terme de CIC\Gamma , associe un terme de \Upsilon  telle que :

- si \Gamma  ` t : T alors h\Gamma i `\Upsilon hti : hT i,
- si de plus t !fi'0 t0 alors hti !+ ht0i.
Ainsi, !fi'0 est fortement normalisante dans CIC\Gamma .

86 CHAPITRE 7. EXEMPLES DE CAC
D'efinition 99 (Traduction) Nous d'efinissons hti sur les termes bien typ'es, par
r'ecurrence sur \Gamma  ` t : T :

ffl Soit I = Ind(X : A)f ~Cg avec A = (~x : ~A)?. Nous prenons hIi = [~x : h ~Ai]IndI (~x)

o`u IndI est un symbole de type hAi.

ffl Par hypoth`ese, Ci = (~z : ~B)X ~m. Nous prenons hConstr(i; I)i = [~z : h ~Bi`0]

ConstrIi (~z) o`u `0 = fX 7! hIig, ConstrIi est un symbole de type (~z : ~B0)IndI (h ~mi),
B0j = hBji si X n'appara^it pas dans Bj, et B0j = (~y : h ~Di)IndI (h~qi) si Bj = (~y :

~D)X~q.

ffl Soit Q un terme qui n'est pas de la forme [~x : ~A][y : I~x]K avec K = (~y : ~U )?.

Nous prenons hElim(I; Q; ~a; c)f ~f gi = WElimI (hQi; h~ai; hci; h ~f i) o`u WElimI est
un symbole de type (Q : (~x : h ~Ai) hIi~x ! ?)(~x : h ~Ai)(y : hIi~x)( ~f : h ~T i)hQi~xy et
Ti = \Delta fI; X; Ci; Q; Constr(i; I)g.

ffl Soit Q un terme de la forme [~x : ~A][y : I~x]K avec K = (~y : ~U )?. Nous prenons

hElim(I; Q; ~a; c)f ~f gi = SElimQI (h~ai; hci; h ~f i) o`u SElimQI est un symbole de type

(~x : h ~Ai)(y : hIi~x)( ~f : h ~T i)hKi, Ti = \Delta 0fI; X; Ci; ~xy; K; Constr(i; I)g.

ffl Les autres termes sont d'efinis r'ecursivement : huvi = huihvi; : : :

Soit \Upsilon  le CAC dont les symboles sont ceux d'ecrits pr'ec'edemment et dont les r`egles
sont :

WElimI (Q; ~x; ConstrIi (~z); ~f ) ! \Delta 0W [I; X; Ci; fi; Q; ~f ; ~z]

SElimQI (~x; ConstrIi (~z); ~f ) ! \Delta 0S[I; X; Ci; fi; Q; ~f ; ~z]

o`u \Delta 0W [I; X; C; f; Q; ~f ; ~z] et \Delta 0S[I; X; C; f; Q; ~f ; ~z] sont d'efinis de la mani`ere suivante :

- \Delta 0W [I; X; X ~m; f; Q; ~f ; ~z] = \Delta 0S[I; X; X ~m; f; Q; ~f ; ~z] = f ,
- \Delta 0S[I; X; (z : B)D; f; Q; ~f ; z~z] = \Delta 0S[I; X; D; f z; Q; ~f ; ~z]

et \Delta 0W [I; X; (z : B)D; f; Q; ~f ; z~z] = \Delta 0W [I; X; D; f z; Q; ~f ; ~z] si X =2 FV(B)

- \Delta 0S[I; X; (z : B)D; f; Q; ~f ; z~z] = \Delta 0S[I; X; D; f z [~y : ~D]SElimQI ( ~f ; ~q; z~y); Q; ~f ; ~z]

et \Delta 0W [I; X; (z : B)D; f; Q; ~f ; z~z] =
\Delta 0W [I; X; D; f z [~y : ~D]WElimI (Q; ~f ; ~q; z~y); Q; ~f ; ~z] si B = (~y : ~D)X~q

Comme !fi'0 est confluente, \Upsilon  est un ATS logique. Donc, la fi-r'eduction pr'eserve
le typage. Cela va nous ^etre utile pour montrer que la traduction pr'eserve le typage :

Lemme 100 Si \Gamma  ` t : T alors h\Gamma i `\Upsilon hti : hT i.

Preuve. Par r'ecurrence sur \Gamma  ` t : T .
(Ind) Nous devons montrer `\Upsilon hIi : hAi. Nous avons hIi = [~x : h ~Ai]IndI (~x) avec

IndI de type hAi = (~x : h ~Ai)?. Comme ` A : 2, par hypoth`ese de r'ecurrence, nous
avons `\Upsilon hAi : 2, c'est-`a-dire, `\Upsilon o/IndI : 2. Par inversion, on obtient ~x : h ~Ai `\Upsilon ? : 2.
Donc, \Gamma  = ~x : h ~Ai est valide et, par le lemme d'environnement et (weak), pour tout
i, \Gamma  `\Upsilon xi : hAii. Ainsi, par (symb), \Gamma  `\Upsilon IndI (~x) : ? et, par (abs), \Gamma  `\Upsilon hIi : hAi.

7.1. CALCUL DES CONSTRUCTIONS INDUCTIVES 87

(Constr) Nous devons montrer h\Gamma i `\Upsilon hConstr(i; I)i : hCi`i o`u ` = fX 7! Ig. Nous

avons Ci = (~z : ~B) X ~m, hConstr(i; I)i = [~z : h ~Bi`0]ConstrIi (~z), `0 = fX 7! hIig,
ConstrIi de type (~z : ~B0)IndI (h ~mi), B0j = hBji si X n'appara^it pas dans Bj,

B0j = (~y : h ~Di)IndI (h~qi) si Bj = (~y : ~D)X~q, hCi`i = hCii`0 = (~z : h ~Bi`0)hIih ~mi et
hIi = (~x : h ~Ai)IndI (~x).

Ainsi, hIih ~mi !\Lambda fi IndI (h ~mi). De plus, si X n'appara^it pas dans Bj alors B0j =
hBji = hBji`0. Si Bj = (~y : ~D)X~q alors B0j = (~y : h ~Di)IndI (h~qi) et hBji`0 = (~y :
h ~Di)hIih~qi. Comme, hIih~qi !\Lambda fi IndI (h~qi), pour tout j, hBji`0 !\Lambda fi B0j.

Comme \Gamma  ` I : T , par hypoth`ese de r'ecurrence, h\Gamma i `\Upsilon hIi : hT i et h\Gamma i est
valide. Par ailleurs, par inversion, ` I : A et X : A ` Ci : ?. Par inversion
encore, X : A; ~z : ~B ` X ~m : ?. Par hypoth`ese de r'ecurrence, `\Upsilon hIi : hAi et
X : hAi; ~z : h ~Bi `\Upsilon Xh ~mi : ?. Par substitution, ~z : h ~Bi`0 `\Upsilon hIih ~mi : ?. Donc,
\Delta  = ~z : h ~Bi`0 est valide. Comme h ~Bi`0 !\Lambda fi ~B0, par pr'eservation du typage sur les

environnements, il en va de m^eme de \Delta 0 = ~z : ~B0. Donc, ~z : ~B0 `\Upsilon hIih ~mi : ? et,
par (prod), `\Upsilon (~z : ~B0)IndI (h ~mi) : ?, c'est-`a-dire, `\Upsilon o/ConstrI

i

: ?.

Par le lemme d'environnement et (conv), pour tout j, \Delta  `\Upsilon zj : B0j. Donc,
par (symb), \Delta  `\Upsilon  ConstrIi (~z) : IndI (h ~mi) et, par (abs), `\Upsilon hConstr(i; I)i : (~z :
h ~Bi`0)IndI (h ~mi). Finalement, par (conv) et (weak), h\Gamma i `\Upsilon hConstr(i; I)i : hCi`i.

(?-Elim) Nous devons montrer h\Gamma i `\Upsilon hElim(I; Q; ~a; c)f ~f gi : hQ~aci. Nous avons

hElim(I; Q; ~a; c)f ~f gi = WElimI (hQi; h~ai; hci; h ~f i), WElimI de type (Q : hBi)(~x :
h ~Ai)(y : I~x)( ~f : h ~T i)hQi~xy, B = (~x : ~A)I~x ! ?, Ti = \Delta fI; X; Ci; Q; Constr(i; I)g
et hQ~aci = hQih~aihci. Afin de pouvoir appliquer (symb), montrons (1) h\Gamma i `

\Upsilon hQi : hBi, (2) h\Gamma i `\Upsilon h~ai : h

~Aifl0, (3) h\Gamma i `

\Upsilon hci : hIi~xfl

0, (4) h\Gamma i `

\Upsilon h

~f i : h ~T ifl0

et (5) `\Upsilon o/WElimI : ?, o`u fl0 = fQ 7! hQi; ~x 7! h~ai; y 7! hci; ~f 7! h ~f ig. D'abord,
remarquons que, comme \Gamma  ` c : I~a, par hypoth`ese de r'ecurrence, h\Gamma i `\Upsilon hci : hI~ai
et h\Gamma i est valide.

(1) Comme ` Q : B, par hypoth`ese de r'ecurrence, `\Upsilon hQi : hBi. Donc, par affaiblissement, h\Gamma i `\Upsilon hQi : hBi.

(2) Comme \Gamma  ` aj : Ajfl, par hypoth`ese de r'ecurrence, h\Gamma i `\Upsilon haji : hAjfli. Or,

hAjfli = hAjifl0 car FV(Aj) ` f~xg.

(3) Comme \Gamma  ` c : I~a, par hypoth`ese de r'ecurrence, h\Gamma i `\Upsilon hci : hI~ai. Or, hI~ai =

hIih~ai = hIi~xfl0.

(4) Comme \Gamma  ` fi : Ti, par hypoth`ese de r'ecurrence, h\Gamma i `\Upsilon hfii : hTii. Or,

hTiifl0 = hTii car Ti est clos (` Ti : ?).

(5) Soit \Delta  = Q : hBi; ~x : h ~Ai; (y : hIi~x) et \Delta 0 = \Delta ; ~f : h ~T i. Montrons que

\Delta 0 est valide. En effet, si c'est le cas, alors \Delta 0 `\Upsilon hQi~xy : ? et, par (prod),
`\Upsilon o/WElimI : ?. Nous avons `\Upsilon hQi : hBi. Donc, `\Upsilon hBi : 2. Par (var), Q : hBi `

\Upsilon Q : hBi. Par inversion, Q : hBi; ~x : h

~Ai; y : hIi~x `

\Upsilon ? : 2 et \Delta  est valide.

Soit \Delta i = \Delta ; f1 : hT1i; : : : ; fi : hTii. Montrons par r'ecurrence sur i que \Delta i est

valide. Si i = 0, c'est imm'ediat. Montrons alors que si \Delta i est valide alors \Delta i+1
l'est aussi. Comme `\Upsilon hTi+1i : ?, par affaiblissement, \Delta i `\Upsilon hTi+1i : ?. Donc,
par (var), \Delta i+1 `\Upsilon fi+1 : Ti+1 et \Delta i+1 est valide.

88 CHAPITRE 7. EXEMPLES DE CAC

(2-Elim) Nous devons montrer h\Gamma i `\Upsilon hElim(I; Q; ~a; c)f ~f gi : hKi. Nous avons

hElim(I; Q; ~a; c)f ~f gi = SElimQI (h~ai; hci; h ~f i), SElimQI de type (~x : h ~Ai)(y : I~x)( ~f :
h ~T i)hKi et Ti = \Delta 0fI; X; Ci; Q; Constr(i; I)g. Afin de pouvoir appliquer (symb),
montrons (1) h\Gamma i `\Upsilon h~ai : h ~Aifl0, (2) h\Gamma i `\Upsilon hci : hIi~xfl0, (3) h\Gamma i `\Upsilon h ~f i : h ~T ifl0 et
(4) `\Upsilon o/SElimI : 2, o`u fl0 = f~x 7! h~ai; y 7! hci; ~f 7! h ~f ig. D'abord, remarquons
que, comme \Gamma  ` c : I~a, par hypoth`ese de r'ecurrence, h\Gamma i `\Upsilon hci : hI~ai et h\Gamma i est
valide.

(1) Comme \Gamma  ` aj : Ajfl, par hypoth`ese de r'ecurrence, h\Gamma i `\Upsilon haji : hAjfli. Or,

hAjfli = hAjifl0 car FV(Aj) ` f~xg.

(2) Comme \Gamma  ` c : I~a, par hypoth`ese de r'ecurrence, h\Gamma i `\Upsilon hci : hI~ai. Or, hI~ai =

hIih~ai = hIi~xfl0.

(3) Comme \Gamma  ` fi : Ti, par hypoth`ese de r'ecurrence, h\Gamma i `\Upsilon hfii : hTii. Or,

hTiifl0 = hTii car Ti est clos (` Ti : 2).

(4) Soit \Delta  = ~x : h ~Ai; y : hIi~x et \Delta 0 = \Delta ; ~f : h ~T i. Nous avons \Delta  `\Upsilon hKi : 2.

Montrons que \Delta 0 est valide. En effet, si c'est le cas, alors, par affaiblissement,
\Delta 0 `\Upsilon hKi : 2 et, par (prod), `\Upsilon o/SElimI : ?. Soit \Delta i = \Delta ; f1 : hT1i; : : : ; fi : hTii.
Montrons par r'ecurrence sur i que \Delta i est valide. Si i = 0, c'est imm'ediat.
Montrons alors que si \Delta i est valide alors \Delta i+1 l'est aussi. Comme `\Upsilon hTi+1i : 2,
par affaiblissement, \Delta i `\Upsilon hTi+1i : 2. Donc, par (var), \Delta i+1 `\Upsilon fi+1 : Ti+1 et
\Delta i+1 est valide.

Les autres cas se traitent sans difficult'e. \Xi 

Lemme 101 Les r`egles de \Upsilon  sont bien typ'ees.

Preuve. Nous devons montrer que chacune des r`egles v'erifie les conditions (S3)
`a (S5). Voyons le cas de WElimI (Q; ~x; ConstrIi (~z); ~f ) ! \Delta 0W [I; X; Ci; fi; Q; ~f ; ~z].

Le cas de SElimQI (~x; ConstrIi (~z); ~f ) ! \Delta 0S[I; X; Ci; fi; Q; ~f ; ~z] se traite de mani`ere
similaire. Soit B = (~x : ~A)I~x ! ?. Nous avons o/WElimI = (Q : hBi)(~x : h ~Ai)(y :
hIi~x)( ~f : h ~T i)Q~xy, Ti = \Delta fI; X; Ci; Q; Constr(i; I)g, Ci = (~z : ~B)X ~m, Bj = (~yj :

~Dj)X~qj si X 2 FV(Bj), o/

ConstrIi = (~z :

~B0)IndI (h ~mi), B0

j = hBji si X =2 FV(Bj),

B0j = (~yj : h ~Dji)IndI (h~qji) sinon, et o/IndI = (~x : h ~Ai)?. Soit l = WElimI (Q; ~x; c; ~f ),

r = \Delta 0W [I; X; Ci; fi; Q; ~f ; ~z], c = ConstrIi (~z) et fl = fy 7! cg. Nous prenons \Gamma  = Q :
hBi; ~z : ~B0; ~f : h ~T i et ae = f~x 7! h ~mig.

(S2) Nous devons montrer \Gamma  `\Upsilon r : Qh ~mic. Nous avons r = \Delta 0W [I; X; Ci; fi; Q; ~f ; ~z]

et Ti = \Delta fI; X; Ci; Q; Constr(i; I)g. Cela ne pr'esente pas de difficult'es.

(S3) Nous devons montrer que si \Delta  `\Upsilon loe : T alors oe : \Gamma  ! \Delta . Nous avons \Delta  `

\Upsilon WElimI (Qoe; ~xoe; Constr

I
i (~zoe);

~f oe) : T . Alors, par inversion, on d'eduit \Delta  `

\Upsilon Qoe : hBioe, \Delta  `\Upsilon ~zoe :

~B0oe et \Delta  `

\Upsilon 

~f oe : h ~T ioe, c'est-`a-dire, oe : \Gamma  ! \Delta .

(S4) Nous devons montrer que si \Delta  `\Upsilon loe : T alors, pour tout x, xaeoe # xoe.

Par inversion, nous avons \Delta  ` \Upsilon  coe : hIi~xoe et IndI (h ~mioe) C\Lambda \Delta  hIi~xoe. Par
ailleurs, hIi~xoe !\Lambda fi IndI (~xoe). Donc, IndI (h ~mioe) C\Lambda  IndI (~xoe) et, par confluence,
IndI (h ~mioe) # IndI (~xoe). Comme IndI est constant et h ~mioe = ~xaeoe, on obtient
~xoe # ~xaeoe. \Xi 

7.1. CALCUL DES CONSTRUCTIONS INDUCTIVES 89
Lemme 102 Les r`egles de \Upsilon  sont bien form'ees.

Preuve. Voyons le cas de WElimI (Q; ~x; ConstrIi (~z); ~f ) ! \Delta 0W [I; X; Ci; fi; Q; ~f ;
~z]. Le cas de SElimQI (~x; ConstrIi (~z); ~f ) ! \Delta 0S[I; X; Ci; fi; Q; ~f ; ~z] se traite de mani`ere similaire. Soit B = (~x : ~A)I~x ! ?. Nous avons \Gamma  = Q : hBi; ~z : ~B0; ~f : h ~T i
et ae = f~x 7! h ~mig. Nous devons montrer que chaque variable x 2 dom(\Gamma ) est
faiblement accessible dans un des arguments de WElimI , que x\Gamma  est 'egal `a T ae o`u
T est le type de x d'eriv'e de l et que \Gamma  `\Upsilon lae : (Q~xy)flae.

L'accessibilit'e est imm'ediate pour Q et ~f . Les zj sont faiblement accessibles
puisque toutes les positions d'un constructeur sont accessibles (voir la d'efinition de
Acc(ConstrIi )). Le type de zj d'eriv'e de l est B0j qui ne d'epend pas de ~x. Donc,
B0jae = B0j = zj\Gamma .

Voyons \Gamma  `\Upsilon lae : (Q~xy)flae maintenant. Nous avons lae = WElimI (Q; h ~mi,
ConstrIi (~z); ~f ) et (Q~xy)flae = Qh ~mic. Pour appliquer (symb), nous devons montrer
(1) `\Upsilon o/WElimI : ?, (2) \Gamma  `\Upsilon Q : hBi, (3) \Gamma  `\Upsilon h ~mi : h ~Aiae, (4) \Gamma  `\Upsilon c : hIih ~mi et
(5) \Gamma  `\Upsilon  ~f : h ~T i.

Montrons alors que \Gamma  est valide. Tout d'abord, WElimI n'est d'efini que s'il existe
un terme bien typ'e de la forme Elim(I; Q0; ~a; c0)f ~f g. Et, dans ce cas, nous avons
` Q0 : B et ` ~T : ?. Donc, ` B : 2 et `\Upsilon hBi : 2. Ainsi, Q : hBi est valide. Par ailleurs,
si WElimI est bien d'efini alors IndI est 'egalement bien d'efini, et donc ConstrIi aussi.
Or, nous avons montr'e dans le lemme pr'ec'edent que, dans ce cas, `\Upsilon o/ConstrI

i

: ?. Par

affaiblissement, Q : hBi `\Upsilon o/ConstrI

i

: ?. Par inversion, Q : hBi; ~z : ~B0 `\Upsilon IndI (h ~mi) : ?

et Q : hBi; ~z : ~B0 est valide. Enfin, comme ` ~T : ?, `\Upsilon h ~T i : ? et, par affaiblissement,
Q : hBi; ~z : ~B0 `\Upsilon h ~T i : ?. Donc \Gamma  est valide.

(1) D'ej`a montr'e dans le lemme pr'ec'edent.
(2) Par le lemme d'environnement.
(3) De ~z : ~B0 `\Upsilon IndI (h ~mi) : ?, par inversion, nous d'eduisons ~z : ~B0 `\Upsilon h ~mi : h ~Aiae.

Donc, par affaiblissement, \Gamma  `\Upsilon h ~mi : h ~Aiae.

(4) Comme \Gamma  `\Upsilon ~z : ~B0, par (symb), \Gamma  `\Upsilon c : IndI (h ~mi). Or, hIih ~mi !\Lambda fi IndI (h ~mi).

D'apr`es (3), \Gamma  `\Upsilon h ~mi : h ~Aiae. Donc, par (app), \Gamma  `\Upsilon hIih ~mi : ?. Donc, par (conv),
\Gamma  `\Upsilon c : hIih ~mi.

(5) Par le lemme d'environnement. \Xi 

Lemme 103 \Upsilon  v'erifie les conditions de normalisation forte de la D'efinition 91.

Preuve.
(A0) D'ej`a montr'e.
(A1) Nous avons d'ej`a vu que ! est confluente.
(A2) Pour la structure inductive, nous prenons :

- IndI ?C IndJ si J est un sous-terme strict de I est un pr'e-ordre bien fond'e,
- Ind(IndI ) = ;,
- Acc(ConstrIi ) = f1; : : : ; ng o`u n est l'arit'e de ConstrIi .

90 CHAPITRE 7. EXEMPLES DE CAC

Montrons que cette structure est admissible. Soit C un pr'edicat constant. Alors
C = IndI avec I = Ind(X : A)f ~Cg et A = (~x : ~A)?, et C est de type (~x : h ~Ai)?.
Soit c = ConstrIi un des constructeurs de C. Par hypoth`ese, Ci = (~z : ~B)X ~m et
Bj = (~yj : ~Dj)X~qj si X 2 FV(Bj). Donc c est de type (~z : ~B0) avec B0j = hBji si

X =2 FV(Bj), et B0j = (~yj : h ~Dji)C(h~qji) avec X =2 FV( ~Dj~qj) sinon. Soit ~v = ~m,
j 2 Acc(c) et Uj = B0j.

(I3) 8D 2 CF 2; D =C C ) Pos(D; Uj) ` Pos+(Uj). N'ecessairement, D = C.

Soit X =2 FV(Bj) et Pos(C; Uj ) = ;, soit Bj = (~y : ~D)X~q, X =2 FV( ~D~q).
Dans tous les cas, Pos(C; Uj) ` Pos+(Uj).

(I4) 8D 2 CF 2; D ?C C ) Pos(D; Uj) ` Pos0(Uj). Si D = IndJ ?C C = IndI

alors I est un sous-terme strict de J . Donc, J ne peut pas appara^itre dans
I et Pos(D; Uj) = ;.

(I5) 8F 2 DF 2; Pos(F; Uj) ` Pos0(Uj). Par hypoth`ese sur les types de CIC\Gamma .
(I6) 8Y 2 FV2(Uj); 9 'Y ^ ffC ; v'Y = Y . Par hypoth`ese sur les types de CIC\Gamma .
(I2) 8Y 2 FV2(Uj); 'Y 2 Ind(C) ) Pos(Y; Uj) ` Pos+(Uj). Car Ind(C) = ;.

(A3) Pour *, on prend l''egalit'e. Montrons que les r`egles qui d'efinissent SElimQI

forment un syst`eme :

- r'ecursif : On le montre ci-apr`es pour tous les symboles.
- petit : Nous avons SElimQI (~x; ConstrIi (~z); ~f ) ! \Delta 0S[I; X; Ci; fi; Q; ~f ; ~z]. Nous

d'esignerons par ~l les arguments de SElimQI et par r le membre droit de la
r`egle. Nous devons montrer que, pour tout X 2 FV2(r), il existe un unique
^X tel que l^X = X. Nous avons FV2(r) = f ~f g [ (f~zg " X 2). Pour les fj, c'est
imm'ediat. Pour les zj 2 X 2, cela d'ecoule de la restriction de l''elimination
forte aux types inductifs petits : ~z = ~x~z0 avec f~z0g " X 2 = ;.

- simple :

(B1) Les symboles qui apparaissent dans les arguments de WElimI ou

SElimQI sont constants.

(B2) Au plus une r`egle peut s'appliquer au sommet d'un terme de la forme

WElimI (Q; ~a; c; ~f ) ou SElimQI (~a; c; ~f ).

(A4) Nous avons F1 = ;. Nous n'avons donc qu'`a v'erifier les conditions (a) et (b) :

(a) (F; R) est r'ecursif : Voyons le cas de WElimI (Q; ~x; ConstrIi (~z); ~f ) !

\Delta 0W [I; X; Ci; fi; Q; ~f ; ~z]. Nous d'esignerons respectivement par l et par r le
membre gauche et le membre droit de cette r`egle. Le cas de SElimQI (~x,
ConstrIi (~z); ~f ) ! \Delta 0S[I; X; Ci; fi; Q; ~f ; ~z] se traite de mani`ere similaire.

Pour la pr'ec'edence *F , nous prenons WElimI ?F WElimJ , WElimI
?F SElimQJ , SElimI ?F WElimJ et SElimI ?F SElimQJ si J est un
sous-terme strict de I, et tous les symboles d'efinis sup'erieurs aux symboles
constants.

Pour le statut, nous prenons statWElimI = lex(mul(xk)) o`u k est la
position de l'argument de type hIi~x. De m^eme pour SElimI . Il est donc
imm'ediat que cet assignement est compatible avec *F .

7.2. CALCUL DES CONSTRUCTIONS INDUCTIVES + R 'ECRITURE 91

Nous avons d'ej`a montrer que les r`egles 'etaient bien form'ees. Montrons
maintenant que r appartient `a la cl^oture calculable de l, c'est-`a-dire, \Gamma  `c
r : Qh ~mic o`u c = ConstrIi (~z). Tout d'abord, remarquons que R et o/ sont
compatibles avec *F . C'est clair pour R. Pour o/ , cela est d^u `a notre restriction sur SElimQI : les inductifs de Q sont des sous-termes de I. Ainsi,
par les Lemmes 89 et 87, nous avons \Gamma  `c x\Gamma  : s pour tout x 2 doms(\Gamma ), et
\Gamma  `c o/g : s pour tout g ^F WElimI . `A partir de l`a, on v'erifie ais'ement que
\Gamma  `c r : Qh ~mic.

(b) (F ; R) est s^ur : Soit ~T U la s'equence hQi; h ~Ai; hIi~x; h ~T i; Q~xy. Nous devons

montrer :

- 8X 2 FV2( ~T U ); Xflae 2 dom2(\Gamma ),
- 8X; X0 2 FV2( ~T U ); Xflae = X0flae ) X = X0.

Nous avons FV2( ~T U ) = fQg [ f~xg " X 2, Qflae = Q 2 dom2(\Gamma ) et xiflae =
hmii. Donc les propri'et'es pr'ec'edentes sont v'erifi'ees du fait de l'hypoth`ese
de s^uret'e que nous faisons sur les types de CIC\Gamma . \Xi 

Il ne nous reste plus maintenant qu'`a montrer que la traduction r'efl'echit la
normalisation forte :

Lemme 104 Si \Gamma  ` t : T et t !fi'0 t0 alors hti !+ ht0i.

Preuve. Par r'ecurrence sur \Gamma  ` t : T .
(Ind) Comme I 2 N F , aucune r'eduction n'est possible.
(Constr) Comme \Gamma  ` I : T , par inversion, I 2 N F et aucune r'eduction n'est

possible.

(?-Elim) Nous avons hti = WElimI (hQi; h~ai; hci; h ~f i). Comme \Gamma  ` I : T , par

inversion, I 2 N F et aucune r'eduction n'est possible dans I. Si Q !fi'0 Q0 alors,

comme ` Q : (~x : ~A)I~x ! ?, par hypoth`ese de r'ecurrence, hQi !+ hQ0i et
hti !+ ht0i. Si ~a !fi'0 ~a0 alors, comme \Gamma  ` ~a : ~Afl, par hypoth`ese de r'ecurrence,
h~ai !+ h~a0i et hti !+ ht0i. Enfin, si c !fi'0 c0 alors, comme \Gamma  ` c : I~a, par
hypoth`ese de r'ecurrence, hci !+ hc0i et hti !+ ht0i.

(2-Elim) Nous avons hti = SElimQI (h~ai; hci; h ~f i). Comme \Gamma  ` I : T , par inversion,

I 2 N F et aucune r'eduction n'est possible dans I. De m^eme, comme Q 2 N F ,
aucune r'eduction n'est possible dans Q. Si ~a !fi'0 ~a0 alors, comme \Gamma  ` ~a : ~Afl,
par hypoth`ese de r'ecurrence, h~ai !+ h~a0i et hti !+ ht0i. Enfin, si c !fi'0 c0 alors,
comme \Gamma  ` c : I~a, par hypoth`ese de r'ecurrence, hci !+ hc0i et hti !+ ht0i.

Les autres cas se traitent sans difficult'es. \Xi 

7.2 Calcul des Constructions Inductives + R'ecriture

Nous venons de voir qu'une grande partie du Calcul des Constructions Inductives
est formalisable dans un CAC. Nous allons voir que nous pouvons rajouter `a ce

92 CHAPITRE 7. EXEMPLES DE CAC
CAC des r`egles de r'ecriture qui ne sont pas formalisables dans CIC. Prenons les
symboles nat : ?, 0 : nat, s : nat ! nat, +; \Theta  : nat ! nat ! nat, list : ? ! ?,
nil : (A : ?)list(A), cons : (A : ?)A ! list(A) ! list(A), app : (A : ?)list(A)) !
list(A) ! list(A), len : (A : ?)list(A) ! nat la longueur d'une liste, in : (A :
?)A ! list(A) ! ? le pr'edicat d'appartenance d'un 'el'ement `a une liste, incl : (A :
?)list(A) ! list(A) ! ? le pr'edicat d'appartenance des 'el'ements d'une liste `a un
autre liste, sub : (A : ?)list(A) ! list(A) ! ? le pr'edicat "^etre une sous-liste de",
eq : (A : ?)A ! A ! ? l''egalit'e polymorphe, ? : ? la proposition toujours vraie, ? : ?
la proposition toujours fausse, : : ? ! ?, .; ^ : ? ! ? ! ?, et les r`egles suivantes :

x + 0 ! x
0 + x ! x
x + s(y) ! s(x + y)
s(x) + y ! s(x + y)
(x + y) + z ! x + (y + z)

x \Theta  0 ! 0
0 \Theta  x ! 0
x \Theta  s(y) ! (x \Theta  y) + x

s(0) \Theta  x ! x
x \Theta  s(0) ! x

:? ! ?
:? ! ?

P . ? ! ?
P . ? ! P

P ^ ? ! P
P ^ ? ! ?

eq(A; 0; 0) ! ?
eq(A; 0; s(x)) ! ?
eq(A; s(x); 0) ! ?
eq(A; s(x); s(y)) ! eq(nat; x; y)

app(A; nil(A0); `) ! `
app(A; cons(A0; x; `); `0) ! cons(A; x; app(A; `; `0))

app(A; app(A0; `; `0); `00) ! app(A; `; app(A; `0; `00))

len(A; nil(A0)) ! 0
len(A; cons(A0; x; `)) ! s(len(A; `))

len(A; app(A0; `; `0)) ! len(A; `) + len(A; `0)

in(A; x; nil(A0)) ! ?
in(A; x; cons(A0; y; l)) ! eq(A; x; y) . in(A; x; l)

sub(A; nil(A0); l) ! ?
sub(A; cons(A0; x; l); nil(A00)) ! ?
sub(A; cons(A0; x; l); cons(A00; x0; l0)) ! (eq(A; x; x0) ^ sub(A; l; l0))

.sub(A; cons(A; x; l); l0)
incl(A; nil(A0); l) ! ?
incl(A; cons(A0; x; l); l0) ! in(A; x; l0) ^ incl(A; l; l0)

eq(L; nil(A); nil(A0)) ! ?
eq(L; nil(A); cons(A0; x; l)) ! ?
eq(L; cons(A0; x; l); nil(A)) ! ?
eq(L; cons(A; x; l); cons(A0; x0; l0)) ! eq(A; x; x0) ^ eq(list(A); l; l0)

Le syst`eme de r'ecriture est r'ecursif, simple, petit, s^ur et confluent (cela peut ^etre
prouv'e automatiquement par CiME [30]). Comme les r`egles sont lin'eaires-gauches,
la combinaison avec !fi est confluente. Donc, les conditions de normalisation forte
sont v'erifi'ees.

7.3. D 'EDUCTION NATURELLE MODULO 93

On notera en particulier la derni`ere r`egle o`u \Gamma  = A : ?; x : A; x0 : A; ` : list(A); `0 :
list(A) et ae = fA0 7! A; L 7! list(A)g. Elle est bien form'ee : par exemple, cons(A0; x0,
`0) : L \Lambda ae1 x0 : A0. Et elle v'erifie le Sch'ema G'en'eral : fcons(A; x; `) : L, cons(A0; x0; `0) :
Lg (\Lambda ae1)mul fx : A; x0 : A0g; f` : list(A); `0 : list(A)g.

Cependant, il manque de nombreuses autres r`egles importantes pour avoir une
proc'edure de d'ecision pour les tautologies propositionnelles classiques (Figure 1.3)
ou d'autres r`egles de simplification de l''egalit'e (Figure 1.4). Pour cela, il faudrait
avoir de la r'ecriture modulo commutativit'e et associativit'e et affaiblir certaines
conditions dans la d'efinition du Sch'ema G'en'eral.

7.3 D'eduction Naturelle Modulo

La D'eduction Naturelle Modulo (NDM) pour la logique du premier ordre [47]
peut ^etre pr'esent'ee comme une extension de la D'eduction Naturelle avec la r`egle
d'inf'erence suivante :

\Gamma  ` P
\Gamma  ` Q

if P j Q

o`u j est une relation d''equivalence sur les propositions stable par substitution et
contexte. C'est une extension tr`es puissante de la logique du premier ordre puisque la
logique d'ordre sup'erieur et la th'eorie des ensembles skol'emis'ee peuvent toutes deux
^etre d'ecrites comme des th'eories modulo (en utilisant des substitutions explicites

[1]).

Dans [48], G. Dowek et B. Werner 'etudient la normalisation forte de l''elimination
des coupures dans le cas o`u j est engendr'e par un syst`eme de r'ecriture du premier
ordre confluent et faiblement normalisant. En particulier, ils prouvent la normalisation dans deux cas g'en'eraux : quand le syst`eme est positif et quand il est sans
quantificateur. Dans [49], ils fournissent un exemple de syst`eme confluent et faiblement normalisant pour lequel l''elimination des coupures n'est pas normalisante. Le
probl`eme vient du fait que la r`egle d''elimination du quantificateur 8 introduit une
substitution :

\Gamma  ` 8x:P (x)

\Gamma  ` P (t)

Ainsi, quand un symbole de pr'edicat est d'efini par une r`egle dont le membre
droit contient des quantificateurs, sa combinaison avec la fi-r'eduction peut ne pas
pr'eserver la normalisation. Un crit`ere de normalisation pour la r'ecriture d'ordre
sup'erieur comme celui que nous fournissons est donc n'ecessaire.

Maintenant, puisque NDM est un CAC (les connecteurs logiques peuvent ^etre
vus comme des symboles de pr'edicat constants), on peut comparer les conditions
g'en'erales donn'ees dans [48] avec les n^otres.

(A1) Dans [48], seulement !R doit ^etre confluent. Nous ne savons pas si cela

implique toujours la confluence de !R [ !fi. C'est vrai si R est lin'eaire-gauche
car, alors, nous avons une union de CRS lin'eaires-gauches et confluents n'ayant
aucune paire critique l'un par rapport `a l'autre (r'esultat g'en'eral d^u `a V. van

94 CHAPITRE 7. EXEMPLES DE CAC

Oostrom [116] et montr'e dans le cas particulier de !fi par F. M"uller [92]). Mais
nous ne connaissons pas de travaux qui montrent que, en pr'esence de types
d'ependants et de r'ecriture sur les types, !R [ !fi est confluent m^eme si R
n'est pas lin'eaire-gauche (V. Breazu-Tannen et J. Gallier ont montr'e dans [26]
la pr'eservation de la confluence pour le *-calcul polymorphe d'ordre sup'erieur
avec r'ecriture du premier ordre au niveau objet).

(A2) Les types de NDM sont primitifs et forment une structure inductive admissible

si on les prend tous 'equivalents.

(A3) Dans [48], la normalisation forte de l''elimination des coupures est prouv'ee

dans deux cas g'en'eraux : quand (DF 2; RDF2) est sans quantificateur et quand
il est positif. Les syst`emes sans quantificateur sont primitifs. Donc, dans ce cas,
(A3) est satisfait. Dans le cas positif par contre, nous demandons en plus que
les arguments des membres gauches des r`egles soient faits de symboles constants
et qu'au plus une r`egle puisse s'appliquer au sommet d'un terme (conditions de
"simplicit'e"). D'un autre c^ot'e, nous fournissons un nouveau cas : (DF 2; RDF2)
peut ^etre r'ecursif et simple (il est forc'ement petit).

(A4) Les r`egles sans quantificateur sont de premier ordre et ceux avec quantificateurs ne le sont pas. Dans [48], ces deux types de r`egles sont trait'ees de la
m^eme mani`ere. Mais le contre-exemple donn'e dans [49] nous montre qu'elles ne
le devraient pas. Dans nos conditions, nous demandons `a ce que les symboles
d'efinis par des r`egles avec quantificateurs satisfassent le Sch'ema G'en'eral.

Th'eor`eme 105 Un syst`eme NDM satisfaisant les conditions (A1), (A3) et (A4) est
fortement normalisant.

Chapitre 8
Correction des conditions de
normalisation forte

Notre preuve de normalisation forte est bas'ee sur l'extension au Calcul des
Constructions par T. Coquand et J. Gallier [33] de la m'ethode de Tait et Girard
des candidats de r'eductibilit'es [62]. L'id'ee est d'interpr'eter chaque type T par un
ensemble [[T ]] de termes fortement normalisants et de prouver que tout terme de
type T appartient `a [[T ]]. Nous renvoyons le lecteur vers le Chapitre 3 de la th`ese
de B. Werner [118] pour une introduction sur les candidats, et vers l'article [54] de
J. Gallier pour une pr'esentation plus d'etaill'ee. Une diff'erence importante entre les
candidats de T. Coquand et J. Gallier et les candidats de B. Werner pour le Calcul
des Constructions Inductives est que les premiers sont constitu'es de termes bien
typ'es alors que les seconds sont constitu'es de termes purs.

8.1 Espace des termes interpr'et'es

Afin de disposer de l'environnement dans lequel un terme est typable, nous raisonnerons plut^ot sur des fermetures (paires environnement-terme) que sur des termes
seuls.

D'efinition 106 (Fermeture) Une fermeture est un couple \Gamma  ` t constitu'e d'un
environnement \Gamma  2 E et d'un terme t 2 T . Une fermeture \Gamma  ` t est typable s'il
existe un terme T 2 T tel que \Gamma  ` t : T . On notera par T l'ensemble des fermetures
typables.

L'ensemble des fermetures de type \Gamma  ` T est T\Gamma `T = f\Gamma 0 ` t 2 T j \Gamma 0 ' \Gamma  et
\Gamma 0 ` t : T g. L'ensemble de fermetures de type \Gamma  ` T dont les termes sont fortement normalisables sera not'e SN\Gamma `T . La restriction d'un ensemble S ` T\Gamma `T `a un
environnement \Gamma 0 ' \Gamma  est Sj\Gamma 0 = S " T\Gamma 0`T = f\Gamma 00 ` t 2 S j \Gamma 00 ' \Gamma 0g.

On v'erifie ais'ement les propri'et'es 'el'ementaires suivantes :

Lemme 107

(a) si \Gamma 0 ` t 2 T\Gamma `T et \Gamma 0 ` \Gamma 00 2 E alors \Gamma 00 ` t 2 T\Gamma `T .
(b) Si \Gamma  ` \Gamma 0 2 E alors T\Gamma 0`T ` T\Gamma `T et T\Gamma `T j\Gamma 0 = T\Gamma 0`T .

95

96 CHAPITRE 8. CORRECTION DES CONDITIONS

(c) Si T C \Gamma  T 0 alors T\Gamma `T = T\Gamma `T 0.

Nous devons d'efinir une interpr'etation pour tous les termes qui peuvent ^etre le
type d'un autre terme, c'est-`a-dire pour tous les termes T pour lesquels il existe
\Gamma  et t tels que \Gamma  ` t : T . D'apr`es le lemme de correction des types, il existe s tel
que T = s ou \Gamma  ` T : s. Ainsi, il nous faut une interpr'etation pour les termes des
ensembles suivants :

- B = f\Gamma  ` T 2 E \Theta  T j \Gamma  2 E et T = 2g,
- TY

?

= P

0

= f\Gamma  ` T 2 E \Theta  T j \Gamma  ` T : ?g,

- TY

2

= K = f\Gamma  ` K 2 E \Theta  T j \Gamma  ` K : 2g.

Un terme T tel que \Gamma  ` T 2 P

0

peut ^etre obtenu par application d'un terme U `a

un terme v. Par inversion, U doit avoir un type de la forme (x : V )W . Par correction
des types, il existe s tel que \Gamma  ` (x : V )W : s. Comme T appartient `a la m^eme classe
que U , T 2 P0 ` P = T21 et U 2 Ts1, par classification, on obtient s = 2. Donc,

d'apr`es le lemme sur les sortes maximales, \Gamma  ` U ne peut pas appartenir `a P

0

. Il nous

faut donc aussi donner une interpr'etation aux termes des ensembles suivants :

- P

?

= f\Gamma  ` T 2 E \Theta  T j 9 x; U; K; \Gamma  ` T : (x : U )K ^ \Gamma  ` U : ? ^ \Gamma  ` K : 2g,

- P

2

= f\Gamma  ` T 2 E \Theta  T j 9 X; K; L; \Gamma  ` T : (X : K)L ^ \Gamma  ` K : 2 ^ \Gamma  ` L : 2g,

- P = P

0

[ P

?

[ P

2

,

- TY = B [ K [ P.

Afin de justifier notre d'efinition de P et de s'assurer que les termes `a interpr'eter
sont bien tous dans TY, il suffit de voir, d'apr`es le lemme sur les sortes maximales,
que la projection de P sur T , c'est-`a-dire fT 2 T j 9 \Gamma  2 E; \Gamma  ` T 2 Pg, est 'egale `a
P.

Lemme 108 Les ensembles P

0

, P

?

, P

2

, K et B sont disjoints deux `a deux.

Preuve. Nous venons de voir que P

0

est disjoint de P

?

et P

2

. Puisque 2 n'est

pas typable, B est disjoint de tous les autres. P et K sont disjoints puisque leurs
projections P et K sont disjointes. Il nous reste donc `a v'erifier que P

?

et P

2

sont

bien disjoints. Supposons qu'il existe \Gamma  ` T 2 P

?

" P

2

. Alors il existe x, U , K, X, K0

et L tels que \Gamma  ` T : (x : U )K, \Gamma  ` U : ?, \Gamma  ` K : 2, \Gamma  ` T : (X : K0)L, \Gamma  ` K0 : 2
et \Gamma  ` L : 2. Par convertibilit'e des types, (x : U )K C \Lambda \Gamma  (X : K0)L. Par compatibilit'e
avec le produit, U C \Lambda \Gamma  K0. Par correction de la conversion, ? = 2, ce qui n'est pas
possible. \Xi 

Nous allons maintenant introduire une mesure sur TY qui nous permettra de
faire des d'efinitions r'ecursives bien fond'ees.

D'efinition 109 _(\Gamma  ` T ) =

ae

0 si T = 2 or \Gamma  ` T : 2

*(K) si \Gamma  ` T : K et \Gamma  ` K : 2
o`u * est d'efini sur les types de pr'edicats de la mani`ere suivante :

- *(?) = 0

8.2. CANDIDATS DE R 'EDUCTIBILIT 'E 97

- *((x : U )K) = 1 + *(K)
- *((X : K)L) = 1 + max(*(K); *(L))

On doit v'erifier que cette d'efinition ne d'epend pas de K. Comme tous les types
de T sont convertibles les uns aux autres, il suffit de v'erifier que * est invariante par
conversion :

Lemme 110 Si K C \Lambda \Gamma  K0 alors *(K) = *(K0).

Preuve. Par r'ecurrence sur la taille de K et K0. D'apr`es le lemme sur les sortes
maximales, K est de la forme (~x : ~T )?, K0 est de la forme (~x : ~T 0)? et j~xj = j~x0j.
Soit n = j~xj = j~x0j. Par compatibilit'e avec le produit et ff-'equivalence, on peut
supposer que ~x0 = ~x. Si n = 0 alors K = K0 et *(K) = *(K0). Supposons alors
n ? 0. Soit L = (x2 : T2) : : : (xn : Tn)? et L0 = (x2 : T 02) : : : (xn : T 0n)?. Par compatibilit'e
avec le produit, T1 C \Lambda \Gamma  T 01 et L C \Lambda \Gamma ;x1 :T1 L0. Par correction de la conversion, T1 et T 01
sont typables par la m^eme sorte s. Par inversion et r'egularit'e, \Gamma ; x1 : T1 ` L : 2 et
\Gamma ; x1 : T1 ` L0 : 2. Ainsi, par hypoth`ese de r'ecurrence, *(L) = *(L0) et, si s = 2,
*(T1) = *(T 01). Donc, *(K) = *(K0). \Xi 

Lemme 111 Si \Gamma  ` T 2 TY et ` : \Gamma  ! \Delta  alors \Delta  ` T ` 2 TY et _(\Delta  ` T `) = _(\Gamma  `
T ).

Preuve. Tout d'abord, il est facile de montrer par r'ecurrence sur la structure
des types de pr'edicats que, si K est un type de pr'edicats et ` une substitution, alors
K` est un type de pr'edicats et *(K`) = *(K). Montrons maintenant le lemme par
cas sur T .

- T = 2. \Delta  ` T ` = \Delta  ` 2 2 TY et _(\Delta  ` T `) = 0 = _(\Gamma  ` T ).
- \Gamma  ` T : 2. Par substitution, \Delta  ` T ` : 2, \Delta  ` T ` 2 TY et _(\Delta  ` T `) = 0 = _(\Gamma  `

T ).

- \Gamma  ` T : K et \Gamma  ` K : 2. Par substitution, \Delta  ` T ` : K` et \Delta  ` K` : 2.

Donc \Delta  ` T ` 2 TY. Maintenant, _(\Delta  ` T `) = *(K`) et _(\Gamma  ` T ) = *(K). Or,
*(K`) = *(K). \Xi 

8.2 Candidats de r'eductibilit'e

On notera par :
- SN l'ensemble des termes fortement normalisables pour !,
- WN l'ensemble des termes faiblement normalisables pour !,
- CR l'ensemble des termes t tels que deux r'eductions partant de t confluent toujours.

D'efinition 112 (Termes neutres) Un terme est neutre s'il n'est ni une abstraction ni de la forme c(~t) o`u c est un constructeur.

98 CHAPITRE 8. CORRECTION DES CONDITIONS
D'efinition 113 (Candidats de r'eductibilit'e) Pour chaque \Gamma  ` T 2 TY, nous
allons d'efinir par r'ecurrence sur _(\Gamma  ` T ) :

- l'ensemble R\Gamma `T des candidats de r'eductibilit'e de type \Gamma  ` T ,
- la restriction Rj\Gamma 0 d'un candidat R 2 R\Gamma `T `a un environnement \Gamma 0 ' \Gamma ,
- la relation ^\Gamma `T sur R\Gamma `T ,
- l''el'ement ?\Gamma `T de R\Gamma `T ,
- la fonction

V

\Gamma `T de l'ensemble des parties de R\Gamma `T dans R\Gamma `T .

ffl T = 2.

- R\Gamma `2 = fSN\Gamma `2g.
- Rj\Gamma 0 = R " T\Gamma 0`2.
- R1 ^\Gamma `2 R2 si R1 ` R2.
- ?\Gamma `2 = SN\Gamma `2.
-

V

\Gamma `2(!) = ?\Gamma `2.

ffl \Gamma  ` T : s.

- R\Gamma `T est l'ensemble de tous les sous-ensembles R de T\Gamma `T tels que :

(R1) R ` SN (normalisation forte) ;
(R2) si \Gamma 0 ` t 2 R et t ! t0 alors \Gamma 0 ` t0 2 R (stabilit'e par r'eduction) ;
(R3) si \Gamma 0 ` t 2 T\Gamma `T , t est neutre et, pour tout t0 tel que t ! t0, \Gamma 0 ` t0 2 R,

alors \Gamma 0 ` t 2 R (stabilit'e par expansion pour les termes neutres) ;

(R4) si \Gamma 0 ` t 2 R et \Gamma 0 ` \Gamma 00 2 E alors \Gamma 00 ` t 2 R (stabilit'e par affaiblissement).
- Rj\Gamma 0 = R " T\Gamma 0`T .
- R1 ^\Gamma `T R2 si R1 ` R2.
- ?\Gamma `T = SN\Gamma `T .
-

V

\Gamma `T (!) =

T

! si ! 6= ;, ?\Gamma `T sinon.

ffl \Gamma  ` T : (x : U )K.

- R\Gamma `T est l'ensemble de toutes les fonctions R qui, `a \Gamma 0 ` u 2 T\Gamma `U , associent un

'el'ement de R\Gamma 0`T u et v'erifient :

(P1) si u ! u0 alors R(\Gamma 0 ` u) = R(\Gamma 0 ` u0) (stabilit'e par r'eduction),
(P2) si \Gamma  ` \Gamma 0 2 E alors R(\Gamma  ` u)j\Gamma 0 = R(\Gamma 0 ` u) (compatibilit'e avec l'affaiblissement).

- Rj\Gamma 0 = RjT

\Gamma 0`U

.

- R1 ^\Gamma `T R2 si, pour tout \Gamma 0 ` u 2 T\Gamma `U , R1(\Gamma 0 ` u) ^\Gamma 0`T u R2(\Gamma 0 ` u).
- ?\Gamma `T (\Gamma 0 ` u) = ?\Gamma 0`T u.
-

V

\Gamma `T (!)(\Gamma 

0 ` u) = V

\Gamma 0`T u(fR(\Gamma 

0 ` u) j R 2 !g).

ffl \Gamma  ` T : (X : K)L. Notons \Sigma \Gamma `K l'ensemble des couples (\Gamma 0 ` U; S) tels que

\Gamma 0 ` U 2 T\Gamma `K et S 2 R\Gamma 0`U .

- R\Gamma `T est l'ensemble de toutes les fonctions R qui, `a un couple (\Gamma 0 ` U; S) 2

\Sigma \Gamma `K , associent un 'el'ement de R\Gamma 0`T U et v'erifient :

8.2. CANDIDATS DE R 'EDUCTIBILIT 'E 99

(P1) si U ! U 0 alors R(\Gamma 0 ` U; S) = R(\Gamma 0 ` U 0; S) (stabilit'e par r'eduction),
(P2) si \Gamma  ` \Gamma 0 2 E alors R(\Gamma  ` U; S)j\Gamma 0 = R(\Gamma 0 ` U; Sj\Gamma 0 ) (compatibilit'e avec

l'affaiblissement).

- Rj\Gamma 0 = Rj\Sigma \Gamma 0`K .
- R1 ^\Gamma `T R2 si, pour tout (\Gamma 0 ` U; S) 2 \Sigma \Gamma `K, R1(\Gamma 0 ` U; S) ^\Gamma 0`T U R2(\Gamma 0 ` U; S).
- ?\Gamma `T (\Gamma 0 ` U; S) = ?\Gamma 0`T U .
-

V

\Gamma `T (!)(\Gamma 

0 ` U; S) = V

\Gamma 0`T U (fR(\Gamma 

0 ` U; S) j R 2 !g).

Le lemme suivant assure que tous ces objets sont bien d'efinis.
Lemme 114 (Propri'et'es des candidats)

(a) R\Gamma `T , ^\Gamma `T , ?\Gamma `T et

V

\Gamma `T sont bien d'efinis.

(b) Si T ! T 0 alors R\Gamma `T = R\Gamma `T 0.

(c) Si R 2 R\Gamma `T et \Gamma  ` \Gamma 0 2 E alors Rj\Gamma 0 2 R\Gamma 0`T .
(d) ?\Gamma `T 2 R\Gamma `T .
(e) Si T ! T 0 alors ?\Gamma `T = ?\Gamma `T 0.
(f) Si \Gamma  ` \Gamma 0 2 E alors ?\Gamma `T j\Gamma 0 = ?\Gamma 0`T .
(g) Si ! ` R\Gamma `T alors

V

\Gamma `T (!) 2 R\Gamma `T .

(h) Si T ! T 0 alors

V

\Gamma `T =

V

\Gamma `T 0 .

(i) Si \Gamma  ` \Gamma 0 2 E alors

V

\Gamma `T (!)j\Gamma 0 =

V

\Gamma 0`T (fRj\Gamma 0 j R 2 !g).

Preuve. Par r'ecurrence sur _(\Gamma  ` T ).
ffl T = 2.

(a) Imm'ediat.
(b) 2 n'est pas r'eductible.
(c) N'ecessairement, R = SN\Gamma `2. Donc Rj\Gamma 0 = SN\Gamma `2 " T\Gamma 0`2 = SN\Gamma 0`2 2 R\Gamma 0`2.
(d) Imm'ediat.
(e) 2 n'est pas r'eductible.
(f) ?\Gamma `2j\Gamma 0 = SN\Gamma `2 " T\Gamma 0`2 = SN\Gamma 0`2 = ?\Gamma 0`2.
(g)

V

\Gamma `2(!) = ?\Gamma `2.

(h) 2 n'est pas r'eductible.

(i)

V

\Gamma `2(!)j\Gamma 0 = ?\Gamma `2j\Gamma 0 = ?\Gamma 0`2 =

V

\Gamma 0`2(fRj\Gamma 0 j R 2 !g.

ffl \Gamma  ` T : s.

(a) Imm'ediat.
(b) Par pr'eservation du typage, T\Gamma `T = T\Gamma `T 0.
(c) Par affaiblissement, Rj\Gamma 0 ` T\Gamma 0`T . Montrons maintenant que Rj\Gamma 0 v'erifie (R1)

`a (R4). Pour (R1), (R2) et (R4), c'est imm'ediat. Pour (R3), soit \Gamma 00 ` t 2 T\Gamma 0`T
tel que t soit neutre et, pour tout t0 tel que t ! t0, \Gamma 00 ` t0 2 Rj\Gamma 0. Comme
Rj\Gamma 0 ` R, \Gamma 00 ` t 2 R. Mais \Gamma 00 ` t 2 T\Gamma 0`T . Donc \Gamma 00 ` t 2 Rj\Gamma 0.

100 CHAPITRE 8. CORRECTION DES CONDITIONS

(d) Par d'efinition, ?\Gamma `T ` T\Gamma `T et il est facile de v'erifier que ?\Gamma `T v'erifie (R1)

`a (R4).

(e) Par pr'eservation du typage.
(f) Imm'ediat.
(g) Comme chaque 'el'ement de ! est inclus dans T\Gamma `T et v'erifie (R1) `a (R4), il

est facile de v'erifier qu'il en est de m^eme pour

T

!.

(h) Imm'ediat.
(i) (

T

!)j\Gamma 0 = (

T

!) " T\Gamma 0`T =

T

fR " T\Gamma 0`T j R 2 !g =

T

fRj\Gamma 0 j R 2 !g.

ffl \Gamma  ` T : (x : U )K.

(a) Il nous suffit de v'erifier que _(\Gamma 0 ` T u) ! _(\Gamma  ` T ) et que les d'efinitions ne

d'ependent pas du choix d'un type pour T .

Par affaiblissement, \Gamma 0 ` T : (x : U )K et \Gamma 0 ` (x : U )K : 2. Par (app),
\Gamma 0 ` T u : Kfx 7! ug. Par inversion et r'egularit'e, \Gamma 0; x : U ` K : 2. Par
substitution, \Gamma 0 ` Kfx 7! ug : 2. Donc \Gamma 0 ` T u 2 TY et _(\Gamma 0 ` T u) =
*(Kfx 7! ug). Par invariance par substitution, *(Kfx 7! ug) = *(K). Donc
_(\Gamma  ` T ) = *((x : U )K) = 1 + *(K) ? _(\Gamma  ` T u).

Montrons maintenant que les d'efinitions ne d'ependent pas du choix d'un
type pour T . Supposons que \Gamma  ` T : (x0 : U 0)K0. Par convertibilit'e des types et
compatibilit'e avec le produit, U C \Lambda \Gamma  U 0. Donc T\Gamma `U = T\Gamma `U0 et R\Gamma `T , ^\Gamma `T ,
?\Gamma `T et

V

\Gamma `T restent inchang'es si on remplace U par U

0.

(b) Par hypoth`ese de r'ecurrence, R\Gamma 0`T u = R\Gamma 0`T 0u.
(c) Imm'ediat.
(d) V'erifions que ?\Gamma `T v'erifie (P1) et (P2).

(P1) Par hypoth`ese de r'ecurrence (e), ?\Gamma 0`T u = ?\Gamma 0`T u0.
(P2) Par hypoth`ese de r'ecurrence (f), ?\Gamma 0`T uj\Gamma 00 = ?\Gamma 00`T u.

(e) Par pr'eservation du typage, ?\Gamma `T et ?\Gamma `T 0 ont m^eme domaine. De plus, ils

sont 'egaux puisque, par hypoth`ese de r'ecurrence, ?\Gamma 0`T u v'erifie (e).

(f) ?\Gamma `T j\Gamma 0 et ?\Gamma 0`T ont m^eme domaine et sont 'egaux.
(g) Soit !0 = fR(\Gamma 0 ` u) j R 2 !g. Par d'efinition, si R 2 R\Gamma `T et \Gamma 0 ` u 2 T\Gamma `U

alors R(\Gamma 0 ` u) 2 R\Gamma 0`T u. Par hypoth`ese de r'ecurrence,

V

\Gamma 0`T u v'erifie (g).
Donc,

V

\Gamma 0`T u(!

0) 2 R

\Gamma 0`T u. Reste `a voir si

V

\Gamma `T v'erifie (P1) et (P2).

(P1) Soit !00 = fR(\Gamma 0 ` u0) j R 2 !g. Comme chaque R 2 ! v'erifie (P1),

R(\Gamma 0 ` u0) = R(\Gamma 0 ` u). De plus, par hypoth`ese de r'ecurrence,

V

\Gamma 0`T u v'erifie
(h). Donc

V

\Gamma 0`T u(!

0) = V

\Gamma 0`T u0(!

00).

(P2) Soit !1 = fR(\Gamma  ` u) j R 2 !g et !2 = fR(\Gamma  ` u)j\Gamma 0 j R 2 !g. Comme

chaque R 2 ! v'erifie (P2), R(\Gamma  ` u)j\Gamma 0 = R(\Gamma 0 ` u). Par hypoth`ese de
r'ecurrence,

V

\Gamma `T u v'erifie (i). Donc

V

\Gamma `T u(!1)j\Gamma 0 =

V

\Gamma 0`T u(!2).

(h) D'apr`es (a), R\Gamma `T = R\Gamma `T 0. Donc,

V

\Gamma `T et

V

\Gamma `T 0 ont le m^eme domaine. Soit
! ` R\Gamma `T . Alors,

V

\Gamma `T (!) et

V

\Gamma `T 0(!) ont le m^eme domaine et sont 'egales
car, par hypoth`ese de r'ecurrence,

V

\Gamma 0`T u v'erifie (h).

8.3. SCH 'EMA D'INTERPR 'ETATION DES TYPES 101

(i)

V

\Gamma `T (!)j\Gamma 0 et

V

\Gamma 0`T (fRj\Gamma 0 j R 2 !g) ont le m^eme domaine et sont 'egales car,
si \Gamma 00 ` u 2 T\Gamma 0`U alors R(\Gamma 00 ` u) = Rj\Gamma 0(\Gamma 00 ` u).

ffl \Gamma  ` T : (X : K)L. La preuve est similaire au cas pr'ec'edent. \Xi 

Lemme 115 Soit X\Gamma `T = f\Gamma 0 ` t 2 T\Gamma `T j t = x~t; x 2 X ; ~t 2 SN g. Si \Gamma  ` T : s
alors X\Gamma `T 6= ; et, pour tout R 2 R\Gamma `T , X\Gamma `T ` R.

Preuve. X\Gamma `T ` T\Gamma `T . Comme X s est infini et dom(\Gamma ) est fini, il existe x 2
X s n dom(\Gamma ). Donc, par (var), \Gamma ; x : T ` x : T . Ainsi, \Gamma ; x : T ` x 2 T\Gamma `T et X\Gamma `T 6= ;.
Maintenant, soient R 2 R\Gamma `T , \Gamma 0 2 E, x 2 X et ~t 2 SN tels que \Gamma 0 ` x~t 2 T\Gamma `T .
Montrons que \Gamma 0 ` x~t 2 R par r'ecurrence sur ~t avec !lex comme ordre bien fond'e.
Comme x~t est neutre, par (R3), il suffit de montrer que tout r'eduit imm'ediat de x~t
appartient `a R. Mais c'est justement l'hypoth`ese de r'ecurrence. \Xi 

Lemme 116 (Compl'etude du treillis des candidats) Pour tout \Gamma  ` T 2 TY,
(R\Gamma `T ; ^\Gamma `T ) est un inf-demi-treillis complet. De plus, comme il admet ?\Gamma `T comme
plus grand 'el'ement, c'est un treillis complet. La borne inf'erieure d'une partie de
R\Gamma `T est donn'ee par

V

\Gamma `T .

Preuve. Il est facile de v'erifier par r'ecurrence sur _(\Gamma  ` T ) que ^\Gamma `T est une
relation d'ordre (i.e. r'eflexive, transitive et anti-sym'etrique) et que ?\Gamma `T est le plus
grand 'el'ement de R\Gamma `T . \Xi 

8.3 Sch'ema d'interpr'etation des types

Nous d'efinissons l'interpr'etation d'un type \Gamma  ` T relativement `a une substitution
` : \Gamma  ! \Delta  par r'ecurrence sur la structure de T . Pour cela, il nous faut donner une
interpr'etation aux variables et symboles de pr'edicat qui apparaissent dans T . Nous
allons donc commencer par d'efinir un sch'ema d'interpr'etation [[\Gamma  ` T ]]I\Delta ;`;, qui utilise
un assignement de candidats , pour les variables de pr'edicat et une interpr'etation
I pour les symboles de pr'edicat. Dans le Sous-chapitre 8.4, nous d'efinissons l'interpr'etation des symboles de pr'edicat constants et, dans le Sous-chapitre 8.6, nous
d'efinissons l'interpr'etation des symboles de pr'edicat d'efinis.

D'efinition 117 (Assignement de candidats) Un assignement de candidats est
une fonction , de X 2 dans

S

f R\Delta `T j \Delta  ` T 2 TYg de domaine fini. 'Etant donn'e

une substitution ` : \Gamma  ! \Delta , on dit que , est compatible avec (`; \Gamma ; \Delta ) si, pour
tout X 2 dom2(\Gamma ), X, 2 R\Delta `X`. La restriction de , `a un environnement \Gamma 0 est
l'assignement ,j\Gamma 0 d'efini par X(,j\Gamma 0) = (X,)j\Gamma 0 .

`A toute substitution ` : \Gamma  ! \Delta , on peut associer l'assignement canonique ,`

tel que, pour tout X 2 dom2(\Gamma ), X,` = ?\Delta `x`. D'apr`es le Lemme 114 (d), ,` est
compatible avec (`; \Gamma ; \Delta ).

Lemme 118 Soit ` : \Gamma  ! \Delta  une substitution et , un assignement de candidats
compatible avec (`; \Gamma ; \Delta ).

(a) Si ` ! `0 alors `0 : \Gamma  ! \Delta  et , est compatible avec (`0; \Gamma ; \Delta ).

102 CHAPITRE 8. CORRECTION DES CONDITIONS

(b) Si \Delta  ` \Delta 0 2 E alors ` : \Gamma  ! \Delta 0 et ,j\Delta 0 est compatible avec (`; \Gamma ; \Delta 0).

Preuve.
(a) D'apr`es le Lemme 35, nous savons que `0 : \Gamma  ! \Delta . Soit X 2 dom2(\Gamma ). Puisque

, est compatible avec (`; \Gamma ; \Delta ), X, 2 R\Delta `X`. D'apr`es le Lemme 114 (b),
R\Delta `X`0 = R\Delta `X`. Donc X, 2 R\Delta `X`0.

(b) Par affaiblissement, ` : \Gamma  ! \Delta 0. Soit X 2 dom2(\Gamma ). Par d'efinition, X(,j\Delta 0 ) =

(X,)j\Delta 0 . Puisque , est compatible avec (`; \Gamma ; \Delta ), X, 2 R\Delta `X`. Donc, d'apr`es
le Lemme 114 (c), (X,)j\Delta 0 2 R\Delta 0`X`. \Xi 

Soit F un symbole de pr'edicat de type (~x : ~T )?. Par la suite, on se permettra
de consid'erer F , qui n'est pas un terme en g'en'eral, comme repr'esentant sa forme
j-longue [~x : ~T ]F (~x).

D'efinition 119 (Interpr'etation d'un symbole de pr'edicat) Une interpr'etation pour un symbole de pr'edicat F est une fonction I qui `a un environnement \Delta 
associe un 'el'ement de R\Delta `F tel que :

(P3) si \Delta  ` \Delta 0 2 E alors I\Delta j\Delta 0 = I\Delta 0 (compatibilit'e avec l'affaiblissement).
Une interpr'etation pour un ensemble G de symboles de pr'edicat est une fonction
qui, `a un symbole G 2 G, associe une interpr'etation pour G.

D'efinition 120 (Sch'ema d'interpr'etation) L'interpr'etation de \Gamma  ` T 2 TY par
rapport `a un environnement \Delta  2 E , une substitution ` : \Gamma  ! \Delta , un assignement de
candidats , compatible avec (`; \Gamma ; \Delta ) et une interpr'etation IF pour chaque F 2 F 2,
est un 'el'ement de R\Delta `T ` d'efini par r'ecurrence sur T :

ffl [[\Gamma  ` s]]I\Delta ;`;, = SN\Delta `s,
ffl [[\Gamma  ` F (~t)]]I\Delta ;`;, = I\Delta `F (~a) o`u, si o/F = (~x : ~T )U :

- ai = \Delta  ` ti` si xi 2 X ?,
- ai = (\Delta  ` ti`; [[\Gamma  ` ti]]I\Delta ;`;,) si xi 2 X 2,
ffl [[\Gamma  ` X]]I\Delta ;`;, = X,,
ffl [[\Gamma  ` (x : U )V ]]I\Delta ;`;, = f\Delta 0 ` t 2 T\Delta `(x:U`)V ` j 8\Delta 00 ` u 2 [[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

, \Delta 00 ` tu 2

[[\Gamma ; x : U ` V ]]I\Delta 00;`[fx7!ug;,j

\Delta 00

g,

ffl [[\Gamma  ` (X : K)V ]]I\Delta ;`;, = f\Delta 0 ` t 2 T\Delta `(X:K`)V ` j 8\Delta 00 ` U 2 [[\Gamma  ` K]]I\Delta 0;`;,j

\Delta 0

,

\Delta 00 ` tU 2

T

f [[\Gamma ; X : K ` V ]]I\Delta 00;`[fX7!Ug;,j

\Delta 00[fX7!Sg

j S 2 R\Delta 00`U gg,

ffl [[\Gamma  ` [x : U ]V ]]I\Delta ;`;,(\Delta 0 ` u) = [[\Gamma ; x : U ` V ]]I\Delta 0;`[fx7!ug;,j

\Delta 0

,

ffl [[\Gamma  ` [X : K]V ]]I\Delta ;`;,(\Delta 0 ` U; S) = [[\Gamma ; X : K ` V ]]I\Delta 0;`[fX7!Ug;,j

\Delta 0[fX7!Sg

,

ffl [[\Gamma  ` V u]]I\Delta ;`;, = [[\Gamma  ` V ]]I\Delta ;`;,(\Delta  ` u`),
ffl [[\Gamma  ` V U ]]I\Delta ;`;, = [[\Gamma  ` V ]]I\Delta ;`;,(\Delta  ` U `; [[\Gamma  ` U ]]I\Delta ;`;,).
Dans le cas o`u \Gamma  ` T : s, nous dirons qu'une fermeture appartenant `a [[\Gamma  ` T ]]I\Delta ;`;,
est calculable . Enfin, nous dirons que (`; \Gamma ; \Delta ) est valide par rapport `a , si, pour
tout x 2 dom(\Gamma ); \Delta  ` x` 2 [[\Gamma  ` x\Gamma ]]I\Delta ;`;,.

8.3. SCH 'EMA D'INTERPR 'ETATION DES TYPES 103

D'apr`es le Lemme 115, l'identit'e est valide par rapport `a tout assignement compatible avec elle.

Lemme 121 (Correction du sch'ema d'interpr'etation)

(a) [[\Gamma  ` T ]]I\Delta ;`;, est bien d'efini.
(b) [[\Gamma  ` T ]]I\Delta ;`;, 2 R\Delta `T `.
(c) Si ` ! `0 alors [[\Gamma  ` T ]]I\Delta ;`;, = [[\Gamma  ` T ]]I\Delta ;`0;,.
(d) Si \Delta  ` \Delta 0 2 E alors [[\Gamma  ` T ]]I\Delta ;`;,j\Delta 0 = [[\Gamma  ` T ]]I\Delta 0;`;,j

\Delta 0

.

Preuve. Notons tout d'abord que, pour (c), [[\Gamma  ` T ]]I\Delta ;`0;, existe car, d'apr`es
le Lemme 118 (a), `0 : \Gamma  ! \Delta  et , est compatible avec (`0; \Gamma ; \Delta ). Pour (d), [[\Gamma  `
T ]]I\Delta ;`;,j\Delta 0 existe car, d'apr`es (b), [[\Gamma  ` T ]]I\Delta ;`;, 2 R\Delta `T `, et [[\Gamma  ` T ]]I\Delta 0;`;,j

\Delta 0

existe car,

d'apr`es le Lemme 118 (b), ` : \Gamma  ! \Delta 0 et ,j\Delta 0 est compatible avec (`; \Gamma ; \Delta 0).

ffl T = s.

(a) Imm'ediat.
(b) D'apr`es le Lemme 114 (d).
(c) Car [[\Gamma  ` s]]I\Delta ;`;, ne d'epend pas de `.

(d) [[\Gamma  ` s]]I\Delta ;`;,j\Delta 0 = SN\Delta `s " T\Delta 0`s = SN\Delta 0`s = [[\Gamma  ` s]]I\Delta 0;`;,j

\Delta 0

.

ffl T = F (~t).

(a) [[\Gamma  ` T ]]I\Delta ;`;, = I\Delta `F (~a) o`u ai = \Delta  ` ti` si xi 2 X ? et ai = (\Delta  ` ti`; [[\Gamma  ` ti]]I\Delta ;`;,)

si xi 2 X 2. Par hypoth`ese de r'ecurrence (a) et (b), [[\Gamma  ` ti]]I\Delta ;`;, est bien d'efini
et appartient `a R\Delta `ti`. Donc ~a est dans le domaine de I\Delta `F et [[\Gamma  ` T ]]I\Delta ;`;,
est bien d'efini.

(b) Par d'efinition de I\Delta `F .
(c) Par (P1) .
(d) Par (P2) .
ffl T = X.

(a) Imm'ediat.
(b) Car , est compatible avec (`; \Gamma ; \Delta ).
(c) Car [[\Gamma  ` X]]I\Delta ;`;, ne d'epend pas de `.
(d) Par d'efinition de ,j\Delta 0.
ffl T = (x : U )V . Soit \Gamma 0 = \Gamma ; x : U .

(a) Supposons que \Delta  ` \Delta 0 2 E . D'apr`es le Lemme 118 (b), ` : \Gamma  ! \Delta 0 et ,j\Delta 0

est compatible avec (`; \Gamma ; \Delta 0). Ainsi, par hypoth`ese de r'ecurrence (a) et (b),
[[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

est bien d'efini et appartient `a R\Delta 0`U`.

Par correction des types, il existe s tel que \Gamma  ` T : s. Par inversion, \Gamma 0 `
V : s. D'apr`es le lemme d'environnement, \Gamma  ` U : ?. Donc, par substitution,
\Delta 0 ` U ` : ? et [[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

` T\Delta 0`U`.

104 CHAPITRE 8. CORRECTION DES CONDITIONS

Maintenant, soit \Delta 00 ` u 2 [[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

et oe = ` [ fx 7! ug. Puisque

` : \Gamma  ! \Delta , \Delta 00 ` u : U ` et x =2 FV(\Gamma 0), nous avons oe : \Gamma 0 ! \Delta 00.
D'apr`es le Lemme 118 (b), ,j\Delta 00 est compatible avec (`; \Gamma ; \Delta 00). Et puisque
dom2(oe) = dom2(`) et oe et ` sont 'egales sur ce domaine, ,j\Delta 00 est compatible
avec (oe; \Gamma 0; \Delta 00). Donc, par hypoth`ese de r'ecurrence (a) et (b), [[\Gamma 0 ` V ]]I\Delta 00;oe;,j

\Delta 00

est bien d'efini et appartient `a R\Delta 00`V oe.

Enfin, par substitution, \Delta 00 ` V oe : s. Donc, [[\Gamma 0 ` V ]]I\Delta 00;oe;,j

\Delta 00

` T\Delta 00`V oe et

[[\Gamma  ` T ]]I\Delta ;`;, est bien d'efini.

(b) Par substitution, \Delta  ` T ` : s. Donc, on doit prouver que [[\Gamma  ` T ]]I\Delta ;`;, est

inclus dans T\Delta `T ` (imm'ediat) et satisfait (R1) `a (R4). Nous avons vu en (a)
que, si \Delta  ` \Delta 0 2 E , \Delta 00 ` u 2 [[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

et oe = ` [ fx 7! ug, alors

[[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

et [[\Gamma 0 ` V ]]I\Delta 00;oe;,j

\Delta 00

sont respectivement inclus dans T\Delta 0`U` et

T\Delta 00`V oe et satisfont (R1) `a (R4).

(R1) D'apr`es le Lemme 115, il existe y 2 X ? n dom(\Delta 0) tel que \Delta 0; y : U ` `

y 2 [[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

. Posons \Delta 00 = \Delta 0; y : U ` et oe = ` [ fx 7! yg. Alors, par

d'efinition, \Delta 00 ` ty 2 [[\Gamma 0 ` V ]]I\Delta 00;oe;,j

\Delta 00

et, puisque [[\Gamma 0 ` V ]]I\Delta 00;oe;,j

\Delta 00

satisfait

(R1), ty 2 SN et t 2 SN .
(R2) Soit \Delta 00 ` u 2 [[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

et oe = ` [ fx 7! ug. Par d'efinition,

\Delta 00 ` tu 2 [[\Gamma 0 ` V ]]I\Delta 00;oe;,j

\Delta 00

et, puisque tu ! t0u et [[\Gamma 0 ` V ]]I\Delta 00;oe;,j

\Delta 00

satisfait (R2), t0u 2 [[\Gamma 0 ` V ]]I\Delta 00;oe;,j

\Delta 00

et t0 2 [[\Gamma  ` T ]]I\Delta ;`;,.

(R3) C'est dans ce cas que nous utilisons de mani`ere essentielle la notion

d'arit'e d'un symbole et la distinction syntaxique entre application du *-
calcul et application d'un symbole 'evoqu'ee dans la Remarque 10. Soit
\Delta 00 ` u 2 [[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

et oe = ` [ fx 7! ug. Par d'efinition, \Delta 00 ` tu 2

T\Delta 00`V oe et tu est neutre. Puisque [[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

satisfait (R1), u 2 SN .

Prouvons que tous les r'eduits imm'ediats v0 de tu appartiennent `a [[\Gamma 0 `
V ]]I\Delta 00;oe;,j

\Delta 00

, par r'ecurrence sur u avec ! comme ordre bien fond'e. Comme

t n'est pas une abstraction, v0 est soit de la forme t0u avec t0 un r'eduit
imm'ediat de t, soit de la forme tu0 avec u0 un r'eduit imm'ediat de u. Dans
le premier cas, \Delta 00 ` t0u 2 T\Delta 00`V oe puisque, par hypoth`ese, \Delta 00 ` t0 2 [[\Gamma  `
T ]]I\Delta ;`;, et \Delta 00 ` u 2 [[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

. Dans le second cas, \Delta 00 ` tu0 2 T\Delta 00`V oe

par hypoth`ese de r'ecurrence.

Puisque [[\Gamma 0 ` V ]]I\Delta 00;oe;,j

\Delta 00

satisfait (R3), \Delta 00 ` tu 2 [[\Gamma 0 ` V ]]I\Delta 00;oe;,j

\Delta 00

et

\Delta 00 ` t 2 [[\Gamma  ` T ]]I\Delta ;`;,.

(R4) Supposons que \Delta 0 ` \Delta 00 2 E , \Delta 000 ` u 2 [[\Gamma  ` U ]]I\Delta 00;`;,j

\Delta 00

et oe =

` [ fx 7! ug. Par hypoth`ese de r'ecurrence (d), [[\Gamma  ` U ]]I\Delta 00;`;,j

\Delta 00

= [[\Gamma  `

U ]]I\Delta 0;`;,j

\Delta 0

j\Delta 00 = [[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

" T\Delta 00`U`. Ainsi, \Delta 000 ` u 2 [[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

,

\Delta 000 ` tu 2 [[\Gamma 0 ` V ]]I\Delta 000;oe;,j

\Delta 000

et \Delta 00 ` t 2 [[\Gamma  ` T ]]I\Delta ;`;,.

(c) Montrons que [[\Gamma  ` T ]]I\Delta ;`;, ` [[\Gamma  ` T ]]I\Delta ;`0;,. L'inclusion inverse se traite de

mani`ere similaire. Puisque \Delta  ` T oe : s, par conversion, T\Delta `T `0 = T\Delta `T ` et

8.3. SCH 'EMA D'INTERPR 'ETATION DES TYPES 105

\Delta 0 ` t 2 T\Delta `T `0. Maintenant, soit \Delta 00 ` u 2 [[\Gamma  ` U ]]I\Delta 0;`0;,j

\Delta 0

, oe = ` [ fx 7! ug

et oe0 = oe [ fx 7! ug. Par hypoth`ese de r'ecurrence (c), [[\Gamma  ` U ]]I\Delta 0;`0;,j

\Delta 0

=

[[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

. Donc, puisque [[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

satisfait (R3), \Delta 00 ` tu 2 [[\Gamma 0 `

V ]]I\Delta ;oe;,. Et puisque oe ! oe0, par hypoth`ese de r'ecurrence (c), \Delta 00 ` tu 2 [[\Gamma 0 `
V ]]I\Delta ;oe0;, et \Delta 0 ` t 2 [[\Gamma  ` T ]]I\Delta ;`0;,.

(d) Montrons que [[\Gamma  ` T ]]I\Delta ;`;,j\Delta 0 ` [[\Gamma  ` T ]]I\Delta 0;`;,j

\Delta 0

. L'inclusion inverse se traite

de mani`ere similaire. Par d'efinition, [[\Gamma  ` T ]]I\Delta ;`;,j\Delta 0 = [[\Gamma  ` T ]]I\Delta ;`;, " T\Delta 0`T `.
Soit \Delta 00 ` t 2 [[\Gamma  ` T ]]I\Delta ;`;,j\Delta 0, \Delta 000 ` u 2 [[\Gamma  ` T ]]I\Delta 00;`;,j

\Delta 00

et oe = ` [ fx 7! ug.

Par d'efinition de [[\Gamma  ` T ]]I\Delta ;`;,, \Delta 000 ` tu 2 [[\Gamma 0 ` V ]]I\Delta 000;oe;,j

\Delta 000

. Donc, puisque

\Delta 00 ` t 2 T\Delta 0`T `, \Delta 00 ` t 2 [[\Gamma  ` T ]]I\Delta 0;`;,j

\Delta 0

.

ffl T = (X : K)V . Similaire au cas pr'ec'edent.
ffl T = [x : U ]V . Soit \Gamma 0 = \Gamma ; x : U .

(a) Soit \Delta 0 ` u 2 T\Delta `U` et oe = ` [ fx 7! ug. Puisque \Delta  ` \Delta 0 2 E , par le

Lemme 118 (b), ` : \Gamma  ! \Delta 0 et ,j\Delta 0 est compatible avec (`; \Gamma ; \Delta 0). De plus,
puisque \Delta 0 ` u : U ` et x =2 FV(\Gamma ), oe : \Gamma 0 ! \Delta 0. Par ailleurs, ,j\Delta 0 est
compatible avec (oe; \Gamma 0; \Delta 0) puisque dom2(oe) = dom2(`). Ainsi, par hypoth`ese
de r'ecurrence (a), [[\Gamma 0 ` V ]]I\Delta 0;oe;,j

\Delta 0

est bien d'efini et [[\Gamma  ` T ]]I\Delta ;`;, est bien d'efini.

(b) R\Delta `T ` est l'ensemble des fonctions qui `a \Delta 0 ` u 2 T\Delta `U` associent un 'el'ement

de R\Delta 0`(T ` u) et v'erifient (P1) et (P2). Par hypoth`ese de r'ecurrence (b),
[[\Gamma 0 ` V ]]I\Delta 0;oe;,j

\Delta 0

2 R\Delta 0`V oe. Comme (T ` u) !fi V oe, par le Lemme 114 (b),

R\Delta 0`V oe = R\Delta 0`(T ` u).

(P1) Supposons que u ! u0. [[\Gamma  ` T ]]I\Delta ;`;,(\Delta 0 ` u0) = [[\Gamma 0 ` V ]]I\Delta 0;oe0;,j

\Delta 0

o`u

oe0 = ` [ fx 7! u0g. Comme oe ! oe0, par hypoth`ese de r'ecurrence (c),
[[\Gamma 0 ` V ]]I\Delta 0;oe0;,j

\Delta 0

= [[\Gamma 0 ` V ]]I\Delta 0;oe;,j

\Delta 0

et [[\Gamma  ` T ]]I\Delta ;`;, 2 R\Delta `T `.

(P2) Supposons que \Delta  ` \Delta 0 2 E . [[\Gamma  ` T ]]I\Delta ;`;,(\Delta  ` u)j\Delta 0 = [[\Gamma 0 ` V ]]I\Delta ;oe;,j\Delta 0.

Par hypoth`ese de r'ecurrence (d), [[\Gamma 0 ` V ]]I\Delta ;oe;,j\Delta 0 = [[\Gamma 0 ` V ]]I\Delta 0;oe;,0j

\Delta 0

=

[[\Gamma  ` T ]]I\Delta ;`;,(\Delta 0 ` u).

(c) [[\Gamma  ` T ]]I\Delta ;`0;,(\Delta 0 ` u) = [[\Gamma 0 ` V ]]I\Delta 0;oe0;,j

\Delta 0

o`u oe0 = oe [ fx 7! ug. oe ! oe0

donc, par hypoth`ese de r'ecurrence (c), [[\Gamma 0 ` V ]]I\Delta 0;oe0;,j

\Delta 0

= [[\Gamma 0 ` V ]]I\Delta 0;oe;,j

\Delta 0

et

[[\Gamma  ` T ]]I\Delta ;`0;, = [[\Gamma  ` T ]]I\Delta ;`;,.

(d) [[\Gamma  ` T ]]I\Delta ;`;,j\Delta 0 = [[\Gamma  ` T ]]I\Delta ;`;,jT

\Delta 0`U`

est la fonction qui, `a \Delta 00 ` u 2 T\Delta 0`U`,

associe [[\Gamma 0 ` V ]]I\Delta 00;oe;,j

\Delta 00

o`u oe = ` [ fx 7! ug. C'est [[\Gamma  ` T ]]I\Delta 0;`;,j

\Delta 0

.

ffl T = [X : K]V . Similaire au cas pr'ec'edent.
ffl T = V u.

(a) Par hypoth`ese de r'ecurrence (a), [[\Gamma  ` V ]]I\Delta ;`;, est bien d'efini et appartient

`a R\Delta `V `. Puisque T 2 TY et T 6= 2, T est typable dans \Gamma . Par inversion,
il existe U et K tels que \Gamma  ` V : (x : U )K et \Gamma  ` u : U . Par substitution,
\Delta  ` V ` : (x : U `)K` et \Delta  ` u` : U `. Donc, R\Delta `V ` est l'ensemble des

106 CHAPITRE 8. CORRECTION DES CONDITIONS

fonctions qui `a \Delta 0 ` u0 2 T\Delta `U` associent un 'el'ement de R\Delta 0`V `u0. Ainsi,
comme \Delta  ` u` 2 T\Delta `U`, [[\Gamma  ` T ]]I\Delta ;`;, est bien d'efini.

(b) [[\Gamma  ` T ]]I\Delta ;`;, 2 R\Delta `(V `u`) = R\Delta `T `.
(c) Par hypoth`ese de r'ecurrence (c), [[\Gamma  ` V ]]I\Delta 0;`0;,j

\Delta 0

= [[\Gamma  ` V ]]I\Delta ;`;,. Comme

u` !\Lambda  uoe et [[\Gamma  ` V ]]I\Delta ;`;, v'erifie (P1), [[\Gamma  ` T ]]I\Delta ;`;, = [[\Gamma  ` T ]]I\Delta ;`0;,.

(d) [[\Gamma  ` T ]]I\Delta ;`;,j\Delta 0 = [[\Gamma  ` V ]]I\Delta ;`;,(\Delta  ` u`)j\Delta 0 . Par (P2), [[\Gamma  ` V ]]I\Delta ;`;,(\Delta  ` u`)j\Delta 0 =

[[\Gamma  ` V ]]I\Delta ;`;,(\Delta 0 ` u`) = [[\Gamma  ` V ]]I\Delta ;`;,j\Delta 0(\Delta 0 ` u`). Par hypoth`ese de r'ecurrence
(d), [[\Gamma  ` V ]]I\Delta ;`;,j\Delta 0(\Delta 0 ` u`) = [[\Gamma  ` V ]]I\Delta 0;`;,j

\Delta 0

(\Delta 0 ` u`) = [[\Gamma  ` T ]]I\Delta 0;`;,j

\Delta 0

.

ffl T = (V U ). Similaire au cas pr'ec'edent. \Xi 

Lemme 122 Soient deux interpr'etations I et I0 'egales sur les symboles de pr'edicat
apparaissant dans T , et soient deux assignements de candidats , et ,0 'egaux sur les
variables libres de T . Alors, [[\Gamma  ` T ]]I

0

\Delta ;`;,0 = [[\Gamma  ` T ]]

I
\Delta ;`;,.

Preuve. Par r'ecurrence sur T . \Xi 

Lemme 123 (Substitution de candidats) Soient \Gamma 0, \Gamma 1 et \Gamma 2, trois environnements valides, soit \Gamma 0 ` T 2 TY, soient `1 : \Gamma 0 ! \Gamma 1 et `2 : \Gamma 1 ! \Gamma 2, deux substitutions, et soit ,2, un assignement de candidats compatible avec (`2; \Gamma 1; \Gamma 2). Alors,
l'assignement de candidats ,12 d'efini par X,12 = [[\Gamma 1 ` X`1]]I\Gamma 2;`2;,2 est compatible

avec (`1`2; \Gamma 0; \Gamma 2) et [[\Gamma 1 ` T `1]]I\Gamma 2;`2;,2 = [[\Gamma 0 ` T ]]I\Gamma 2;`1`2;,12 .

Preuve. D'apr`es le Lemme 121 (b), X,12 2 R\Gamma 2`X`1`2 . Donc ,12 est compatible
avec (`1`2; \Gamma 0; \Gamma 2). Soit R = [[\Gamma 0 ` T ]]I\Gamma 2;`1`2;,12 et R0 = [[\Gamma 1 ` T `1]]I\Gamma 2;`2;,2. Montrons
que R = R0 par r'ecurrence sur T . D'apr`es le Lemme 121 (b), R et R0 appartiennent
tous deux `a R\Gamma 2`T `1`2 .

ffl T = s. R0 = [[\Gamma 1 ` s]]I\Gamma 2;`2;,2 = SN\Gamma 2`s = R.
ffl T = F (~t). Supposons que o/F = (~x : ~T )?. Alors, R = I\Gamma 2`F (~a) o`u ai = \Gamma 2 ` ti`1`2

si xi 2 X ?, et ai = (\Gamma 2 ` ti`1`2; [[\Gamma 0 ` ti]]I\Gamma 2;`1`2;,12) si xi 2 X 2. De m^eme, R0 =

I\Gamma 2`F (~a0) o`u a0i = \Gamma 2 ` ti`1`2 si xi 2 X ?, et a0i = (\Gamma 2 ` ti`1`2; [[\Gamma 1 ` ti`1]]I\Gamma 2;`2;,2) si
xi 2 X 2. Par hypoth`ese de r'ecurrence, pour tout xi 2 X 2, [[\Gamma 0 ` ti]]I\Gamma 2;`1`2;,12 =
[[\Gamma 1 ` ti`1]]I\Gamma 2;`2;,2 . Donc, ~a = ~a0 et R = R0.

ffl T = X. R = X,12 = [[\Gamma 1 ` X`1]]I\Gamma 2;`2;,2 = R0.
ffl T = (x : U )V . Soit \Gamma 00 = \Gamma 0; x : U , \Gamma 01 = \Gamma 1; x : U `1 et \Gamma 02 ` t 2 R. Comme

R 2 R\Gamma 2`T `1`2 , \Gamma 02 ` t 2 T\Gamma 2`T `1`2 . Soit \Gamma 002 ` u 2 [[\Gamma 1 ` U `1]]I\Gamma 0

2;`2;,2j\Gamma 02

. D'apr`es le

Lemme 121 (d), pour tout X 2 dom2(\Gamma 0), X,12j\Gamma 02 = [[\Gamma 1 ` X`1]]I\Gamma 0

2;`2;,2j\Gamma 02

. Par

hypoth`ese de r'ecurrence, [[\Gamma 1 ` U `1]]I\Gamma 0

2;`2;,2j\Gamma 02

= [[\Gamma 0 ` U ]]I\Gamma 0

2;`1`2;,12j\Gamma 02

. Par d'efinition

de R\Gamma 2`T `1`2, \Gamma 002 ` tu 2 [[\Gamma 00 ` V ]]I\Gamma 00

2 ;`1`2[fx7!ug;,12j\Gamma 002

. Par ailleurs, X,12j\Gamma 002 = [[\Gamma 1 `

X`1]]I\Gamma 00

2 ;`2;,2j\Gamma 002

, `1 : \Gamma 00 ! \Gamma 01, `2 [ fx 7! ug : \Gamma 01 ! \Gamma 002 et `1`2 [ fx 7! ug =

`1(`2[fx 7! ug). Donc, par hypoth`ese de r'ecurrence, [[\Gamma 00 ` V ]]I\Gamma 00

2 ;`1`2[fx7!ug;,12j\Gamma 002

=

8.4. INTERPR 'ETATION DES SYMBOLES DE PR 'EDICAT CONSTANTS 107

[[\Gamma 01 ` V `1]]I\Gamma 00

2 ;`2[fx7!ug;,2j\Gamma 002

et \Gamma 02 ` t 2 R0. Ainsi, R ` R0. De m^eme, on montrerait

que R0 ` R.
ffl T = (X : K)V . Similaire au cas pr'ec'edent.
ffl T = [x : U ]V . Soit \Gamma 00 = \Gamma 0; x : U , \Gamma 01 = \Gamma 1; x : U `1 et \Gamma 02 ` u 2 T\Gamma 2`U`1`2 . Par

d'efinition, R(\Gamma 02 ` u) = [[\Gamma 00 ` V ]]I\Gamma 0

2;`1`2[fx7!ug;,12j\Gamma 02

. Par hypoth`ese de r'ecurrence,

[[\Gamma 00 ` V ]]I\Gamma 0

2;`1`2[fx7!ug;,12j\Gamma 02

= [[\Gamma 01 ` V `1]]I\Gamma 0

2;`2[fx7!ug;,2j\Gamma 02

. Donc, R(\Gamma 02 ` u) =

R0(\Gamma 02 ` u) et R = R0.
ffl T = [X : K]V . Similaire au cas pr'ec'edent.
ffl T = V u. R = [[\Gamma 0 ` V ]]I\Gamma 2;`1`2;,12 (\Gamma 2 ` u`1`2). Par hypoth`ese de r'ecurrence, [[\Gamma 0 `

V ]]I\Gamma 2;`1`2;,12 = [[\Gamma 1 ` V `1]]I\Gamma 2;`2;,2. Donc, R = R0.

ffl T = V U . Similaire au cas pr'ec'edent. \Xi 

8.4 Interpr'etation des symboles de pr'edicat constants

Dans ce sous-chapitre, nous d'efinissons l'interpr'etation I pour les symboles de
pr'edicat constants par r'ecurrence sur ?C. Soit C un symbole de pr'edicat constant et
supposons que nous ayons d'ej`a d'efini une interpr'etation K pour tous les symboles
plus petits que C.

Comme N. P. Mendler [89] ou B. Werner [118], nous allons d'efinir cette interpr'etation comme le point fixe d'une fonction monotone sur un treillis complet,
la monotonie 'etant assur'ee par les conditions de positivit'e des pr'edicats inductifs
(D'efinition 74). La principale diff'erence avec ces travaux est que nous avons une
notion de constructeur beaucoup plus g'en'erale puisqu'elle inclut toute fonction dont
le type de sortie est un symbole de pr'edicat constant, afin de pouvoir d'efinir des
fonctions ou des pr'edicats par filtrage non seulement sur des constructeurs au sens
habituel (constants) mais aussi sur des symboles d'efinis.

Nous d'esignerons par :
- [C] l'ensemble des symboles de pr'edicats constants 'equivalents `a C,
- I l'ensemble des interpr'etations pour [C],
- ^ la relation sur I d'efinie par I ^ I0 si, pour tout D 2 [C] et \Delta  2 E , I\Delta `D ^\Delta `D

I0\Delta `D.

Pour all'eger les notations, 'etant donn'ee I 2 I, nous d'esignerons [[\Gamma  ` T ]]K[I\Delta ;`;, par
[[\Gamma  ` T ]]I\Delta ;`;,.

Soit D un symbole de pr'edicat constant 'equivalent `a C. Supposons que D soit
d'arit'e n et de type (~x : ~T )?. 'Etant donn'e un environnement \Delta , par d'efinition,
R\Delta `D est l'ensemble des fonctions qui, `a a1 2 A1, . . ., an 2 An, associe un 'el'ement
de R\Delta n`D(~t) o`u :

- ai = \Delta i ` ti et Ai = T\Delta i\Gamma 1`Ti` si xi 2 X ?,

108 CHAPITRE 8. CORRECTION DES CONDITIONS

- ai = (\Delta i ` ti; Si) et Ai = \Sigma \Delta i\Gamma 1`Ti` si xi 2 X 2,
- \Delta 0 = \Delta  et ` = f~x 7! ~tg.

D'efinition 124 (Interpr'etation monotone) Soit I 2 I, xi 2 X 2, \Delta  2 E et ~a;~a0
deux s'equences d'arguments pour I telles que ai = (\Delta i ` ti; Si), a0i = (\Delta i ` ti; S0i) et,
pour tout j 6= i, aj = a0j. Alors I est monotone en son i-`eme argument si Si ^ S0i implique I\Delta `D(~a) ^ I\Delta `D(~a0). Nous d'esignerons par Im l'ensemble des interpr'etations
qui sont monotones en chacun de leurs arguments inductifs i 2 Ind(D).

Lemme 125 (Im; ^) est un treillis complet.

Preuve. Tout d'abord, ^ est bien une relation d'ordre puisque, pour tout D =C
C et \Delta  2 E , ^\Delta `D est une relation d'ordre.

Montrons que Im admet comme plus grand 'el'ement la fonction I? d'efini par
I?\Delta `D = ?\Delta `D. La fonction I?D est bien une interpr'etation car, d'apr`es le Lemme 114
(d) et (f), I?\Delta `D 2 R\Delta `D et si \Delta  ` \Delta 0 2 E alors I?\Delta `D\Delta  = ?\Delta `Dj\Delta 0 = ?\Delta 0`D =
I?\Delta 0`D. Par ailleurs, I? est le plus grand 'el'ement de I puisque ?\Delta `D est le plus
grand 'el'ement de R\Delta `D.

Montrons maintenant que I? est monotone en ses arguments inductifs. Soit i 2
Ind(D) et ~a;~a0 deux s'equences d'arguments pour I?\Delta `D telles que ai = (\Delta i ` ti; Si),
a0i = (\Delta i ` ti; S0i), Si ^ S0i et, pour tout j 6= i, aj = a0j. Alors, I?\Delta `D(~a) = ?\Delta n`D(~t) =

I?\Delta `D(~a0).

Montrons maintenant que toute partie de Im admet une borne inf'erieure. Soit
= ` Im et I^ la fonction d'efinie par I^\Delta `D =

V

\Delta `D(!\Delta `D) o`u !\Delta `D = fI\Delta `D j I 2
=g. La fonction I^ est bien une interpr'etation car, d'apr`es le Lemme 114 (g) et (i),

I^\Delta `D 2 R\Delta `D et si \Delta  ` \Delta 0 2 E alors I^\Delta `Dj\Delta 0 = I^\Delta 0`D.

Montrons que I^ est monotone en ses arguments inductifs. Soit i 2 Ind(D) et
~a;~a0 deux s'equences d'arguments de I^\Delta `D v'erifiant les conditions pour montrer la

monotonie. Alors, I^\Delta `D(~a) =

T

fI\Delta `D(~a) j I 2 =g et I^\Delta `D(~a0) =

T

fI\Delta `D(~a0) j I 2

=g. Comme chaque I est monotone en ses arguments inductifs, I\Delta `D(~a) ^ I\Delta `D(~a0).
Donc, I^\Delta `D(~a) ^ I^\Delta `D(~a0).

Il ne nous reste plus qu'`a montrer que I^ est la borne inf'erieure de =. Tout
d'abord, pour tout I 2 =, I^ ^ I puisque I^\Delta `D est la borne inf'erieure de !\Delta `D.
Supposons maintenant qu'il existe I0 2 Im tel que, pour tout I 2 =, I0 ^ I. Alors,
puisque I^\Delta `D est la borne inf'erieure de !\Delta `D, I0 ^ I^. \Xi 

D'efinition 126 (Interpr'etation des symboles de pr'edicat constants) Soit
' la fonction qui, `a I 2 Im, associe l'interpr'etation 'I telle que 'I\Delta `D(~a) soit
l'ensemble des \Delta 0 ` u 2 SN\Delta n`D(~t) tels que si u se r'eduit en un terme de la forme

d(~u) avec d un constructeur de type (~y : ~U )D(~v) alors, pour tout j 2 Acc(d),
\Delta 0 ` uj 2 [[~y : ~U ` Uj]]I\Delta 0;`;,j

\Delta 0

o`u ` = f~y 7! ~ug et, pour tout Y 2 FV2(Uj),

Y , = S'Y . Nous montrons ci-apr`es que ' est monotone. Nous pouvons donc prendre
I\Delta `D = lfp(')\Delta `D o`u lfp(') est le plus petit point fixe de '.

Cette d'efinition a pour but essentiel d'assurer la correction de la relation d'accessibilit'e (Lemme 134) : si d(~u) est calculable alors chaque uj accessible (j 2 Acc(d))

8.4. INTERPR 'ETATION DES SYMBOLES DE PR 'EDICAT CONSTANTS 109
est calculable. C'est ce qui nous permettra d'assurer la calculabilit'e des variables
d'un membre gauche de r`egle si les arguments du membre gauche sont calculables,
et donc la calculabilit'e des membres droits qui appartiennent `a la cl^oture calculable
de la r`egle.

Lemme 127 'I est bien d'efini et est bien une interpr'etation.

Preuve. Montrons tout d'abord que 'I est bien d'efini. Tout d'abord, , existe
du fait de l'hypoth`ese (I6). Soit \Gamma d = ~y : ~U . Il faut s'assurer que ` : \Gamma d ! \Delta 0 et que
,j\Delta 0 est compatible avec (`; \Gamma d; \Delta 0). Par pr'eservation du typage, \Delta 0 ` d(~u) : D(~t).
Par inversion, \Delta 0 ` d(~u) : D(~v`), D(~v`) C \Lambda \Delta 0 D(~t) et, pour tout j, \Delta 0 ` uj : Uj`.
Donc, ` : \Gamma d ! \Delta 0. Soit Y 2 FV2(Uj). Nous avons Y , = S'Y 2 R\Delta 'Y `t'Y . Par le
Lemme 114 (c), Y ,j\Delta 0 2 R\Delta 0`t'Y . Par (A1), comme D est constant, pour tout i,
vi` # ti. Ainsi, par le Lemme 114 (b), R\Delta 0`t'Y = R\Delta 0`v'Y `. Par (I6), v'Y = Y . Donc
Y , 2 R\Delta 0`Y `.

Enfin, il faut s'assurer que les interpr'etations n'ecessaires `a la d'efinition de [[~y : ~U `
Uj]]I\Delta 0;`;,j

\Delta 0

sont toutes bien d'efinies. L'interpr'etation des symboles de pr'edicat constants plus petits que D est K. L'interpr'etation des symboles de pr'edicat constants
'equivalents `a D est I. Par (I4) et (I5), les symboles de pr'edicat constants plus

grands que D ou les symboles de pr'edicat d'efinis ne peuvent appara^itre qu'`a des
positions neutres. Or il est facile de v'erifier que les termes qui se trouvent `a de telles
positions ne sont pas interpr'et'es.

Maintenant, montrons que 'I\Delta `D 2 R\Delta `D. Pour cela, on doit montrer que R =
'I\Delta `D(~a) est inclus dans T\Delta n`D(~t) (imm'ediat) et satisfait les propri'et'es (R1) `a (R4) :

(R1) Par d'efinition.
(R2) Soit \Delta 0 ` u 2 R et u0 tel que u ! u0. Par d'efinition, \Delta 0 ` u 2 SN\Delta n`D(~t).

Donc, \Delta 0 ` u0 2 SN\Delta n`D(~t). Supposons que u0 !\Lambda  d(~u) avec o/d = (~y : ~U )D(~v).
Alors, u !\Lambda  d(~u). Donc, pour tout j 2 Acc(d), \Delta 0 ` uj 2 [[~y : ~U ` Uj]]I\Delta 0;`;,j

\Delta 0

et

\Delta 0 ` u0 2 R.

(R3) Soit \Delta 0 ` u 2 T\Delta n`D(~t) tel que u soit neutre et, pour tout u0 tel que u ! u0,

\Delta 0 ` u0 2 R. Alors, \Delta 0 ` u 2 SN\Delta n`D(~t). Supposons maintenant que u !\Lambda  d(~u)
avec o/d = (~y : ~U )D(~v). Puisque u est neutre, il existe u0 tel que u ! u0 et
u0 !\Lambda  d(~u). Donc, pour tout j 2 Acc(d), \Delta 0 ` uj 2 [[~y : ~U ` Uj]]I\Delta 0;`;,j

\Delta 0

et

\Delta 0 ` u 2 R.

(R4) Soit \Delta 0 ` u 2 R et supposons que \Delta 0 ` \Delta 00 2 E . Alors, \Delta 00 ` u 2 SN\Delta n`D(~t).

Supposons maintenant que u !\Lambda  d(~u) avec o/d = (~y : ~U )D(~v). Alors, pour tout
j 2 Acc(d), \Delta 0 ` uj 2 Rj o`u Rj = [[~y : ~U ` Uj]]I\Delta 0;`;,j

\Delta 0

. D'apr`es le Lemme 121 (b),

Rj appartient `a R\Delta n`Uj` et donc satisfait (R4). Donc \Delta 00 ` uj 2 Rj et \Delta 00 ` u 2
R.

Enfin, il ne nous reste plus qu'`a montrer les propri'et'es (P1) `a (P3). Pour (P1), la
stabilit'e par r'eduction, c'est imm'ediat car, si ~t ! ~t0 alors SN\Delta n`D(~t) = SN\Delta n`D(~t0).
Pour (P2) et (P3), il est facile de voir que les fonctions ont le m^eme domaine et sont
'egales. \Xi 

110 CHAPITRE 8. CORRECTION DES CONDITIONS
Lemme 128 'I est monotone en ses arguments inductifs.

Preuve. Soit i 2 Ind(D). Nous devons montrer que Si ^ S0i implique 'I\Delta `D(~a) `
'I\Delta `D(~a0). Soit alors \Delta 0 ` u 2 'I\Delta `D(~a) et montrons que \Delta 0 ` u 2 'I\Delta `D(~a0). Tout
d'abord, \Delta 0 ` u 2 SN\Delta n`D(~t). Supposons maintenant que u se r'eduise sur un terme

de la forme d(~u) avec d un constructeur de type (~y : ~U )D(~v). Soit j 2 Acc(d). Nous
devons montrer que \Delta 0 ` uj 2 [[~y : ~U ` Uj]]I\Delta 0;`;,0j

\Delta 0

o`u ` = f~y 7! ~ug et, pour tout

Y 2 FV2(Uj), Y ,0 = S0'Y .

Nous avons \Delta 0 ` uj 2 [[~y : ~U ` Uj]]I\Delta 0;`;,j

\Delta 0

o`u, pour tout Y 2 FV2(Uj), Y , = S'Y .

Si, pour tout Y 2 FV2(Uj), 'Y 6= i, alors , = ,0 et \Delta 0 ` uj 2 [[~y : ~U ` Uj]]I\Delta 0;`;,0j

\Delta 0

.

Supposons maintenant qu'il existe Y 2 FV2(Uj) tel que 'Y = i. Alors, Y , = Si ^
Y ,0 = S0i. Par (I2), Pos(Y; Uj) ` Pos+(Uj). Enfin, Uj v'erifie (I3), (I4) et (I5).

Montrons alors par r'ecurrence sur T que, pour tout \Gamma  ` T 2 TY, \Delta  2 E , ` :
\Gamma  ! \Delta , ,; ,0 compatibles avec (`; \Gamma ; \Delta ) tels que Y , ^ Y ,0 et, pour tout X 6= Y ,
X, = X,0 :

- si Pos(Y; T ) ` Pos+(T ) et T v'erifie (I3), (I4) et (I5) alors [[\Gamma  ` T ]]I\Delta ;`;, ^ [[\Gamma  `

T ]]I\Delta ;`;,0,

- si Pos(Y; T ) ` Pos\Gamma (T ) et T v'erifie (I3\Gamma ), (I4) et (I5) alors [[\Gamma  ` T ]]I\Delta ;`;, * [[\Gamma  `

T ]]I\Delta ;`;,0,

o`u (I3\Gamma ) est la propri'et'e 8D 2 CF 2; D =C C ) Pos(D; T ) ` Pos\Gamma (T ). Nous
d'etaillons le premier cas ; le second se traite de mani`ere similaire.

ffl T = s. Nous avons [[\Gamma  ` T ]]I\Delta ;`;, = SN\Delta `s = [[\Gamma  ` T ]]I\Delta ;`;,0.
ffl T = E(~t). Nous avons [[\Gamma  ` T ]]I\Delta ;`;, = I\Delta `E(~a) et [[\Gamma  ` T ]]I\Delta ;`;,0 = I\Delta `E(~a0) avec

ai = a0i = \Delta  ` ti` si xi 2 X ?, et ai = (\Delta  ` ti`; Si), a0i = (\Delta  ` ti`; S0i), Si = [[\Gamma  `
ti]]I\Delta ;`;, et S0i = [[\Gamma  ` ti]]I\Delta ;`;,0 si xi 2 X 2. Comme T v'erifie (I3), (I4) et (I5), nous
avons E 2 CF 2 et E ^C D. Donc, I\Delta `E est monotone en ses arguments inductifs.
Soit i ^ ffE. Montrons que ti v'erifie (I3), (I4) et (I5) :

(I3) Soit D0 =C D. Nous devons montrer que Pos(D0; ti) ` Pos+(ti). Si Pos(D0; ti)

= ;, c'est imm'ediat. S'il existe p 2 Pos(D0; ti) alors i:p 2 Pos(D0; T ). Comme
Pos(D0; T ) ` Pos+(T ) et Pos+(T ) = f"g [

S

fi:Pos+(ti) j i 2 Ind(E)g, nous

avons i 2 Ind(E) et p 2 Pos+(ti).

(I4) et (I5) Soit D0 ?C D ou D0 2 DF 2. Nous devons montrer que Pos(D0; ti) `

Pos0(ti). Si Pos(D0; ti) = ;, c'est imm'ediat. S'il existe p 2 Pos(D0; ti) alors i:p 2
Pos(D0; T ). Comme Pos(D0; T ) ` Pos0(T ) et Pos0(T ) = f"g [

S

fi:Pos0(ti) j i 2

Ind(E)g, nous avons i 2 Ind(E) et p 2 Pos0(ti).

Voyons maintenant les relations entre Si et S0i. Si Pos(Y; ti) = ; alors, par hypoth`ese de r'ecurrence, Si = S0i. S'il existe p 2 Pos(Y; ti) alors i:p 2 Pos(Y; T ).
Comme Pos(Y; T ) ` Pos+(T ) et Pos+(T ) = f"g [

S

fi:Pos+(ti) j i 2 Ind(E)g,

nous avons n'ecessairement i 2 Ind(E) et p 2 Pos+(ti). Donc, par hypoth`ese de
r'ecurrence, Si ^ S0i. Finalement, comme I\Delta `E est monotone en ses arguments
inductifs, on conclut que [[\Gamma  ` T ]]I\Delta ;`;, ^ [[\Gamma  ` T ]]I\Delta ;`;,0.

8.4. INTERPR 'ETATION DES SYMBOLES DE PR 'EDICAT CONSTANTS 111

ffl T = Y . Nous avons [[\Gamma  ` T ]]I\Delta ;`;, = Y , ^ Y ,0 = [[\Gamma  ` T ]]I\Delta ;`;,0. Or, Pos(Y; Y ) = " `

Pos+(Y ).

ffl T = X 6= Y . Nous avons [[\Gamma  ` T ]]I\Delta ;`;, = X, = X,0 = [[\Gamma  ` T ]]I\Delta ;`;,0.

ffl T = (x : U )V . Soit \Gamma 0 = \Gamma ; x : U . Nous avons [[\Gamma  ` T ]]I\Delta ;`;, = f\Delta 0 ` t 2

T\Delta `(x:U`)V ` j 8\Delta 00 ` u 2 [[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

, \Delta 00 ` tu 2 [[\Gamma 0 ` V ]]I\Delta 00;`0;,j

\Delta 00

g et

[[\Gamma  ` T ]]I\Delta ;`;,0 = f\Delta 0 ` t 2 T\Delta `(x:U`)V ` j 8\Delta 00 ` u 2 [[\Gamma  ` U ]]I\Delta 0;`;,0j

\Delta 0

, \Delta 00 `

tu 2 [[\Gamma 0 ` V ]]I\Delta 00;`0;,0j

\Delta 00

g o`u `0 = ` [ fx 7! ug. Nous devons montrer que [[\Gamma  `

T ]]I\Delta ;`;, ` [[\Gamma  ` T ]]I\Delta ;`;,0. Soit \Delta 0 ` t 2 T\Delta `(x:U`)V ` et \Delta 00 ` u 2 [[\Gamma  ` U ]]I\Delta 0;`;,0j

\Delta 0

.

Comme Pos(Y; T ) ` Pos+(T ) et Pos+(T ) = 1:Pos\Gamma (U ) [ 2:Pos+(V ), nous avons
Pos(Y; U ) ` Pos\Gamma (U ) et Pos(Y; V ) ` Pos+(V ). Montrons que U v'erifie (I3\Gamma ), (I4)
et (I5) :

(I3\Gamma ) Soit D0 =C D. Nous devons montrer que Pos(D0; U ) ` Pos\Gamma (U ). Si Pos(D0,

U ) = ;, c'est imm'ediat. S'il existe p 2 Pos(D0; U ) alors 1:p 2 Pos(D0; T ). Comme
Pos(D0; T ) ` Pos+(T ) et Pos+(T ) = 1:Pos\Gamma (U ) [ 2:Pos+(V ), nous avons p 2
Pos\Gamma (U ).

(I4) et (I5) Soit D0 =C D ou D0 2 DF2. Nous devons montrer que Pos(D0; U ) `

Pos0(U ). Si Pos(D0; U ) = ;, c'est imm'ediat. S'il existe p 2 Pos(D0; U ) alors 1:p 2
Pos(D0; T ). Comme Pos(D0; T ) ` Pos0(T ) et Pos0(T ) = 1:Pos0(U ) [ 2:Pos0(V ),
nous avons p 2 Pos0(U ).

De m^eme, V v'erifie (I3), (I4) et (I5). Donc, par hypoth`ese de r'ecurrence, [[\Gamma  `
U ]]I\Delta 0;`;,0j

\Delta 0

` [[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

et [[\Gamma 0 ` V ]]I\Delta 00;`0;,j

\Delta 00

` [[\Gamma 0 ` V ]]I\Delta 00;`0;,0j

\Delta 00

. Ainsi,

\Delta 00 ` u 2 [[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

, \Delta 00 ` tu 2 [[\Gamma 0 ` V ]]I\Delta 00;`0;,j

\Delta 00

et \Delta 00 ` tu 2 [[\Gamma 0 ` V ]]I\Delta 00;`0;,0j

\Delta 00

.

Donc, \Delta 0 ` t 2 [[\Gamma  ` T ]]I\Delta ;`;,0 et [[\Gamma  ` T ]]I\Delta ;`;, ` [[\Gamma  ` T ]]I\Delta ;`;,0.
ffl T = (X : K)V . Similaire au cas pr'ec'edent.
ffl T = [x : U ]V . [[\Gamma  ` T ]]I\Delta ;`;, est la fonction qui `a \Delta 0 ` u 2 T\Delta `U` associe [[\Gamma 0 `

V ]]I\Delta 0;`0;,j

\Delta 0

o`u \Gamma 0 = \Gamma ; x : U et `0 = ` [ fx 7! ug. [[\Gamma  ` T ]]I\Delta ;`;,0 est la fonction qui

`a \Delta 0 ` u 2 T\Delta `U` associe [[\Gamma 0 ` V ]]I\Delta 0;`0;,0j

\Delta 0

o`u \Gamma 0 = \Gamma ; x : U et `0 = ` [ fx 7! ug.

Nous devons montrer que, pour tout \Delta 0 ` u 2 T\Delta `U`, [[\Gamma 0 ` V ]]I\Delta 0;`0;,j

\Delta 0

^ [[\Gamma 0 `

V ]]I\Delta 0;`0;,0j

\Delta 0

. Comme Pos(Y; T ) ` Pos+(T ) et Pos+(T ) = 1:Pos(U ) [ 2:Pos+(V ),

nous avons Pos(Y; V ) ` Pos+(V ). Montrons que V v'erifie (I3), (I4) et (I5).

(I3) Soit D0 =C D. Nous devons montrer que Pos(D0; V ) ` Pos+(V ). Si Pos(D0,

V ) = ;, c'est imm'ediat. S'il existe p 2 Pos(D0; V ) alors 2:p 2 Pos(D0; T ). Comme
Pos(D0; T ) ` Pos+(T ) et Pos+(T ) = 1:Pos(U ) [ 2:Pos+(V ), nous avons p 2
Pos+(V ).

(I4) et (I5) Soit D0 =C D ou D0 2 DF 2. Nous devons montrer que Pos(D0; V ) `

Pos0(V ). Si Pos(D0; V ) = ;, c'est imm'ediat. S'il existe p 2 Pos(D0; V ) alors 2:p 2
Pos(D0; T ). Comme Pos(D0; T ) ` Pos0(T ) et Pos0(T ) = 1:Pos(U ) [ 2:Pos0(V ),
nous avons p 2 Pos0(V ).

Donc, par hypoth`ese de r'ecurrence, [[\Gamma 0 ` V ]]I\Delta 0;`0;,j

\Delta 0

^ [[\Gamma 0 ` V ]]I\Delta 0;`0;,0j

\Delta 0

et [[\Gamma  `

T ]]I\Delta ;`;, ^ [[\Gamma  ` T ]]I\Delta ;`;,0.

112 CHAPITRE 8. CORRECTION DES CONDITIONS

ffl T = [X : K]V . Similaire au cas pr'ec'edent.
ffl T = V u. Nous avons [[\Gamma  ` T ]]I\Delta ;`;, = [[\Gamma  ` V ]]I\Delta ;`;,(\Gamma  ` u) et [[\Gamma  ` T ]]I\Delta ;`;,0 = [[\Gamma  `

V ]]I\Delta ;`;,0(\Gamma  ` u). Comme Pos(Y; T ) ` Pos+(T ) et Pos+(T ) = 1:Pos+(V ) [ 2:Pos(u),
nous avons Pos(Y; V ) ` Pos+(V ). Montrons que V v'erifie (I3), (I4) et (I5).

(I3) Soit D0 =C D. Nous devons montrer que Pos(D0; V ) ` Pos+(V ). Si Pos(D0,

V ) = ;, c'est imm'ediat. S'il existe p 2 Pos(D0; V ) alors 1:p 2 Pos(D0; T ). Comme
Pos(D0; T ) ` Pos+(T ) et Pos+(T ) = 1:Pos+(V ) [ 2:Pos(u), nous avons p 2
Pos+(V ).

(I4) et (I5) Soit D0 =C D ou D0 2 DF 2. Nous devons montrer que Pos(D0; V ) `

Pos0(V ). Si Pos(D0; V ) = ;, c'est imm'ediat. S'il existe p 2 Pos(D0; V ) alors 1:p 2
Pos(D0; T ). Comme Pos(D0; T ) ` Pos0(T ) et Pos0(T ) = 1:Pos0(V ) [ 2:Pos(u),
nous avons p 2 Pos0(V ).

Donc, par hypoth`ese de r'ecurrence, [[\Gamma  ` V ]]I\Delta ;`;, ^ [[\Gamma  ` V ]]I\Delta ;`;,0 et [[\Gamma  ` T ]]I\Delta ;`;, ^
[[\Gamma  ` T ]]I\Delta ;`;,0.

ffl T = V U . Nous avons [[\Gamma  ` T ]]I\Delta ;`;, = [[\Gamma  ` V ]]I\Delta ;`;,(\Gamma  ` U; [[\Gamma  ` U ]]I\Delta ;`;,) et [[\Gamma  `

T ]]I\Delta ;`;,0 = [[\Gamma  ` V ]]I\Delta ;`;,0(\Gamma  ` U; [[\Gamma  ` U ]]I\Delta ;`;,0). Comme Pos(Y; T ) ` Pos+(T ) et
Pos+(T ) = 1:Pos+(V ), nous avons Pos(Y; V ) ` Pos+(V ) et Pos(Y; U ) = ;. Nous
avons vu dans le cas pr'ec'edent que V v'erifie (I3), (I4) et (I5). Montrons que U
v'erifie aussi (I3), (I3\Gamma ), (I4) et (I5).

(I3) et (I3\Gamma ) Soit D0 =C D. Nous devons montrer que Pos(D0; U ) ` Pos+(U ) [

Pos\Gamma (U ). S'il existe p 2 Pos(D0; U ) alors 2:p 2 Pos(D0; T ). Comme Pos(D0; T ) `
Pos+(T ) et Pos+(T ) = 1:Pos+(V ), ce n'est pas possible. Donc, Pos(D0; U ) = ; `
Pos+(U ) [ Pos\Gamma (U ).

(I4) et (I5) Soit D0 =C D ou D0 2 DF 2. Nous devons montrer que Pos(D0; V ) `

Pos0(V ). S'il existe p 2 Pos(D0; U ) alors 2:p 2 Pos(D0; T ). Comme Pos(D0; T )
` Pos0(T ) et Pos0(T ) = 1:Pos0(V ), ce n'est pas possible. Donc, Pos(D0; U ) =
; ` Pos0(U ).

Donc, par hypoth`ese de r'ecurrence, [[\Gamma  ` V ]]I\Delta ;`;, ^ [[\Gamma  ` V ]]I\Delta ;`;,0, [[\Gamma  ` U ]]I\Delta ;`;, =
[[\Gamma  ` U ]]I\Delta ;`;,0 et [[\Gamma  ` T ]]I\Delta ;`;, ^ [[\Gamma  ` T ]]I\Delta ;`;,0. \Xi 

Lemme 129 ' est monotone.

Preuve. Soient I; I0 2 Im tel que I ^ I0. Nous devons montrer que, pour tout
D =F C, \Delta  2 E et ~a, 'I\Delta `D(~a) ^ 'I

0

\Delta `D(~a). Soit alors \Delta 

0 ` u 2 'I

\Delta `D(~a) et montrons

que \Delta 0 ` u 2 'I

0

\Delta `D(~a). Tout d'abord, \Delta 

0 ` u 2 SN

\Delta n`D(~t). Supposons maintenant

que u se r'eduise sur un terme de la forme d(~u) avec d un constructeur de type

(~y : ~U )D(~v). Soit j 2 Acc(d). Nous devons montrer que \Delta 0 ` uj 2 [[~y : ~U ` Uj]]I

0

\Delta 0;`;,j\Delta 0
o`u ` = f~y 7! ~ug et, pour tout Y 2 FV2(Uj), Y , = S'Y .

Nous avons \Delta 0 ` uj 2 [[~y : ~U ` Uj]]I\Delta 0;`;,j

\Delta 0

et Uj v'erifie (I3), (I4) et (I5).

Montrons alors par r'ecurrence sur T que, pour tout \Gamma  ` T 2 TY, \Delta  2 E , ` : \Gamma  ! \Delta ,
, compatible avec (`; \Gamma ; \Delta ) :

- si T v'erifie (I3), (I4) et (I5) alors [[\Gamma  ` T ]]I\Delta ;`;, ^ [[\Gamma  ` T ]]I

0

\Delta ;`;,,

8.4. INTERPR 'ETATION DES SYMBOLES DE PR 'EDICAT CONSTANTS 113

- si T v'erifie (I3\Gamma ), (I4) et (I5) alors [[\Gamma  ` T ]]I\Delta ;`;, * [[\Gamma  ` T ]]I

0

\Delta ;`;,,

o`u (I3\Gamma ) est la propri'et'e 8D 2 CF 2; D =C C ) Pos(D; T ) ` Pos\Gamma (T ). Nous
d'etaillons le premier cas ; le second se traite de mani`ere similaire.

ffl T = s. Nous avons [[\Gamma  ` T ]]I\Delta ;`;, = SN\Delta `s = [[\Gamma  ` T ]]I

0

\Delta ;`;,.

ffl T = E(~t). Nous avons [[\Gamma  ` T ]]I\Delta ;`;, = I\Delta `E(~a) et [[\Gamma  ` T ]]I

0

\Delta ;`;, = I

0
\Delta `E(~a

0) avec a

i =

a0i = \Delta  ` ti` si xi 2 X ?, et ai = (\Delta  ` ti`; Si), a0i = (\Delta  ` ti`; S0i), Si = [[\Gamma  ` ti]]I\Delta ;`;, et

S0i = [[\Gamma  ` ti]]I

0

\Delta ;`;, si xi 2 X

2. Comme T v'erifie (I3), (I4) et (I5), nous avons E 2

CF 2 et E ^C D. Donc, I\Delta `E et I0\Delta `E sont monotones en leurs arguments inductifs.
Nous avons vu dans le lemme pr'ec'edent que ti v'erifie (I3), (I4) et (I5). Donc, par
hypoth`ese de r'ecurrence, Si ^ S0i. Finalement, comme I\Delta `E est monotone en ses
arguments inductifs et I ^ I0, on conclut que I\Delta `E(~a) ^ I\Delta `E(~a0) ^ I0\Delta `E(~a0) et
donc que [[\Gamma  ` T ]]I\Delta ;`;, ^ [[\Gamma  ` T ]]I\Delta ;`;,0.

ffl T = X. Nous avons [[\Gamma  ` T ]]I\Delta ;`;, = Y , = [[\Gamma  ` T ]]I

0

\Delta ;`;,.

ffl T = (x : U )V . Soit \Gamma 0 = \Gamma ; x : U . Nous avons [[\Gamma  ` T ]]I\Delta ;`;, = f\Delta 0 ` t 2

T\Delta `(x:U`)V ` j 8\Delta 00 ` u 2 [[\Gamma  ` U ]]I\Delta 0;`;,j

\Delta 0

, \Delta 00 ` tu 2 [[\Gamma 0 ` V ]]I\Delta 00;`0;,j

\Delta 00

g et

[[\Gamma  ` T ]]I

0

\Delta ;`;, = f\Delta 

0 ` t 2 T

\Delta `(x:U`)V ` j 8\Delta 

00 ` u 2 [[\Gamma  ` U ]]I0

\Delta 0;`;,j\Delta 0 , \Delta 

00 ` tu 2

[[\Gamma 0 ` V ]]I

0

\Delta 00;`0;,j\Delta 00 g o`u `

0 = ` [ fx 7! ug. Nous devons montrer que [[\Gamma  ` T ]]I

\Delta ;`;, `

[[\Gamma  ` T ]]I

0

\Delta ;`;,. Soit \Delta 

0 ` t 2 T

\Delta `(x:U`)V ` et \Delta 

00 ` u 2 [[\Gamma  ` U ]]I

\Delta 0;`;,0j\Delta 0 . Nous avons

vu dans le lemme pr'ec'edent que U v'erifie (I3\Gamma ), (I4) et (I5) et que V v'erifie (I3),

(I4) et (I5). Donc, par hypoth`ese de r'ecurrence, [[\Gamma  ` U ]]I

0

\Delta 0;`;,j\Delta 0 ` [[\Gamma  ` U ]]

I
\Delta 0;`;,j\Delta 0

et [[\Gamma 0 ` V ]]I\Delta 00;`0;,j

\Delta 00

` [[\Gamma 0 ` V ]]I

0

\Delta 00;`0;,j\Delta 00 . Ainsi, \Delta 

00 ` u 2 [[\Gamma  ` U ]]I

\Delta 0;`;,j\Delta 0 , \Delta 

00 ` tu 2

[[\Gamma 0 ` V ]]I\Delta 00;`0;,j

\Delta 00

et \Delta 00 ` tu 2 [[\Gamma 0 ` V ]]I

0

\Delta 00;`0;,j\Delta 00 . Donc, \Delta 

0 ` t 2 [[\Gamma  ` T ]]I0

\Delta ;`;, et

[[\Gamma  ` T ]]I\Delta ;`;, ` [[\Gamma  ` T ]]I

0

\Delta ;`;,.

ffl T = (X : K)V . Similaire au cas pr'ec'edent.

ffl T = [x : U ]V . [[\Gamma  ` T ]]I\Delta ;`;, est la fonction qui `a \Delta 0 ` u 2 T\Delta `U` associe [[\Gamma 0 `

V ]]I\Delta 0;`0;,j

\Delta 0

o`u \Gamma 0 = \Gamma ; x : U et `0 = ` [ fx 7! ug. [[\Gamma  ` T ]]I

0

\Delta ;`;, est la fonction qui

`a \Delta 0 ` u 2 T\Delta `U` associe [[\Gamma 0 ` V ]]I

0

\Delta 0;`0;,j\Delta 0 o`u \Gamma 

0 = \Gamma ; x : U et `0 = ` [ fx 7! ug.

Nous devons montrer que, pour tout \Delta 0 ` u 2 T\Delta `U`, [[\Gamma 0 ` V ]]I\Delta 0;`0;,j

\Delta 0

^ [[\Gamma 0 `

V ]]I

0

\Delta 0;`0;,j\Delta 0 . Nous avons vu dans le lemme pr'ec'edent que V v'erifie (I3), (I4) et

(I5). Donc, par hypoth`ese de r'ecurrence, [[\Gamma 0 ` V ]]I\Delta 0;`0;,j

\Delta 0

^ [[\Gamma 0 ` V ]]I

0

\Delta 0;`0;,j\Delta 0 et

[[\Gamma  ` T ]]I\Delta ;`;, ^ [[\Gamma  ` T ]]I

0

\Delta ;`;,.

ffl T = [X : K]V . Similaire au cas pr'ec'edent.

ffl T = V u. Nous avons [[\Gamma  ` T ]]I\Delta ;`;, = [[\Gamma  ` V ]]I\Delta ;`;,(\Gamma  ` u) et [[\Gamma  ` T ]]I\Delta ;`;,0 =

[[\Gamma  ` V ]]I\Delta ;`;,0(\Gamma  ` u). Nous avons vu dans le lemme pr'ec'edent que V v'erifie (I3),
(I4) et (I5). Donc, par hypoth`ese de r'ecurrence, [[\Gamma  ` V ]]I\Delta ;`;, ^ [[\Gamma  ` V ]]I

0

\Delta ;`;, et

[[\Gamma  ` T ]]I\Delta ;`;, ^ [[\Gamma  ` T ]]I

0

\Delta ;`;,.

ffl T = V U . Nous avons [[\Gamma  ` T ]]I\Delta ;`;, = [[\Gamma  ` V ]]I\Delta ;`;,(\Gamma  ` U; [[\Gamma  ` U ]]I\Delta ;`;,) et [[\Gamma  `

T ]]I\Delta ;`;,0 = [[\Gamma  ` V ]]I\Delta ;`;,0(\Gamma  ` U; [[\Gamma  ` U ]]I\Delta ;`;,0). Nous avons vu dans le lemme

114 CHAPITRE 8. CORRECTION DES CONDITIONS

pr'ec'edent que U v'erifie (I3), (I3\Gamma ), (I4) et (I5), et que V v'erifie (I3), (I4) et (I5).
Donc, par hypoth`ese de r'ecurrence, [[\Gamma  ` V ]]I\Delta ;`;, ^ [[\Gamma  ` V ]]i

0

\Delta ;`;,, [[\Gamma  ` U ]]

I
\Delta ;`;, = [[\Gamma  `

U ]]I

0

\Delta ;`;, et [[\Gamma  ` T ]]

I
\Delta ;`;, ^ [[\Gamma  ` T ]]

I0
\Delta ;`;,. \Xi 

Comme (Im; ^) est un treillis complet, ' admet un plus petit point fixe I qui
est une interpr'etation pour tous les symboles de pr'edicat constants 'equivalents `a C.
Par r'ecurrence sur ?C on obtient ainsi une interpr'etation I pour tous les symboles
de pr'edicat constants.

Notons que, dans le cas d'un symbole de pr'edicat constant primitif, l'interpr'etation est simplement l'ensemble des termes fortement normalisables de ce type.

Lemme 130 (Interpr'etation des pr'edicats constants primitifs) Si C est un
symbole de pr'edicat constant primitif alors I\Delta `C = ?\Delta `C.

Preuve. Comme I\Delta `C ^ ?\Delta `C, il nous suffit de montrer que, pour tout u 2
SN , C primitif de type (~x : ~T )?, ~a arguments de I\Delta `C , ai = \Delta i ` ti si xi 2 X ?,
ai = (\Delta i ` ti; Si) si xi 2 X 2, et \Delta 0 ' \Delta n, si \Delta 0 ` u : C(~t) alors \Delta 0 ` u 2 I\Delta `C(~a), par
r'ecurrence sur u avec ! [ \Lambda  comme ordre bien fond'e. Supposons que u !\Lambda  c(~u) avec
c un constructeur de type (~y : ~U )C(~v). Si u !+ c(~u), nous pouvons conclure par
hypoth`ese de r'ecurrence. Supposons alors que u = c(~u). Dans ce cas, nous devons
montrer que, pour tout j 2 Acc(c), \Delta 0 ` uj 2 [[~y : ~U ` Uj]]I\Delta 0;`;,j

\Delta 0

o`u ` = f~y 7! ~ug

et, pour tout Y 2 FV2(Uj), Y , = S'Y . Par d'efinition des symboles de pr'edicat
primitifs, pour tout j 2 Acc(c), Uj est de la forme D( ~w) avec D un symbole de
pr'edicat primitif. Supposons que o/D = (~z : ~V )?. Soit a0i = \Delta 0 ` wi` si zi 2 X ?, et
a0i = (\Delta 0 ` wi`; [[~y : ~U ` wi]]I\Delta 0;`;,0j

\Delta 0

) si zi 2 X 2. Comme uj 2 SN et \Delta 0 ` uj : D( ~w`),

par hypoth`ese de r'ecurrence, \Delta 0 ` uj 2 I\Delta `D(~a0). Or, par (P3), I\Delta `D(~a0) = I\Delta 0`D(~a0)
et [[~y : ~U ` Uj]]I\Delta 0;`;,j

\Delta 0

= I\Delta 0`D(~a0). Donc, \Delta 0 ` u 2 I\Delta `C (~a). \Xi 

8.5 Ordre de r'eductibilit'e

Dans ce sous-chapitre, on suppose donn'ee une interpr'etation J pour les symboles
de pr'edicat d'efinis et nous d'esignons [[\Gamma  ` T ]]I[J\Delta ;`;, par [[\Gamma  ` T ]]\Delta ;`;,.

Le point fixe de la fonction ' d'efinie dans le sous-chapitre pr'ec'edent peut ^etre
atteint par it'eration transfinie `a partir du plus petit 'el'ement de Im. Notons par 'a
l'interpr'etation obtenue apr`es a it'erations.

D'efinition 131 (Ordre d'une fermeture) L'ordre de \Delta 0 ` t 2 I\Delta `C (~a), o(\Delta 0 `
t), est le plus petit ordinal a tel que \Delta 0 ` t 2 'a\Delta `C (~a).

Cette notion d'ordre va nous permettre de d'efinir un ordre bien fond'e dans lequel
les d'efinitions sur des pr'edicats strictement positifs d'ecroissent strictement. En effet,
dans ce cas-l`a, l'ordre sous-terme ne suffit pas. Dans l'exemple de l'addition sur les
ordinaux de Brouwer (voir page 69), nous avons la r`egle :

+(x; lim(f )) ! lim([n : nat] + (x; f n))

8.5. ORDRE DE R 'EDUCTIBILIT 'E 115

Nous avons un appel r'ecursif avec f n comme argument, qui n'est pas un sousterme de lim(f ). Cependant, du fait de la d'efinition de l'interpr'etation des symboles
de pr'edicat constant et de la d'efinition de l'interpr'etation du produit, nous pouvons
dire que, si lim(f ) est calculable alors f est calculable, et donc que, pour tout n
calculable, f n est calculable. Autrement dit, l'ordre de lim(f ) est plus grand que
celui de f n : o(lim(f )) ? o(f n).

D'efinition 132 (Ordre de r'eductibilit'e) On suppose donn'es une pr'ec'edence
*F sur F et un assignement de statuts stat compatible avec *F . Soit f un symbole
d'arit'e non nulle et de statut statf = lex(m1; : : : ; mk). Notons \Theta f l'ensemble des

quadruplets (g; \Delta ; `; ,) tels que, si o/g = (~x : ~T )U et \Gamma g = ~x : ~T , alors g =F f , \Delta  2 E ,
` : \Gamma g ! \Delta , , est compatible avec (`; \Gamma g; \Delta ), (`; \Gamma g; \Delta ) est valide par rapport `a ,.
Nous munissons \Theta f de l'ordre Af d'efini par :

ffl (g; \Delta ; `; ,) Af (g0; \Delta 0; `0; ,0) si ~m` (A1f ; : : : ; Akf )lex ~m`0,
ffl mul(~u) Aif mul(~u0) si f~ug (Ai)mul f~u0g avec :

- Ai=?? si i 2 SP (f ) o`u u ?? u0 si o(\Delta  ` u) ? o(\Delta 0 ` u0),
- Ai=! [\Lambda  sinon.

Nous munissons \Theta  =

S

f\Theta f j f 2 F g de l'ordre de r'eductibilit'e A d'efini par

(g; \Delta ; `; ,) A (g0; \Delta 0; `0; ,0) si g ?F g0 ou, g =F g0 et (g; \Delta ; `; ,) Af (g0; \Delta 0; `0; ,0).

Lemme 133 L'ordre de r'eductibilit'e est bien fond'e et compatible avec la r'eduction :
si ` ! `0 alors (g; \Delta ; `; ,) w (g; \Delta ; `0; ,).

Preuve. L'ordre de r'eductibilit'e est bien fond'e car les ordinaux sont bien fond'es
et les extensions lexicographiques et multi-ensembles pr'eservent la bonne fondation.
Il est compatible avec la r'eduction par d'efinition de l'interpr'etation des symboles de
pr'edicat constants. \Xi 

Nous v'erifions ci-apr`es, d'une part, que la relation d'accessibilit'e est correcte :
un sous-terme accessible dans un terme calculable est calculable, et d'autre part,
que l'ordre sur les arguments est 'egalement correct : si li ?2 uj et li est calculable
alors uj est calculable et admet un ordre plus petit que celui de li.

Lemme 134 (Correction de l'accessibilit'e) Si t : T \Lambda ae1 u : U , \Gamma  ` tae : T ae,
oe : \Gamma  ! \Delta  et \Delta  ` toe 2 [[\Gamma  ` T ae]]\Delta ;oe;, alors \Gamma  ` uae : U ae et \Delta  ` uoe 2 [[\Gamma  ` U ae]]\Delta ;oe;,.

Preuve. Par d'efinition de \Lambda ae1, nous avons t de la forme c(~u) avec c un constructeur de type (~y : ~U )C(~v), T ae = C(~v)flae o`u fl = f~y 7! ~ug, u = uj avec j 2 Acc(c) et
U ae = Ujflae. Supposons que o/C = (~x : ~T )?. Alors, [[\Gamma  ` C(~v)flae]]\Delta ;oe;, = I\Delta `C (~a) avec
ai = \Delta  ` viflaeoe si xi 2 X ?, et ai = (\Delta  ` viflaeoe; Si) o`u Si = [[\Gamma  ` viflae]]\Delta ;oe;, si xi 2 X 2.
Par d'efinition de I\Delta `C, \Delta  ` ujoe 2 [[\Gamma c ` Uj]]\Delta ;flaeoe;,0 avec, pour tout Y 2 FV2(Uj),
Y ,0 = S'Y = [[\Gamma  ` v'Y flae]]\Delta ;oe;,. Par (I6), v'Y = Y et Y ,0 = [[\Gamma  ` Y flae]]\Delta ;oe;,. De
\Gamma  ` tae : T ae, par inversion, on d'eduit que, pour tout i, \Gamma  ` uiae : Uiflae. Donc,
flae : \Gamma c ! \Gamma . Ainsi, par substitution de candidats, [[\Gamma c ` Uj]]\Delta ;flaeoe;,0 = [[\Gamma  ` Ujflae]]\Delta ;oe;,
et \Delta  ` ujoe 2 [[\Gamma  ` U ae]]\Delta ;oe;,. \Xi 

116 CHAPITRE 8. CORRECTION DES CONDITIONS
Lemme 135 (Correction de l'ordre sur les arguments) Supposons que t : T
?2 u : U , c'est-`a-dire que t soit de la forme c(~t) avec c un constructeur de type
(~x : ~T )C(~v), u soit de la forme x~u avec x 2 dom(\Gamma 0), x\Gamma 0 de la forme (~y : ~U )D( ~w)
et D =C C, et que t : T (\Lambda ae2)+ x : V avec V ae = x\Gamma 0.

Soit ` = f~y 7! ~ug. Si \Gamma  ` tae : T ae, oe : \Gamma  ! \Delta , \Delta  ` toe 2 [[\Gamma  ` T ae]]\Delta ;oe;,
et, pour tout i, \Delta  ` uioe 2 [[\Gamma  ` Ui`]]\Delta ;oe;,, alors \Delta  ` xoe~uoe 2 [[\Gamma  ` D( ~w)`]]\Delta ;oe;, et
o(\Delta  ` toe) ? o(\Delta  ` xoe~uoe).

Preuve. Soit p le chemin suivi de t `a x dans t : T (\Lambda ae2)+ x : V . Montrons que
si p = j1 : : : jnjn+1 alors c(~t) : C(~v)fl = c0(~t0) : C0(~v0)fl0 \Lambda ae2 c1(~t1) : C1(~v1)fl1 \Lambda ae2
: : : \Lambda ae2 cn(~tn) : Cn(~vn)fln \Lambda ae2 x : V avec, si o/ci = (~xi : ~T i)C(~vi) et fli = f~xi 7! ~tig :

- pour tout i ! n, ci+1(~ti+1) = tiji+1, T iji+1 = Ci+1( ~wi+1) et ~wi+1fliae = ~vi+1fli+1ae,
- T njn+1 = (~y : ~U )D( ~w0) et ~w0fln = ~w.

Proc'edons par r'ecurrence sur n. Si n = 0, c'est imm'ediat. Supposons alors que
c(~t) : C(~v)fl \Lambda ae2 tj1 : Tj1fl0 (\Lambda ae2)+ x : V . Comme tj1 : Tj1fl0 (\Lambda ae2)+ x : V , tj1 = c1(~t1)
avec o/c1 = (~x1 : ~T 1)C1(~v1) et Tj1fl0ae = C1(~v1)fl1ae o`u fl1 = f~x1 7! ~t1g. Par ailleurs,
par d'efinition de \Lambda ae2, Tj1 est de la forme (~z : ~V )C01( ~w1). Donc, j~zj = 0, C01 = C1 et

~w1fl0ae = ~v1fl1ae. Ainsi, on peut conclure par r'ecurrence sur tj1 : Tj1fl (\Lambda ae2)+ x : V .

Comme nous sommes dans une structure inductive admissible (A2), on en d'eduit
que C *F C1 *F : : : *F Cn * D. Et comme D =F C et ?F est bien fond'e, nous
avons C =F C1 =F : : : =F D.

Posons wn+1 = tjp~u, Wn+1 = D( ~w)` et, pour tout i ^ n, wi = tjj1:::ji et Wi =
Ci(~vi)fli. Montrons par r'ecurrence sur n que, pour tout i ^ n + 1, \Delta  ` wioe 2 [[\Gamma  `
Wi]]\Delta ;oe;, et que, pour tout i ^ n, o(\Delta  ` wioe) ? o(\Delta  ` wi+1oe).

ffl Cas n ? 0. c(~t) : C(~v)fl \Lambda ae2 tj1 : Tj1fl (\Lambda ae2)+ x : V . Par hypoth`ese, nous avons \Gamma  `

c(~t)ae : C(~v)flae et \Delta  ` c(~t)oe 2 [[\Gamma  ` C(~v)flae]]\Delta ;oe;,. Par correction de l'accessibilit'e,
\Gamma  ` tj1 ae : Tj1 flae et \Delta  ` tj1oe 2 [[\Gamma  ` Tj1flae]]\Delta ;oe;,. Comme Tj1 flae = C1(~v1)fl1ae et
C1 =F C, o(\Delta  ` toe) ? o(\Delta  ` tj1 oe). Ainsi, on peut conclure par hypoth`ese de
r'ecurrence sur tj1 : Tj1fl.

ffl Cas n = 0. c(~t) : C(~v)fl \Lambda ae2 x : V . Comme dans le cas n ? 0, nous avons

\Delta  ` xoe 2 [[\Gamma  ` V ae]]\Delta ;oe;,. Nous avons V ae = (~y : ~U )D( ~w). Soit m = j~uj et `k = fy1 7!
u1; : : : ; yk 7! ukg. Montrons par r'ecurrence sur k ^ m que \Delta  ` xoe u1oe : : : ukoe 2
[[\Gamma  ` (yk+1 : Uk+1`k) : : : (ym : Um`k)D( ~w)`k]]\Delta ;oe;, et donc que o(\Delta  ` toe) ? o(\Delta  ` t0oe).

Si k = 0, c'est imm'ediat. Supposons donc k ? 0. Par hypoth`ese de r'ecurrence,
\Delta  ` xoe u1oe : : : uk\Gamma 1oe 2 [[\Gamma  ` (yk : Uk`k\Gamma 1) : : : (ym : Um`k\Gamma 1)D( ~w)`k\Gamma 1]]\Delta ;oe;,. Comme
\Delta  ` ukoe 2 [[\Gamma  ` Uk`k\Gamma 1]]\Delta ;oe;,, nous avons \Delta  ` xoe u1oe : : : ukoe 2 [[\Gamma ; yk : Uk`k\Gamma 1 `
(yk+1 : Uk+1`k\Gamma 1) : : : (ym : Um`k\Gamma 1)D( ~w)`k\Gamma 1]]\Delta ;oe0;,0 o`u oe0 = oe [ fyk 7! ukoeg, ,0 = ,
si yk 2 X ? et ,0 = , [ fyk 7! [[\Gamma  ` uk]]\Delta ;oe;,g si yk 2 X 2. Ainsi, par substitution de
candidats, [[\Gamma ; yk : Uk`k\Gamma 1 ` (yk+1 : Uk+1`k\Gamma 1) : : : (ym : Um`k\Gamma 1)D( ~w)`k\Gamma 1]]\Delta ;oe0;,0 =
[[\Gamma  ` (yk+1 : Uk+1`k) : : : (ym : Um`k)D( ~w)`k]]\Delta ;oe;,. \Xi 

8.6. INTERPR 'ETATION DES SYMBOLES DE PR 'EDICAT D 'EFINIS 117
8.6 Interpr'etation des symboles de pr'edicat d'efinis

Dans ce sous-chapitre, nous d'efinissons l'interpr'etation J pour les symboles de
pr'edicat d'efinis par r'ecurrence sur O/.

Soit un symbole de pr'edicat d'efini F et supposons que nous ayons d'ej`a d'efini
une interpr'etation K pour tous les symboles inf'erieurs `a F . Soit [F ] l'ensemble des
symboles 'equivalents `a F . Nous d'efinissons l'interpr'etation des symboles de [F ] selon
que [F ] est primitif, positif ou r'ecursif.

Pour all'eger les notations, nous d'esignerons [[\Gamma  ` T ]]I[K[J\Delta ;`;, par [[\Gamma  ` T ]]J\Delta ;`;,. Et
pour les arguments des interpr'etations, nous utiliserons les notations donn'ees au
d'ebut du Sous-chapitre 8.4.

8.6.1 Syst`emes primitifs
D'efinition 136 Pour chaque G 2 [F ], nous prenons J\Delta `G = ?\Delta `G.

8.6.2 Syst`emes positifs, petits et simples

Soit J l'ensemble des interpr'etations pour [F ] et ^ la relation sur J telle que
J ^ J 0 si, pour tout G 2 [F ] et \Delta  2 E , J\Delta `G ^\Delta `G J 0\Delta `G. Comme (R\Delta `G; ^\Delta `G) est
un treillis complet, il est facile de voir que (J ; ^) est 'egalement un treillis complet.

D'efinition 137 Soit  la fonction qui, `a J 2 J , associe l'interpr'etation J telle
que :

J\Delta `G(~a) =

(

[[\Gamma  ` r]]J\Delta n;oe;, si ~t 2 WN " CR; ~t #= ~loe et (G(~l) ! r; \Gamma ; ae) 2 R

?\Delta n`G(~t) sinon
o`u, pour chaque X 2 FV2(r), X, = S^X j\Delta n . Ci-apr`es, nous montrons que  est
monotone. Donc, nous pouvons prendre J\Delta `G = lfp()\Delta `G.

Lemme 138 J est bien d'efini et est bien une interpr'etation.

Preuve. Par simplicit'e, au plus une seule r'egle peut s'appliquer au sommet de
G(~t #). L'existence de ^X est l'hypoth`ese de petitesse. Maintenant, par (S4), si
~t = ~loe alors oe : \Gamma  ! \Delta n. Par ailleurs, , est compatible avec (oe; \Gamma ; \Delta n) puisque,

pour chaque X 2 FV2(r), X, = S^X j\Delta n 2 R\Delta n`Xoe car S^X 2 R\Delta ^X `t^X et, par
petitesse, t^X = l^X oe = Xoe.

Montrons maintenant que J est une interpr'etation pour [F ]. D'apr`es le Lemme
121 (b), [[\Gamma  ` r]]J\Delta n;oe;, 2 R\Delta n`roe = R\Delta n`F (~t). Par ailleurs, ?\Delta n`F (~t) 2 R\Delta n`F (~t). Il ne
nous reste plus qu'`a v'erifier les propri'et'es (P1) `a (P3).

(P1) Supposons que ~t ! ~t0. Par (A1), ! est confluente, donc f~tg ` WN si et

seulement si f~t0g ` WN , et si f~tg ` WN alors ~t #= ~t0 #. Donc, J\Delta `G(~a) =
J\Delta `G(~a0).

(P2) Supposons que \Delta n ` \Delta 0 2 E . D'apr`es le Lemme 121 (d), [[\Gamma  ` r]]J\Delta n;oe;,j\Delta 0 = [[\Gamma  `

r]]I\Delta 0;oe;,j

\Delta 0

. Par ailleurs, ?\Delta n`F (~t)j\Delta 0 = ?\Delta 0`F (~t). Donc, J\Delta `G(~a)j\Delta 0 = J\Delta 0`G(~a).

Maintenant, supposons que \Delta k ` \Delta 0k 2 E . Prenons a0k = \Delta 0k ` tk si xk 2
X ?, et a0k = (\Delta 0k ` tk; Skj\Delta 0k ) si xk 2 X 2. Alors, J\Delta `G(a1; : : : ; ak\Gamma 1; ak)j\Delta 0k et

118 CHAPITRE 8. CORRECTION DES CONDITIONS

J\Delta `G(a1; : : : ; ak\Gamma 1; a0k) sont 'egales puisqu'elles ont le m^eme domaine et sont
'egales sur ce domaine.

(P3) \Delta `Gj\Delta 0 et \Delta 0`G sont 'egales puisqu'elles ont le m^eme domaine et sont 'egales

sur ce domaine. \Xi 

Lemme 139  est monotone.

Preuve. Comme pour le Lemme 129. \Xi 

8.6.3 Syst`emes r'ecursifs, petits et simples

Soit G 2 [F ], \Delta  2 E . `A une s'equence d'arguments ~a pour J\Delta `G, nous associons
la substitution ` = f~x 7! ~tg : \Gamma G ! \Delta n et l'assignement , = f~x 7! ~Sj\Delta ng compatible avec (`; \Gamma G; \Delta n). Soit D l'ensemble des s'equences ~a telles que (`; \Gamma G; \Delta n) soit
valide par rapport `a ,. Nous munissons D de l'ordre bien fond'e suivant : ~a A ~a0 si
(G; \Delta n; `; ,) A (G; \Delta 0n; `0; ,0).

D'efinition 140 Nous d'efinissons alors J\Delta `G(~a) par r'ecurrence sur A :

J\Delta `G(~a) =

8
?!

?:

[[\Gamma  ` r]]J\Delta n;oe;, si

f~tg ` WN " CR; ~t #= ~loe; ~a # 2 D

et (G(~l) ! r; \Gamma ; ae) 2 R
?\Delta n`G(~t) sinon

o`u, pour chaque X 2 FV2(r), X, = S^X j\Delta n.

Lemme 141 J est bien d'efini et est bien une interpr'etation.

Preuve. Par simplicit'e, au plus une seule r'egle peut s'appliquer au sommet de
G(~t #). L'existence de ^X est l'hypoth`ese de petitesse. Maintenant, par (S4), si
~t = ~loe alors oe : \Gamma  ! \Delta n. Par ailleurs, , est compatible avec (oe; \Gamma ; \Delta n) puisque,

pour chaque X 2 FV2(r), X, = S^X j\Delta n 2 R\Delta n`Xoe car S^X 2 R\Delta ^X `t^X et, par
petitesse, t^X = l^X oe = Xoe.

La bonne fondation de la d'efinition de J d'ecoule du Lemme 147 et du Th'eor`eme
146. Dans le Lemme 147 de r'eductibilit'e des symboles d'ordre sup'erieur, nous montrons qu'`a partir d'une s'equence ~a 2 D il est possible d'appliquer le Th'eor`eme 146
de correction de la cl^oture calculable. Et dans ce th'eor`eme, nous montrons que, dans
un appel r'ecursif G0(~a0) (cas (symb=)), nous avons ~a A ~a0. Comme A est compatible
avec la r'eduction, ~a A ~a0 #.

Enfin, pour s'assurer que J est bien une interpr'etation, on proc`ede de la m^eme
mani`ere que dans le cas d'un syst`eme simple et positif. \Xi 

8.7 Correction des conditions de normalisation forte
D'efinition 142 (Cap et aliens) Soit i une injection entre les classes de termes
modulo $\Lambda  et X . Le cap d'un terme t par rapport `a un ensemble G de symboles est
le plus grand terme capG(t) = t[x1]p1 : : : [xn]pn tel que, pour tout i :

- tjpi n'est pas de la forme f (~t) avec f 2 G,
- xi = i(tjpi).

8.7. CORRECTION DES CONDITIONS DE NORMALISATION FORTE 119
Les tjpi sont les aliens de t. Nous noterons par aliensG(t) leur multi-ensemble.
Lemme 143 (Pr'e-r'eductibilit'e des symboles de premier ordre) Soit f 2 F1
et ~t des termes tels que f (~t) soit typable. Si les ti sont fortement normalisables alors
f (~t) est fortement normalisable.

Preuve. Montrons que tout r'eduit imm'ediat t0 de t = f (~t) est fortement normalisable. Ci-apr`es, par cap, on d'esigne le cap par rapport `a F1.

Cas R! 6= ;. Par r'ecurrence sur (aliens(t); cap(t))lex avec ((! [ \Lambda )mul; !R1 )lex
comme ordre bien fond'e (les aliens sont fortement normalisables et, par (f ), !R1
est fortement normalisant sur T(F1; X )).

Si la r'eduction a lieu dans cap(t) alors c'est une R1-r'eduction. Par (c), aucun
symbole de F! n'appara^it dans les r`egles de R1. Donc, cap(t) !R1 cap(t0). Par (d),
les membres droits des r`egles de R1 sont alg'ebriques et, par (e), les r`egles de R1
sont non-dupliquantes. Donc, aliens(t) \Lambda mul aliens(t0) et nous pouvons conclure par
hypoth`ese de r'ecurrence.

Si la r'eduction a lieu dans un alien alors aliens(t) (! [ \Lambda )mul aliens(t0) et nous
pouvons conclure par hypoth`ese de r'ecurrence.

Cas R! = ;. Puisque les ti sont fortement normalisables et qu'aucune fi-r'eduction ne peut avoir lieu au sommet de t, t admet une forme fi-normale. Notons ficap(t)
le cap de sa forme fi-normale. Montrons que tout r'eduit imm'ediat t0 de t est fortement
normalisable, par r'ecurrence sur (ficap(t); aliens(t))lex avec (!R1 ; (! [ \Lambda )mul)lex
comme ordre bien fond'e (de m^eme, les aliens sont fortement normalisables et, par
(f ), !R1 est fortement normalisant sur T(F1; X )).

Si la r'eduction a lieu dans cap(t) alors c'est une R1-r'eduction. Par (d), les
membres droits des r`egles de R1 sont alg'ebriques. Donc, t0 admet une forme finormale et ficap(t) !R1 ficap(t0). On peut donc conclure par hypoth`ese de r'ecurrence.

Si la r'eduction est une fi-r'eduction dans un alien alors ficap(t) = ficap(t0) et
aliens(t) (! [ \Lambda )mul aliens(t0). Nous pouvons donc conclure par hypoth`ese de
r'ecurrence.

Reste le cas o`u la r'eduction est une R1-r'eduction ayant lieu dans un alien u. Alors,
aliens(t) !mul aliens(t0) et ficap(t) !\Lambda R1 ficap(t0). Nous pouvons donc conclure par
hypoth`ese de r'ecurrence. Pour voir que ficap(t) !\Lambda R1 ficap(t0), il suffit de remarquer
le fait suivant : si on fi-normalise u, tous les r'esidus du R1-radical restent r'eductibles
car, par (c), aucun symbole de F! n'appara^it dans R1. \Xi 

Th'eor`eme 144 (Normalisation forte de !R) La relation !R1 [ !R! est fortement normalisante sur les termes typables.

Preuve. Par r'ecurrence sur la structure des termes. Le seul cas un peu ennuyeux
est celui d'un symbole. Dans le cas d'un symbole de premier ordre, on utilise le lemme
de pr'e-r'eductibilit'e des symboles de premier ordre. Dans le cas d'un symbole d'ordre
sup'erieur, il faut montrer que si f 2 F!, ~t 2 SN et f (~t) 2 T alors t = f (~t) 2 SN
o`u SN d'esigne ici la normalisation forte par rapport `a !R=!R1 [ !R! .

Pour cela, montrons que tout r'eduit imm'ediat t0 de t est fortement normalisable par r'ecurrence sur (f; $(~t); ~t;~t) avec (?F ; (?N)statf ; (\Lambda  [ !R)statf ; (!R)lex)lex

120 CHAPITRE 8. CORRECTION DES CONDITIONS
comme ordre bien fond'e o`u $(t) = 0 si t n'est pas de la forme g(~u) et $(t) = 1
sinon. Supposons que t0 = f (~t0) avec ti !R t0i et, pour tout j 6= i, tj = t0j. Alors
~t (!R)lex ~t0 et $(ti) * $(t0i) car si ti n'est pas de la forme g(~u) alors t0i ne l'est pas

non plus.

Supposons maintenant qu'il existe f (~l) ! r 2 R! telle que ~t = ~loe et t0 = roe.
Par (a), r appartient `a la cl^oture calculable de l. Il est alors ais'e de montrer que
roe est fortement normalisable en raisonnant par r'ecurrence sur la structure de r.

`A nouveau, le cas seul cas un peu ennuyeux est celui d'un symbole. Mais, soit le

symbole est plus petit que f , soit il est 'equivalent `a f et ses arguments ~u sont
plus petits que ~l. Si li ?1 uj alors li \Lambda  uj et FV(uj) ` FV(li). Donc lioe \Lambda  ujoe
et $(lioe) = 1 * $(ujoe). Si maintenant li ?2 uj alors uj est de la forme x~v et
$(lioe) = 1 ? $(ujoe) = 0. \Xi 

Lemme 145 (R'eductibilit'e des symboles de premier ordre) Soit f 2 F1,
o/f = (~x : ~T )U , \Delta  2 E , ` : \Gamma f ! \Delta  et , compatible avec (`; \Gamma f ; \Delta ). Si (`; \Gamma f ; \Delta ) est
valide par rapport `a , alors \Delta  ` f (~x`) 2 [[\Gamma f ` U ]]\Delta ;`;,.

Preuve. Posons ti = xi` et t = f (~t). Si f n'est pas un constructeur alors t est
neutre et il suffit de prouver que, pour tout r'eduit imm'ediat t0 de t, \Delta  ` t0 2 [[\Gamma f `
U ]]\Delta ;`;,.

Si f est un constructeur alors U = C(~v) et [[\Gamma f ` U ]]\Delta ;`;, = I\Delta `C (~a) o`u ai =
\Delta  ` vi` si xi 2 X ? et ai = (\Delta  ` vi`; S0i) avec S0i = [[\Gamma f ` vi]]\Delta ;`;, si xi 2 X 2. Soit
j 2 Acc(f ). Puisque ` est valide par rapport `a ,, \Delta  ` tj 2 [[\Gamma f ` Tj]]\Delta ;`;,. Donc,
dans ce cas 'egalement, il suffit de prouver que, pour tout r'eduit imm'ediat t0 de t,
\Delta  ` t0 2 [[\Gamma f ` U ]]\Delta ;`;,.

Par ailleurs, pour les symboles de premier ordre, U = ? ou U = C(~v) avec C un
symbole de pr'edicat primitif. Donc [[\Gamma f ` U ]]\Delta ;`;, = SN\Delta `U` et il suffit de prouver
que tout r'eduit imm'ediat t0 de t est fortement normalisable. C'est le lemme de
pr'e-r'eductibilit'e pr'ec'edent. \Xi 

Th'eor`eme 146 (Correction de la cl^oture calculable) Soit f 2 F , o/f = (~x : ~T )
U , R = (f (~l) ! r; \Gamma 0; ae) 2 R, fl0 = f~x 7! ~lg, \Delta  2 E , oe : \Gamma 0 ! \Delta  et , compatible
avec (oe; \Gamma 0; \Delta ) tels que :

ffl (oe; \Gamma 0; \Delta ) est valide par rapport `a , ;
ffl pour tout i, \Delta  ` lioe 2 [[\Gamma 0 ` Tifl0ae]]\Delta ;oe;, ;
ffl pour tout g ^F f , si o/g = (~y : ~U )V , \Delta 0 2 E , `0 : \Gamma  ! \Delta , ,0 est compatible avec

(`0; \Gamma g; \Delta 0) et (`0; \Gamma g; \Delta 0) est valide par rapport `a ,0, alors \Delta 0 ` g(~y)`0 2 [[\Gamma g `
V ]]\Delta 0;`0;,j\Delta 0 d`es lors que (f; \Delta ; fl0oe; ,) A (g; \Delta 0; `0; ,0).

Si \Gamma 0; \Gamma  `c t : T , \Delta  ` \Delta 0 2 E , oe0 : \Gamma  ! \Delta 0, ,0 est compatible avec (oe0; \Gamma ; \Delta 0)
et (oe0; \Gamma ; \Delta 0) est valide par rapport `a ,0, alors \Delta 0 ` toeoe0 2 [[\Gamma 0; \Gamma  ` T ]]\Delta 0;oeoe0;,00 o`u
,00 = ,j\Delta 0 [ ,0.

Preuve. Par r'ecurrence sur \Gamma 0 `c t : T (\Gamma 0 = \Gamma 0; \Gamma ), nous montrons :
(a) \Delta 0 ` toeoe0 2 [[\Gamma 0 ` T ]]\Delta 0;oeoe0;,00,
(b) si t =2 O et t ! t0 alors [[\Gamma 0 ` t]]\Delta 0;oeoe0;,00 = [[\Gamma 0 ` t0]]\Delta 0;oeoe0;,00.

8.7. CORRECTION DES CONDITIONS DE NORMALISATION FORTE 121

(ax) \Gamma 0 `c ? : 2

(a) \Delta 0 ` ? 2 [[\Gamma 0 ` 2]]\Delta 0;oe;,j\Delta 0 = SN\Delta 0`2.
(b) ? est irr'eductible.

(symb!)

\Gamma 0 `c o/g : s \Gamma 0 `c u1 : U1fl : : : \Gamma 0 `c un : Unfl

\Gamma 0 `c g(~u) : V fl

(a) Par hypoth`ese de r'ecurrence, \Delta 0 ` uioeoe0 2 [[\Gamma 0 ` Uifl]]\Delta 0;oeoe0;,00 . Par substitution

de candidats, il existe ,000 tel que [[\Gamma 0 ` Uifl]]\Delta ;`;, = [[\Gamma g ` Ui]]\Delta 0;floeoe0;,000 et
[[\Gamma 0 ` V fl]]\Delta ;`;, = [[\Gamma g ` V ]]\Delta 0;floeoe0;,000 . Ainsi, (floeoe0; \Gamma g; \Delta 0) est valide par rapport
`a ,000 et, par hypoth`ese sur g, \Delta 0 ` g(~y)floeoe0 2 [[\Gamma g ` V ]]\Delta 0;floeoe0;,000.

(b) Nous avons [[\Gamma 0 ` g(~u)]]\Delta 0;oeoe0;,00 = I\Delta 0`g(~a) avec ai = \Delta 0 ` uioeoe0 si yi 2 X ?, et

ai = (\Delta 0 ` uioeoe0; Si) et Si = [[\Gamma 0 ` ui]]\Delta 0;oeoe0;,00) si yi 2 X 2. Il y a deux cas :

- ui ! u0i. On conclut par (P1).
- ~u = ~l0oe00 et (g(~l0) ! r0; \Gamma 00; ae0) 2 R. Soit oe000 = oe00oeoe0. Par (A3), il y a deux

sous-cas :

ffl g appartient `a un syst`eme primitif. Alors I\Delta 0`g = ?\Delta 0`g et [[\Gamma 0 `

g(~u)]]\Delta 0;oeoe0;,00 = ?\Delta `g(~l0oe000) = ?\Delta `r0oe000 . Par substitution de candidats, il

existe ,000 tel que [[\Gamma 0 ` r0oe00]]\Delta 0;oeoe0;,00 = [[\Gamma 00 ` r0]]\Delta 0;oe000;,000. Par ailleurs, r0 est
de la forme [~x : ~T ]g0(~u)~v avec g0 ' g ou g0 un symbole de pr'edicat constant
primitif. Si g0 ' g alors I\Delta 0`g0 = ?\Delta 0`g0, et si g0 est un symbole de pr'edicat
constant primitif alors, d'apr`es le Lemme 130, I\Delta 0`g0 = ?\Delta 0`g0. Donc,

[[\Gamma 00 ` r0]]\Delta 0;oe000;,000 = ?\Delta 0`r0oe000 et [[\Gamma 0 ` g(~l0oe00)]]\Delta 0;oeoe0;,00 = [[\Gamma 0 ` r0oe00]]\Delta 0;oeoe0;,00.

ffl g appartient `a un syst`eme positif ou r'ecursif, petit et simple.

Comme \Delta 0 ` uioeoe0 2 [[\Gamma 0 ` Uifl]]\Delta 0;oeoe0;,00 ` SN , par (A1), uioeoe0 admet

une forme normale. Par simplicit'e, les symboles de ~l0 sont constants. Donc
uioeoe0 est de la forme ~l0oe000 avec oe00oeoe0 !\Lambda  oe000. Par simplicit'e encore, au
plus une r`egle peut s'appliquer au sommet d'un terme. Donc I\Delta 0`g(~a) =
[[\Gamma 00 ` r0]]\Delta 0;oe000;,000 avec, pour tout X 2 FV2(r0), X,000 = S^X = [[\Gamma 0 `
l^X oe00]]\Delta 0;oeoe0;,00. Par petitesse, l^X = X. Donc X,000 = [[\Gamma 0 ` Xoe00]]\Delta 0;oeoe0;,00
et, par substitution de candidats, [[\Gamma 00 ` r0]]\Delta 0;oe000;,000 = [[\Gamma 0 ` r0oe00]]\Delta 0;oeoe0;,00.

(symb=)

\Gamma 0 `c o/g : s \Gamma 0 `c u1 : U1fl : : : \Gamma 0 `c un : Unfl

\Gamma 0 `c g(~u) : V fl

(~l : ~T fl0 ? ~u : ~U fl)

(a) Comme dans le cas pr'ec'edent, nous avons (floeoe0; \Gamma g; \Delta 0) valide par rapport

`a ,000. Montrons que (f; \Delta ; fl0oe; ,) Af (g; \Delta 0; floeoe0; ,000). Pour cela, il suffit de
montrer que, si li : Tifl0 ?1 uj : Ujfl alors lioe \Lambda ujoeoe0, et si li : Tifl0 ?2 uj : Ujfl
alors o(\Delta  ` lioe) ? o(\Delta 0 ` ujoeoe0).

Supposons que li : Tifl0 ?1 uj : Ujfl. Alors, li \Lambda  uj et FV(uj) ` FV(li). Donc,
lioeoe0 = lioe \Lambda  ujoeoe0.

Supposons maintenant que li : Tifl0 ?2 uj : Ujfl. Par d'efinition de ?2, nous
avons uj = x~v, x 2 dom(\Gamma 0) et x\Gamma 0 = (~z : ~V )W . Soit ` = f~z 7! ~vg. Par
correction de l'ordre sur les arguments, il suffit de v'erifier que :

122 CHAPITRE 8. CORRECTION DES CONDITIONS

(1) \Gamma 0 ` liae : Tifl0ae,
(2) \Delta 0 ` lioeoe0 2 [[\Gamma 0 ` Tifl0ae]]\Delta 0;oeoe0;,00,
(3) pour tout k, \Delta 0 ` vkoeoe0 2 [[\Gamma 0 ` Vk`]]\Delta 0;oeoe0;,00.

En effet, de cela on d'eduit que o(\Delta 0 ` lioeoe0) ? o(\Delta 0 ` ujoeoe0). Or lioe = lioeoe0
et o(\Delta  ` lioe) * o(\Delta 0 ` lioe).

(1) Par d'efinition d'une r`egle bien form'ee, \Gamma 0 ` f (~l)ae : U fl0ae. Donc, par inversion, \Gamma 0 ` liae : Tifl0ae. Comme \Gamma 0 ` \Gamma 0 2 E , par affaiblissement, \Gamma 0 ` liae :
Tifl0ae.

(2) Par hypoth`ese, \Delta  ` lioe 2 [[\Gamma 0 ` Tifl0ae]]\Delta ;oe;,. Or lioeoe0 = lioe et

[[\Gamma 0 ` Tifl0ae]]\Delta 0;oeoe0;,00 = [[\Gamma 0 ` Tifl0ae]]\Delta 0;oe;,j\Delta 0 = [[\Gamma 0 ` Tifl0ae]]\Delta ;oe;,j\Delta 0.

(3) Par hypoth`ese, on a \Gamma 0 `c x~v : Ujfl. Soit q = j~vj. Par inversion, il existe ~V 0

et ~W 0 tels que \Gamma 0 `c xv1 : : : vq\Gamma 1 : (xq : V 0q )W 0q, \Gamma 0 `c vq : V 0q et W 0qfxq 7!
vqg C \Lambda \Gamma 0 Ujfl, et pour tout k ! q \Gamma  1, \Gamma 0 `c xv1 : : : vk : (xk+1 : V 0k+1)W 0k+1,
\Gamma 0 `c vk+1 : V 0k+1 et W 0k+1fxk+1 7! vk+1g C \Lambda \Gamma 0 (xk+2 : V 0k+2)W 0k+2. Ainsi, par
hypoth`ese de r'ecurrence, pour tout k, \Delta 0 ` vkoeoe0 2 [[\Gamma 0 ` V 0k]]\Delta 0;oeoe0;,00. Montrons que V 0k C \Lambda \Gamma 0 Vk`. Soit Wk = (zk+1 : Vk+1) : : : (zq : Vq)W et `k = fz1 7!
v1; : : : ; zk\Gamma 1 7! vk\Gamma 1g. Montrons par r'ecurrence sur k que V 0k C \Lambda \Gamma 0 Vk`k\Gamma 1 et
W 0kfxk 7! vkg C \Lambda \Gamma 0 Wk`k.

ffl Cas k = 1. Comme (~z : ~V )W C \Lambda \Gamma 0 (x1 : V 01)W 01, par compatibilit'e avec le

produit et ff-'equivalence (on prend x1 = z1), V 01 C \Lambda \Gamma 0 V1 et W 01 C \Lambda \Gamma 0 ;z1:V 0

1

W1.

Donc, W 01fx1 7! v1g C \Lambda \Gamma 0 W1`1.
ffl Cas k ? 1. Par hypoth`ese de r'ecurrence, nous avons W 0k\Gamma 1fxk\Gamma 1 7! vk\Gamma 1g

C \Lambda \Gamma 0 Wk\Gamma 1`k\Gamma 1. Or, W 0k\Gamma 1fxk\Gamma 1 7! vk\Gamma 1g C \Lambda \Gamma 0 (xk : V 0k)W 0k et Wk\Gamma 1`k\Gamma 1 =
(zk : Vk`k\Gamma 1)Wk`k\Gamma 1. Par compatibilit'e avec le produit et ff-'equivalence (on
prend xk = zk), V 0k C \Lambda \Gamma 0 Vk`k\Gamma 1 et W 0k C \Lambda \Gamma 0 ;zk:V 0

k

Wk`k\Gamma 1. Donc, W 0kfxk 7!

vkg C \Lambda \Gamma 0 Wk`k.

En conclusion, \Delta 0 ` vkoeoe0 2 [[\Gamma 0 ` V 0k]]\Delta 0;oeoe0;,00 et V 0k C \Lambda \Gamma 0 Vk`k = Vk`. Par
(conv'), les types utilis'es dans une conversion sont typables. On peut donc
appliquer l'hypoth`ese de r'ecurrence (b). Ainsi, [[\Gamma 0 ` V 0k]]\Delta 0;oeoe0;,00 = [[\Gamma 0 `
Vk`]]\Delta 0;oeoe0;,00 et \Delta 0 ` vkoeoe0 2 [[\Gamma 0 ` Vk`]]\Delta 0;oeoe0;,00.

(b) Comme pour (symb!).

(acc)

\Gamma 0 `c x\Gamma 0 : s

\Gamma 0 `c x : x\Gamma 0

(a) Puisque (oe; \Gamma 0; \Delta 0) est valide par rapport `a ,j\Delta 0.
(b) x est irr'eductible.

(var)

\Gamma 0 `c T : s

\Gamma 0; x : T `c x : T

(a) Car (oeoe0; \Gamma 0; \Delta 0) est valide par rapport `a ,00.
(b) x est irr'eductible.

8.7. CORRECTION DES CONDITIONS DE NORMALISATION FORTE 123

(weak)

\Gamma 0 `c t : T \Gamma 0 `c U : s

\Gamma 0; x : U `c t : T

(a) Par hypoth`ese de r'ecurrence, \Delta 0 ` toeoe0 2 [[\Gamma 0 ` T ]]\Delta 0;oeoe0;,00 = [[\Gamma 0; \Gamma ; x : U `

T ]]\Delta 0;oeoe0;,00.

(b) Comme x =2 FV(t), [[\Gamma 0; x : U ` t]]\Delta 0;oeoe0;,00 = [[\Gamma 0 ` t]]\Delta 0;oeoe0;,00. Or, par hypoth`ese

de r'ecurrence, [[\Gamma 0 ` t]]\Delta 0;oeoe0;,00 = [[\Gamma 0 ` t0]]\Delta 0;oeoe0;,00.

(prod)

\Gamma 0; x : T `c U : s

\Gamma 0 `c (x : T )U : s

(a) Nous devons montrer que \Delta 0 ` (x : T oeoe0)U oeoe0 2 [[\Gamma 0 ` s]]\Delta 0;oeoe0;,00 = SN\Delta 0`s.

Par inversion, \Gamma 0 ` T : s0. Par hypoth`ese de r'ecurrence, \Delta 0 ` T oeoe0 2 [[\Gamma 0 `
s0]]\Delta 0;oeoe0;,00. Montrons maintenant que U oeoe0 2 SN . Nous pouvons toujours
supposer que x =2 dom(\Delta 0). Alors, oeoe0 : \Gamma 0; x : T ! \Delta 00 o`u \Delta 00 = \Delta ; x : T oeoe0.
Soit ,000 = ,00j\Delta 00 si x 2 X ?, et ,000 = ,00j\Delta 00 [ fx 7! ?\Delta 00`xg si x 2 X 2. Alors,
,000 est compatible avec (oeoe0; \Gamma 0; x : T; \Delta 00) puisque, si x 2 X 2 alors x,000 2
R\Delta 00`x = R\Delta 0`xoeoe0 et, pour tout X 2 dom2(\Gamma 0), X,000 = X,00 2 R\Delta 0`Xoeoe0
puisque ,00 est compatible avec (oeoe0; \Gamma 0; \Delta 0). De plus, (oeoe0; \Gamma 0; x : T; \Delta 00) est
valide par rapport `a ,000 car, par le Lemme 115, \Delta 00 ` xoeoe0 = \Delta 00 ` x 2 [[\Gamma 0; x :
T ` T ]]\Delta 00;oeoe0;,000. Donc, par hypoth`ese de r'ecurrence, \Delta 00 ` U oeoe0 2 [[\Gamma 0; x : T `
s0]]\Delta 00;oeoe0;,000 = SN\Delta 00`s0.

(b) Il y a deux cas :

- T ! T 0. Montrons que [[\Gamma 0 ` (x : T )U ]]\Delta 0;oeoe0;,00 ` [[\Gamma 0 ` (x : T 0)U ]]. L'inclusion

inverse se prouve de mani`ere similaire. Soit \Delta 00 ` u 2 [[\Gamma 0 ` (x : T )U ]]\Delta 0;oeoe0;,00,
\Delta 000 ` t 2 [[\Gamma 0 ` T 0]]\Delta 00;oeoe0;,00j\Delta 00 et oe00 = oeoe0 [ fx 7! tg. Par hypoth`ese de
r'ecurrence, [[\Gamma 0 ` T ]]\Delta 00;oeoe0;,00j\Delta 00 = [[\Gamma 0 ` T 0]]\Delta 00;oeoe0;,00j\Delta 00 . Donc, \Delta 000 ` t 2 [[\Gamma 0 `
T ]]\Delta 00;oeoe0;,00j\Delta 00 , \Delta 000 ` ut 2 [[\Gamma 0; x : T ` U ]]\Delta 000;oe00;,00j\Delta 000 et \Delta 00 ` u 2 [[\Gamma 0 ` (x :
T 0)U ]]\Delta 0;oeoe0;,00.

- U ! U 0. Montrons que [[\Gamma 0 ` (x : T )U ]]\Delta 0;oeoe0;,00 ` [[\Gamma 0 ` (x : T )U 0]]. L'inclusion

inverse se prouve de mani`ere similaire. Soit \Delta 00 ` u 2 [[\Gamma 0 ` (x : T )U ]]\Delta 0;oeoe0;,00,
\Delta 000 ` t 2 [[\Gamma 0 ` T ]]\Delta 00;oeoe0;,00j\Delta 00 et oe00 = oeoe0 [ fx 7! tg. Alors, \Delta 000 ` ut 2 [[\Gamma 0; x :
T ` U ]]\Delta 000;oe00;,00j\Delta 000 . Par hypoth`ese de r'ecurrence, [[\Gamma 0; x : T ` U ]]\Delta 000;oe00;,00j\Delta 000 =
[[\Gamma 0; x : T ` U 0]]\Delta 000;oe00;,00j\Delta 000 . Donc, \Delta 00 ` ut 2 [[\Gamma 0; x : T ` U 0]]\Delta 000;oe00;,00j\Delta 000 et
\Delta 00 ` u 2 [[\Gamma 0 ` (x : T )U 0]]\Delta 0;oeoe0;,00.

(abs)

\Gamma 0; x : T `c u : U \Gamma 0 `c (x : T )U : s

\Gamma 0 `c [x : T ]u : (x : T )U

(a) Soit \Gamma 00 = \Gamma 0; x : T . Nous devons montrer que \Delta 0 ` [x : T oeoe0]uoeoe0 2 [[\Gamma 0 ` (x :

T )U ]]\Delta 0;oeoe0;,00. Soit \Delta 00 ` t 2 [[\Gamma 0 ` T ]]\Delta 0;oeoe0;,00 et S 2 R\Delta 00`t si x 2 X 2. Soit
oe00 = oeoe0 [fx 7! tg, ,000 = ,00j\Delta 00 si x 2 X ? et ,000 = ,00j\Delta 00 [fx 7! Sg si x 2 X 2.
Nous avons oe00 : \Gamma 00 ! \Delta 00, ,000 est compatible avec (oe00; \Gamma 00; \Delta 00) et (oe00; \Gamma 00; \Delta 00)
est valide par rapport `a ,00. Donc, par hypoth`ese de r'ecurrence, \Delta 00 ` uoe00 2
R = [[\Gamma 00 ` U ]]\Delta 00;oe00;,000. Alors, pour montrer que v = [x : T oeoe0]uoeoe0 t 2 R, il
nous suffit de montrer que T oeoe0; uoeoe0 2 SN . En effet, dans ce cas, il est facile
de montrer que tous les r'eduits imm'ediats du terme neutre v appartiennent `a

124 CHAPITRE 8. CORRECTION DES CONDITIONS

R par r'ecurrence sur (T oeoe0; uoeoe0; t) avec !lex comme ordre bien fond'e. Par
hypoth`ese de r'ecurrence, nous avons \Delta 0 ` (x : T oeoe0)U oeoe0 2 [[\Gamma 0 ` s]]\Delta 0;oeoe0;,00.
Donc, T oeoe0 2 SN . Enfin, si on prend t = x, ce qui est possible d'apr`es le
Lemme 115, nous avons vu que, par hypoth`ese de r'ecurrence, uoe00 = uoeoe0 2
SN .

(b) Il y a deux cas :

- T ! T 0. Comme T\Delta 0`T oeoe0 = T\Delta 0`T 0oeoe0 , [[\Gamma 0 ` [x : T ]u]]\Delta 0;oeoe0;,00 et [[\Gamma 0 ` [x :

T 0]u]] ont le m^eme domaine et sont 'egales.

- u ! u0. Soit \Delta 00 ` t 2 T\Delta 0`T oeoe0 , S 2 R\Delta 00`t si x 2 X 2, oe00 = oeoe0 [ fx 7! tg,

,000 = ,00j\Delta 00 si x 2 X ? et ,000 = ,00j\Delta 00 [ fx 7! Sg si x 2 X 2. Par hypoth`ese
de r'ecurrence, [[\Gamma 0; x : T ` u]]\Delta 00;oe00;,000 = [[\Gamma 0; x : T ` u0]]\Delta 00;oe00;,000. Donc, [[\Gamma 0 ` [x :
T ]u]]\Delta 0;oeoe0;,00 = [[\Gamma 0 ` [x : T ]u0]]\Delta 0;oeoe0;,00.

(app)

\Gamma 0 `c t : (x : U )V \Gamma 0 `c u : U

\Gamma 0 `c tu : V fx 7! ug

(a) Par hypoth`ese de r'ecurrence, \Delta 0 ` toeoe0 2 [[\Gamma 0 ` (x : U )V ]]\Delta 0;oeoe0;,00 et \Delta 0 ` uoeoe0 2

[[\Gamma 0 ` U ]]\Delta 0;oeoe0;,00 . Soit S = [[\Gamma 0 ` u]]\Delta 0;oeoe0;,00 si x 2 X 2. Alors, par d'efinition
de [[\Gamma 0 ` (x : U )V ]]\Delta 0;oeoe0;,00, \Delta 0 ` toeoe0uoeoe0 2 R = [[\Gamma 0; x : U ` V ]]\Delta 0;oe00;,000 o`u
oe00 = oeoe0 [ fx 7! uoeoe0g, ,000 = ,00 si x 2 X ?, et ,000 = ,00 [ fx 7! Sg si x 2 X 2.
Par substitution de candidats, R = [[\Gamma 0 ` V fx 7! ug]]\Delta 0;oeoe0;,00.

(b) Il y a trois cas :

- t ! t0. Par hypoth`ese de r'ecurrence, [[\Gamma 0 ` t]]\Delta 0;oeoe0;,00 = [[\Gamma 0 ` t0]]\Delta 0;oeoe0;,00.

Donc, [[\Gamma 0 ` tu]]\Delta 0;oeoe0;,00 = [[\Gamma 0 ` t]]\Delta 0;oeoe0;,00(\Delta 0 ` uoeoe0; [[\Gamma 0 ` u]]\Delta 0;oeoe0;,00 ) = [[\Gamma 0 `
t0]](\Delta 0 ` uoeoe0; [[\Gamma 0 ` u]]\Delta 0;oeoe0;,00) = [[\Gamma 0 ` t0u]]\Delta 0;oeoe0;,00.

- u ! u0. Par hypoth`ese de r'ecurrence, [[\Gamma 0 ` u]]\Delta 0;oeoe0;,00 = [[\Gamma 0 ` u0]]\Delta 0;oeoe0;,00.

Par (P1), [[\Gamma 0 ` t]](\Delta 0 ` uoeoe0; [[\Gamma 0 ` u]]\Delta 0;oeoe0;,00) = [[\Gamma 0 ` t]](\Delta 0 ` u0oeoe0; [[\Gamma 0 `
u0]]\Delta 0;oeoe0;,00). Donc, [[\Gamma 0 ` tu]]\Delta 0;oeoe0;,00 = [[\Gamma 0 ` tu0]]\Delta 0;oeoe0;,00 .

- t = [x : U 0]v et t0 = vfx 7! ug. Soit oe00 = fx 7! ugoeoe0 et ,000 = ,00 [ fx 7!

[[\Gamma 0 ` u]]\Delta 0;oeoe0;,00g. Par substitution de candidats, [[\Gamma 0 ` t0]]\Delta 0;oeoe0;,00 = [[\Gamma 0; x :
U 0 ` v]]\Delta 0;oe00;,000 . D'un autre c^ot'e, [[\Gamma 0 ` tu]]\Delta 0;oeoe0;,00 = [[\Gamma 0 ` t]]\Delta 0;oeoe0;,00(\Delta 0 `
uoeoe0; [[\Gamma 0 ` u]]\Delta 0;oeoe0;,00) = [[\Gamma 0; x : U 0 ` v]]\Delta 0;oeoe0[fx7!uoeoe0g;,000 = [[\Gamma 0; x : U 0 `
v]]\Delta 0;oe00;,000 .

(conv)

\Gamma 0 `c t : T \Gamma 0 `c T : s T # T 0 \Gamma 0 `c T 0 : s

\Gamma 0 `c t : T 0

(a) Soit U le r'eduit commun `a T et T 0. Par hypoth`ese de r'ecurrence, \Delta 0 ` toeoe0 2

[[\Gamma 0 ` T ]]\Delta 0;oeoe0;,00 , [[\Gamma 0 ` T ]]\Delta 0;oeoe0;,00 = [[\Gamma 0 ` U ]]\Delta 0;oeoe0;,00 et [[\Gamma 0 ` T 0]]\Delta 0;oeoe0;,00 = [[\Gamma 0 `
U ]]\Delta 0;oeoe0;,00. Donc, [[\Gamma 0 ` T ]]\Delta 0;oeoe0;,00 = [[\Gamma 0 ` T 0]]\Delta 0;oeoe0;,00 et \Delta 0 ` toeoe0 2 [[\Gamma 0 `
T 0]]\Delta 0;oeoe0;,00 .

(b) Par hypoth`ese de r'ecurrence. \Xi 

Lemme 147 (R'eductibilit'e des symboles d'ordre sup'erieur) Soit f 2 F!,
o/f = (~x : ~T )U , \Delta  2 E , ` : \Gamma f ! \Delta  et , compatible avec (`; \Gamma f ; \Delta ). Si (`; \Gamma f ; \Delta ) est
valide par rapport `a , alors \Delta  ` f (~x)` 2 [[\Gamma f ` U ]]\Delta ;`;,.

8.7. CORRECTION DES CONDITIONS DE NORMALISATION FORTE 125

Preuve. Par r'ecurrence sur ((f; \Delta ; `; ,); ~x`) avec (A; !)lex comme ordre bien
fond'e.

Posons ti = xi` et t = f (~t). Comme dans le lemme sur les symboles de premier
ordre, il suffit de montrer que, pour tout r'eduit imm'ediat t0 de t, \Delta  ` t0 2 [[\Gamma f `
U ]]\Delta ;`;,.

Si la r'eduction a lieu dans un ti alors on peut conclure par hypoth`ese de r'ecurrence car les candidats de r'eductibilit'e sont stables par r'eduction (R2) et A est compatible avec la r'eduction.

Supposons maintenant qu'il existe une r`egle (l ! r; \Gamma 0; ae) et une substitution oe
telles que t = loe. Supposons de plus que l = f (~l) et fl0 = f~x 7! ~lg. Alors, ` = fl0oe.
Par (S5), pour tout xi 2 FV2( ~T U ), xifl0oe # xifl0aeoe.

Montrons alors que [[\Gamma f ` U ]]\Delta ;`;, = [[\Gamma f ` U ]]\Delta ;fl0aeoe;, et [[\Gamma f ` Ti]]\Delta ;`;, = [[\Gamma f `
Ti]]\Delta ;fl0aeoe;,. Par (S4), oe : \Gamma 0 ! \Delta . Par d'efinition d'une r`egle bien form'ee, \Gamma 0 `
lae : U fl0ae. Donc, par inversion, fl0ae : \Gamma f ! \Gamma 0 et fl0aeoe : \Gamma f ! \Delta . Montrons
maintenant que , est compatible avec (fl0aeoe; \Gamma f ; \Delta ). Soit xi 2 FV2( ~T U ). Comme ,
est compatible avec (fl0oe; \Gamma f ; \Delta ), xi, 2 R\Delta `xifl0oe. Comme xifl0oe # xifl0aeoe, d'apr`es le
Lemme 114 (b), xi, 2 R\Delta `xifl0aeoe. Donc, d'apr`es le Lemme 121 (c), [[\Gamma f ` U ]]\Delta ;`;, =
[[\Gamma f ` U ]]\Delta ;fl0aeoe;, et [[\Gamma f ` Ti]]\Delta ;`;, = [[\Gamma f ` Ti]]\Delta ;fl0aeoe;,.

D'efinissons maintenant ,0 de telle sorte que [[\Gamma f ` U ]]\Delta ;fl0aeoe;, = [[\Gamma 0 ` U fl0ae]]\Delta ;oe;,0
et [[\Gamma f ` Ti]]\Delta ;fl0aeoe;, = [[\Gamma 0 ` Tifl0ae]]\Delta ;oe;,0. Soit Y 2 dom2(\Gamma 0). Par (b), pour tout

X 2 FV2( ~T U ), Xfl0ae 2 dom2(\Gamma 0) et, pour tout X; X0 2 FV2( ~T U ), Xfl0ae = X0fl0ae
implique X = X0. Alors, s'il existe X (n'ecessairement unique) tel que Y = Xfl0ae,
nous prenons Y ,0 = X,. Sinon, nous prenons Y ,0 = ?\Delta `Y oe. V'erifions que ,0 est
compatible avec (oe; \Gamma 0; \Delta ). Soit Y 2 dom2(\Gamma 0). Si Y = Xfl0ae alors Y ,0 = X,.
Puisque , est compatible avec (fl0aeoe; \Gamma 0; \Delta ), X, 2 R\Delta `Xfl0aeoe. Comme Xfl0ae = Y ,
Y ,0 2 R\Delta `Y oe. Enfin, si Y 6= Xfl0ae, Y ,0 = ?\Delta `Y oe 2 R\Delta `Y oe. Donc, ,0 est compatible
avec (oe; \Gamma 0; \Delta ). Par substitution de candidats, il existe ,00 tel que [[\Gamma 0 ` U fl0ae]]\Delta ;oe;,0 =
[[\Gamma f ` U ]]\Delta ;fl0aeoe;,00 et, pour tout X 2 dom2(\Gamma f ), X,00 = [[\Gamma 0 ` Xfl0ae]]\Delta ;oe;,0 . Si X 2

FV2( ~T U ) alors, par (b), Xfl0ae = Y 2 dom2(\Gamma 0) et X,00 = Y ,0 = X,. Comme ,00 et ,
co"incident sur FV2(U ), [[\Gamma f ` U ]]\Delta ;fl0aeoe;,00 = [[\Gamma f ` U ]]\Delta ;fl0aeoe;,. Ainsi, [[\Gamma f ` U ]]\Delta ;fl0aeoe;, =
[[\Gamma 0 ` U fl0ae]]\Delta ;oe;,0. On montrerait de m^eme que [[\Gamma f ` Ti]]\Delta ;fl0aeoe;, = [[\Gamma 0 ` Tifl0ae]]\Delta ;oe;,0.

Prouvons maintenant que (oe; \Gamma 0; \Delta ) est valide par rapport `a ,0. Par d'efinition
du Sch'ema G'en'eral, (l ! r; \Gamma 0; ae) est bien form'ee : \Gamma 0 ` f (~l)ae : U fl0ae, dom(ae) "
dom(\Gamma 0) = ; et, pour tout x 2 dom(\Gamma 0), il existe i tel que li : Tifl0 (\Lambda ae1)\Lambda  x : x\Gamma 0.
Par inversion, \Gamma 0 ` liae : Tifl0ae. Comme \Delta  ` lioe 2 [[\Gamma 0 ` Tifl0ae]]\Delta ;oe;,0, par correction de
l'accessibilit'e, \Delta  ` xoe 2 [[\Gamma 0 ` x\Gamma 0ae]]\Delta ;oe;,0. Comme dom(ae)"dom(\Gamma 0) = ;, x\Gamma 0ae = x\Gamma 0
et \Delta  ` xoe 2 [[\Gamma 0 ` x\Gamma 0]]\Delta ;oe;,0.

Ainsi, par correction de la cl^oture calculable, \Delta  ` roe 2 [[\Gamma 0 ` U fl0ae]]\Delta ;oe;,0 = [[\Gamma f `
U ]]\Delta ;`;,. \Xi 

Lemme 148 (R'eductibilit'e des termes bien typ'es) Pour tout \Gamma  ` t : T , \Delta  2
E , ` : \Gamma  ! \Delta , , compatible avec (`; \Gamma ; \Delta ), si (`; \Gamma ; \Delta ) est valide par rapport `a , alors
\Delta  ` t` 2 [[\Gamma  ` T ]]\Delta ;`;,.

Preuve. Par r'ecurrence sur \Gamma  ` t : T . On proc`ede comme dans le lemme de
correction de la cl^oture calculable sauf dans le cas (symb) o`u on utilise les lemmes

126 CHAPITRE 8. CORRECTION DES CONDITIONS
de r'eductibilit'e des symboles de premier ordre et d'ordre sup'erieur. \Xi 
Th'eor`eme 149 (Normalisation forte) Toutes les termes bien typ'es sont fortement normalisables.

Preuve. Supposons que \Gamma  ` t : T . Soit ` la substitution identit'e. C'est une
substitution bien typ'ee de \Gamma  dans \Gamma . Soit , l'assignement de candidats d'efini par
X, = ?\Gamma `X. C'est un assignement compatible avec (`; \Gamma ; \Gamma ) puisque, pour tout
X 2 dom2(\Gamma ), X, 2 R\Gamma `X . Enfin, (`; \Gamma ; \Gamma ) est valide par rapport `a , puisque, pour
tout x 2 dom(\Gamma ), \Gamma  ` x 2 [[\Gamma  ` x\Gamma ]]\Gamma ;`;,. Donc, d'apr`es le lemme de r'eductibilit'e des
termes bien typ'es, \Gamma  ` t 2 [[\Gamma  ` T ]]\Delta ;`;, et, puisque [[\Gamma  ` T ]]\Delta ;`;, ` SN , t est fortement
normalisable. \Xi 

Chapitre 9
Futures directions de recherche

Dans ce chapitre, nous 'enum'erons plus ou moins par ordre d'importance certaines de nos conditions de normalisation forte qu'il conviendrait d'affaiblir ou des
extensions qu'il conviendrait d''etudier. Mise `a part la r'ecriture modulo, tous ces
probl`emes nous paraissent assez difficiles.

ffl R'ecriture modulo. Dans notre travail, nous n'avons pas consid'er'e de r'ecriture

modulo certaines th'eories 'equationnelles extr^emement utiles comme l'associativit'e
et la commutativit'e. Il est important de pouvoir 'etendre nos r'esultats `a ce type
de r'ecriture. Mais, alors que cela ne semble pas poser trop de difficult'es pour
ce qui est de la r'ecriture au niveau objet, et nous avons d'ej`a quelques r'esultats
pr'eliminaires dans cette direction, cela est moins clair dans le cas de la r'ecriture
au niveau type.

ffl Types quotients. Nous avons vu que la r'ecriture permet la formalisation de

types quotients de mani`ere interne, en autorisant des r`egles sur des "constructeurs". Cependant, prouver des propri'et'es par "induction" sur de tels types n'ecessite de conna^itre quelles sont les formes normales [70] et peut 'egalement n'ecessiter
une strat'egie de r'eduction particuli`ere [37] ou de la r'ecriture conditionnelle.

ffl Confluence. Parmi nos conditions de normalisation forte, nous demandons non

seulement que la r'ecriture soit confluente mais 'egalement que sa combinaison avec
la fi-r'eduction le soit. C'est l`a une condition assez forte dans la mesure o`u on ne
peut pas s'appuyer sur la normalisation forte pour montrer la confluence [95, 20].
Et mis `a part les cas des syst`emes de r'ecriture du premier ordre en l'absence de
types d'ependants [26] ou des syst`emes d'ordre sup'erieur lin'eaires-gauches [92, 116],
peu de r'esultats sont connus sur la modularit'e de la confluence pour la combinaison
r'ecriture d'ordre sup'erieur et fi-r'eduction. Il serait donc int'eressant d''etudier de
pr`es cette question tout `a fait g'en'erale.

ffl Confluence locale. Nous pensons que, peut-^etre, la confluence locale est suffisante pour 'etablir notre r'esultat. En effet, confluence locale et normalisation forte

127

128 CHAPITRE 9. FUTURES DIRECTIONS DE RECHERCHE

impliquent confluence. Cependant, dans ce cas, il semble n'ecessaire de montrer de
nombreuses propri'et'es en m^eme temps que la normalisation forte, en particulier
la correction de la fi-r'eduction ("subject reduction" ), ce qui semble difficile car
beaucoup de d'efinitions reposent sur cette propri'et'e.

ffl Simplicit'e. Pour les symboles de pr'edicat non primitifs, nous demandons que les

r'egles qui les d'efinissent n'aient pas de paires critiques avec les autres r'egles. Ces
conditions tr`es fortes permettent de d'efinir de mani`ere simple une interpr'etation
valide pour ces symboles de pr'edicats. Il conviendrait d''etudier dans quelle mesure
ces conditions peuvent ^etre affaiblies.

ffl Coh'erence logique. Contrairement `a ce qui se passe dans le Calcul des Constructions pur, dans le Calcul des Constructions Alg'ebriques, il n'est pas impossible
que les symboles et les r`egles de r'ecriture permettent de former une preuve de
? = (P : ?)P en forme normale dans l'environnement vide. Dans ce cas, la normalisation forte ne suffit plus `a assurer la coh'erence logique. Il convient donc de
rechercher des conditions syntaxiques sur les symboles et les r`egles qui assurent la
coh'erence du syst`eme (`a l'instar des environnements "fortement coh'erents" de J.
Seldin [106]). Et, de mani`ere plus g'en'erale, il convient de rechercher et d''etudier
des mod`eles du Calcul des Constructions Alg'ebriques.

ffl Conservativit'e.1 Nous avons vu que, dans le Calcul des Constructions, l'ajout de

r`egles de r'ecriture permet de typer davantage de termes. Il conviendrait d''etudier
dans quelle mesure une proposition prouvable en utilisant un ensemble de r`egles
de r'ecriture fl1 ! r1, : : : g peut aussi ^etre prouv'ee en utilisant un ensemble
d'hypoth`eses fl1 = r1, : : : g. Cela constitue une autre voix de recherche pour
'etablir la coh'erence logique et mieux comprendre l'impact de la r'ecriture sur le

typage et la prouvabilit'e.

ffl D'efinitions locales. Dans notre travail, nous nous sommes restreints `a des symboles d'efinis de mani`ere globale. Cependant, en pratique, au cours de l''elaboration
d'une preuve formelle dans un syst`eme comme Coq [52], il peut ^etre utile d'introduire des symboles et des r`egles de r'ecriture permettant de simplifier celle-ci. Il
conviendrait de r'efl'echir aux probl`emes que cela peut poser d'avoir des d'efinitions
locales et d''etudier dans quelle mesure nos travaux peuvent ^etre utiles pour les
r'esoudre. Le probl`eme des abr'eviations locales a d'ej`a 'et'e r'esolu par E. Poll et P.
Severi [101]. Celui des d'efinitions locales par r'ecriture est abord'e par J. Chrzaszcz
[27].

ffl HORPO. Pour assurer la normalisation forte des d'efinitions d'ordre sup'erieur,

nous avons fait le choix d''etendre la m'ethode du Sch'ema G'en'eral de J.-P. Jouannaud et M. Okada [73]. Or, l'ordre HORPO de J.-P. Jouannaud et A. Rubio [74],

1Nous remercions Henk Barendregt pour nous avoir sugg'er'e d'approfondir cette question.

129
qui 'etend aux termes du *-calcul simplement typ'e l'ordre RPO de N. Dershowitz pour les termes du premier ordre, est naturellement plus puissant puisqu'il
est d'efini de mani`ere r'ecursive. De plus, D. Walukiewicz a r'ecemment 'etendu cet
ordre aux termes du Calcul des Constructions avec symboles au niveau objet [117].
La combinaison de nos deux travaux devrait permettre d'aboutir `a une extension
de HORPO aux termes du Calcul des Constructions avec symboles au niveau type
'egalement.

ffl j-R'eduction. Parmi nos conditions, nous l'avons vu, nous demandons la confluence de !=!R [ !fi. Tels quels, nos r'esultats ne peuvent donc pas s'appliquer `a la j-r'eduction, bien connue pour poser des difficult'es suppl'ementaires [56],
puisque !fi [ !j n'est pas confluente sur les termes mal typ'es. L`a encore, il
conviendrait d''etudier dans quelle mesure cette condition de confluence peut-^etre
rel^ach'ee.

ffl Pr'edicats positifs non-stricts. Les ordres utilis'es dans la d'efinition du Sch'ema

G'en'eral pour comparer deux s'equences d'arguments permettent d'accepter des
d'efinitions par r'ecursion sur des types basiques ou strictement positifs comme
c'est le cas dans le syst`eme Coq [52]. Cependant, N. P. Mendler [89] a montr'e
que les d'efinitions par r'ecursion sur des types positifs non-stricts [87] 'etaient
'egalement fortement normalisantes. Il serait int'eressant de parvenir `a d'efinir un

sch'ema permettant d'accepter de telles d'efinitions. Cependant, dans ce cas, on se
heurte `a une difficult'e importante, comme celle que nous avons rencontr'e avec la
'-r'eduction du Calcul des Constructions Inductives (CIC) (voir discussion avant la
D'efinition 94) : la pr'esence d'appels r'ecursifs avec des variables li'ees qui, bien s^ur,
ne peuvent ^etre instanci'ees que par des sous-termes stricts du membre gauche.

130 CHAPITRE 9. FUTURES DIRECTIONS DE RECHERCHE

Bibliographie

[1] M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. L'evy. Explicit substitutions.

Journal of Functional Programming, 1(4) :375-416, 1991.

[2] T. Altenkirch. Constructions, Inductive Types and Strong Normalization. PhD

thesis, Edinburgh University (UK), 1993.

[3] F. Baader and T. Nipkow. Term Rewriting and All That. Cambridge University Press, 1998.

[4] F. Barbanera. Adding algebraic rewriting to the Calculus of Constructions :

strong normalization preserved. In Proc. of the 2nd Int. Work. on Conditional
and Typed Rewriting Systems, LNCS 516, 1990.

[5] F. Barbanera and M. Fern'andez. Combining first and higher order rewrite

systems with type assignment systems. In Proc. of the 1st Int. Conf. on Typed
Lambda Calculi and Applications, LNCS 664, 1993.

[6] F. Barbanera and M. Fern'andez. Modularity of termination and confluence in

combinations of rewrite systems with *!. In Proc. of the 20th Int. Colloq. on
Automata, Languages and Programming, LNCS 700, 1993.

[7] F. Barbanera, M. Fern'andez, and H. Geuvers. Modularity of strong normalization and confluence in the algebraic-*-cube. In Proc. of the 9th IEEE Symp.
on Logic in Computer Science, 1994. Extended version in [8].

[8] F. Barbanera, M. Fern'andez, and H. Geuvers. Modularity of strong normalization in the algebraic-*-cube. Journal of Functional Programming, 7(6) :613-
660, 1997.

[9] H. Barendregt. Introduction to generalized type systems. Journal of Functional Programming, 1(2) :125-154, 1991.

[10] H. Barendregt. Lambda calculi with types. In S. Abramski, D. Gabbay, and

T. Maibaum, editors, Handbook of logic in computer science, volume 2. Oxford
University Press, 1992.

[11] B. Barras. Auto-validation d'un syst`eme de preuves avec familles inductives.

PhD thesis, Universit'e Paris VII (France), 1999.

[12] G. Barthe. The relevance of proof-irrelevance. In Proc. of the 25th Int. Colloq.

on Automata, Languages and Programming, LNCS 1443, 1998.

[13] G. Barthe and H. Geuvers. Congruence types. In Proc. of the 9th Int. Work.

on Computer Science Logic, LNCS 1092, 1995.

131

132 BIBLIOGRAPHIE

[14] G. Barthe and H. Geuvers. Modular properties of algebraic type systems.

In Proc. of the 2nd Int. Work. on Higher-Order Algebra, Logic and Term
Rewriting, LNCS 1074, 1995.

[15] G. Barthe and P.-A. Melli`es. On the subject reduction property for algebraic

type systems. In Proc. of the 10th Int. Work. on Computer Science Logic,
LNCS 1258, 1996.

[16] G. Barthe and F. van Raamsdonk. Termination of algebraic type systems :

the syntactic approach. In Proc. of the 6th Int. Conf. on Algebraic and Logic
Programming, LNCS 1298, 1997.

[17] P. Bendix and D. Knuth. Computational problems in abstract algebra, chapter

Simple word problems in universal algebra. Pergamon Press, 1970.

[18] S. Berardi. Towards a mathematical analysis of the Coquand-Huet Calculus of

Constructions and the other systems in Barendregt's Cube. Technical report,
Carnegie-Mellon University (USA) and Universita di Torino (Italy), 1988.

[19] F. Blanqui. Definitions by rewriting in the Calculus of Constructions. In Proc.

of the 16th IEEE Symp. on Logic in Computer Science, 2001.

[20] F. Blanqui. Termination and confluence of higher-order rewrite systems. In

Proc. of the 11th Int. Conf. on Rewriting Techniques and Applications, LNCS
1833, 2000.

[21] F. Blanqui, J.-P. Jouannaud, and M. Okada. The Calculus of Algebraic

Constructions. In Proc. of the 10th Int. Conf. on Rewriting Techniques and
Applications, LNCS 1631, 1999.

[22] F. Blanqui, J.-P. Jouannaud, and M. Okada. Inductive-data-type systems.

Theoretical Computer Science, 277, 2001.

[23] V. Breazu-Tannen. Combining algebra and higher-order types. In Proc. of the

3rd IEEE Symp. on Logic in Computer Science, 1988.

[24] V. Breazu-Tannen and J. Gallier. Polymorphic rewriting conserves algebraic

strong normalization. In Proc. of the 16th Int. Colloq. on Automata, Languages
and Programming, LNCS 372, 1989. Extended version in [25].

[25] V. Breazu-Tannen and J. Gallier. Polymorphic rewriting conserves algebraic

strong normalization. Theoretical Computer Science, 83(1) :3-28, 1991.

[26] V. Breazu-Tannen and J. Gallier. Polymorphic rewriting conserves algebraic

confluence. Information and Computation, 114(1) :1-29, 1994.

[27] J. Chrzaszcz. Modular rewriting in the Calculus of Constructions, 2000. Presented at the Int. Work. on Types for Proofs and Programs.

[28] A. Church. A simple theory of types. Journal of Symbolic Logic, 5 :56-68,

1940.

[29] L. Colson and D. Fredholm. System T, call-by-value and the minimum problem. Theoretical Computer Science, 206 :301-315, 1998.

[30] E. Contejean, C. March'e, B. Monate, and X. Urbain. CiME, 2000. Available

at http://www.lri.fr/~demons/cime.html.

BIBLIOGRAPHIE 133

[31] T. Coquand. Pattern matching with dependent types. In Proc. of the

1992 Int. Work. on Types for Proofs and Programs. See http://www.lfcs.-
informatics.ed.ac.uk/research/types-bra/proc/.

[32] T. Coquand. An algorithm for testing conversion in type theory. In G. Huet

and G. Plotkin, editors, Logical Frameworks, pages 255-279. Cambridge University Press, 1991.

[33] T. Coquand and J. Gallier. A proof of strong normalization for the Theory

of Constructions using a Kripke-like interpretation, 1990. Paper presented
at the 1st Int. Work. on Logical Frameworks but not published in the proceedings. Available at ftp://ftp.cis.upenn.edu/pub/papers/gallier/-
sntoc.dvi.Z.

[34] T. Coquand and G. Huet. A theory of constructions, 1984. Paper presented at the Int. Symp. on Semantics of Data Types but not published in the
proceedings. Extended version in [35].

[35] T. Coquand and G. Huet. The Calculus of Constructions. Information and

Computation, 76(2-3) :95-120, 1988.

[36] T. Coquand and C. Paulin-Mohring. Inductively defined types. In Proc. of

the 1988 Int. Conf. on Computer Logic, LNCS 417.

[37] P. Courtieu. Normalized types. In Proc. of the 15th Int. Work. on Computer

Science Logic, LNCS 2142, 2001.

[38] H. B. Curry and R. Feys. Combinatory Logic. North-Holland, 1958.
[39] N. de Bruijn. The mathematical language AUTOMATH, its usage, and some

of its extensions. In Proc. of the Symp. on Automatic Demonstration, Lecture
Notes in Mathematics. Springer, 1968. Reprinted in [58].

[40] N. Dershowitz. Hierarchical termination. In Proc. of the 4th Int. Work. on

Conditional and Typed Rewriting Systems, LNCS 968, 1994.

[41] N. Dershowitz. Orderings for term rewriting systems. In 20th IEEE Symposium

on Foundations of Computer Science, 1979. Extended version in [42].

[42] N. Dershowitz. Orderings for term rewriting systems. Theoretical Computer

Science, 17 :279-301, 1982.

[43] N. Dershowitz and J.-P. Jouannaud. Rewrite systems. In J. van Leeuwen,

editor, Handbook of Theoretical Computer Science, volume B, chapter 6. NorthHolland, 1990.

[44] D. Dougherty. Adding algebraic rewriting to the untyped lambda calculus. In

Proc. of the 4th Int. Conf. on Rewriting Techniques and Applications, LNCS
488, 1991. Extended version in [45].

[45] D. Dougherty. Adding algebraic rewriting to the untyped lambda calculus.

Information and Computation, 101(2) :251-267, 1992.

[46] G. Dowek. La part du calcul, 1999. M'emoire d'habilitation. Available at

http://logical.inria.fr/~dowek/.

[47] G. Dowek, T. Hardin, and C. Kirchner. Theorem proving modulo. Technical

Report 3400, INRIA Rocquencourt (France), 1998.

134 BIBLIOGRAPHIE

[48] G. Dowek and B. Werner. Proof normalization modulo. In Proc. of the 1998

Int. Work. on Types for Proofs and Programs, LNCS 1657.

[49] G. Dowek and B. Werner. An inconsistent theory modulo defined by a

confluent and terminating rewrite system, 2000. Available at http://-
logical.inria.fr/~dowek/.

[50] K. Drosten. Termersetzungssysteme. PhD thesis, Passau University (Germany), 1989.

[51] M. Fern'andez. Mod`eles de calculs multiparadigmes fond'es sur la r'e'ecriture.

PhD thesis, Universit'e Paris-Sud (France), 1993. See [8].

[52] J.-C. Filli^atre, C. Paulin, and et al . The Coq Proof Assistant Reference Manual. INRIA Rocquencourt (France), 2000. Available at http://coq.inria.-
fr/.

[53] K. Futatsugi, J. Goguen, J.-P. Jouannaud, and J. Meseguer. Principles of OBJ2. In Proc. of the 12th ACM Symp. on Principles of Programming Languages,
1985.

[54] J. Gallier. On Girard's "Candidats de R'eductibilit'e". In P.-G. Odifreddi,

editor, Logic and Computer Science. North-Holland, 1990.

[55] G. Gentzen. Investigations into logical deduction. PhD thesis, G"ottingen,

Germany, 1933. See [109].

[56] H. Geuvers. Logics and Type Systems. PhD thesis, Nijmegen University (Netherlands), 1993.

[57] H. Geuvers and M.-J. Nederhof. A modular proof of strong normalization for

the Calculus of Constructions. Journal of Functional Programming, 1(2) :155-
189, 1991.

[58] H. Geuvers, R. Nederpelt, and R. de Vrijer, editors. Selected Papers on Automath, volume 133 of Studies in Logic and the Foundations of Mathematics.
North-Holland, 1994.

[59] E. Gim'enez. Structural recursive definitions in type theory. In Proc. of the 25th

Int. Colloq. on Automata, Languages and Programming, LNCS 1443, 1998.

[60] E. Gim'enez. Un Calcul de Constructions infinies et son application `a la

v'erification de syst`emes communiquants. PhD thesis, ENS Lyon (France),
1996.

[61] J.-Y. Girard. Une extension de l'interpr'etation de G"odel `a l'analyse et son application `a l''elimination des coupures dans l'analyse et la th'eorie des types. In
J. Fenstad, editor, Proc. of the 2nd Scandinavian Logic Symposium, volume 63
of Studies in Logic and the Foundations of Mathematics. North-Holland, 1971.
See [62].

[62] J.-Y. Girard, Y. Lafont, and P. Taylor. Proofs and Types. Cambridge University Press, 1988.

[63] K. G"odel. "Uber einer bisher noch nicht ben"utzte Erweiterung des finiten standpunktes. Dialectica, 12, 1958. Reprinted in [64].

BIBLIOGRAPHIE 135

[64] K. G"odel. Collected works - vol. 2 : publications 1938-1974. Oxford University

Press, 1990.

[65] J. A. Goguen and J. J. Tardo. An introduction to OBJ : a language for writing

and testing formal algebraic specifications. In Proc. of the Specification and
Reliable Software Conference, 1979.

[66] R. Harper, F. Honsell, and G. Plotkin. A framework for defining logics. In

Proc. of the 2nd IEEE Symp. on Logic in Computer Science, 1987.

[67] W. A. Howard. The formulae-as-types notion of construction (1969). In J. P.

Seldin and J. R. Hindley, editors, To H. B. Curry : Essays on Combinatory
Logic, Lambda Calculus and Formalism. Academic Press, 1980.

[68] J. Hsiang. Topics in Automated Theorem Proving and Program Generation.

PhD thesis, University of Illinois (USA), 1982.

[69] J.-P. Jouannaud, C. Kirchner, H. Kirchner, and A. Megreliss. Programming

with equalities, subsorts, overloading and parametrization in OBJ. Journal of
Logic Programming, 12(1 and 2) :257-279, 1992.

[70] J.-P. Jouannaud and E. Kounalis. Proof by induction in equational theories

without constructors. In Proc. of the 1st IEEE Symp. on Logic in Computer
Science, 1986. Extended version in [71].

[71] J.-P. Jouannaud and E. Kounalis. Automatic proofs by induction in theories

without constructors. Information and Computation, 82(1) :1-33, 1989.

[72] J.-P. Jouannaud and M. Okada. Executable higher-order algebraic specification languages. In Proc. of the 6th IEEE Symp. on Logic in Computer Science,
1991. Extended version in [73].

[73] J.-P. Jouannaud and M. Okada. Abstract Data Type Systems. Theoretical

Computer Science, 173(2) :349-391, 1997.

[74] J.-P. Jouannaud and A. Rubio. The Higher-Order Recursive Path Ordering. In

Proc. of the 14th IEEE Symp. on Logic in Computer Science, 1999. Extended
version in [76].

[75] J.-P. Jouannaud and A. Rubio. A recursive path ordering for higher-order

terms in eta-long beta-normal form. In Proc. of the 7th Int. Conf. on Rewriting
Techniques and Applications, LNCS 1103, 1996.

[76] J.-P. Jouannaud and A. Rubio. Higher-order recursive path orderings "

la carte", 2001. Journal submission. Available at http://www.lri.fr/-
~jouannau/.

[77] C. Kirchner and et al . ELAN user manual. INRIA Nancy (France), 2000.

Available at http://elan.loria.fr/.

[78] J. W. Klop, V. van Oostrom, and F. van Raamsdonk. Combinatory reduction

systems : introduction and survey. Theoretical Computer Science, 121 :279-
308, 1993.

[79] C. Loria-Saenz and J. Steinbach. Termination of combined (rewrite and *-

calculus) systems. In Proc. of the 3rd Int. Work. on Conditional and Typed
Rewriting Systems, LNCS 656, 1992.

136 BIBLIOGRAPHIE

[80] Z. Luo. An Extended Calculus of Constructions. PhD thesis, Edinburgh University (UK), 1990.

[81] Z. Luo and R. Pollack. LEGO Proof Development System : User's manual.

Edinburgh University (UK), 1992. Available at http://www.dcs.ed.ac.uk/home/lego/.

[82] O. Lysne and J. Piris. A termination ordering for higher order rewrite systems.

In Proc. of the 6th Int. Conf. on Rewriting Techniques and Applications, LNCS
914, 1995.

[83] P. Martin-L"of. Haupsatz for the intuitionnistic theory of iterated inductive

definitions. In J. Fenstad, editor, Proc. of the 2nd Scandinavian Logic Symposium, volume 63 of Studies in Logic and the Foundations of Mathematics.
North-Holland, 1971. See [84].

[84] P. Martin-L"of. Intuitionistic type theory. Bibliopolis, Napoli, Italy, 1984.
[85] R. Matthes. Monotone fixed-point types and strong normalization. In Proc.

of the 12th Int. Work. on Computer Science Logic, LNCS 1584, 1998.

[86] R. Matthes. Extensions of System F by Iteration and Primitive Recursion on

Monotone Inductive Types. PhD thesis, M"unchen University (Germany), 1998.

[87] R. Matthes. Lambda calculus : A case for inductive definitions. Available at

http://www.tcs.informatik.uni-muenchen.de/~matthes/, 2000.

[88] R. Mayr and T. Nipkow. Higher-order rewrite systems and their confluence.

Theoretical Computer Science, 192(2) :3-29, 1998.

[89] N. P. Mendler. Inductive Definition in Type Theory. PhD thesis, Cornell

University (USA), 1987.

[90] J. Meseguer and et al . Maude : Specification and Programming in Rewriting Logic. SRI International's Computer Science Laboratory (USA), 1999.
Available at http://maude.csl.sri.com/.

[91] D. Miller. A logic programming language with lambda-abstraction, function

variables, and simple unification. In Proc. of the 1989 Int. Work. on Extensions
of Logic Programming, LNCS 475.

[92] F. M"uller. Confluence of the lambda calculus with left-linear algebraic rewriting. Information Processing Letters, 41(6) :293-299, 1992.

[93] R. Nederpelt. Strong normalization in a typed lambda calculus with lambda

structured types. PhD thesis, Eindhoven University (Netherlands), 1973.

[94] M. Newman. On theories with a combinatorial definition of equivalence. Annals of Mathematics, 43(2) :223-243, 1942.

[95] T. Nipkow. Higher-order critical pairs. In Proc. of the 6th IEEE Symp. on

Logic in Computer Science, 1991. Extended version in [88].

[96] M. J. O'Donnell. Computing in systems described by equations. In LNCS 58.

Springer, 1977.

[97] M. Okada. Strong normalizability for the combined system of the typed lambda

calculus and an arbitrary convergent term rewrite system. In Proc. of the 1989
Int. Symp. on Symbolic and Algebraic Computation, ACM Press.

BIBLIOGRAPHIE 137

[98] C. Paulin-Mohring. Extracting F!'s programs from proofs in the Calculus of

Constructions. In Proc. of the 16th ACM Symp. on Principles of Programming
Languages, 1989.

[99] C. Paulin-Mohring. Inductive definitions in the system Coq - rules and properties. In Proc. of the 1st Int. Conf. on Typed Lambda Calculi and Applications,
LNCS 664, 1993.

[100] D. A. Plaisted. A recursively defined ordering for proving termination of term

rewriting systems. Technical report, University of Illinois (USA), 1978.

[101] E. Poll and P. Severi. Pure Types Systems with definitions. In Proc. of the

3rd Int. Symp. on Logical Foundations of Computer Science, LNCS 813, 1994.

[102] R. Pollack. The theory of LEGO, a proof checker for the Extended Calculus

of Constructions. PhD thesis, Edinburgh University (UK), 1994.

[103] J. Reynolds. Towards a theory of type structure. In Programming Symposium,

LNCS 19, 1974.

[104] M. Rusinowitch. On termination of the direct sum of term-rewriting systems.

Information Processing Letters, 1987.

[105] H. Schwichtenberg. Definierbare Funktionen im *-Kalk"ul mit Typen. Archive

for Mathematical Logic, 17 :113-114, 1976.

[106] J. Seldin. Excluded middle without definite descriptions in the theory of

constructions. In Proc. of the 1st Montreal Workshop on Programming Language Theory, 1991.

[107] M. P. A. Sellink. Verifying process algebra proofs in type theory. In Proc. of the

Int. Work. on Semantics of Specification Languages, Workshops in Computing,
1993.

[108] M. Stefanova. Properties of Typing Systems. PhD thesis, Nijmegen University

(Netherlands), 1998.

[109] M. E. Szabo, editor. Collected papers of Gerhard Gentzen. Studies in Logic

and the Foundations of Mathematics. North-Holland, 1969.

[110] W. W. Tait. Infinitely long terms of transfinite type. In J. Crossley and

M. Dummet, editors, Formal Systems and Recursive Functions, Studies in
Logic and the Foundations of Mathematics. North-Holland, 1965.

[111] W. W. Tait. Intensional interpretations of functionals of finite type I. Journal

of Symbolic Logic, 32(2) :198-212, 1967.

[112] J. Terlouw. Een nadera bewijstheoretische analyse van GSTT's. Technical

report, Nijmegen University (Netherlands), 1989.

[113] Y. Toyama. Counterexamples to termination for the direct sum of term rewriting systems. Information Processing Letters, 25(3) :141-143, 1987.

[114] L. S. van Benthem Jutting. Typing in pure type systems. Information and

Computation, 105(1) :30-41, 1993.

[115] J. van de Pol. Termination of higher-order rewrite systems. PhD thesis,

Utrecht University (Nederlands), 1996.

138 BIBLIOGRAPHIE
[116] V. van Oostrom. Confluence for Abstract and Higher-Order Rewriting. PhD

thesis, Vrije University (Netherlands), 1994.

[117] D. Walukiewicz. Termination of rewriting in the Calculus of Constructions.

In Proc. of the 2000 Workshop on Logical Frameworks and Meta-languages.

[118] B. Werner. Une Th'eorie des Constructions Inductives. PhD thesis, Universit'e

Paris VII (France), 1994.

[119] A. Whitehead and B. Russell. Principia Mathematica. Cambridge University

Press, 1911.

BIBLIOGRAPHIE 139
Index
(?1; : : : ; ?n)lex, Chap. 2
(G; RG ), Def. 90
(l ! r; \Gamma ; ae), Def. 58
?mul, Chap. 2
?statf , Def. 78
?1; ?2; ?, Def. 79
?C; *C; =C, Def. 72
?F ; *F ; =F , Def. 77
T ! U , Chap. 2
[C], page 107
[F ], page 117
\Gamma  ` T , Def. 106
\Gamma  ` t : T , Def. 8
[[\Gamma  ` T ]]I\Delta ;`;,, Def. 120
!\Lambda ; !+; ; $\Lambda , Chap. 2
!fi; !j, Chap. 2
#, Chap. 2
!j, Chap. 9
!', page 82
!'0, Def. 94V

\Gamma `T , Def. 113
O/; *; ', Def. 91

j, Sec. 7.3
^, page 107, Sec. 8.6.2
^\Gamma `T , Def. 113
[x : T ]u, Def. 2
hti; h\Gamma i, Thm. 98, Def. 99
(x : T )U , Def. 2
Af ; A, Def. 132, Lem. 133
`, Def. 5
?; 2, Def. 65
\Lambda , Rem. 3
\Lambda 1; \Lambda 2, Def. 76
`, Def. 8, Thm. 92
`f , Def. 53
`c, Def. 80, Lem. 146
`s, Def. 9, Lem. 43
`\Upsilon , Thm. 98, Def. 99

`w, Def. 9, Lem. 19
?\Gamma `T , Def. 113
4, page 81
;, Def. 5
~t, Chap. 2

f (~t), Def. 2
l ! r, Def. 56
t[u]p, Rem. 3
tjp, Rem. 3
uv, Def. 2
j~tj, Chap. 2
(conv'), Def. 9
(weak'), Def. 9

Ai, page 107
A, Def. 7
~a, page 107

ai, page 107
a, Def. 91, Thm. 144, Lem. 147
A0, Def. 91
A1, Def. 91, Lem. 127, Lem. 138, Lem. 146
A2, Def. 91, Lem. 135
A3, Def. 91, Lem. 146
A4, Def. 91
abstraction, Def. 2
Acc, Def. 72
Acc(c), Def. 76
accessibilit'e, Def. 76, Lem. 134, Lem. 135
admissible, Def. 32, Thm. 60
affaiblissement, Lem. 16
aliens; aliensG, Def. 142, Lem. 143, Thm. 144
ff-'equivalence, Chap. 2, Lem. 44
application, Def. 2
arit'e d'un statut, Def. 78
arit'e d'un symbole, Def. 1, Rem. 10,

Lem. 121 (R3)
arit'e maximale, Def. 70
assignement canonique, Def. 117

140

INDEX 141
assignement de candidats, Def. 117
assignement de statuts, Def. 78
assignement de type, Def. 6
ATS, Def. 57
axiome, Def. 7

B, Def. 7
B , page 96
b, Def. 91, Lem. 147
fi-r'eduction, Chap. 2
fiTSM, Def. 7
bien fond'e, Chap. 2

Cif , Def. 78
C , Def. 20
C, Def. 7
C\Gamma ; C \Gamma  , Rem. 9, Def. 20, Lem. 37
c, Def. 91, Lem. 143
CAC, Def. 65
candidat de r'eductibilit'e, Def. 113, Lem. 114,

Lem. 115
cap; capG , Def. 142, Lem. 143, Thm. 144
CF ; CF s, Def. 56
CIC, Sec. 7.1, Fig. 7.1
CIC\Gamma , Def. 97, Fig. 7.2
cl^oture calculable, Def. 80, Fig. 6.1,

Lem. 146
classes de typage, Rem. 49, Def. 66
classes syntaxiques, Def. 67
classification, Lem. 48
coh'erence logique, Rem. 93, Chap. 9
compatibilit'e avec *F , Def. 53, Def. 78,

Def. 84
confluence, Chap. 2, Chap. 9
confluence locale, Chap. 2, Lem. 64,

Chap. 9
conjecture, Conj. 95
conservativit'e, Chap. 9
Constr(i; I), page 81
ConstrIi , Def. 99
constructeur, Def. 69
convertibilit'e des types, Lem. 41
correction de la fi-r'eduction, Lem. 31
correction de la conversion, Lem. 42
correction de la r'ecriture, Lem. 59
correction des types, Lem. 28

CR, page 97
cube de Barendregt, Fig. 1.2

d, Def. 91, Lem. 143, Lem. 145
d'efinition locale, Chap. 9
d'ependance par rapport aux symboles,

Lem. 54, Lem. 87, Lem. 89
d'ependance par rapport aux variables,

Lem. 50
\Delta [I; X; C; f; F ], page 82
\Delta fI; X; C; Q; cg, page 82
\Delta i; \Delta n, page 107
\Delta 0[I; X; C; f; Q; ~f ; ~z], Def. 94
\Delta 0fI; X; C; ~xy; K; cg, Def. 97
\Delta 0S[I; X; C; f; Q; ~f ; ~z], Def. 99
\Delta 0W [I; X; C; f; Q; ~f ; ~z], Def. 99
DF ; DF s, Def. 56
dom(\Gamma ), Def. 5
dom(`); doms(`), Rem. 4
domaine, Rem. 4, Def. 5

E , Def. 8
E, Def. 5
e, Def. 91, Lem. 143
Elim(I; Q; ~a; c)f ~f g, page 81
environnement, Def. 5
environnement valide, Def. 8
j-r'eduction, Chap. 2, Chap. 9
jTSM, Def. 7
extension lexicographique, Chap. 2
extension multi-ensemble, Chap. 2

F; F s; Fn; F sn, Def. 1
F1, Lem. 143, Lem. 145
F1; F!, Def. 91
F!, Lem. 147
f, Def. 91, Lem. 143
fermeture, Def. 106
fermeture calculable, Def. 120
forme normale, Chap. 2
F unElim(I; Q; ~f ), page 82
FV(\Gamma ), Def. 5
FV(t); FVs(t), Chap. 2

\Gamma f , Def. 6
HORPO, page 68, Chap. 9

142 INDEX
I, Def. 117, page 107, page 117
I, page 107
Im, Def. 124
'Y , Def. 74
I2, Def. 74, Lem. 128
I3, Def. 74, Lem. 128, Lem. 129
I4, Def. 74, Lem. 127, Lem. 128, Lem. 129
I5, Def. 74, Lem. 127, Lem. 128, Lem. 129
I6, Def. 74, Def. 126, Lem. 127, Lem. 134
inconvertibilit'e des sortes maximales,

Lem. 36
Ind(X : A)f ~Cg, page 81
Ind, Def. 72
IndI , Def. 99
interpr'etation d'un symbole de pr'edicat,

Def. 119
interpr'etation des symboles de pr'edicat

constants, Def. 126
interpr'etation des symboles de pr'edicat

constants primitifs, Lem. 130
interpr'etation des symboles de pr'edicat

d'efinis primitifs, Def. 136
interpr'etation des symboles de pr'edicat

d'efinis, positifs, petits et simples,
Def. 137
interpr'etation des symboles de pr'edicat

d'efinis, r'ecursifs, petits et simples,
Def. 140
interpr'etation monotone, Def. 124
inversion, Lem. 21, Lem. 29, Lem. 39
'0-r'eduction, Conj. 95, Def. 94
'-r'eduction, page 82

J, page 107, page 117
J , Sec. 8.6.2

K, page 107, page 117
K , Def. 66
K, Def. 67
^X , Def. 90

L, page 107
*P, Fig. 1.1
*-syst`eme sort'e, Def. 1
Lemme d'ff-'equivalence, Lem. 44
Lemme d'affaiblissement, Lem. 16
Lemme d'environnement, Lem. 14

Lemme d'inconvertibilit'e des sortes maximales, Lem. 36
Lemme d'inversion, Lem. 21, Lem. 29,

Lem. 39
Lemme de classification, Lem. 48
Lemme de conversion pour les environnements, Lem. 22
Lemme de convertibilit'e des types, Lem. 41
Lemme de correction de la fi-r'eduction,

Lem. 31
Lemme de correction de la conversion,

Lem. 42
Lemme de correction de la r'ecriture,

Lem. 59
Lemme de correction des types, Lem. 28
Lemme de permutation faible, Lem. 18
Lemme de permutation forte, Lem. 52
Lemme de remplacement, Lem. 15
Lemme de s'eparation, Lem. 47
Lemme de substitution, Lem. 24
Lemme de substitution de candidats,

Lem. 123
Lemme de transitivit'e, Lem. 17
Lemme des sortes maximales, Lem. 45
Lemme des variables libres, Lem. 12
lex, Def. 78
lfp, Def. 126, Def. 137
logique, Def. 30

_, Def. 109
mul, Def. 78
multi-ensemble, Chap. 2

NDM, Sec. 7.3
N F , Def. 97
non-dupliquant, Def. 90, Lem. 143
normalisation, Chap. 2, Thm. 98, Thm. 144,

Thm. 149
*, Def. 109

O , Def. 66
O, Def. 67
objet, Def. 8, Def. 66
o(\Gamma  ` t), Def. 131
ordre d'une fermeture, Def. 131
ordre de r'eductibilit'e, Def. 132, Lem. 133
ordre sur les arguments, Def. 79, Lem. 135

INDEX 143
P, Def. 66
P, Def. 67
P

0

; P

?

; P

2

, page 96

p, Def. 91, Def. 136
P1, Def. 113, Lem. 121, Lem. 146
P2, Def. 113, Lem. 121, Lem. 121
P3, Def. 117, Lem. 130
', Def. 126
Pos(t); Pos(f; t); Pos(x; t), Rem. 3
position, Rem. 3
position accessible, Def. 72
position inductive, Def. 72, Def. 124
positions positives et n'egatives, Def. 73
pr'e-RTS, Def. 32
pr'ec'edence, Def. 77
pr'edicat, Def. 8, Def. 66
pr'edicat basique, Def. 75
pr'edicat positif non-strict, Chap. 9
pr'edicat primitif, Def. 75
pr'edicat strictement positif, Def. 75
pr'eservation des sortes, Lem. 33
pr'eservation du typage, Def. 32, Lem. 35
produit d'ependant, Def. 2
produit non-d'ependant, Chap. 2
, Def. 137
PTS, page 16

q, Def. 91, Def. 137
R\Gamma , Def. 113
R; RG , Def. 56
R\Gamma `T , Def. 113
r, Def. 91, Def. 140
R1, Def. 113, Lem. 114, Lem. 121
R2, Def. 113, Lem. 114, Lem. 121, Lem. 147
R3, Def. 113, Lem. 114, Lem. 115, Lem. 121
R4, Def. 113, Lem. 114, Lem. 127
r'ecriture, Def. 56
r'ecriture modulo, Chap. 9
r`egle bien typ'ee, Def. 58
r`egle de formation du produit, Def. 7
r`egle de r'ecriture, Def. 56
r`egle lin'eaire-gauche, Def. 56
r`egles de typage de *P, Fig. 1.1
r`egles de typage de CIC, Fig. 7.1
r`egles de typage de CIC\Gamma , Fig. 7.2

r`egles de typage des TSM, Fig. 3.1
r`egle bien form'ee, Def. 81, Lem. 146,

Lem. 147
remplacement, Rem. 3, Lem. 15
renforcement, Lem. 50
restriction, Def. 106, Def. 113, Def. 117
ae, Def. 58
RTS, Def. 32

Si, page 107
Sj\Gamma , Def. 106
S, Def. 1
S3, Def. 58, Thm. 60, Lem. 87
S4, Def. 58, Thm. 60, Lem. 138, Lem. 141,

Lem. 147
S5, Def. 58, Thm. 60, Lem. 147
s'eparation, Lem. 47
sch'ema d'interpr'etation, Def. 120
Sch'ema G'en'eral, page 67
SElimQI , Def. 99
\Sigma \Gamma `K, Def. 113
SN , page 97
SN\Gamma `T , Def. 106
sorte, Def. 1
sorte maximale, Def. 27
sorte r'eguli`ere, Def. 38
sous-terme, Rem. 3
SP (f ), Def. 78
stabilit'e par contexte, Chap. 2, Lem. 33
stabilit'e par substitution, Chap. 2, Lem. 33
stat; statf , Def. 78
statut, Def. 78
structure inductive, Def. 72
structure inductive admissible, Def. 74
substitution, Rem. 4, Lem. 24
substitution bien typ'ee, Def. 11
substitution de candidats, Lem. 123
substitution valide, Def. 120
sym'etrie, Lem. 33
symbole, Def. 1, Rem. 10, Lem. 121 (R3)
symbole constant, Def. 56
symbole d'ordre sup'erieur, Def. 91, Lem. 147
symbole d'efini, Def. 56
symbole du premier ordre, Def. 91, Lem. 143,

Lem. 145
syst`eme de premier ordre, Def. 90

144 INDEX
syst`eme de r'ecriture, Def. 90
syst`eme petit, Def. 90, Def. 137, Lem. 138,

Def. 140, Lem. 141, Lem. 146
syst`eme positif, Def. 90, Sec. 8.6.2
syst`eme primitif, Def. 90, Sec. 8.6.1
syst`eme r'ecursif, Def. 82, Sec. 8.6.3
syst`eme s^ur, Def. 90
syst`eme simple, Def. 90, Lem. 138, Lem. 146,

Chap. 9

T(F ; X ), Def. 55
T; Ts0; Ts1, Def. 8
T , Def. 2
T (F ; X ), Def. 55
T, Def. 106
T\Gamma `T , Def. 106
ti, page 107
o/ (t; p), Def. 61
o/; o/f , Def. 6
terme, Def. 2
terme alg'ebrique, Def. 55
terme clos, Chap. 2
terme neutre, Def. 112
transitivit'e, Lem. 17
treillis, Lem. 116, Lem. 125
TSM, Def. 7, Fig. 3.1
TSM fonctionnel, Def. 40
TSM injectif, Def. 46
TSM r'egulier, Def. 38
TSM stable par substitution, Def. 23
TY; TY

?

; TY

2

, page 96

typage, Def. 8, Thm. 92
type, Def. 8
type canonique, Def. 61
type d'eriv'e, Def. 61
type de pr'edicat, Def. 66
type inductif admissible, Def. 96
types quotients, Chap. 9

\Upsilon , Thm. 98, Def. 99
variable, Def. 1
variable li'ee, Chap. 2
variable libre, Chap. 2
vecteur, Chap. 2

W ElimI , Def. 99

WN , page 97
X ; X s, Def. 1
X\Gamma `T , Lem. 115
,; ,j\Gamma 0; ,`, Def. 117