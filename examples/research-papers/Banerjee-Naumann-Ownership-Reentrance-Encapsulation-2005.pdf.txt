

State based ownership, reentrance, and encapsulation

Anindya Banerjee?1 and David A. Naumann??2
1 Kansas State University, Manhattan KS 66506 USA ab@cis.ksu.edu
2 Stevens Institute of Technology, Hoboken NJ 07030 USA naumann@cs.stevens.edu

Abstract. A properly encapsulated data representation can be revised for refactoring or other purposes without affecting the correctness of client programs and
extensions of a class. But encapsulation is difficult to achieve in object-oriented
programs owing to heap based structures and reentrant callbacks. This paper
shows that it is achieved by a discipline using assertions and auxiliary fields to
manage invariants and transferrable ownership. The main result is representation
independence: a rule for modular proof of equivalence of class implementations.

1 Introduction
You are responsible for a library consisting of many Java classes. While fixing a bugor refactoring some classes, you revise the implementation of a certain class in a way
that is intended not to change its observable behavior, e.g., an internal data structure ischanged for reasons of performance. You are in no position to check, or even be aware
of, the many applications that use the class via its instances or by subclassing it. Inprinciple, the class could have a full functional specification. It would then suffice to
prove that the new version meets the specification. In practice, full specifications arerare. Nor is there a well established logic and method for modular reasoning about the
code of a class in terms of the specifications of the classes it uses, without regard totheir implementations or the users of the class in question [20] (though progress has
been made). One problem is that encapsulation, crucial for modular reasoning aboutinvariants, is difficult to achieve in programs that involve shared mutable objects and
reentrant callbacks which violate simple layering of abstractions. Yet complicated heapstructure and calling patterns are used, in well designed object-oriented programs, precisely for orderly composition of abstractions in terms of other abstractions.There is an alternative to verification with respect to a specification. One can attempt
to prove that the revised version is behaviorally equivalent to the original. Of coursetheir behavior is not identical, but at the level of abstraction of source code (e.g., modulo
specific memory addresses), it may be possible to show equivalence of behavior. If anyspecifications are available they can be taken into account using assert statements.

There is a standard technique for proving equivalence [18, 24]: Define a coupling
relation to connect the states of the two versions and prove that it has the simulationproperty, i.e., it holds initially and is preserved by parallel execution of the two versions

of each method. In most cases, one would want to define a local coupling relation for

? Supported in part by NSF grants CCR-0209205, ITR-0326577, and CCR-0296182.
?? Supported in part by NSF grants CCR-0208984, CCF-0429894, and by Microsoft Research.

2
a single pair of instances of the class, as methods act primarily on a target object (self)and the

island of its representation objects; an induced coupling for complete states isthen obtained by a general construction. A language with good encapsulation should

enjoy an abstraction or representation independence theorem that says a simulation forthe revised class induces a simulation for any program built using the class. Suitable
couplings are the identity except inside the abstraction boundary and an identity extension lemma says simulation implies behavioral equivalence of two programs that differonly by revision of a class. Again, such reasoning can be invalidated by heap sharing, which violates encapsulation of data, and by callbacks, which violate hierarchicalcontrol structure.

There is a close connection between the equivalence problem and verification: ver-ification of object oriented code involves object invariants that constrain the internal
state of an instance. Encapsulation involves defining the invariant in a way that protectsit from outside interference so it holds globally provided it is preserved by the methods
of the class of interest. Simulations are like invariants over two copies of the state space,and again modular reasoning requires that the coupling for a class be independent from
outside interference. The main contribution of this paper is a representation independence theorem using a state-based discipline for heap encapsulation and control of
callbacks.

Extant theories of data abstraction assume, in one way or another, a hierarchy ofabstractions such that control does not reenter an encapsulation boundary while already

executing inside it. In many programming languages it is impossible to write code thatfails to satisfy the assumption. But it is commonplace in object oriented programs for
a method m acting on some object o to invoke a method on some other object whichin turn leads to invocation of some method on

o --possibly m itself-- while the initialinvocation of m is in progress. This makes it difficult to reason about when an object's

invariant holds [20, 25]; we give an example later.

There is an analogous problem for reasoning with simulations. In previous work [2]we formulated an abstraction theorem that deals with sharing and is sound for programs

with reentrant callbacks, but it is not easy to apply in cases where reentrant callbacksare possible. The theorem allows the programmer to assume that all methods preserve
the coupling relation when proving simulation, i.e., when reasoning about parallel ex-ecution of two versions of a method of the class of interest. This assumption is like
verifying a procedure implementation under the assumption that called procedures arecorrect. But the assumption that called methods preserve the coupling is of no use if the
call is made in an uncoupled intermediate state. For the examples in [2], we resort toad hoc reasoning for examples involving callbacks.

In a recent advance, [6, 21] reentrancy is managed using an explicit auxiliary (or
ghost) field inv to designate states in which an object invariant is to hold. Encapsulationis achieved using a notion of ownership represented by an auxiliary mutable field own.

This is more flexible than type-based static analyses because the ownership invariantneed only hold in certain flagged states. Heap encapsulation is achieved not by disallowing boundary-crossing pointers but by limiting, in a state-dependent way, their use.Reasoning hinges on a global

program invariant that holds in all states, using inv fieldsto track which object invariants are temporarily not in force because control is within

3
their encapsulation boundary. When inv holds, the object is said to be packed; a fieldmay only be updated when the object is unpacked.

In this paper we adapt the inv/own discipline [6, 21]1 to proving class equivalenceby simulation. The inv fields make it possible for an induced coupling relation to hold at
some pairs of intermediate states during parallel execution of two alternative implemen-tations. This means that the relation-preservation hypothesis of the abstraction theorem
can be used at intermediate states even when the local coupling is not in force. So per-method modular reasoning is fully achieved. In large part the discipline is unchanged,
as one would hope in keeping with the idea that a coupling is just an invariant over twoparallel states. But we have to adapt some features in ways that make sense in terms
of informal considerations of information hiding. The discipline imposes no control onfield reads, only writes, but for representation independence we need to control reads as
well. The discipline also allows ownership transfer quite freely, though it is not trivialto design code that correctly performs transfers. For representation independence, the
transfer of previously-encapsulated data to clients (an unusual form of controlled "repexposure" [16]) is allowed but must occur only in the code of the encapsulating class;
even then, it poses a difficult technical challenge. The significance of our adaptations isdiscussed in Section 7.

A key insight is that, although transferring ownership and packing/unpacking in-volve only ghost fields that cannot affect program execution, it is useful to consider
them to be observable. It is difficult to reason about two versions of a class, in a modu-lar way, if they differ in the way objects cross the encapsulation boundary or in which
methods assume the invariant is in force. The requisite similarity can be expressed us-ing assert statements so we can develop a theory based on this insight without the need
to require that the class under revision has any specifications.
Contributions. The main contributions are (a) formulation of a notion of instance-basedcoupling analogous to invariants in the

inv/own discipline; (b) proof of a representationindependence theorem for a language with inheritance and dynamic dispatch, recursive

methods and callbacks; mutable objects, type casts, and recursive types; and (c) resultson identity extension and use of the theorem to prove program equivalence. Together
these constitute a rule by which the reasoner considers just the methods of the revisedclass and concludes that the two versions yield equivalent behavior for any program
context.

The theorem allows ownership transfers that cross encapsulation boundaries: fromclient to abstraction [16], between abstractions, and even from abstraction to client [29,

4]. The theorem supports the most important form of modularity: reasoning about onemethod implementation (or rather, one corresponding pair) at a time --on the assumption that all methods preserve the coupling (even the one in question, modulo termi-nation). Our theorem also supports local reasoning in the sense that a single instance
(or pair of instances) is considered, together with the island comprised of its currentlyencapsulated representation objects.

1 Called the "Boogie methodology" in the context of the Spec# project [7] at Microsoft Research,

which implements the discipline as part of a comprehensive verification system inspired by the
ESC projects.

4

The discipline can be used in any verification system that supports ghost variablesand assertions. So our formalism treats predicates in assertions semantically, avoiding
ties to any particular logic or specification formalism.

Related work besides the inv/own discipline. Representation independence is needednot only for modular proof of equivalence of class implementations but also for modular reasoning about improvements (called data refinement). Such reasoning is neededfor correctness preserving refactoring. The refactoring rules of Borba et al. [10] were
validated using the data refinement theory of Cavalcanti and Naumann [13] which doesnot model sharing/aliasing. We plan to use the present result to overcome that limitation. Representation independence has also been used to justify treating a method aspure if none of its side effects are visible outside an encapsulation boundary [8, 26].

Representation independence is proved in [2] for a language with shared mutableobjects on the basis of ownership confinement imposed using restrictions expressed in
terms of ordinary types; but these restrictions disallow ownership transfer. The resultsare extended to encompass ownership transfer in [4] but at the cost of substantial technical complications and the need for reachability analysis at transfer points, which aredesignated by explicit annotations. Like the present paper, our previous results are based
on a semantics in which the semantics of primitive commands is given in straightfor-ward operational terms. It is a denotational semantics in that a command denotes a state
transformer function, defined by induction on program structure. To handle recursion,method calls are interpreted relative to a method environment that gives the semantics of
all methods. This is constructed as the limit of approximations, each exact up to a cer-tain maximum calling depth. This model directly matches the recursion rule of Hoare
logic, of which the abstraction theorem is in some sense a generalization.

For simple imperative code and single-instance modules, O'Hearn et al. [29, 23]have proved strong rules for local reasoning about object invariants and simulations

using separation logic which, being state based, admits a notion of ownership transfer.

Confinement disciplines based on static analysis have been given with the objectiveof encapsulation for modular reasoning, though mostly without formal results on modular reasoning [14, 11]. Work using types makes confinement a program invariant, i.e.,a property required to hold in every reachable state. This makes it difficult to transfer
ownership, due to temporary sharing at intermediate states. Most disciplines precludetransfer (e.g., [15, 11]); where it is allowed, it is achieved using nonstandard constructs
such as destructive reads and restrictive linearity constraints (e.g., [12, 30]).

Outline. Sect. 2 sketches the inv/own discipline. It also sketches an example of theuse of simulation to prove equivalence of two versions of a class involving reentrant
callbacks, highlighting the problems and the connection between our solution and theinv

/own discipline. Sect. 3 formalizes the language for which our result is given andSect. 4 formalizes the discipline in our semantics. Sect. 5 gives the main definitions--

proper annotation, coupling, simulation--and the abstraction theorem. Sect. 6 connectssimulation with program equivalence. Sect. 7 discusses future work and assesses our
adaptation of the discipline. For lack of space, all proofs are omitted and can be foundin the companion technical report, which also treats generics [5].

5
class Task { void run(){ } }class

Qnode {
Task tsk; Qnode nxt; int count, limit;invariant

tsk 6= null ^ 0<=count<=limit;
... // constructor elided (in subsequent figures these ellipses are elided too)void

run() { tsk.run(); count := count+1; }void
setTsk(Task t, int lim) {
tsk := t; limit := lim; count := 0; pack self as Qnode; } }

Fig. 1. Classes Task and Qnode. The pack statement is discussed later.
class Queue {

Qnode tsks; int runs := 0;invariant

runs = (\Sigma  p 2 tsks.nxt* | p.count);int
getRuns() { result := runs; }void

runAll() {
Qnode p := tsks; int i := 0;while

p 6= null do {if
p.getCount() < p.getLimit() then p.run(); i := i+1; fi; p := p.getNxt(); }
runs := runs+i; }void

add(Task t, int lim){
Qnode n := new Qnode; n.setTsk(t,lim); n.setNxt(tsks); tsks := n; } }

Fig. 2. Class Queue.

2 Background and overview
2.1 The inv/own discipline
To illustrate the challenge of reentrant callbacks as well as the state based ownershipdiscipline, we consider a class

Queue that maintains a queue of tasks. Each task has anassociated limit on the number of times it can be run. Method

Queue.runAll runs eachtask that has not exceeded its limit. For simplicity we refrain from using interfaces; class

Task in Fig. 1 serves as the interface for tasks. Class Qnode in the same Figure is usedby

Queue which maintains a singly linked list of nodes that reference tasks. Field counttracks the number of times the task has been run. For brevity we omit initialization and

constructors throughout the examples.

Fig. 2 gives class Queue. One intended invariant of Queue is that no task has beenrun more times than its limit. This is expressed, in a decentralized way, by the invariant

declared in Qnode. Some notation: we write \Gamma  Qnode(o) for the predicate o.tsk6=nulland

o.count<=o.limit.
Another intended invariant of Queue is that runs is the sum of the count fields of thenodes reached from

tsks. This is the declared \Gamma  Queue of Fig. 2. (The reader may thinkof other useful invariants, e.g., that the list is null-terminated.) Note that at intermediate

points in the body of Queue.runAll, \Gamma  Queue does not hold because runs is only updatedafter the loop. In particular, \Gamma  Queue does not hold at the point where

p.run() is invoked.
For an example reentrant callback, consider tasks of the following type.

6
class RTask extends Task { Queue q; void run(){q.runAll(); } . . . }
Consider a state in which o points to an instance of Queue and the first node in the list,o.

tsks, has count=0 and limit=1. Moreover, suppose field q of the first node's task hasvalue

o. Invocation of o.runAll diverges: before count is incremented to reflect the firstinvocation, the task makes a

reentrant call on o.runAll --in a state where \Gamma  Queue doesnot hold. In fact
runAll again invokes run on the first task and the program fails due tounterminating recursion.

As another example, suppose RTask.run is instead void run(){q.getRuns();} .This seems harmless, in that

getRuns neither depends on \Gamma  Queue nor invokes any meth-ods --it is even useful, returning a lower bound on the actual sum of runs. It typifies

methods like state readers in the observer pattern, that are intended to be invoked asreentrant callbacks.

The examples illustrate that it is sometimes but not always desirable to allow areentrant callback when an object's invariant is violated temporarily by an "outer" invocation. The ubiquity of method calls makes it impractical to require an object's in-variant to be reestablished before making

any call --e.g., the point between n.setTskand
n.setNxt of method add in Fig. 2-- although this is sound and has been proposedin the literature on object oriented verification [17, 22].

A better solution is to prevent just the undesirable reentrant calls. One could makethe invariant an explicit precondition, e.g., for

runAll but not getRuns. This puts re-sponsibility on the caller, e.g.,
RTask.run cannot establish the precondition and is thusprevented from invoking
runAll. But an object invariant like \Gamma  Queue involves encapsu-lated state not suitable to be visible in a public specification.

The solution of the Boogie methodology [6, 21] is to introduce a public ghost field,inv, that explicitly represents whether the invariant is in force. In the lingo, o

.inv saysobject
o is packed. Special statements pack and unpack set and unset inv.A given object is an instance not only of its class but of all its superclasses, each of

which may have invariants. The methodology takes this into account as follows. Insteadof

inv being a boolean, as in the simplified explanation above, it ranges over class namesC such that C is a superclass of the object's allocated type. That is, it is an invariant

(enforced by typing rules) that o.inv >= type(o) where type(o) is the dynamic type of o.The discipline requires certain assertions preceding pack and unpack statements as well
as field updates, to ensure that the following is a program invariant (i.e., it holds in allreachable states).

o.inv <= C ) \Gamma  C(o) (1)
for all C and all allocated objects o. That is, if o is packed at least to class C then theinvariant \Gamma  C for C holds. Perhaps the most important stipulated assertion is that \Gamma  C(o)

is required as precondition for packing o to level C.Fig. 3 shows how the discipline is used for class

Queue. Assertions impose precon-ditions on
runAll and add which require that the target object is packed to Queue. In
runAll, the unpack statement sets inv to the superclass of Queue, putting the task ina position where it cannot establish the precondition for a reentrant call to

runAll, al-though it can still call
getRuns which imposes no precondition on inv. After the updateto
runs, \Gamma  Queue holds again as required by the precondition (not shown) of pack. Theghost field com is discussed below.

7
void runAll() { assert self.inv = Queue && ! self.com;unpack

self from Queue;
Qnode p := self.tsks; int i := 0;while

p 6= null do {if
p.getCount() < p.getLimit() then p.run(); i := i+1; fi; p := p.getNxt(); }
self.runs := self.runs + i;pack

self as Queue; }void
add(Task t, int lim){ assert self.inv = Queue && ! self.com;unpack

self from Queue;
Qnode n := new Qnode; setown n to (self,Queue);
n.setNxt(tsks); n.setTsk(t,lim); self.tsks := n;pack

self as Queue; } }

Fig. 3. Methods of class Queue with selected annotations.

In order to maintain (1) as a program invariant, it is necessary to control updatesto fields on which invariants depend. The idea is that, to update field

f of some object
p, all objects o whose invariant depends on p. f must be unpacked. Put differently,\Gamma  (o) should depend only on state encapsulated for o. The discipline uses a form of

ownership for this purpose: \Gamma  (o) may depend only on objects transitively owned by o.For example, an instance of

Queue owns the Qnodes reached from field tsks.
Ownership is embodied in an auxiliary field own, so that if p.own = (o,C) then odirectly owns

p and an admissible invariant \Gamma  D(o) may depend on p for types D with
type(o) <= D <= C. The objects transitively owned by o are called its island. For modularreasoning, it is not feasible to require as an explicit precondition for each field update

that all transitive owners are unpacked. A third ghost field, com, is used to enforce aprotocol whereby packing/unpacking is dynamically nested or bracketed (though this
need not be textually apparent).

In addition to (1), two additional conditions are imposed as program invariants,i.e., to hold in all reachable states of all objects. The first may be read "an object is

committed to its owner if its owner is packed". The second says that a committed objectis fully packed. These make it possible for an assignment to

p. f to be subject only tothe precondition p
.inv > C where C is the class that declares f .
The invariants are formalized in Def. 3 in Sect. 4. The stipulated preconditions ap-pear in Table 1, which also describes the semantics of the pack and unpack statements

in detail.2 The diligent reader may enjoy completing the annotation of Fig. 3 accordingto the rules of Table 1. Consult [6, 21] for more leisurely introductions to the discipline.

2.2 Representation independence
Consider the subclass AQueue of Queue declared in Fig. 4. It maintains an array, actsks,of tasks which is used in an overriding declaration of

runAll intended as an optimization

2 We omit the preconditions e 6= null and "e not error" that are needed for the rest of the precondition to be meaningful. Different verification systems make different choices in handling
errors in assertions. Our formulation follows [28] and differs superficially from [6, 21].

8

assert e1.inv > C; /* where C is the class that declares f ; i.e., f 2 dom(dfieldsC) */
e1. f := e2

assert e.inv = superC ^ \Delta  C(e) ^ 8p | p.own = (e,C) ) ~p.com ^ p.inv = type p;pack

e as C /* sets e.inv := C and p.com := true for all p with p.own = (e,C) */

assert e.inv = C ^ ~e.com;unpack

e from C /* sets e.inv := superC and p.com := f alse for all p with p.own = (e,C) */

assert e1.inv = Object ^ (e2 = null . e2.inv > C);setown

e1 to (e2,C) /* sets e1.own := (e2,C) */

Table 1. Stipulated preconditions of field update and of the special commands.

for the situation where many tasks are inactive (have reached their limit). We've dropped
runs and getRuns for brevity. Method add exhibits a typical pattern: unpack to establishthe condition in which a super call can be made (since the superclass unpacks from its

own level); after that call, reestablish the current class invariant. (This imposes proofobligations on inheritance, see [6].)

The implementation of Fig. 4 does not set actsks[i] to null immediately when thetask's count reaches its limit; rather, that situation is detected on the subsequent invocation of runAll. An alternative implementation is given in Fig. 5; it uses a different datastructure and handles the limit being reached as soon as it happens. Both implementations maintain an array of Qnode, but in the alternative implementation, its array artskis accompanied by a boolean array

brtsk. Instead of setting entry i null when the node'stask has reached its limit,
brtsk[i] is set false.

We claim that the two versions are equivalent, in the context of arbitrary clientprograms (and subclasses, though for lack of space we do not focus on subclasses in

the sequel). We would like to argue as follows. Let f ilt1(o.actsks) be the sequenceof non-null elements of o

.actsks with count < limit. Let f ilt2(ts,bs) take an array tsof tasks and a same-length array

bs of booleans and return the subsequence of thosetasks
n in ts where bs is true and n.count < n.limit. Consider the following relationthat connects a state for an instance o of the original implementation (Table 4) with

an instance o0 for the alternative: f ilt1(o.actsks) = f ilt2(o0.artsk,o0.brtsk). The ideais that methods of the new version behave the same as the old version, modulo this
change of representation. That is, for each method of AQueue, parallel execution ofthe two versions from a related pair of states results in a related pair of outcomes. (For
this to hold we need to conjoin to the relation the invariants associated with the twoversions, e.g., the second version requires

artsk.length=brtsk.length.)

The left side of the picture below is an instance of some subclass of AQueue, slicedinto the fields of

Queue, AQueue, and subclasses; dashed lines show the objects en-capsulated at the two levels relevant to reasoning about

AQueue --namely the Qnodesreached from
tsks and the array actsks.

9
class AQueue extends Queue {private

Qnode[ ] actsks; private int alen;void
add(Task t, int lim) { assert self.inv = AQueue && ! self.com;unpack

self from AQueue;
super.add(t,lim); actsks[alen] := self.tsks; self.alen := self.alen+1;pack

self as AQueue; }void
runAll() { assert self.inv= AQueue && ! self.com;unpack

self from AQueue;int
i := self.alen - 1;while

i >= 0 do {
Qnode qn := self.actsks[i];if

qn 6= null then if qn.getCount() < qn.getLimit()then

qn.run(); else self.actsks[i] := null; fi; fi;
i := i - 1; }pack

self as AQueue; } }

Fig. 4. First version of Class AQueue. An invariant: actsks[0..alen-1] contains any n in tsks with
n.count < n.limit, in reverse order. (There may also be nulls and some n with n.count = n.limit).
The elided constructor allocates actsks and we ignore the issue of the array becoming full.

c

AQueue
subclasses...

Queue

X AQueue

subclasses...

Queue
a d a d

T T F T
b bc

On the right is an instance for the alternate implementation of AQueue. It is the con-nection between these two islands that is of interest to the programmer. The "a". . . "d"
of the figure indicate that both versions reference the same sequence of tasks, althoughthose tasks are not part of the islands.

In general, a local coupling is a binary relation on islands. It relates the state of anisland for one implementation of the class of interest with an island for the alternative.
A local coupling gives rise to an induced coupling relation on the complete programstate: Two heaps are related by the induced coupling provided that (a) they can be
partitioned into islands and (b) the islands can be put into correspondence so that eachcorresponding pair is related by the local coupling. Moreover, the remaining objects
(not in an island) are related by equality. (More precisely, equality modulo a bijectionon locations, to take into account differences in allocation between the two versions.)
The details are not obvious and are formalized later.

The point of the abstraction theorem is to justify that it is sufficient to check thatthe induced coupling is preserved by methods of

AQueue, assuming the changed datastructure is encapsulated and can neither affect nor be affected by client programs. At

first glance one might expect the proof obligation to be that each method of AQueuepreserves the local coupling, and indeed this will be the focus of reasoning in practice.

10
class AQueue extends Queue {private

Qnode[ ] artsk;private
boolean[ ] brtsk;private int

len;void
add(Task t, int lim) {assert

self.inv= AQueue && ! self.com;unpack

self from AQueue;
super.add(t,lim); self.artsk[alen] := self.tsks; self.brtsk[len] := true; self.len := len+1;pack

self as AQueue; }void
runAll() {assert

self.inv= AQueue && ! self.com;unpack

self from AQueue;int
i := self.len - 1;while

i >= 0 do {if
self.brtsk[i] then Qnode n := self.artsk[i]; int diff := n.limit - n.count;if

diff <= 1 then self.brtks[i] := false; fi;if
diff 6= 0 then n.run(); fi; fi;
i := i - 1; }pack

self as AQueue; } }

Fig. 5. Alternative implementation of AQueue.

But in general a method may act on more than just the island for self, e.g., by invokingmethods on client objects or on other instances of

AQueue. So the proof obligation isformalized in terms of the induced coupling.

In fact the proof obligation is not simply that each corresponding pair of methodimplementations preserves the coupling, but rather that they preserve the coupling

un-der the assumption that any method they invoke preserves the coupling.3 There is also

a proof obligation for initialization but it is straightforward so we do not discuss it inconnection with the examples.

For example, in the case of method runAll, one must prove that the implementationsgiven in Fig. 4 and in Fig. 5 preserve the coupling on the assumption that the invoked
methods getCount, getLimit, Qnode.run, etc. preserve the coupling. The assumption isnot so important for

getCount or getLimit. For one thing, it is possible to fully describetheir simple behavior. For another, the alternative implementation of

runAll does noteven invoke these methods but rather accesses the fields directly.

The assumption about Qnode.run is crucial, however. Because run invokes, in turn,
Task.run, essentially nothing is known about its behavior. For this reason both imple-mentations of

runAll invoke run on the same tasks in the same order; otherwise, it ishard to imagine how equivalence of the implementations could be verified in a modular way, i.e., reasoning only about class AQueue. But here we encounter the problemwith simulation based reasoning that is analogous to the problem with invariants and

3 The reason this is sound is similar to the justification for proof rules for recursive procedures: it

is essentially the induction step for a proof by induction on the maximum depth of the method
call stack.

11
reentrant callbacks. There is no reason for the coupling to hold at intermediate points ofthe methods of

AQueue. If a method is invoked at such a point, the assumption that thecalled method preserves the coupling is of no use --just as the assumption of invariantpreservation is of no use if a method is invoked in a state where the invariant does nothold.

The Boogie discipline solves the invariant problem for an object o by replacing thedeclared invariant \Gamma  (o) with an implication --see (1)-- that is true in all states. As
with invariants, so too with couplings: It does not make sense to ask a coupling to holdin every state, because two different implementations with nontrivial differences do not
have lockstep correspondence of states. (For example, imagine that in the alternativeversion, the arrays are compressed every 100th invocation of

runAll.) Our generalizationof the Boogie idea is that the local coupling relation for a particular (pair of) island(s) is

conditioned on an inv field so that the local coupling may hold in some pairs of states atintermediate points --in particular, at method calls that can lead to reentrant callbacks.

Consider corresponding instances o, o0 of the two versions of AQueue. The localcoupling serves to describe the corresponding pair of islands when

o and o0 are packed.So the induced coupling relation on program states requires corresponding pairs of

islands to satisfy the local coupling just when they are packed. Because inv is part of thebehavior observable at the level of reasoning, we can assume both versions follow the
same pattern of packing (though not necessarily of control structure) and thus include
o.inv = o0.inv as a conjunct of the induced coupling.

Consider the two implementations of runAll. To a first approximation, what mattersis that each updates some internal state and then both reach a point where

run is invoked.At that point, the
local coupling does not hold --but the induced coupling relation canand does hold, because the island is unpacked. This parallels the way \Gamma  C(

o) can befalse while o
.inv <= C ) \Gamma  C(o) remains true, recall (1). So we can use the assumptionabout called methods to conclude that the coupling holds after the corresponding calls

to run.

The hardest part of the proof for runAll is at the point where the two implementa-tions pack self to AQueue. Just as both implementations invoke

run (and on the samequeue nodes), both need to pack in order to preserve the coupling. And at this point

we have to argue that the local coupling is reestablished. To do so, we need to knowthe state of the internal structures that have been modified. We would like to argue that
the only modifications are only those explicit in the code of runAll, but what about theeffect of

run? Owing to the preconditions on add and runAll, the only possible reen-trant callbacks are to

getRuns and this does no updates. (In other examples, modifiesspecifications would be needed at this point for modular reasoning.)

This concludes the sketch of how our abstraction theorem handles reentrant call-backs and encapsulation using the inv

/own discipline. Several features of the disciplineneed to be adapted, in ways which also make sense in terms of informal considerations

of information hiding. The additional restrictions are formalized in Section 5 and theirsignificance discussed in Section 7. As a preview we make the following remarks, using
"Abs" as the generic name for a class for which two versions are considered.

The discipline does not constrain field access, as reading cannot falsify an invariantpredicate. Of course for reasons of information hiding one expects that visibility and

12
alias confinement are used to prevent most or all reads of encapsulated objects. Infor-mation hiding is exactly what is formalized by representation independence and indeed
the abstraction theorem fails if a client can read fields of encapsulated objects. So everyfield access e

. f is subject to a precondition: If e is transitively owned by some instance
o of the class, Abs, under revision, then either self is o or else self is transitively ownedby o.

Another problematic feature is that "pack e as C" can occur in any class, so long asits preconditions are established. This means that, unlike traditional theories, an invariant is not simply established at initialization. In our theory the local coupling must beestablished preceding each "pack

e as Abs". We aim for modular reasoning where onlyAbs needs to be considered, so we insist that pack e as C with C = Abs occurs only in

code of Abs.

Although the discipline supports hierarchical ownership, our technical treatmentbenefits from heap partitioning ideas from separation logic (we highlight the connections where possible, e.g., in Proposition 1). For this reason and a more technical one, itis convenient to prevent an instance of Abs from transitively owning another instance of
Abs (lest their islands be nested). This can be achieved by a simple syntactic restriction.It does not preclude that, say, class

AQueue can hold tasks that own AQueue objects,because an instance of
AQueue owns its representation objects (the Qnodes), not thetasks they contain. Nor does it preclude hierarchical ownership, e.g.,

Abs could own ahashtable that in turn owns some arrays.

Finally, consider ownership transfer across the encapsulation boundary. The hardestcase is where a hitherto-encapsulated object is released to a client, e.g., when a memory manager allocates nodes from a free list [29, 4]. This can be seen as a deliberateexposure of representation and thus is observable behavior that must be retained in a
revised version of the abstraction. Yet encapsulated data of the two versions can be ingeneral quite different. To support modular reasoning about the two versions, it appears
essential to restrict outward transfer of objects encapsulated for Abs to occur only incode of

Abs, where the reasoner can show that the coupling is preserved.

3 An illustrative language
Following [6, 21], we formalize the inv/own discipline in terms of a language in whichfields have public visibility, to illuminate the conditions necessary for sound reasoning about invariants and simulations. In practice, private and protected visibility andperhaps lightweight alias control would serve to automatically check most of the conditions. This section formalizes the language, adapting notations and typing rules fromFeatherweight Java [19] and imperative features and the special commands from our
previous papers [2, 28].

A complete program is given as a class table, CT , that maps class name C to adeclaration

CT (C) of the form class C extends D { _T _f ; _M }. The categories T, M aregiven by the grammar in Table 2. Barred identifiers like _

T indicate finite lists, e.g., _T _fstands for a list _f of field names with corresponding types _T .

Well formed class tables are characterized using typing rules which are expressedusing some auxiliary functions that in turn depend on the class table, allowing classes

13
C 2 ClassName m 2 MethName f 2 FieldName x,self,result 2 VarName

T ::= bool | void | C data type
M ::= T m( _T _x) {S} method declaration
S ::= x:= e | e. f := e assign to local var. or param., update field|

x:= new C | x:= e.m( _e) object creation, method call|
T x:= e in S | S; S | if e then S else S fi local variable, sequence, conditional| pack

e as C | unpack e from C set inv to C, set inv to superC| setown

e to (e0,C) set e.own to (e0,C)| assert \Theta 

assert (semantic predicate \Theta  )
e ::= x | null | true | false variable, constant|

e. f | e = e | e is C | (C) e field access, ptr. equality, type test, castTable 2. Grammar.

to make mutually recursive references to other classes, without restriction. In particular,this allows recursive methods (so we omit loops). For a class C, fields(C) is defined as
the inherited and declared fields of C; dfields(C) is the fields declared in C; super(C)is the direct superclass of

C. For a method declaration, T m( _T1 _x) {S} in C, the methodtype mtype(m
,C) is _T1 ! T and parameter names, pars(m,C), is _x. For m inheritedin
C, mtype(m,C) = mtype(m,D) and pars(m,C) = pars(m,D) where D is the directsuperclass of

C.For use in the semantics, xfields(C) extends fields(C) by assigning "types" to the

auxiliary fields: com : bool, own : owntyp, and inv : (invtypC). (These are not includedin FieldName.) Neither

invtypC nor owntyp are types in the programming language butthere are corresponding semantic domains and the slight notational abuse is convenient.

A typing context \Gamma  is a finite function from variable names to types, such that self 2dom \Gamma  . Selected typing rules for expressions and commands are given in Table 3. A
judgement of the form \Gamma  ` e : T says that expression e has type T in the context of amethod of class \Gamma 

self, with parameters and local variables declared by \Gamma  . A judgement\Gamma  ` S says that S is a command in the same context. A class table CT is well formed

if each method declaration M 2 CT (C) is well formed in C; this is written C ` M anddefined by the following rule:

_x : _T , self : C,result : T ` S
if mtype(m,superC) is defined then mtype(m,superC) = _T !T and pars(m,superC) = _x

C ` T m( _T _x){S}

To formalize assertions, we prefer to avoid both the commitment to a particularformula language and the complication of an environment for declaring predicate names

to be interpreted in the semantics. So we indulge in a mild and commonplace abuse ofnotation: the syntax of assert uses a semantic predicate. We say \Gamma  ` assert \Lambda  is well
formed provided that \Lambda  is a set of program states for context \Gamma  . This treatment ofassertions is also convenient for taking advantage of a theorem prover's native logic.

Semantics. Some semantic domains correspond directly to the syntax. For example,each data type

T denotes a set [[T ]] of values. The meaning of context \Gamma  is a set [[\Gamma  ]] ofstores; a store s 2 [[\Gamma  ]] is a type-respecting assignment of locations and primitive values

14

\Gamma  ` e : C ( f : T ) 2 fields(C)

\Gamma  ` e. f : T

\Gamma  ` e1 : D1 \Gamma  ` e2 : D2 D2 <= C

\Gamma  ` setown e1 to (e2,C)

\Gamma  ` e : D D <= C

\Gamma  ` pack e as C

\Gamma  ` e : D D <= C
\Gamma  ` unpack e from C

\Gamma  ` e : D mtype(m,D) = _T !U x 6= self \Gamma  ` _e : _U _U <= _T U <= \Gamma  x

\Gamma  ` x:= e.m( _e)

Table 3. Typing rules for selected expressions and commands.

to the local variables and parameters given by a typing context \Gamma  . The semantics, andlater the coupling relation, is structured in terms of category names q given in Table 4
which also defines the semantic domains.

A program state for context \Gamma  is a pair (h,s) where s is in [[\Gamma  ]] and h is a heap, i.e., afinite partial function from locations to object states. An

object state is a type-respectingmapping of field names to values. A command typable in \Gamma  denotes a function mapping

each program state (h,s) either to a final state (h0,s0) or to the distinguished value ?which represents runtime errors, divergence, and assertion failure. An

object state isa mapping from (extended) field names to values. A
pre-heap is like a heap except forpossibly having dangling references. If h
,h0 are pre-heaps with disjoint domains then wewrite
h * h0 for their union; otherwise h * h0 is undefined. Function application associatesto the left, so h o f is the value of field f of the object h o at location o. We also write

h o. f . Application binds more tightly than binary operator symbols and ",".

We assume that a countable set Loc is given, along with a distinguished value nilnot in

Loc. We assume given a function type from Loc to non-primitive types distinctfrom
Object, such that for each C there are infinitely many locations o with type o = C.This is used in a way that is equivalent to tagging object states with their type.

The meaning of a derivable command typing \Gamma  ` S will be defined to be a functionsending each method environment u to an element of [[\Gamma  `

cmd]]. (The keyword "cmd"just provides notation for command meanings.) That is, [[\Gamma  `

S]]u is a state transformer[[
heap \Omega  \Gamma  ]] ! [[(heap \Omega  \Gamma  )?]]. The method environment is used only to interpret themethod call command. Meanings for expressions and commands are defined, in Table 5,

by recursion on typing derivation. The semantics is defined for an arbitrary location-valued function fresh such that type(fresh(C

,h)) = C and fresh(C,h) 62 dom h.

The meaning of a well typed method declaration M, of the form M = T m( _T _x){S},is the total function in [[

menv]] ! [[(C, _x, _T !T )]] defined as follows: Given a methodenvironment u, a heap

h and a store s 2 [[ _x : _T , result : C]], first execute S to obtainthe updated heap h

0 and the updated store s0; then return (h0,s0(result)). A methodenvironment u maps each C

, m to a meaning obtained in this way or by inheritance. Forwell formed class table

CT , the semantics [[CT ]] is defined as the least upper bound ofan ascending chain of method environments--the approximation chain--with method

15
q ::= T | \Gamma  | q?|

owntyp | invtypC | stateC own and inv val., object state|
pre-heap | heap | heap \Omega \Gamma  | heap \Omega  T heap fragment, closed heap, state, result|
(\Gamma  ` cmd) | (\Gamma  ` T ) | (C, _x, _T !T1) | menv command, expr., method, method envir.

[[C]] = {nil} [ {o 2 Loc | type o <= C} [[bool]] = {true,false} [[void]] = {it}
[[invtypC]] = {B | C <= B}
[[owntyp]] = {(o,C) | o = nil . type o <= C}
[[stateC]] = {s | doms = dom(xfieldsC) ^ 8( f : T ) 2 xfieldsC | s f 2 [[T]]}
[[pre-heap]] = {h | dom h `fin Loc ^ 8o 2 dom h | h o 2 [[state(type o)]]}
[[heap]] = {h | h 2 [[pre-heap]] ^ 8s 2 rng h | rng s " Loc ` dom h}
[[\Gamma  ]] = {s | doms = dom\Gamma  ^ sself 6= nil ^ 8x 2 dom s | sx 2 [[\Gamma  x]] }
[[heap\Omega \Gamma  ]] = {(h,s) | h 2 [[heap]] ^ s 2 [[\Gamma  ]] ^ rng s " Loc ` dom h}
[[heap\Omega  T ]] = {(h,v) | h 2 [[heap]] ^ v 2 [[T]] ^ (v 2 Loc ) v 2 dom h)}
[[\Gamma  ` cmd]] = [[heap \Omega \Gamma  ]] ! [[(heap \Omega \Gamma  )?]]
[[\Gamma  ` T ]] = {v | v 2 ([[heap \Omega \Gamma  ]] ! [[T]]?) ^ 8h,s | v(h,s) 2 Loc ) v(h,s) 2 dom h}
[[(C, _x, _T !T1)]] = [[heap \Omega  ( _x : _T ,self : C)]] ! [[(heap \Omega  T1)?]]
[[menv]] = {u | 8C,m | uCm is defined iff mtype(m,C) is defined,

and uCm 2 [[C,pars(m,C),mtype(m,C)]] if uCm defined }Table 4.
Semantic categories q and domains [[q]]. (Readers familiar with notation for dependent
function spaces might prefer to write [[pre-heap]] = (o : Loc 9 [[state(type o)]]) and similarly for[[

state C]] and [[\Gamma  ]].)

declarations interpreted as above and a suitable interpretation for inherited methods.Details omitted.

A predicate for state type \Gamma  is just a subset \Lambda  ` [[heap \Omega  \Gamma  ]]. For emphasis we canwrite (

h, s) |= \Lambda  for (h, s) 2 \Lambda  . Note that ? /2 \Lambda  . We give no formal syntax to denotepredicates but rather use informal metalanguage for which the correspondence should

be clear. For example, "self. f 6= null" denotes the set of (h,s) with h(s self). f 6= nil. and"8

o | \Lambda  (o)" denotes the set of (h,s) such that (h,s) |= \Lambda  (o) for all o 2 dom h. Notethat quantification over objects (e.g., in Table 1 and Def. 3) is interpreted to mean quantification over allocated locations; the range of quantification can include unreachableobjects but this causes no problems.

By contrast with [6, 21], we have taken care to separate the annotations requiredby the

inv/own discipline from the semantics of commands. The invariants encoded inthe semantic domains (e.g., the value in a field has its declared type and there are no

dangling pointers) depend in no way on assertions, only on typing. A similar semanticmodel has been machine checked in PVS [27].

4 The inv/own discipline
The discipline reviewed in Sect. 2.1 is designed to make (1) a program invariant for ev-ery object. This is achieved using additional program invariants that govern ownership.
We formalize this as a global predicate, disciplined, defined in three steps.

16

[[\Gamma  ` e. f : T ]](h,s) = let o = [[\Gamma  ` e : C]](h,s) in if o = nil then ? else ho. f
[[\Gamma  ` x:= e.m( _e)]]u(h,s) = let o = [[\Gamma  ` e : T ]](h,s) in if o = nil then ? else

let _v = [[\Gamma  ` _e : _U]](h,s) in let _x = pars(m,T ) in
let s1 = [ _x 7! _v,self 7! o] in
let (h1,v1) = u(typeo)m(h,s1) in (h1,[s | x 7!v1])
[[\Gamma  ` assert \Theta  ]]u(h,s) = if (h,s) 2 \Theta  then (h,s) else ?
[[\Gamma  ` pack e as C]]u(h,s) =

let q = [[\Gamma  ` e : D]](h,s) in if q = nil then ? else
let h1 = l p 2 dom h | if h p.own = (q,C) then [h p | com7!true] else h p in ([h1 | q.inv7!C], s)
[[\Gamma  ` unpack e from C]]u(h,s) =

let q = [[\Gamma  ` e : N]](h,s) in if q = nil then ? else
let h1 = l p 2 dom h | if h p.own = (q,C) then [h p | com7!false] else h p in
([h1 | q.inv7!superC], s)
[[\Gamma  ` setown e1 to (e2,C)]]u(h,s) =

let q = [[\Gamma  ` e1 : N1]](h,s) in if q = nil then ? else
let p = [[\Gamma  ` e2 : N2]](h,s) in ([h | q.own 7!(p,C)], s)

Table 5. Semantics of selected expressions and commands. To streamline the treatment of ?,
the metalanguage expression "let a = b in ..." denotes ? if b is ?. We use function extension
notation [h | o7!st] for h extended or overridden at o with value st. For brevity the nested function
extension for field update is written [h | o. f 7!v].

Definition 1 (transitive C- and C"-ownership). For any heap h, the relation o O/hC pon

dom h, read "o owns p at C in h", holds iff either (o,C) = h p.own or there are q and
D such that (o,C) = h q.own and q O/hD p. The relation o O/hC" p holds iff there is some

D with C <= D and o O/hD p.

Definition 2 (admissible invariant). A predicate \Lambda  ` [[heap \Omega  (self : C)]] is admissible as an invariant for C provided that it is not falsifiable by creation of new objects andfor every (h

,s) and o, f such that \Lambda  depends on o. f in (h, s), field f is neither inv nor
com, and one of the following conditions holds: o = s(self) and f is in dom(xfieldsC)or s(

self) O/hC" o.

For dependence on fields of self, the typing condition, f 2 dom(xfieldsC), prevents aninvariant for

C from depending on fields declared in a subclass of C (which could beexpressed in a formula using a cast). An invariant can depend on any fields of objects

owned at C or above. We refrain from introducing syntax for declaring invariants. In thesubsequent definitions, an admissible invariant \Gamma  C is assumed given for every class C.
We assume \Gamma  Ob ject = true.
Definition 3 (disciplined, \Xi  ). A heap h is disciplined if h |= \Xi  where \Xi  is definedto be the conjunction of the following: 8

o,C | o.inv <= C ) \Gamma  C(o)8o

,C, p | o.inv <= C ^ p.own = (o,C) ) p.com8
o | o.com ) o.inv = type(o)A state (
h,s) is disciplined if h is. Method environment u is disciplined provided that

17
every method maintains \Xi  (i.e., for any C,m, h,s, if h 2 \Xi  and u C m (h,s) = (h0,v)--and thus u

C m (h,s) 6= ?-- then h0 2 \Xi  ).

Lemma 1 (transitive ownership). Suppose h is disciplined and o O/hC p. Then (a) typeo <=
C and (b) h o.inv <= C implies h p.com = true.

Corollary 1. If h is disciplined, o O/hC p, and h p.inv > type p then h o.inv > C.

Partitioning the heap. We partition the objects in the heap in order to formalize the en-capsulation boundary depicted in Sect. 2.2. Given an object o 2 domh and class name
A with typeo <= A we can partition h into pre-heaps Ah (the A-object), Rh (the represen-tation of

o for class A), Sh (objects owned by o at a superclass), and Fh (free from o)determined by the following conditions: Ah is the singleton [o 7! h o], Rh is h restricted

to the set of p with o O/hA p, Sh is h restricted to the set of p with o O/hC p for some
C > A, and Fh is the rest of h. Note that if o O/hB p for some proper subclass B < A thenp 2 domFh. A pre-heap of the form Ah * Rh * Sh is called an island. In these terms,

dependency of admissible invariants is described in the following Proposition. As anillustration, here is the island for the left side of the situation depicted in Sect. 2.2:

Ah
AQueue
subclasses...

Queue

X

Sh
Rh
Fh

Proposition 1 (island). Suppose \Gamma  C is an admissible invariant for C and o 2 domhwith typeo <= C. If h = Fh * Ah * Rh * Sh is the partition defined above then Fh

0 * Ah *Rh * Sh |= \Gamma  C(o) iff h |= \Gamma  C(o), for all Fh
0 such that Fh0 * Ah * Rh * Sh is a heap.

The discipline. To impose the stipulated preconditions of Table 1 we consider programswith the requisite syntactic structure (similar to formal proof outlines).

Definition 4 (properly annotated). The annotated commands are the subset of thecategory of commands where each pack, unpack, setown, and field update is immediately preceded by an assert. A properly annotated command is an annotated commandsuch that each of these assertions is (or implies) the precondition stipulated in Table 1. A
properly annotated class table is one such that each method body is properly annotated.

For any class table and family of invariants there exists a proper annotation: just addassert commands with the stipulated preconditions. For practical interest, of course,

one wants assertions that can collectively be proved correct. The abstraction theoremdepends on proper annotation but does not depend on the invariants themselves; one
may take \Gamma  C = true for all C. What matters is ownership structure and the use of inv.We use the following [6, 21, 28].

Proposition 2. If method environment u is disciplined then any properly annotatedcommand S maintains \Xi  in the sense that for all (h

,s), if h |= \Xi  and (h0,s0) =[[\Gamma  `
S]]u(h, s) then h0 |= \Xi  . If CT is a properly annotated class table then the methodenvironment [[

CT ]] is disciplined.

18
5 The abstraction theorem
5.1 Comparing class tables
We compare two implementations of a designated class Abs, in the context of a fixedbut arbitrary collection of other classes, such that both implementations give rise to a

well formed class table. The two versions can have completely different declarations, solong as methods of the same signatures are present -- declared or inherited -- in both.
To simplify the additional precondition needed for reading fields, we consider programsdesugared into a form like that used in Separation Logic.

Definition 5 (properly annotated for Abs). The annotated commands for Abs arethose of Def. 4 with the additional restriction that no expression of the form e

. f occursexcept in commands of the form assert \Lambda  ;
x:= e. f (in particular, no field access ap-pears in this e). The properly annotated commands for Abs are those that are properly

annotated according to Def. 4 and moreover

- fields of Abs have private visibility (i.e., if f 2 dfieldsAbs then accesses and updatesof

f only occur in code of class Abs)- If \Gamma 

self 6= Abs then field access \Gamma  ` x:= e. f is subject to stipulated precondition(8o | o O/

Abs e ) o O/Abs self)- if \Gamma  self 6= Abs then \Gamma  ` pack e as Abs is not allowed

- if \Gamma  self 6= Abs then \Gamma  ` setown e1 to (e2,C) is subject to an additional precondition:(9

o | o O/Abs e1) ) C = Abs . (9o | o O/Abs e2)

The effect of the last precondition is that if e1 is initially owned at Abs then after atransfer (that occurs in code outside class Abs) it is still owned at Abs.

In order to work with heap partitions, along the lines of Prop. 1, it is convenientto have notation to extract the one object in a singleton heap. We define pickdom by
pickdom(h) = o where domh = {o}; it is undefined if domh is not a singleton.Prop. 1 considers a single object together with its owned representation; now we
consider all objects of a given class.
Definition 6 (A-decomposition). For any class A and heap h, the A-decomposition ofh is the set Fh

,Ah1,Rh1,Sh1 .. . , Ahk,Rhk,Shk (for some k >= 0) of pre-heaps, all subsetsof
h, determined by the following conditions:

- each domAhi contains exactly one object o and typeo <= A- every o 2 domh with typeo <= A occurs in dom Ah

i for some i;- dom Rh
i = {p | o O/hA p} where pickdom Ahi = o;- dom Sh
i = {p | o O/h(superA)" p} with pickdom Ahi = o;-
dom Fh = dom h - ([i | dom(Ahi * Rhi * Shi))

We say that no A-object owns an A-object in h provided for every o, p in domh iftype o <= A and o O/h

(typeo)" p then type p \Theta  A. Def. 8 in the sequel imposes a syntacticrestriction to maintain this property as an invariant, where A is the class for which two

representations are compared. A consequence is that there is a unique decomposition ofthe heap into separate islands of the form

Ah * Rh * Sh. We use the term "partition" eventhough some blocks can be empty.

19
Lemma 2 (A-partition). Suppose no A-object owns an A-object in h. Then the A-decomposition is a partition of

h, that is, h = Fh * Ah1 * Rh1 * Sh1 * . .. * Ahk * Rhk * Shk.

To maintain the invariant that no Abs-object owns an Abs-object, we formulate amild syntactic restriction expressed using a static approximation of ownership.

Definition 7 (may own, O/9). Given well formed CT , define O/9 to be the least transi-tively closed relation such that

- D2 O/9 D1 for every occurrence of setown e1 to (e2,D) in a method of CT , withstatic types e

1 : D1 and e2 : D2- if C O/9 D, C0 <= C and D0 <= D then C0 O/9 D0

If Abs 6O/9 Abs then it is a program invariant that no Abs-object owns an Abs-object(recall the definition preceding Lemma 2). This is a direct consequence of the following.
Lemma 3. It is a program invariant that if o O/hC p then typeo O/9 type p.
Definition 8 (comparable class tables). Well formed class tables CT and CT 0 are com-parable with respect to class name Abs (6=

Object) provided the following hold.

- CT (C) = CT 0(C) for all C 6= Abs.- CT (Abs) and CT 0(Abs) declare the same methods with the same signatures and the

same direct superclass.- For every method m declared in CT (Abs), m is declared in CT 0(Abs) and has the
same signature; mutatis mutandis for m declared in CT 0.- CT and CT 0 are properly annotated for Abs.
- Abs 6O/9 Abs in both CT and CT 0
The last condition ensures that the Abs-decomposition of any disciplined heap is a par-tition, by Lemmas 2 and 3. We write `

,`0 for the typing relation determined by CT,CT 0respectively; similarly we write [[-]]
, [[-]]0 for the respective semantics.

5.2 Coupling relations
The definitions are organized as follows. A local coupling is a suitable relation on is-lands. This induces a family of

coupling relations, \Pi  b q for each category name q andtyped bijection b . Each relation \Pi  b q is from [[q ]] to [[q ]]0. Here b is a bijection on

locations, used to connect a heap in [[heap]] to one in [[heap]]0. The idea is that b relatesall objects except those in the

Rhi or Rh0i blocks that have never been exposed. Finally,a simulation is a coupling that is preserved by all methods of Abs and holds initially.

Definition 9. A typed bijection is a bijective relation, b , from Loc to Loc, such thatb

o o0 implies typeo = type o0 for all o, o0. A total bijection on h,h0 is a typed bijectionwith

domh = domb and domh0 = rngb . Finally, b fully partitions h, h0 for Abs if, forall o 2 domh (resp. o 2 dom h0) with type o <= Abs, o is in dom b (resp. rng b ).

Lemma 4 (typed bijection and Abs-partition). Suppose b is a typed bijection withb `

domh * domh0 and b fully partitions h, h0 for Abs. If h, h0 are disciplined and par-tition as h = Fh *

. ..Ah j * Rhj * Shj and h0 = Fh0 * . .. Ah0k * Rh0k * Sh0k then j = k.

20

o ,b o0 in [[C]] , b oo0 . o = nil = o0
v ,b v0 in [[T]] , v = v0 for primitive types T
s ,b s0 in [[stateC]] , 8( f : T ) 2 xfieldsC | s f ,b s0 f . ( f : T ) 2 dfields Abs
s ,b s0 in [[\Gamma  ]] , 8x 2 dom\Gamma  | sx ,b s0 x
h ,b h0 in [[pre-heap]] , 8o 2 dom h,o0 2 domh0 | b oo0 ) ho ,b h0o0
(h,s),b (h0,s0) in [[heap\Omega \Gamma  ]] , h ,b h0 ^ s ,b s0
v ,b v0 in [[q?]] , v = ? = v0 . (v 6= ? 6= v0 ^ v ,b v0 in [[q ]])
(o,C) ,b (o0,C0) in [[owntyp]] , (o = nil = o0) . (b oo0 ^C = C0)
B ,b B0 in [[invtypC]] , B = B0

Table 6. Value equivalence for the designated class Abs. The relation for heap is the same as for
pre-heap. For object states, , is independent from the declared fields of CT(Abs) and CT 0(Abs).

Definition 10 (equivalence for Abs modulo bijection). For any b we define a relation,

b for data values, object states, heaps, and stores, in Table 6.

Equivalence hides the private fields of Abs. In the identity extension lemma, it isused in conjunction with the following which hides objects owned at

Abs.

Definition 11 (encap). Suppose no A-object owns an A-object in h. Define encapA hto be the pre-heap Fh * Ah

1 * Sh1 * .. . * Ahk * Shk where the A-partition of h is as inLemma 2.

The most important definition is of local coupling, which is analogous to an objectinvariant but is a relation on pairs of pre-heaps. In Def. 2, we take an invariant \Gamma  C to be
a predicate (set of states) and the program invariant \Xi  is based on the conjunction ofthese predicates for all objects and types --subject to inv, see Def. 3). By contrast, we
define a local coupling \Sigma  in terms of pre-heaps. And we are concerned with a singleclass,

Abs, rather than all C. We impose the same dependency condition as in Def. 2,but in terms of pre-heaps of the form h = Ah * Rh * Sh. (Recall Proposition 1.)

Definition 12 (local coupling, \Sigma  ). Given comparable class tables, a local coupling isa function, \Sigma  , that assigns to each typed bijection b a binary relation \Sigma  b on pre-heaps
that satisfies the following. First, \Sigma  b does not depend on inv or com. Second, b ` b0implies \Sigma  b ` \Sigma  b

0. Third, for any b , h,h0, if \Sigma  b h h0 then there are locations o,o0with b o o0 and typeo <= Abs such that the Abs partitions of h

,h0 are h = Ah * Rh * Sh and

h0 = Ah0 * Rh0 * Sh0 with

- pickdom Ah = o and pickdom Ah0 = o0-

o O/hAbs p for all p 2 dom(Rh) and o0 O/h0Abs p0 for all p0 2 dom(Rh0)

- o O/h(superAbs)" p for all p 2 dom(Sh) and o0 O/h0(superAbs)" p0 for all p0 2 dom(Sh0)
- If \Sigma  b depends on f then f is in xfieldsAbs

The first three conditions ensure that \Sigma  relates a single island, for an object ofsome subtype of Abs, to a single island for an object of the same type. Although \Sigma  is

21\Upsilon 
b q a a0 , a ,b a0 if q is bool, C, \Gamma  , or stateC\Upsilon 
b (heap \Omega \Gamma  ) (h,s) (h0,s0) , \Upsilon  b heap h h0 ^\Upsilon  b \Gamma  s s0 ^ disciplined(h,s) ^ disciplined(h0,s0)\Upsilon 
b (heap \Omega  T ) (h,v) (h0,v0) , \Upsilon  b heap h h0 ^\Upsilon  b T v v0\Upsilon 
b (q?) a a0 , (a = ? = a0) . (a 6= ? 6= a0 ^\Upsilon  b q a a0)\Upsilon 
b (\Gamma  ` T ) v v0 , 8h,s,h0,s0 | \Upsilon  b (heap \Omega \Gamma  ) (h,s) (h0,s0))\Upsilon 

b T? (v(h,s)) (v0(h0,s0))\Upsilon 
b (C, _x, _T !T1) v v0 , 8h,s,h0,s0 | \Upsilon  b (heap \Omega \Gamma  ) (h,s) (h0,s0)) 9

b0 ' b | \Upsilon  b0 (heap \Omega  T1)? (v(h,s)) (v0(h0,s0))
where \Gamma  = [ _x : _T ,self : C]\Upsilon 
menv u u0 , 8C,m,b | \Upsilon  b (C, _x, _T !T ) (uCm) (u0Cm)

where mtype(m,C) = _T !T and pars(m,C) = _xTable 7. The induced coupling relation for Def. 13.

unconstrained for the private fields of CT (Abs) and CT 0(Abs), it may also depend onfields inherited from a superclass of Abs (but not on subclass fields). The induced coupling relation, defined below, imposes the additional constraint that fields of proper sub-and super-classes of

Abs are linked by equivalence modulo b . Although superficiallydifferent, the notion of local coupling is closely related to admissible invariant.

In applications, \Sigma  b h h0 would be defined as something like this: h and h0 partitionas islands

Ah * Rh * Sh and Ah0 * Rh0 * Sh0 such that Ah * Rh * Sh |= \Gamma  Abs and Ah0 * Rh0 *Sh0 |= \Gamma  0Abs and some condition links the data structures [18]. The bijection b would

not be explicit but would be induced as a property of the formula language.A local coupling \Sigma  induces a relation on arbitrary heaps by requiring that they
partition such that islands can be put in correspondence so that pairs are related by \Sigma  .
Definition 13 (coupling relation, \Pi  ). Given local coupling \Sigma  , we define for each qand b a relation \Pi  b q ` [[q ]] * [[q ]]0 as follows.

For heaps h,h0, we define \Pi  b heap h h0 iff h,h0 are disciplined, b ` domh*dom h0,and b fully partitions

h,h0 for Abs; moreover, if the Abs-partitions are h = Fh * Ah1 *Rh

1 * Sh1 .. . Ahk * Rhk * Shk and h0 = Fh0 * Ah01 * Rh01 * Sh01 . ..Ah0k * Rh0k * Sh0k then (recallLemma 4) (a) b restricts to a total bijection between dom(Fh) and dom(Fh0); (b) Fh ,

bFh0; and (c) for all i, j, if b (pickdom Ah
i) (pickdom Ah0j) then

- b restricts to a total bijection between dom(Shi) and dom(Sh0j)-

(Ahi * Shi) ,b (Ah0j * Sh0j)-
h(pickdom Ahi).inv <= Abs ) \Sigma  b (Ahi * Rhi * Shi) (Ah0j * Rh0j * Sh0j)

For other categories q we define \Pi  b q in Table 7.

The third item under (c) is the key connection with the inv/own discipline.Under the antecedent in the definition, (Ah

i * Shi) ,b (Ah0j * Sh0j) is equivalent tothe conjunction of Ah
i ,b Ah0j and Shi ,b Sh0j. And Ahi ,b Ah0j means that the twoobjects o
,o0 agree on superclass and subclass fields (but not the declared fields of Abs);in particular,

type o = type o0 <= Abs and Ahi o.inv = Ah0j o0.inv.The gist of the abstraction theorem is that if methods of

Abs are related by \Pi  then allmethods are. In terms of the preceding definitions, we can express quite succinctly the

22
conclusion that all methods are related: \Pi  menv [[CT ]] [[CT 0]]0 . We want the antecedentof the theorem to be that the meaning [[

M]] is related to [[M0]]0, for any m with declaration
M in CT (Abs) and M0 in CT 0(Abs). Moreover, [[M]] depends on a method environment.Thus the antecedent of the theorem is that [[M]]u is related to [[M0]]0u0 for all related

u, u0. (It suffices for u, u0 to be in the approximation chains defining [[CT ]] and [[CT 0]]0).

5.3 Simulation and the abstraction theorem
Definition 14 (simulation). A simulation is a coupling \Pi  such that the following hold.

- (\Sigma  is initialized) For any C <= Abs, and any o,o0 with b o o0 and type o = C we have\Sigma  b

h h0 where h = [o 7! [dom(xfieldsC) 7! defaultsC]] andh0 = [o0 7! [dom(xfields0 C) 7! defaults0C]].

- (methods of Abs preserve \Pi  ) For any disciplined u, u0 such that \Pi  menv u u0we have the following for every m declared in Abs. Let _U!U = mtype(m

, Abs)and _
x = pars(m,Abs). For every b , we have \Pi  b q ([[M]]u) ([[M0]]0u0) where q =(
Abs, _x, _U!U). where M (resp. M0) are as above. (We omit the similar conditionfor inherited methods.)

Lemma 5 (preservation by expressions). For all expressions \Gamma  ` e : T that contain nofield access subexpressions, and all b , we have \Pi  b (\Gamma  `

T ) ([[\Gamma  ` e : T ]]) ([[\Gamma  ` e : T ]]0).

Lemma 6 (preservation by commands). Let u, u0 be disciplined method environ-ments with \Pi 

menv u u0 . If \Gamma  ` S is a properly annotated command for Abs, with\Gamma 
self 6= Abs, then for all b we have the following. If \Pi  b (heap \Omega  \Gamma  ) (h, s) (h0, s0)

and ~(9o | o O/hAbs s(self)) and ~(9o0 | o0 O/h0Abs s0(self)) then there is b0 ' b such that\Pi  b

0 (heap \Omega  \Gamma  )? (v(h,s)) (v0(h0,s0)).

Our main result says that if methods of Abs preserve the coupling then all methods do.
Theorem 1 (abstraction).If \Pi  is a simulation for comparable class tables

CT,CT 0 then \Pi  menv [[CT ]] [[CT 0]]0 .

6 Using the theorem
A complete program is a command S in the context of a class table. To show equiva-lence between

CT,S and CT 0,S, one proves simulation for Abs and then appeals to theabstraction theorem to conclude that [[S]] is related to [[S]]0. Finally, one appeals to an

identity extension lemma that says the relation is the identity for programs where theencapsulated representation is not visible. We choose simple formulations that can also
serve to justify more specification-oriented formulations. We say that a state (h, s) is
Abs-free if type o \Theta  Abs for all o 2 dom h.

Lemma 7 (identity extension). If \Pi  b (heap \Omega  \Gamma  ) (h,s) (h0,s0)then

encapAbs (h, s) ,b encapAbs (h0, s0).

Lemma 8 (inverse identity extension). Suppose (h, s) and (h0,s0) are Abs-free. If(h

, s) ,b (h0,s0) and b is total on h, h0 then \Pi  b (heap \Omega  \Gamma  ) (h, s) (h0, s0).

23
Definition 15 (program equivalence). Suppose programs CT,(\Gamma  ` S) and CT 0,(\Gamma  `0
S0) are such that CT,CT 0 are comparable and properly annotated, and moreover S, S0 areproperly annotated. The programs are

equivalent iff for all disciplined, Abs-free (h,s)and (h0
,s0) in [[heap \Omega  \Gamma  ]] and all b with b total on h,h0 and (h,s) ,b (h0,s0), thereis some b

0 ' b with encap Abs([[\Gamma  ` S]]u(h, s)) ,b0 encapAbs ([[\Gamma  `0 S0]]0u0(h0,s0))where u = [[CT ]] and u0 = [[CT 0]]0.

Proposition 3 (simulation and equivalence). Suppose programs CT, (\Gamma  ` S) andCT 0

,(\Gamma  `0 S) are properly annotated and \Pi  is a simulation from CT to CT 0. If \Gamma  self 6=
Abs then the programs are equivalent.

7 Discussion
Adaptations of the inv/own discipline. As compared with previous work on the disci-pline, we have imposed some additional restrictions to achieve sufficient information
hiding to justify a modular rule for equivalence of class implementations. We arguethat the restrictions are not onerous for practical application, though further practical
experience is needed with the discipline and with our rule.

The first restriction is on field reads. Code in a client class cannot be allowed toread a field of an encapsulated representation object, although the discipline allows the

existence of the reference; otherwise the client code could be representation dependent.On the other hand, a class such as Hashtable might be used both by clients and in the
internal representation of the class Abs under revision; certainly the code of Hashtableneeds to read its own fields. A distinction can be made on the basis of whether the
current target object, i.e., self, is owned by an instance o of Abs. If it is, then we donot need the method invocation to preserve the coupling and we can allow reading of
objects owned by o. If the target object is not owned by an instance of Abs then it shouldhave no need to access objects owned by Abs. This distinction appears in the statement
of Lemma 6 and it is used to stipulate a precondition for field access (see Def. 5).4Because the coupling relation imposes the user-defined local coupling only when
an Abs-object is packed, it appears necessary to restrict pack e as Abs to occur only incode of Abs in order for simulation to be checked only for that code. In the majority of
known examples, packing to a class C is only done in code of C, and this is required inLeino and M"uller's extension of the discipline to handle static fields.

Similar considerations apply to setown o to (p,C): care must be taken to preventarbitrary code from moving objects across the encapsulation boundary for

Abs in waysthat do not admit modular reasoning. One would expect that code outside Abs cannot

move objects across the Abs-boundary at all, but it turns out that the only problematiccase is transfer out from an

Abs island. In the unusual case that setown o to (p,C) oc-curs in code outside Abs but o is initially inside the island for some Abs-object, then

o must end up in the island for some Abs-object. Our stipulated precondition says just

4 This is unattractive in that the other stipulated preconditions mention only direct ownership

whereas this one uses transitive ownership. But in practical examples, code outside Abs rarely
has references to encapsulated objects. We believe such references can be adequately restricted
using visibility control and/or lightweight confinement analyses, e.g., [31, 2].

24
this. In practice it seems that the obligation can be discharged by simple syntactic con-siderations of visibility and/or lightweight alias control.

The last restriction is that an Abs object cannot own other Abs objects. This does notpreclude containers holding containers, because a container does not own its content
(e.g., AQueue owns the Qnodes but not the tasks). It does preclude certain recursivesituations. For example, we could allow

Qnode instances to own their successors butthen we could not instantiate the theory with

Abs:=Qnode. This does not seem tooimportant since it is
Queue that is appropriate to view as an abstraction coupled bya simulation. The restriction is not needed for soundness of simulation. But absent the

restriction, nested islands would require a healthiness condition on couplings (similar tothe healthiness condition used by Cavalcanti and Naumann [13, Def. 5]); e.g., coupling
for an instance of Qnode would need to recursively impose the same predicate on the
nxt node. We disallow nested islands in the present work for simplicity and to highlightconnections with separation logic.

Future work. The discipline may seem somewhat onerous in that it uses verificationconditions rather than lighter weight static analysis for control of the use of aliases. (We
have to say "use of", because whereas confinement disallows certain aliases, the invari-ant discipline merely prevents faulty exploitation of aliases.) The Spec# project [7] is
exploring the inference of annotations. For many situations, simple confinement rulesand other checks are sufficient to discharge the proof obligations and this needs to be
investigated for the additional obligations we have introduced. The advantage of a ver-ification discipline over types is that, while simple cases can be checked automatically,
complicated cases can be checked with additional annotations rather than simply re-jected.

The generalization to a small group of related classes is important, as revisions ofteninvolve several related classes. One sort of example would be a revision of our

Queueexample that involves revising
Qnode as well. If nodes are used only by Queue then thisis subsumed by our theory, as we can consider a renamed version of

Qnode that coexistswith it. The more interesting situations arise in refactoring and in design patterns with

tightly related configurations of multiple objects. The friend and peer dependenciesof [21, 9, 28], and the flexible ownership system of Aldrich and Chambers [1] could be
the basis for a generalization of our results.

References

1. J. Aldrich and C. Chambers. Ownership domains: Separating aliasing policy from mechanism. In ECOOP, 2004.2. A. Banerjee and D. A. Naumann. Ownership confinement ensures representation independence for object-oriented programs. Journal of the ACM, 2002. Accepted, revision pending.
Extended version of [3].3. A. Banerjee and D. A. Naumann. Representation independence, confinement and access

control. In POPL, 2002.4. A. Banerjee and D. A. Naumann. Ownership transfer and abstraction. Technical Report TR
2004-1, Computing and Information Sciences, Kansas State University, 2003.5. A. Banerjee and D. A. Naumann. State based encapsulation and generics. Technical Report
CS Report 2004-11, Stevens Institute of Technology, 2004.

25
6. M. Barnett, R. DeLine, M. F"ahndrich, K. R. M. Leino, and W. Schulte. Verification of

object-oriented programs with invariants. Journal of Object Technology, 3, 2004.
7. M. Barnett, K. R. M. Leino, and W. Schulte. The Spec# programming system: An overview.

In CASSIS post-proceedings, 2004.
8. M. Barnett, D. A. Naumann, W. Schulte, and Qi Sun. 99.44% pure: useful abstractions in

specifications. In ECOOP workshop on Formal Techniques for Java-like Programs, 2004.
9. M. Barnett and D. A. Naumann. Friends need a bit more: Maintaining invariants over shared

state. In Mathematics of Program Construction, 2004.
10. P. H. M. Borba, A. C. A. Sampaio, and M. L. Corn'elio. A refinement algebra for objectoriented programming. In ECOOP, 2003.
11. C. Boyapati, B. Liskov, and L. Shrira. Ownership types for object encapsulation. In POPL,

2003.
12. J. Boyland, J. Noble, and W. Retert. Capabilities for sharing: A generalisation of uniqueness

and read-only. In ECOOP, 2001.
13. A. L. C. Cavalcanti and D. A. Naumann. Forward simulation for data refinement of classes.

In Formal Methods Europe, 2002.
14. D. Clarke and S. Drossopoulou. Ownership, encapsulation and the disjointness of type and

effect. In OOPSLA, 2002.
15. D. G. Clarke, J. Potter, and J. Noble. Ownership types for flexible alias protection. In

OOPSLA, 1998.
16. D. L. Detlefs, K. R. M. Leino, and G. Nelson. Wrestling with rep exposure. Research 156,

DEC Systems Research Center, 1998.
17. J. V. Guttag and J. J. Horning, editors. Larch: Languages and Tools for Formal Specification.

Texts and Monographs in Computer Science. Springer-Verlag, 1993.
18. C. A. R. Hoare. Proofs of correctness of data representations. Acta Inf., 1, 1972.
19. A. Igarashi, B. Pierce, and P. Wadler. Featherweight Java: A minimal core calculus for Java

and GJ. ACM Trans. Prog. Lang. Syst., 23, 2001.
20. B. Jacobs and E. Poll. Java program verification at Nijmegen: Developments and perspective.

In International Symposium on Software Security, 2003.
21. K. R. M. Leino and P. M"uller. Object invariants in dynamic contexts. In ECOOP, 2004.
22. B. Meyer. Object-oriented Software Construction. Second edition, 1997.
23. I. Mijajlovic, N. Torp-Smith, and P. O'Hearn. Refinement and separation contexts. In Foundations of Software Technology and Theoretical Computer Science (FST&TCS), 2004.
24. J. C. Mitchell. Representation independence and data abstraction. In POPL, 1986.
25. P. M"uller, A. Poetzsch-Heffter, and G. Leavens. Modular invariants for object structures.

Technical Report 424, ETH Z"urich, Oct. 2003.
26. D. A. Naumann. Observational purity and encapsulation. In FASE, 2005.
27. D. A. Naumann. Verifying a secure information flow analyzer. To appear in TPHOLS, 2005.
28. D. A. Naumann and M. Barnett. Towards imperative modules: Reasoning about invariants

and sharing of mutable state (extended abstract). In LICS, 2004.
29. P. O'Hearn, H. Yang, and J. Reynolds. Separation and information hiding. In POPL, 2004.
30. F. Smith, D. Walker, and G. Morrisett. Alias types. In ESOP, 2000.
31. J. Vitek and B. Bokowski. Confined types in Java. Software Practice and Experience, 31,

2001.