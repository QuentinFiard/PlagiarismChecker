

Logical Methods in Computer Science
Vol. 2 (5:2) 2006, pp. 1-48
www.lmcs-online.org Submitted Apr. 20, 2006Published Nov. 3, 2006

LINEAR ABADI & PLOTKIN LOGIC
LARS BIRKEDAL a, RASMUS EJLERS MO/GELBERG b, AND RASMUS LERCHEDAHL PETERSEN c

a;c IT University of Copenhagen

e-mail address: {birkedal,rusmus}@itu.dk
b LFCS, School of Informatics, University of Edinburgh

e-mail address: rasmus.mogelberg@ed.ac.uk

Abstract. We present a formalization of a version of Abadi and Plotkin's logic for parametricity for a polymorphic dual intuitionistic/linear type theory with fixed points, and
show, following Plotkin's suggestions, that it can be used to define a wide collection of
types, including existential types, inductive types, coinductive types and general recursive
types. We show that the recursive types satisfy a universal property called dinaturality,
and we develop reasoning principles for the constructed types. In the case of recursive
types, the reasoning principle is a mixed induction/coinduction principle, with the curious
property that coinduction holds for general relations, but induction only for a limited collection of "admissible" relations. A similar property was observed in Pitts' 1995 analysis
of recursive types in domain theory. In a future paper we will develop a category theoretic
notion of models of the logic presented here, and show how the results developed in the
logic can be transferred to the models.

Introduction
In 1983 Reynolds argued that parametric models of the second-order lambda calculus
are very useful for modeling data abstraction in programming [Rey83] (see also [Pie02] for
a recent textbook description). For real programming, one is of course not just interested
in a strongly terminating calculus such as the second-order lambda calculus, but also in a
language with full recursion. Thus in loc. cit. Reynolds also asked for a parametric domaintheoretic model of polymorphism. Informally, what is meant [Rey00] by this is a model
of an extension of the polymorphic lambda calculus [Rey74, Gir72], with a polymorphic
fixed-point operator Y : 8ff: (ff ! ff) ! ff such that

(1) types are modeled as domains, the sublanguage without polymorphism is modeled

in the standard way and Y oe is the least fixed-point operator for the domain oe;

2000 ACM Subject Classification: F.4.1, D.3.3.
Key words and phrases: parametric polymorphism, domain theory, recursive types.
b The majority of this work was conducted while this author was associated with the IT University of

Copenhagen and with the University of Genova. Research partly supported by Danish Natural Science
Research Council stipend no. 272-05-0031.

LOGICAL METHODSl IN COMPUTER SCIENCE DOI:10.2168/LMCS-2 (5:2) 2006 cfl L. Birkedal, R.E. Mo/gelberg, and R.L. Petersen

CCfl Creative Commons

2 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN

(2) the logical relations theorem (also known as the abstraction theorem) is satisfied

when the logical relations are admissible, i.e., strict and closed under limits of chains;
(3) every value in the domain representing some polymorphic type is parametric in the

sense that it satisfies the logical relations theorem (even if it is not the interpretation
of any expression of that type).

Of course, this informal description leaves room for different formalizations of the problem. Even so, it has proved to be a non-trivial problem. Unpublished work of Plotkin [Plo93]
indicates one way to solve the problem model-theoretically by using strict, admissible partial equivalence relations over a domain model of the untyped lambda calculus but, as far
as we know, the details of this relationally parametric model have not been worked out in
the literature.

From a type theoretical perspective parametric polymorphism is interesting because it
allows for encodings of a large collection of types from a small number of constructions.
For example adding parametric polymorphism as a reasoning principle to the second-order
lambda calculus gives encodings of products, coproducts, existential types and general inductive and coinductive types from just ! and polymorphism [PA93, Bg05].

This strength of the typing system also complicates matters when adding recursion.
Simply adding a polymorphic fixed point combinator to parametric second order lambda
calculus would give a type theory with coproducts, products, function spaces and fixed
points, a combination known to exist only in the trivial case of all types being isomorphic
[HP90]. Inspired by domain theory Plotkin suggested to consider a polymorphic dual intuitionistic/linear lambda calculus and restrict the parametricity principle accordingly to
give encodings of coproducts and (co-)inductive types in the linear part of the calculus
but not the intuitionistic part. Moreover, the existence of fixed points would provide solutions to general recursive type equations using Freyd's theory of algebraically compact
categories [Fre90b, Fre90a, Fre91]. This led Plotkin to argue that such a calculus could
serve as a very powerful metalanguage for domain theory.

Thus parametric domain-theoretic models of polymorphic intuitionistic / linear lambda
calculus are of importance both from a programming language perspective (for modeling
data abstraction) and from a purely domain-theoretic perspective.

Recently, Pitts and coworkers [BPR00] have presented a syntactic approach to Reynolds'
challenge, where the notion of domain is essentially taken to be equivalence classes of terms
modulo a particular notion of contextual equivalence derived from an operational semantics
for a language called Lily, which is essentially polymorphic intuitionistic/linear lambda
calculus endowed with an operational semantics.

In parallel with the work presented here, Rosolini and Simpson [RS04] have shown
how to construct parametric domain-theoretic models using synthetic domain-theory in
intuitionistic set-theory. Moreover, they have shown how to give a computationally adequate
denotational semantics of Lily.

This paper presents a formalization of Abadi & Plotkin's logic adapted to the case of
Polymorphic Intuitionistic/Linear Lambda calculus with a polymorphic fixed point combinator denoted Y -- a language which we shall call PILLY . PILLY is a simple extension of
Barber and Plotkin's dual intuitionistic/linear lambda calculus (DILL) with polymorphism
and fixed points. By dual we mean that terms have two contexts of term variables: an
intuitionistic and a linear one.

Linear Abadi-Plotkin Logic (LAPL) presented in this paper is a logic for reasoning
about parametricity for PILLY . As mentioned above, for the logic to be consistent, the

LINEAR ABADI & PLOTKIN LOGIC 3
parametricity principle has to be restricted in some way, so that it can be used to prove
universal properties in the category of linear terms, but not in the category of intuitionistic
terms. To achieve this restriction, LAPL is equipped with a notion of admissible relation,
and the parametricity principle is formulated using these relations only. Admissible relations
form a subset of the set of definable relations between types, and the prime example of an
admissible relation in the logic is the graph of a linear function, whereas the prime example
of a relation that is not admissible in general is the graph of an intuitionistic function.

Using the logic, we show how Plotkin's encodings of a large collection of datatypes
satisfy the usual universal properties with respect to linear maps in the calculus, up to
provability in the logic. In the case of inductive types this means showing that the encodings
give initial algebras for certain functors induced by types, for coinductive types we get final
coalgebras, and for the general recursive types, the encodings give initial dialgebras for the
bifunctors induced by type expressions. These results were sketched by Plotkin in [Plo93],
but since the proofs are non-trivial and have never appeared in the literature we include
them here. We treat recursive types in full generality, meaning that we treat recursive types
with parameters showing that nested recursive types can be modeled.

We also present reasoning principles for the constructed types. Using parametricity we
get an induction principle for inductive types holding only for admissible relations. For the
coinductive types we get a coinduction principle holding for all relations. These results are
extended to recursive types giving a mixed induction/coinduction principle in which the
induction part holds for admissible relations only, but the coinduction part holds for all
relations. Again these principles are treated in full generality, i.e., also for recursive types
with parameters. A similar induction/coinduction principle with the same restrictions was
discovered by Pitts [Pit95] for recursive types in domain theory.

The present paper is the first in a series presenting an axiomatization of domain theoretic models of parametricity. In a forthcoming paper (based on [BMP05]) we present
a sound and complete notion of parametric models of LAPL called parametric LAPLstructures, and show how to transfer the results proved in LAPL to these. In further papers
we will show examples of such parametric LAPL-structures, first treating Plotkin's idea of
using admissible pers over reflexive domains, and in further papers we show how Rosolini
and Simpson's construction [RS04] can be seen as constructing parametric LAPL-structures
and we construct LAPL-structures from Lily syntax in [BMPV06]. Finally in [Mo/g05b] we
show how the parametric completion process of Robinson & Rosolini [RR94] can be adapted
to construct parametric LAPL-structures from internal models of PILLY in quasi toposes.

In each of these models the abstract notion of admissible relations in LAPL is interpreted differently. For example, in the per model the notion of admissible relations are
certain subsets of the set of equivalence classes of pers, and in the Lily model admissible
relations are ??-closed sets of terms. The abstract notion of admissible relations presented
in this paper is general enough to fit all these different cases.

We remark that one can see our notion of parametric LAPL-structure as a suitable
categorical axiomatization of a good category of domains. In Axiomatic Domain Theory
much of the earlier work has focused on axiomatizing the adjunction between the category of
predomains and continuous functions and the category of predomains and partial continuous
functions [Fio96, Page 7] - here we axiomatize the adjunction between the category of
domains and strict functions and the category of domains and all continuous functions and
extend it with parametric polymorphism, which then suffices to also model recursive types.

4 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
Outline. The remainder of this paper consists of two parts. The first part (Section 1)
presents the calculus PILLY and the logic LAPL for reasoning about parametricity. The
second part (Section 2) gives detailed proofs of correctness of encodings of a series of types
including inductive, coinductive and recursive types, and gives the reasoning principles for
these.

1. Linear Abadi-Plotkin Logic
In this section we define a logic for reasoning about parametricity for Polymorphic
Intuitionistic Linear Lambda calculus with fixed points (PILLY ). The logic is based on
Abadi and Plotkin's logic for parametricity [PA93] for the second-order lambda calculus
and thus we refer to the logic as Linear Abadi-Plotkin Logic (LAPL).

The logic for parametricity is basically a higher-order logic over PILLY . Expressions
of the logic are formulas in contexts of variables of PILLY and relations among types of
PILLY . Thus we start by defining PILLY .

1.1. PILLY . PILLY is essentially Barber and Plotkin's DILL [Bar97] extended with polymorphism and a fixed point combinator.

Well-formed type expressions in PILLY are expressions of the form:

ff1 : Type; : : : ; ffn : Type ` oe : Type
where oe is built using the syntax

oe ::= ff | I | oe \Omega  oe | oe ( oe | !oe | Q ff: oe:
and all the free variables of oe appear on the left hand side of the turnstile. The last
construction binds ff, so if we have a type

ff1 : Type; : : : ; ffn : Type ` oe : Type;
then we may form the type

ff1 : Type; : : : ; ffi-1 : Type; ffi+1 : Type : : : ffn : Type ` Q ffi: oe : Type:
We use oe, o/ , !, oe0, o/ 0. . . to range over types. The list of ff's is called the kind context, and
is often denoted simply by \Xi  or ~ff. Since there is only one kind the annotation : Type is
often omitted.

The terms of PILLY are of the form:

\Xi  | x1 : oe1; : : : ; xn : oen; x01 : oe01; : : : ; x0m : oe0m ` t : o/
where the oei, oe0i, and o/ are well-formed types in the kind context \Xi . The list of x's is called
the intuitionistic type context and is often denoted \Gamma , and the list of x0's is called the linear
type context, often denoted \Delta . No repetition of variable names is allowed in any of the
contexts, but permutation akin to having an exchange rule is. Note, that due to the nature
of the axioms of the to-be-introduced formation rules, weakening and contraction can be
derived for all but the linear context.

The grammar for terms is:

t ::=x | ? | Y | *ffix : oe:t | t t | t \Omega  t |!t | \Lambda ff : Type: t | t(oe) |

let x : oe \Omega  y : o/ be t in t | let !x : oe be t in t | let ? be t in t

LINEAR ABADI & PLOTKIN LOGIC 5
We use *ffi, which bear some graphical resemblance to (, to denote linear function abstraction. And we use s, t, u. . . to range over terms.

The formation rules are given in Figure 1. A term context \Xi  | \Gamma ; \Delta  is considered
well-formed if for all types oe appearing in \Gamma  and \Delta , the type construction \Xi  ` oe : Type is
well-formed. The linear contexts \Delta  and \Delta 0 are considered disjoint if the set of variables
appearing in \Delta  is disjoint from the set of variables appearing in \Delta 0. We use - to denote an
empty context. As the types of variables in the let-constructions and function abstractions
are often apparent from the context, these will just as often be omitted.

The fixed point combinator Y appears as a term in the language, but could equivalently
have been given as an operator on terms as e.g. the rec operator in Lily. By having it as
a polymorphic term the parametricity principle it satisfies becomes evident.

\Xi  | \Gamma ; - ` ? : I
\Xi  | \Gamma ; - ` Y : Q ff: !(!ff ( ff) ( ff

\Xi  | \Gamma ; x : oe; - ` x : oe

\Xi  | \Gamma ; x : oe ` x : oe
\Xi  | \Gamma ; \Delta  ` t : oe ( o/ \Xi  | \Gamma ; \Delta 0 ` u : oe \Delta ; \Delta 0 disjoint

\Xi  | \Gamma ; \Delta ; \Delta 0 ` t u : o/

\Xi  | \Gamma ; \Delta ; x : oe ` u : o/

\Xi  | \Gamma ; \Delta  ` *ffix : oe: u : oe ( o/
\Xi  | \Gamma ; \Delta  ` t : oe \Xi  | \Gamma ; \Delta 0 ` s : o/ \Delta ; \Delta 0 disjoint

\Xi  | \Gamma ; \Delta ; \Delta 0 ` t \Omega  s : oe \Omega  o/

\Xi  | \Gamma ; - ` t : oe

\Xi  | \Gamma ; - `!t : oe
\Xi ; ff : Type | \Gamma ; \Delta  ` t : oe \Xi  | \Gamma ; \Delta  is well-formed

\Xi  | \Gamma ; \Delta  ` \Lambda ff : Type: t : Q ff : Type: oe

\Xi  | \Gamma ; \Delta  ` t : Q ff : Type: oe \Xi  ` o/ : Type

\Xi  | \Gamma ; \Delta  ` t(o/ ) : oe[o/ =ff]
\Xi  | \Gamma ; \Delta  ` s : oe \Omega  oe0 \Xi  | \Gamma ; \Delta 0; x : oe; y : oe0 ` t : o/ \Delta ; \Delta 0 disjoint

\Xi  | \Gamma ; \Delta ; \Delta 0 ` let x : oe \Omega  y : oe0 be s in t : o/
\Xi  | \Gamma ; \Delta  ` s : !oe \Xi  | \Gamma ; x : oe; \Delta 0 ` t : o/ \Delta ; \Delta 0 disjoint

\Xi  | \Gamma ; \Delta ; \Delta 0 ` let !x : !oe be s in t : o/

\Xi  | \Gamma ; \Delta  ` t : I \Xi  | \Gamma ; \Delta 0 ` s : oe

\Xi  | \Gamma ; \Delta ; \Delta 0 ` let ? be t in s : oe

Figure 1: Formation rules for terms

6 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
Lemma 1.1. Any term can in a given context be shown to have at most one type, i.e., if
the typing judgements \Xi  | \Gamma ; \Delta  ` t : o/ and \Xi  | \Gamma ; \Delta  ` t : o/ 0 are derivable then o/ = o/ 0.

Lemma 1.2. The following three substitution rules are derivable from the formation rules
of PILLY .

\Xi  | \Gamma ; \Delta ; x : oe ` t : o/ \Xi  | \Gamma ; \Delta 0 ` u : oe

\Xi  | \Gamma ; \Delta ; \Delta 0 ` t[u=x] : o/
\Xi  | \Gamma ; x : oe; \Delta  ` t : o/ \Xi  | \Gamma ; - ` u : oe

\Xi  | \Gamma ; \Delta  ` t[u=x] : o/
\Xi ; ff | \Gamma ; \Delta  ` t : o/ \Xi  ` oe : Type

\Xi  | \Gamma [oe=ff]; \Delta [oe=ff] ` t[oe=ff] : o/ [oe=ff]
What we have described above is called pure PILLY . In general we will consider PILLY
over polymorphic signatures [Jac99, 8.1.1]. Informally, one may think of such a calculus as
pure PILLY with added type-constants and term-constants. For instance, one may have
a constant type for integers or a constant type for lists ff ` lists(ff) : Type. We will be
particularly interested in the internal languages of PILLY models which in general will be
non-pure calculi.

We will also sometimes speak of the calculus PILL. This is PILLY without the fixed
point combinator Y .

1.1.1. Equality. The external equality relation on PILLY terms is the least equivalence
relation given by the rules in Figure 2. External equality is typed in the sense that if in a
given context two terms are externally equal, then they have the same type. The definition
makes use of the notion of a context, which, loosely speaking, is a term with exactly one
hole in it. Formally contexts are defined using the grammar:

C[-] ::= - | let ? be C[-] in t | let ? be t in C[-] | t \Omega  C[-] | C[-] \Omega  t |

let x \Omega  y be C[-] in t | let x \Omega  y be t in C[-] | *ffix : oe: C[-] |
C[-] t | t C[-] |!C[-] | let !x be C[-] in t | let !x be t in C[-] |
\Lambda ff : Type: C[-] | C[-]oe

A context C[-] is called a \Xi  | \Gamma ; \Delta  ` oe -- \Xi  | \Gamma 0; \Delta 0 ` o/ context if for any well-formed term
\Xi  | \Gamma ; \Delta  ` t : oe, the term \Xi  | \Gamma 0; \Delta 0 ` C[t] : o/ is well-formed. A context is linear, if it does
not contain a subcontext of the form !C[-].

We prove a couple of useful lemmas about external equality.

Lemma 1.3. Suppose \Xi  | \Gamma ; \Delta  ` f; g : !oe ( o/ are terms such that

\Xi  | \Gamma ; x : oe; \Delta  ` f (!x) = g(!x):
Then f = g.

Proof. Using the rules for external equality, we conclude from the assumption that

\Xi  | \Gamma ; \Delta ; y : !oe ` let !x be y in f (!x) = let !x be y in g(!x)
and further that

\Xi  | \Gamma ; \Delta ; y : !oe ` f (let !x be y in !x) = g(let !x be y in !x):
Thus

\Xi  | \Gamma ; \Delta ; y : !oe ` f (y) = g(y);

LINEAR ABADI & PLOTKIN LOGIC 7

fi-term\Xi  | \Gamma ; \Delta  ` (*ffix : oe: t)u = t[u=x]

fi-type\Xi  | \Gamma ; \Delta  ` (\Lambda ff : Type: t)oe = t[oe=ff]
j-term\Xi  | \Gamma ; \Delta  ` *ffix : oe: (tx) = t

j-type\Xi  | \Gamma ; \Delta  ` \Lambda ff : Type: (tff) = t

fi - ?\Xi  | \Gamma ; \Delta  ` let ? be ? in t = t
j - ?\Xi  | \Gamma ; \Delta  ` let ? be t in ? = t

fi - \Omega \Xi  | \Gamma ; \Delta  ` let x \Omega  y be s \Omega  u in t = t[s; u=x; y]
j - \Omega \Xi  | \Gamma ; \Delta  ` let x \Omega  y be t in x \Omega  y = t

fi-!\Xi  | \Gamma ; \Delta  ` let !x : oe be !u in t = t[u=x]
j-!\Xi  | \Gamma ; \Delta  ` let !x : oe be t in !x = t

\Xi  | \Gamma ; \Delta  ` t = s : oe C[-] is a \Xi  | \Gamma ; \Delta  ` oe - \Xi  | \Gamma 0; \Delta 0 ` o/ context

\Xi  | \Gamma 0; \Delta 0 ` C[t] = C[s]
C[-] is a linear context

\Xi  | \Gamma ; \Delta  ` let ? be t in C[u] = C[let ? be t in u]
C[-] is a linear context and does not bind x; y or contain them free

\Xi  | \Gamma ; \Delta  ` let x \Omega  y be t in C[u] = C[let x \Omega  y be t in u]

C[-] is linear and does not bind x or contain it free

\Xi  | \Gamma ; \Delta  ` let !x be t in C[u] = C[let !x be t in u]

\Xi  | \Gamma ; - ` f : !oe ( oe

\Xi  | \Gamma ; - ` f !(Y oe (!f )) = Y oe (!f )

Figure 2: Rules for external equality

and hence f = *ffiy : !oe: f (y) = *ffiy : !oe: g(y) = g.

1.1.2. Intuitionistic lambda abstraction. We encode ordinary intuitionistic lambda abstraction using the Girard encoding oe ! o/ =!oe ( o/ . The corresponding lambda abstraction is
defined as

*x : oe: t = *ffiy : !oe: let !x be y in t

where y is a fresh variable. This gives us the rule

\Xi  | \Gamma ; x : oe; \Delta  ` t : o/

\Xi  | \Gamma ; \Delta  ` *x : oe: t : oe ! o/

8 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN

\Xi  ::= - | \Xi ; ff ` Type \Gamma  ::= - | \Gamma ; x : oe
\Theta  ::= - | \Theta ; R : Rel(oe; o/ ) | \Theta ; S : AdmRel(oe; o/ )

\Xi  : Ctx \Xi  ` oe : Type \Xi  | \Gamma ; \Delta  : Ctx
\Xi  | \Gamma  | \Theta  : Ctx \Xi  | \Gamma ; \Delta  ` t : oe \Xi  | \Gamma ; \Delta  ` t = u
\Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ ) \Xi  | \Gamma  | \Theta  ` ae : AdmRel(oe; o/ )

\Xi  | \Gamma  | \Theta  ` OE : Prop \Xi  | \Gamma  | \Theta  | OE1; : : : ; OEn ` 

Figure 3: Types of judgments and grammar for LAPL contexts

For evaluation we have the rule

\Xi  | \Gamma ; - ` t : oe \Xi  | \Gamma ; \Delta  ` f : oe ! o/

\Xi  | \Gamma ; \Delta  ` f !t : o/
and the equality rules give

(*x : oe: t) !s = t[s=x]:

Note that using this notation the constant Y can obtain the more familiar looking type

Y : \Pi ff: (ff ! ff) ! ff:
This notation also explains the occurrences of the !'s in the last rule of Figure 2.

1.2. The logic. As mentioned, expressions of LAPL live in contexts of variables of PILLY
and relations among types of PILLY . The contexts look like this:

\Xi  | \Gamma  | R1 : Rel(o/1; o/ 01); : : : ; Rn : Rel(o/n; o/ 0n); S1 : AdmRel(!1; !01); : : : ; Sm : AdmRel(!m; !0m)
where \Xi  | \Gamma ; - is a context of PILLY and the o/i; o/ 0i ; !i; !0i are well-formed types in context
\Xi , for all i. The list of R's and S's is called the relational context and is often denoted \Theta .
As for the other contexts we do not allow repetition, but do allow permutation of variables.

The concept of admissible relations is taken from domain theory. Intuitively admissible
relations relate ? to ? and are chain complete.

It is important to note that there is no linear component \Delta  in the contexts -- the point
is that the logic only allows for intuitionistic (no linearity) reasoning about terms of PILLY ,
whereas PILLY terms can behave linearly. This simplification of the logic has been chosen
since all parametricity arguments in our knowledge involve purely intuitionistic reasoning.

Propositions in the logic are given by the syntax:

OE ::= (t =oe u) | ae(t; u) | OE oe  | ? | ? | OE ^  | OE .  | 8ff : Type: OE |

8x : oe: OE | 8R : Rel(oe; o/ ): OE | 8S : AdmRel(oe; o/ ): OE |
9ff : Type: OE | 9x : oe: OE | 9R : Rel(oe; o/ ): OE | 9S : AdmRel(oe; o/ ): OE

where ae is a definable relation (to be defined below). The judgments of the logic are
presented in Figure 3. In the following we give formation rules for the above.

Remark 1.4. Our Linear Abadi & Plotkin logic is designed for reasoning about binary
relational parametricity. For reasoning about other arities of parametricity, one can easily
replace binary relations in the logic by relations of other arities. In the case of unary
parametricity, for example, one would then have an interpretation of types as predicates.
See also [Tak98, Wad04]

LINEAR ABADI & PLOTKIN LOGIC 9
We first have the formation rule for internal equality:

\Xi  | \Gamma ; - ` t : oe \Xi  | \Gamma ; - ` u : oe

\Xi  | \Gamma  | \Theta  ` t =oe u : Prop
Notice here the notational difference between t = u and t =oe u. The former denotes external
equality and the latter is a proposition in the logic. The rules for oe, . and ^ are the usual
ones, where oe denotes implication. ?, ? are propositions in any context. We use oeae for
biimplication.

We have the following formation rules for universal quantification:

\Xi  | \Gamma ; x : oe | \Theta  ` OE : Prop

\Xi  | \Gamma  | \Theta  ` 8x : oe: OE : Prop
\Xi  | \Gamma  | \Theta ; R : Rel(oe; o/ ) ` OE : Prop

\Xi  | \Gamma  | \Theta  ` 8R : Rel(oe; o/ ): OE : Prop
\Xi  | \Gamma  | \Theta ; S : AdmRel(oe; o/ ) ` OE : Prop

\Xi  | \Gamma  | \Theta  ` 8S : AdmRel(oe; o/ ): OE : Prop
\Xi ; ff | \Gamma  | \Theta  ` OE : Prop \Xi  | \Gamma  | \Theta  is well-formed

\Xi  | \Gamma  | \Theta  ` 8ff : Type: OE : Prop
The side condition \Xi  | \Gamma  | \Theta  is well-formed means that all the types of variables in \Gamma  and
of relation variables in \Theta  are well-formed in \Xi  (i.e., all the free type variables of the types
occur in \Xi ).

There are similar formation rules for the existential quantifier.
Before we give the formation rule for ae(t; u), we discuss definable relations.

1.2.1. Definable relations. Definable relations are given by the grammar:

ae ::= R | (x : oe; y : o/ ):OE | oe[R]
Definable relations always have a domain and a codomain, just as terms always have types.
The basic formation rules for definable relations are:

\Xi  | \Gamma  | \Theta ; R : Rel(oe; o/ ) ` R : Rel(oe; o/ )

\Xi  | \Gamma ; x : oe; y : o/ | \Theta  ` OE : Prop

\Xi  | \Gamma  | \Theta  ` (x : oe; y : o/ ): OE : Rel(oe; o/ )

\Xi  | \Gamma  | \Theta  ` ae : AdmRel(oe; o/ )

\Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ )
Notice that in the second rule we can only abstract intuitionistic variables to obtain definable relations. In the last rule, ae : AdmRel(oe; o/ ) is an admissible relation, a concept to be
discussed below. The rule says that the admissible relations constitute a subset of the definable relations. The last construction of the grammar refers to the relational interpretation
of types and will be discussed in Section 1.2.3.

An example of a definable relation is the graph relation of a function:

hf i = (x : oe; y : o/ ): f x =o/ y;
for f : oe ( o/ . The equality relation eqoe is defined as the graph of the identity map.

10 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN

If ae : Rel(oe; o/ ) is a definable relation, and we are given terms of the right types, then we
may form the proposition stating that the two terms are related by the definable relation:

\Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ ) \Xi  | \Gamma ; - ` t : oe; s : o/

\Xi  | \Gamma  | \Theta  ` ae(t; s) : Prop (1.1)
We shall also write taes for ae(t; s).

Relations can be reindexed along PILLY maps as in the following derivable rule

\Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ ) \Xi  | \Gamma ; - ` f : oe0 ( oe; g : o/ 0 ( o/

\Xi  | \Gamma  | \Theta  ` (x : oe0; y : o/ 0): ae(f x; g y) : Rel(oe0; o/ 0)
where x; y are fresh variables. We shall use the shorthand notation (f; g)*ae for

(x : oe0; y : o/ 0): ae(f x; g y):

1.2.2. Constructions on definable relations. In this subsection we present some constructions on definable relations - one for each type constructor of PILLY . These will be used to
give a relational interpretation of the types of PILLY .

If ae : Rel(oe; o/ ) and ae0 : Rel(oe0; o/ 0) define

ae ( ae0 = (f : oe ( oe0; g : o/ ( o/ 0): 8x : oe: 8y : o/: ae(x; y) oe ae0(f x; gy):
for fresh variables x; y; f; g. Then the rule

\Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ ); ae0 : Rel(oe0; o/ 0)

\Xi  | \Gamma  | \Theta  ` (ae ( ae0) : Rel((oe ( oe0); (o/ ( o/ 0))
is derivable.

If

\Xi ; ff; fi | \Gamma  | \Theta ; R : AdmRel(ff; fi) ` ae : Rel(oe; o/ )

is well-formed and \Xi  | \Gamma  | \Theta  is well-formed, \Xi ; ff ` oe : Type, and \Xi ; fi ` o/ : Type we may
define the relation

\Xi  | \Gamma  | \Theta  ` 8(ff; fi; R : AdmRel(ff; fi)): ae : Rel((Q ff : Type: oe); (Q fi : Type: o/ ))
as

8(ff; fi; R : AdmRel(ff; fi)): ae =
(t : Q ff : Type: oe; u : Q fi : Type: o/ ): 8ff; fi : Type: 8R : AdmRel(ff; fi): ae(tff; ufi):

In Section 2 we will show how to encode the type constructors \Omega ; !; I using (; ! and
polymorphism as in Figure 5 below. At this point we have not discussed parametricity
and so can not use the encodings, but we will still use these for the definitions of the
constructions on relations corresponding to \Omega ; I and !. The relational interpretations of
\Omega ; I; ! are due to Alex Simpson, who also uses this relational interpretation of ! in a more
general context in [Sim06].

First we define the tensor product of ae and ae0

ae \Omega  ae0 : Rel((oe \Omega  oe0); (o/ \Omega  o/ 0));
for ae : Rel(oe; o/ ) and ae0 : Rel(oe0; o/ 0). We first introduce the map

foe;oe0 : oe \Omega  oe0 ( Q ff: (oe ( oe0 ( ff) ( ff

LINEAR ABADI & PLOTKIN LOGIC 11
defined as

foe;oe0 x = let x0 \Omega  x00 : oe \Omega  oe0 be x in \Lambda ff: *ffih : oe ( oe0 ( ff: h x0 x00:
Then we define

ae \Omega  ae0 = (foe;oe0; fo/;o/0)*(8(ff; fi; R : AdmRel(ff; fi)): (ae ( ae0 ( R) ( R);
or, if we write it out,

ae \Omega  ae0 = (x : oe \Omega  oe0; y : o/ \Omega  o/ 0): 8ff; fi; R : AdmRel(ff; fi):

8t : oe ( o/ ( ff; t0 : oe0 ( o/ 0 ( fi: (ae ( ae0 ( R)(t; t0) oe
R(let x0 \Omega  x00 be x in t x0 x00; let y0 \Omega  y00 be y in t0 y0 y00):

As a derivable rule we get

\Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ ); ae0 : Rel(oe0; o/ 0)

\Xi  | \Gamma  | \Theta  ` (ae \Omega  ae0) : Rel((oe \Omega  oe0); (o/ \Omega  o/ 0))
Following the same strategy, we define a relation IRel : Rel(I; I) using the map

f : I ( Q ff: ff ( ff
defined as *ffix : I: let ? be x in id , where id = \Lambda ff: *ffix : ff: x and define

IRel = (f; f )*(8(ff; fi; R : AdmRel(ff; fi)): R ( R);
which, if we write it out, is

(x : I; y : I): 8(ff; fi; R : AdmRel(ff; fi)): 8z : ff; w : fi:

zRw oe (let ? be x in z)R(let ? be y in w):

The relation IRel types in any context, i.e., \Xi  | \Gamma  | \Theta  ` IRel : Rel(I; I) is derivable for any
well-formed context \Xi  | \Gamma  | \Theta .

The encoding of ! in Figure 5 uses !, which was defined above as oe ! o/ =!oe ( o/ , but
since ! has a natural relational interpretation, we will still use this to define the relational
interpretation of !.

For ae : Rel(oe; o/ ) and ae0 : Rel(oe0; o/ 0) we define

ae ! ae0 = (f : oe ! oe0; g : o/ ! o/ 0): 8x : oe; y : o/: ae(x; y) oe ae0(f (!x); g(!y))
Now, define for any type oe the map foe : !oe ( Q ff: (oe ! ff) ( ff as

*ffix : !oe: \Lambda ff: *ffig : oe ! ff: g(x):
The relation !ae : Rel(!oe; !o/ ) is defined as

(foe; fo/ )*8(ff; fi; R : AdmRel(ff; fi)): (ae ! R) ( R:
The derivable typing rule is

\Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ )

\Xi  | \Gamma  | \Theta  `!ae : Rel(!oe; !o/ )
Remark 1.5. In [BMP05] we show how the constructions on relations presented in this
section gives rise to a PILLY -model of admissible relations. In other words \Omega ; ( defines a symmetric monoidal structure on relations, ! extends this to a linear structure, and
8(ff; fi; R : AdmRel(ff; fi)): defines a polymorphic product.

Remark 1.6. The definitions of ae\Omega ae0 and !ae involve an implicit admissible closure operator
discussed in Section 1.2.5 below. This operator helps secure that the collection of admissible
relations is closed under the constructions above (see Proposition 1.7 below).

12 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
1.2.3. Admissible relations. As mentioned in the introduction, for the theory of parametricity to be consistent in a type theory with recursion the parametricity principle must be
weakened. For this purpose we introduce a notion of admissible relations axiomatized in
Figure 4. In these rules ae j ae0 is a shorthand for 8x; y: ae(x; y) oeae ae0(x; y).

\Xi  | \Gamma  | \Theta ; R : AdmRel(oe; o/ ) ` R : AdmRel(oe; o/ )

\Xi  | \Gamma  | \Theta  ` eqoe : AdmRel(oe; oe)
\Xi  | \Gamma  | \Theta  ` ae : AdmRel(oe; o/ ) \Xi  | \Gamma ; - ` t : oe0 ( oe; u : o/ 0 ( o/ x; y =2 \Gamma 

\Xi  | \Gamma  | \Theta  ` (x : oe0; y : o/ 0): ae(t x; u y) : AdmRel(oe0; o/ 0)

\Xi  | \Gamma  | \Theta  ` ae; ae0 : AdmRel(oe; o/ ) x; y =2 \Gamma 

\Xi  | \Gamma  | \Theta  ` (x : oe; y : o/ ): ae(x; y) ^ ae0(x; y) : AdmRel(oe; o/ )

\Xi  | \Gamma  | \Theta  ` ae : AdmRel(oe; o/ ) x; y =2 \Gamma 

\Xi  | \Gamma  | \Theta  ` (x : o/; y : oe): ae(y; x) : AdmRel(o/; oe)

x; y =2 \Gamma 

\Xi  | \Gamma  | \Theta  ` (x : oe; y : o/ ): ? : AdmRel(oe; o/ )
\Xi  | \Gamma  | \Theta  ` ae : AdmRel(oe; o/ ) \Xi  | \Gamma  | \Theta  ` OE : Prop x; y =2 \Gamma 

\Xi  | \Gamma  | \Theta  ` (x : oe; y : o/ ): OE oe ae(x; y) : AdmRel(oe; o/ )
\Xi ; ff | \Gamma  | \Theta  ` ae : AdmRel(oe; o/ ) \Xi  | \Gamma  | \Theta  \Xi  ` oe : Type \Xi  ` o/ : Type x; y =2 \Gamma 

\Xi  | \Gamma  | \Theta  ` (x : oe; y : o/ ): 8ff : Type: ae(x; y) : AdmRel(oe; o/ )

\Xi  | \Gamma ; z : ! | \Theta  ` ae : AdmRel(oe; o/ ) x; y =2 \Gamma 

\Xi  | \Gamma  | \Theta  ` (x : oe; y : o/ ): 8z : !: ae(x; y) : AdmRel(oe; o/ )
\Xi  | \Gamma  | \Theta ; R : AdmRel(!; !0) ` ae : AdmRel(oe; o/ ) x; y =2 \Gamma 

\Xi  | \Gamma  | \Theta  ` (x : oe; y : o/ ): 8R : AdmRel(!; !0): ae(x; y) : AdmRel(oe; o/ )

\Xi  | \Gamma  | \Theta ; R : Rel(!; !0) ` ae : AdmRel(oe; o/ ) x; y =2 \Gamma 

\Xi  | \Gamma  | \Theta  ` (x : oe; y : o/ ): 8R : Rel(!; !0): ae(x; y) : AdmRel(oe; o/ )
\Xi  | \Gamma  | \Theta  ` ae : AdmRel(oe; o/ ); ae0 : Rel(oe; o/ ) \Xi  | \Gamma  | \Theta  | ? ` ae j ae0

\Xi  | \Gamma  | \Theta  ` ae0 : AdmRel(oe; o/ )
ff1; : : : ; ffn ` oe(~ff) : Type \Xi  | \Gamma  | \Theta  ` ae1 : AdmRel(o/1; o/ 01); : : : ; aen : AdmRel(o/n; o/ 0n)

\Xi  | \Gamma  | \Theta  ` oe[~ae] : AdmRel(oe(~o/ ); oe(~o/ 0))

Figure 4: Rules for admissible relations
A few comments is needed for the last of the rules in Figure 4. First observe that oe[~ae] is
a syntactic construction and is not obtained by substitution as in [PA93]. Still the notation
oe[ae1=ff1; : : : ; aen=ffn] might be more complete, but this quickly becomes overly verbose. In
[PA93] oe[~ae] is to some extent defined inductively on the structure of oe, but in our case that
is not enough, since we will need to form oe[~ae] for type constants (when using the internal
language of a model of LAPL). The inductive definition over the type structure is in stead
reflected in axioms 1.22 to 1.27.

LINEAR ABADI & PLOTKIN LOGIC 13
We call oe[~ae] the relational interpretation of the type oe.
Proposition 1.7. The class of admissible relations contains all graphs and is closed under
the constructions of Section 1.2.2, in fact the following more general rules hold

\Xi  | \Gamma ; - ` f : oe ( o/

\Xi  | \Gamma  | \Theta  ` hf i : AdmRel(oe; o/ )
\Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ ); ae0 : AdmRel(oe0; o/ 0)
\Xi  | \Gamma  | \Theta  ` (ae ( ae0) : AdmRel((oe ( oe0); (o/ ( o/ 0))

\Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ ); ae0 : AdmRel(oe0; o/ 0)

\Xi  | \Gamma  | \Theta  ` (ae ! ae0) : AdmRel((oe ! oe0); (o/ ! o/ 0))

\Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ ); ae0 : Rel(oe0; o/ 0)

\Xi  | \Gamma  | \Theta  ` (ae \Omega  ae0) : AdmRel((oe \Omega  oe0); (o/ \Omega  o/ 0))

\Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ )

\Xi  | \Gamma  | \Theta  `!ae : AdmRel(!oe; !o/ )

\Xi  | \Gamma  | \Theta  ` IRel : AdmRel(I; I)
\Xi ; ff; fi | \Gamma  | \Theta ; R : AdmRel(ff; fi) ` ae : AdmRel(oe; o/ ) \Xi ; ff ` oe : Type \Xi ; fi ` o/ : Type

\Xi  | \Gamma  | \Theta  ` 8(ff; fi; R : AdmRel(ff; fi)): ae : AdmRel((Q ff : Type: oe); (Q fi : Type: o/ ))
where the last rule has the side condition that \Xi  | \Gamma  | \Theta  must be well-formed.

Proof. Graph relations are admissible since equality relations are and admissible relations
are closed under reindexing. For the constructions of Section 1.2.2, we just give the proof
of (.

We must prove that for ae : Rel(oe; o/ ); ae0 : AdmRel(oe0; o/ 0) relations in the same context
ae ( ae0 is admissible. Consider first the relation

(f : oe ( oe0; g : o/ ( o/ 0): ae0(f x; g y)
in the context where we have added fresh variables x : oe; y : o/ to the contexts of ae; ae0. This
relation is a reindexing of ae0 along the evaluation maps, which are linear, and so the relation
is admissible. Since f; g do not occur freely in ae, also

(f : oe ( oe0; g : o/ ( o/ 0): ae(x; y) oe ae0(f x; g y)
is admissible, and so since admissible relations are closed under universal quantification,
ae ( ae0 is admissible.

14 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
1.2.4. Axioms and Rules. The last judgment in Figure 3 has not yet been mentioned. It
says that in the given context, the formulas OE1; : : : ; OEn collectively imply . We will often
write \Phi  for OE1; : : : ; OEn.

Having specified the language of LAPL, it is time to specify the axioms and inference
rules. We have all the usual axioms and rules of predicate logic plus the axioms and rules
specified below.

Rules for substitution:

Rule 1.8. \Xi  | \Gamma ; x : oe | \Theta  | ? ` OE \Xi  | \Gamma  ` t : oe\Xi  | \Gamma  | \Theta  | ? ` OE[t=x]

Rule 1.9. \Xi  | \Gamma  | \Theta ; R : Rel(oe; o/ ) | ? ` OE \Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ )\Xi  | \Gamma  | \Theta  | ? ` OE[ae=R]
Rule 1.10. \Xi  | \Gamma  | \Theta ; S : AdmRel(oe; o/ ) | ? ` OE \Xi  | \Gamma  | \Theta  ` ae : AdmRel(oe; o/ )\Xi  | \Gamma  | \Theta  | ? ` OE[ae=S]

Rule 1.11. \Xi ; ff | \Gamma  | \Theta  | ? ` OE \Xi  ` oe : Type\Xi  | \Gamma [oe=ff] | \Theta [oe=ff] | ? ` OE[oe=ff]
The substitution axiom:

Axiom 1.12. 8ff; fi : Type:8x; x0 : ff:8y; y0 : fi:8R : Rel(ff; fi:)R(x; y)^

x =ff x0 ^ y =fi y0 oe R(x0; y0)

Rules for 8-quantification:

Rule 1.13. \Xi ; ff | \Gamma  | \Theta  | \Phi  ` ==================== \Xi  | \Gamma  | \Theta  ` \Phi \Xi  | \Gamma  | \Theta  | \Phi  ` 8ff : Type:

Rule 1.14. \Xi  | \Gamma ; x : oe | \Theta  | \Phi  ` ================== \Xi  | \Gamma  | \Theta  ` \Phi \Xi  | \Gamma  | \Theta  | \Phi  ` 8x : oe:
Rule 1.15. \Xi  | \Gamma  | \Theta ; R : Rel(o/; o/

0) | \Phi  ` 
======================== \Xi  | \Gamma  | \Theta  ` \Phi \Xi  | \Gamma  | \Theta  | \Phi  ` 8R : Rel(o/; o/ 0):

Rule 1.16. \Xi  | \Gamma  | \Theta ; S : AdmRel(o/; o/

0) | \Phi  ` 
=========================== \Xi  | \Gamma  | \Theta  ` \Phi \Xi  | \Gamma  | \Theta  | \Phi  ` 8S : AdmRel(o/; o/ 0):

Rules for 9-quantification:

Rule 1.17. \Xi ; ff | \Gamma  | \Theta  | OE ` ==================== \Xi  | \Gamma  | \Theta  ` \Xi  | \Gamma  | \Theta  | 9ff : Type:OE ` 

Rule 1.18. \Xi  | \Gamma ; x : oe | \Theta  | OE ` ================= \Xi  | \Gamma  | \Theta  ` \Xi  | \Gamma  | \Theta  | 9x : oe:OE ` 
Rule 1.19. \Xi  | \Gamma  | \Theta ; R : Rel(o/; o/

0) | OE ` 
======================== \Xi  | \Gamma  | \Theta  ` \Xi  | \Gamma  | \Theta  | 9R : Rel(o/; o/ 0:)OE ` 

Rule 1.20. \Xi  | \Gamma  | \Theta ; S : AdmRel(o/; o/

0) | OE ` 
=========================== \Xi  | \Gamma  | \Theta  ` \Xi  | \Gamma  | \Theta  | 9S : AdmRel(o/; o/ 0):OE ` 

LINEAR ABADI & PLOTKIN LOGIC 15
External equality implies internal equality:

Rule 1.21. \Xi  | \Gamma ; - ` t; u : oe \Xi  | \Gamma ; - ` t = u\Xi  | \Gamma  | \Theta  | ? ` t =

oe u

There are also obvious rules expressing that internal equality is an equivalence relation.
We have rules concerning the interpretation of types as relations:

Rule 1.22. ~ff ` ffi : Type \Xi  | \Gamma  | \Theta  ` ~ae : AdmRel(~o/ ; ~o/

0)

\Xi  | \Gamma  | \Theta  | ? ` ffi[~ae] j aei

Rule 1.23. ~ff ` oe

( oe0 : Type \Xi  | \Gamma  | \Theta  ` ~ae : AdmRel(~o/ ; ~o/ 0)

\Xi  | \Gamma  | \Theta  | ? ` (oe ( oe0)[~ae] j (oe[~ae] ( oe0[~ae])

Rule 1.24. ~ff ` oe \Omega  oe

0 : Type \Xi  | \Gamma  | \Theta  ` ~ae : AdmRel(~o/ ; ~o/ 0)

\Xi  | \Gamma  | \Theta  | ? ` (oe \Omega  oe0)[~ae] j (oe[~ae] \Omega  oe0[~ae])

Rule 1.25. \Xi  | \Gamma  | \Theta  ` ~ae : AdmRel(~o/ ; ~o/

0)

\Xi  | \Gamma  | \Theta  | ? ` I[~ae] j IRel

Rule 1.26. ~ff `

Q fi: oe(~ff; fi) : Type \Xi  | \Gamma  | \Theta  ` ~ae : AdmRel(~o/ ; ~o/ 0)

\Xi  | \Gamma  | ? ` (Q fi: oe(~ff; fi))[~ae] j 8(fi; fi0; R : AdmRel(fi; fi0)): oe[~ae; R])
Rule 1.27. ~ff `!oe : Type \Xi  | \Gamma  | \Theta  ` ~ae : AdmRel(~o/ ; ~o/

0)

\Xi  | \Gamma  | \Theta  | ? ` (!oe)[~ae] j!(oe[ae])
If the definable relation ae is of the form (x : oe; y : o/ ): OE(x; y), then ae(t; u) is equivalent
to OE with x; y substituted by t; u:

Rule 1.28. \Xi  | \Gamma ; x : oe; y : o/ | \Theta  ` OE : Prop \Xi  | \Gamma ; - ` t : oe; u : o/\Xi  | \Gamma  | \Theta  | ? ` ((x : oe; y : o/ ): OE)(t; u) oeae OE[t; u=x; y]

Axiom 1.29. \Xi  | \Gamma  | \Theta  | ? ` (Q ff: (ff ! ff) ! ff)(Y; Y )
Given a definable relation ae we may construct a proposition ae(x; y). On the other
hand, if OE is a proposition containing two free variables x and y, then we may construct the
definable relation (x; y): OE. The next lemma tells us that these constructions give a correspondence between definable relations and propositions, which is bijective up to provable
equivalence in the logic.

Lemma 1.30. Suppose \Xi  | \Gamma ; x : oe; y : o/ | \Theta  ` OE is a proposition. Then

\Xi  | \Gamma  | \Theta  | ? ` ((x : oe; y : o/ ): OE)(x; y) oeae OE
Suppose \Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ ) is a definable relation, then

\Xi  | \Gamma  | \Theta  | ? ` ae j (x : oe; y : o/ ): ae(x; y):
The substitution axiom above implies the replacement rule:
Lemma 1.31. \Xi  | \Gamma  | - | ? ` t =

oe t

0 \Xi  | \Gamma ; x : oe; - ` u : o/

\Xi  | \Gamma  | - | ? ` u[t=x] =o/ u[t0=x]

16 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
Proof. Consider the definable relation

ae = (y : oe; z : oe): u[y=x] =o/ u[z=x]:
Clearly ae(t; t) holds, so by substitution ae(t; t0) holds.

Lemma 1.32. Suppose \Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ ); ae0 : Rel(oe0; o/ 0) and x; x0; y; y0are fresh variables. Then

\Xi  | \Gamma  | \Theta  ` 8x : oe; x0 : oe0; y : o/; y0 : o/ 0: ae(x; y) ^ ae0(x0; y0) oe ae \Omega  ae0(x \Omega  x0; y \Omega  y0)

Proof. Suppose ae(x; y) ^ ae0(x0; y0) and that (ae ( ae0 ( R)(t; t0). Then clearly R(t x x0; t0 y y0)
and thus, since

let x \Omega  x0 be x \Omega  x0 in t x x0 = t x x0;

we conclude ae \Omega  ae0(x \Omega  x0; y \Omega  y0).

Lemma 1.33. Suppose \Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ ) then

\Xi  | \Gamma  | \Theta  | ? ` 8x : oe; y : o/: ae(x; y) oe (!ae)(!x; !y)
If \Xi  | \Gamma  | \Theta  ` ae : AdmRel(oe; o/ ) then

\Xi  | \Gamma  | \Theta  | ? ` 8x : oe; y : o/: ae(x; y) oeae (!ae)(!x; !y)

Proof. The first statement is clear from the definition of !ae. For the right to left implication
in the case of ae being admissible, observe that (*x : oe: x; *x : o/: x) : ae ! ae. Since !x(!ae)!y
this implies

ae((*x : oe: x)(!x); (*x : o/: o/ )(!y));

i.e., ae(x; y).

Recall that in Section 1.2.2 the oconstruction ! was defined directly on relations,
whereas in PILLY the type constructor ! is shorthand for !(-) ( (=). The next lemma
shows that the relations ae ! ae0 and !ae ( ae0 coincide in the case of ae0 being admissible.

Lemma 1.34. Suppose \Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ ); ae0 : Rel(oe0; o/ 0). Then

\Xi  | \Gamma  | \Theta  | ? ` 8f : oe ! oe0; g : o/ ! o/ 0: (ae ! ae0)(f; g) oe (!ae ( ae0)(f; g):
If \Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ ); ae0 : AdmRel(oe0; o/ 0) then

\Xi  | \Gamma  | \Theta  | ? ` (ae ! ae0) j (!ae ( ae0):

Proof. For the first implication, suppose (f; g) : !ae ( ae0. We must show that if ae(x; y) then
ae0(f (!x); g(!y)), which follows from the assumptions since !ae(!x; !y).

For the second half, we must show that if ae0 is admissible and ae ! ae0(f; g) and !ae(x; y)
then ae0(f (x); g(y)). But this follows from the definition of !ae(x; y) when using that ae0 is
admissible.

LINEAR ABADI & PLOTKIN LOGIC 17
1.2.5. A closure operator for admissible relations. In this section we present a closure operator on relations giving the least admissible relation containing a given relation. This
closure operator will be particularly useful for proving coinduction principles later. Recall
from Proposition 1.7 that for ae any relation and ae0 admissible ae ( ae0 is admissible. This
means that for any relation ae : Rel(oe; o/ ),

(8ff; fi; S : AdmRel(ff; fi)): (ae ( S) ( S
is an admissible relation from Q ff: (oe ( ff) ( ff to Q ff: (o/ ( ff) ( ff. We define \Phi (ae) to
be the admissible relation obtained by pulling back this relation along the canonical maps
oe ( Q ff: (oe ( ff) ( ff and o/ ( Q ff: (o/ ( ff) ( ff, i.e. \Phi (ae) is

(x : oe; y : o/ ): (8ff; fi; S : AdmRel(ff; fi)): 8f; g: (ae ( S)(f; g) oe S(f (x); g(y)):

Lemma 1.35. The operator \Phi  preserves implication of relations and for any relation ae,
\Phi (ae) is the smallest admissible relation containing ae, i.e.,

if \Xi  | \Gamma  | \Theta  ` ae : Rel(oe; o/ ); ae0 : AdmRel(oe; o/ )
then \Xi  | \Gamma  | \Theta  | ? ` 8x : oe; y : o/: ae(x; y) oe ae0(x; y)

iff \Xi  | \Gamma  | \Theta  | ? ` 8x : oe; y : o/: \Phi (ae)(x; y) oe ae0(x; y)
In later a paper we will show how the programming language Lily gives rise to a model
of LAPL. In this concrete model the notion of admissibility is modeled by the ??-closed
relations, and so the admissible closure operation presented here coincides with ??-closure
as defined in [BPR00].

Remark 1.36. Lemma 1.35 provides an alternative way of viewing the constructions on
relations presented in Section 1.2.2. In fact !ae is the smallest admissible relation containing
all pairs of the form (!x; !y) for ae(x; y). Likewise ae \Omega  ae0 is the smallest admissible relation
containing all pairs (x \Omega  x0; y \Omega  y0) with ae(x; y) ^ ae0(x0; y0), and IRel is the smallest admissible
relation containing (?; ?).

1.2.6. Extensionality and Identity Extension Schemes. Consider the two extensionality
schemes: (8x : oe: t x =

o/ u x) oe t =oe(o/ u
(8ff : Type: t ff =o/ u ff) oe t =Q ff: Type:o/ u:

These are taken as axioms in [PA93], but we shall not take these as axioms as we would
like to be able to talk about models that are not necessarily extensional.

Lemma 1.37. It is provable in the logic that

8f; g : oe ! o/: (8x : oe: f (!x) =o/ g(!x)) oe 8x : !oe: f (x) =o/ g(x):
In particular, extensionality implies

8f; g : oe ! o/: (8x : oe: f (!x) =o/ g(!x)) oe f =oe!o/ g

Proof. The first formula of the theorem is just the statement that (f; g) : eqoe ! eqo/ implies
(f; g) : !eqoe ( eqo/ . The second formula follows from the first.

18 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN

The schema

- | - | - ` 8~ff : Type: oe[eq~ff] j eqoe(~ff)

is called the identity extension schema. Here oe ranges over all types, and eq~ff is short
notation for eqff1 ; : : : ; eqffn .

For any type fi; ff1; : : : ; ffn ` oe(fi; ~ff) we can form the parametricity schema:

- | - | - ` 8~ff8u : (Q fi: oe): 8fi; fi0: 8R : AdmRel(fi; fi0): (u fi)oe[R; eq~ff](u fi0);
where, for readability, we have omitted : Type after fi; fi0.

We remark that the reason that parametricity and identity extension are formulated as
schemas is that we cannot quantify over type constructors.

Proposition 1.38. The identity extension schema implies the parametricity schema.
Proof. The identity extension schema tells us that

8~ff8u : (Q fi: oe): u(Q fi: oe)[eq~ff]u:
Writing out this expression using Rule 1.26 for the relational interpretation of polymorphic
types, one obtains the parametricity schema.

In the case of second-order lambda-calculus, the parametricity schema implied identity
extension for the pure calculus, since it provided the case of polymorphic types in a proof
by induction. It is interesting to notice that this does not seem to be the case for PILLY ,
since it seems that we need identity extension to prove for example eqoe \Omega  eqo/ j eqoe\Omega o/ .

1.3. Logical Relations Lemma. We end our presentation of Linear Abadi & Plotkin
Logic with the logical relations lemma.

Lemma 1.39 (Logical Relations Lemma). In pure LAPL, for any closed term - | -; - `
t : o/ ,

to/ t:

In words, any closed term of closed type, is related to itself in the relational interpretation
of the type. More generally, for any open term

~ff | ~x0 : ~oe0(ff); ~x : ~oe(ff) ` t(~ff; ~x0; ~x) : o/
in the pure calculus; the proposition

8~ff; ~fi: 8 ~R : AdmRel(~ff; ~fi): 8~x : ~oe(~ff); ~y : ~oe(~fi): 8~x0 : ~oe0(~ff); ~y0 : ~oe0(~fi):

~x~oe[ ~R]~y ^ ~x0~oe0[ ~R]~y0 oe t(~ff; ~x0; ~x)o/ [ ~R]t(~fi; ~y0; ~y)

holds in the logic.

A detailed proof of the Logical Relations Lemma can be found in [Mo/g05a].

LINEAR ABADI & PLOTKIN LOGIC 19
oe ,= Q ff: (oe ( ff) ( ff
oe \Omega  o/ ,= Q ff: (oe ( o/ ( ff) ( ff

!oe ,= Q ff: (oe ! ff) ( ff

I ,= Q ff: ff ( ff

0 = Q ff: ff
1 = Q ff: ff
oe + o/ = Q ff: (oe ( ff) ! (o/ ( ff) ! ff
oe * o/ = Q ff: (oe ( ff) + (o/ ( ff) ( ff

N = Q ff: (ff ( ff) ! ff ( ff`
ff: oe = Q fi: (Q ff: oe ( fi) ( fi
uff: oe = Q ff: (oe ( ff) ! ff

*ff: oe = ` ff: !(ff ( oe) \Omega  ff

Figure 5: Types definable using parametricity
2. Encoding datatypes using parametricity
In this section we show how to use the logic to prove correctness of encodings of a large
class of data types in PILLY using parametricity. These encoding are due to Plotkin, and
many of them are listed Figure 5. In Figure 5 there are two sorts of equations. The first
four equations are isomorphisms between types already present in PILLY . In these cases
we shall show that the isomorphisms hold in a category of linear maps, where maps are
considered equal up to provability in the logic. We shall give a precise definition of this
category shortly.

The other type of equation in Figure 5 defines encodings of types not already present in
PILLY . We shall show correctness of these encodings, by which we mean that they satisfy
the usual universal properties with respect to the above mentioned category of linear maps.
In the last two encodings, oe is assumed to be a type expression of PILLY in which ff occurs
only positively (see Section 2.7) in which case uff: oe defines an initial algebra for the functor
induced by oe and *ff: oe defines a final coalgebra. We will also discuss reasoning principles
for the encoded types.

We will prove that the fixed point combinator Y causes the initial algebras and final
coalgebras to coincide -- a phenomenon called algebraic compactness. As a special case
we have the coincidence of the initial and final object (0=1) as can be seen in Figure 5.
Following Freyd [Fre90b, Fre90a, Fre91] we show how algebraic compactness implies the
existence of general recursive types in Section 2.11.

In the following we shall write "using extensionality" and "using identity extension"
to mean that we assume the extensionality schemes and the identity extension schema,
respectively.

2.1. A category of linear functions. The precise formulation of correctness of encodings
of the datatypes presented in this section will be that they satisfy the usual universal
properties. To state this precisely, we introduce for each kind context \Xi  the category
LinType\Xi  as follows:

Objects: are types \Xi  | -; - ` oe : Type.

20 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN

Morphisms: [\Xi  | -; - ` f : oe ( o/ ] are equivalence classes of terms of type oe (

o/ ; the equivalence relation on these terms being provable equality in LAPL using
extensionality and identity extension.

Composition in this category is given by lambda abstraction, i.e. f : oe ( o/ composed with
g : ! ( oe yields *ffix : !: f (gx).

We start by proving that under the assumption of identity extension and extensionality,
for all types \Xi  ` oe : Type we have an isomorphism of objects of LinType\Xi :

oe ,= Q ff: (oe ( ff) ( ff
for ff not free in oe. We can define terms

f : oe ( Q ff: ((oe ( ff) ( ff)
and

g : Q ff: ((oe ( ff) ( ff) ( oe

by

f = *ffix : oe: \Lambda ff: *ffih : oe ( ff: h x

and

g = *ffix : Q ff: ((oe ( ff) ( ff): x oe id oe

Clearly

g (f x) = (f x) oe id oe = x

so g ffi f = id oe. Notice that this only involve external equality and thus we did not need
extensionality here.

Proposition 2.1. Using identity extension and extensionality, one may prove that f ffi g is
internally equal to the identity.

Proof. For a term a : Q ff: (oe ( ff) ( ff we have

f ffi g a = \Lambda ff: *ffih : oe ( ff: h(a oe id oe):
Using extensionality, it suffices to prove that

\Xi ; ff | h : oe ( ff | - ` h(a oe id oe) =ff a ff h
holds in the internal logic.

By the parametricity schema we know that for any admissible relation ae : AdmRel(o/; o/ 0)

(a o/ )((eqoe ( ae) ( ae)(a o/ 0)
If we instantiate this with the admissible relation hhi, we get

(a oe)((eqoe ( hhi) ( hhi)(a ff)
Since id oe(eqoe ( hhi)h we know that (a oe id oe)hhi(a ff h), i.e.,

h(a oe id oe) =ff a ff h;
as desired.

LINEAR ABADI & PLOTKIN LOGIC 21
This proof may essentially be found in [Bg05].
Intuitively, what happens here is that oe is a subtype of Q ff: (oe ( ff) ( ff, where the
inclusion f maps x to application at x. We use parametricity to show that Q ff: (oe ( ff) (
ff does not contain anything that is not in oe.

2.2. Tensor types. The goal of this section is to prove

oe \Omega  o/ ,= Q ff: (oe ( o/ ( ff) ( ff
using identity extension and extensionality, for \Xi  ` oe : Type and \Xi  ` o/ : Type types in the
same context. The isomorphism is in the category LinType\Xi .

This isomorphism leads to the question of whether tensor types are actually superfluous
in the language. The answer is yes in the following sense: Call the language without tensor
types (and I) t and the language as is T . Then there are transformations p : T ! t and
i : t ! T , i being the inclusion, such that p ffi i = idT and i ffi p ,= idt. This is all being
stated more precisely, not to mention proved, in [MBR05]. In this paper we settle for the
isomorphism above.

We can construct terms

f : oe \Omega  o/ ( Q ff: (oe ( o/ ( ff) ( ff
and

g : (Q ff: (oe ( o/ ( ff) ( ff) ( oe \Omega  o/

by

f y = let x \Omega  x0 : oe \Omega  o/ be y in \Lambda ff: *ffih : oe ( o/ ( ff: h x x0

and

g y = y (oe \Omega  o/ ) pairing;

where the map pairing : oe ( o/ ( oe \Omega  o/ is

pairing = *ffix : oe: *ffix0 : o/: x \Omega  x0:
Let us show that the composition g ffi f is the identity.

g ffi f y = g(let x \Omega  x0 : oe \Omega  o/ be y in \Lambda ff: *ffih : oe ( o/ ( ff: h x x0)

= (let x \Omega  x0 : oe \Omega  o/ be y in \Lambda ff: *ffih : oe ( o/ ( ff: h x x0) (oe \Omega  o/ ) pairing
= (\Lambda ff: *ffih : oe ( o/ ( ff: let x \Omega  x0 : oe \Omega  o/ be y in h x x0) (oe \Omega  o/ ) pairing
= let x \Omega  x0 : oe \Omega  o/ be y in x \Omega  x0
= y:

Proposition 2.2. Using extensionality and identity extension one may prove that the composition

f ffi g : (Q ff: (oe ( o/ ( ff) ( ff) ( (Q ff: (oe ( o/ ( ff) ( ff)

is internally equal to the identity.

Proof. We compute

f ffi g (y) = f (y (oe \Omega  o/ ) pairing) =
let x \Omega  x0 : oe \Omega  o/ be (y oe \Omega  o/ pairing) in \Lambda ff: *ffih : oe ( o/ ( ff: h x x0

Suppose we are given a type ff and a map h : oe ( o/ ( ff. We can define OEh : oe \Omega  o/ ( ff as

OEh = *ffiy : oe \Omega  o/: let x \Omega  x0 : oe \Omega  o/ be y in h x x0:

22 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
Then OEh(pairing x x0) = h x x0, which means that pairing(eqoe ( eqo/ ( hOEhi)h. By the
parametricity schema

\Xi ; ff | h : oe ( o/ ( ff; y : Q ff: (oe ( o/ ( ff) ( ff | - | ? `

(y oe \Omega  o/ )((eqoe ( eqo/ ( hOEhi) ( hOEhi)(y ff)
so

(y oe \Omega  o/ pairing)hOEhi(y ff h);

i.e,

OEh(y oe \Omega  o/ pairing) =ff y ff h:

Writing this out we get

\Xi ; ff | h : oe ( o/ ( ff; y : Q ff: (oe ( o/ ( ff) ( ff | - | ? `

let x \Omega  x0 : oe \Omega  o/ be (y oe \Omega  o/ pairing) in h x x0 =ff y ff h:

Using extensionality we get

\Lambda ff: *ffih : oe ( o/ ( ff: let x \Omega  x0 : oe \Omega  o/ be (y oe \Omega  o/ pairing) in (h x x0) =ff y:
This is enough, since by the rules for external equality the left hand side is

let x \Omega  x0 : oe \Omega  o/ be (y oe \Omega  o/ pairing) in (\Lambda ff: *ffih : oe ( o/ ( ff: h x x0):

2.3. Unit object. The goal of this section is to prove that identity extension together with
extensionality implies

I ,= Q ff: ff ( ff:

The isomorphism holds in LinType\Xi  for all \Xi .

We first define maps f : I ( Q ff: ff ( ff and g : (Q ff: ff ( ff) ( I as

f = *ffix : I: let ? be x in id ;

g = *ffit : Q ff: ff ( ff: t I ?;

where

id = \Lambda ff: *ffiy : ff: y:

We first notice that g(f (x)) = (let ? be x in

id ) I ?

= let ? be x in (id I ?)
= let ? be x in ?
= x:

Proposition 2.3. Using identity extension and extensionality, we have that f ffi g is internally equal to the identity on Q ff: ff ( ff.

Proof. First we write out the definition

f ffi g = *ffit : (Q ff: ff ( ff): let ? be (t I ?) in id:
We show that for any t : Q ff: ff ( ff, for any type oe, and any x : oe we have f ffig(t)oex =oe toex.

Given oe; x as above, we can define h : I ( oe as h = *ffiz : I: let ? be z in x. Then hhi
is admissible, so by identity extension

(t I)(hhi ( hhi)(t oe):

LINEAR ABADI & PLOTKIN LOGIC 23
Since h(?) = x we have h(t I ?) =oe t oe x, and by definition

h(t I ?) = let ? be (t I ?) in x

= let ? be (t I ?) in (id oe x)
= (let ? be (t I ?) in id ) oe x
= f ffi g(t) oe x:

2.4. Initial objects and coproducts. We define

0 = Q ff: ff
For each \Xi  this defines a weak initial object in LinType\Xi , since for any type \Xi  ` oe, there
exists a term 0oe : 0 ( oe, defined as

*ffix : 0: x oe

Proposition 2.4. Suppose f : 0 ( oe for some type \Xi  ` oe. Using identity extension and
extensionality it is provable that f =0(oe 0oe. Thus, 0 is an initial object in LinType\Xi  for
each \Xi .

Proof. First notice that for any map h : oe ( o/ , by identity extension (x oe)hhi(x o/ ) for any
x : 0. Thus, by extensionality, h ffi 0oe =0(o/ 0o/ for any h : oe ( o/ . In particular, for any type
oe, the case h = 0oe gives us x 0 oe =oe x oe, i.e., 00 =0(0 id 0. If f : 0 ( oe, by the above we
have 0oe =0(oe f ffi 00 =0(oe f

Next, suppose \Xi  ` oe; o/ are types in the same context. We define

oe + o/ = Q ff: (oe ( ff) ! (o/ ( ff) ! ff
and show under the assumption of identity extension and extensionality that this defines a
coproduct of oe and o/ in LinType\Xi .

First define terms inoe : oe ( oe + o/ , ino/ : o/ ( oe + o/ as

inoe = *ffix : oe: \Lambda ff: *f : oe ( ff: *g : o/ ( ff: f (x)

ino/ = *ffiy : o/: \Lambda ff: *f : oe ( ff: *g : o/ ( ff: g(y)

For any pair of maps f : oe ( !, g : o/ ( ! define the copairing [f; g] : oe + o/ ( ! as

[f; g] = *ffix : oe + o/: x ! !f !g;
then clearly [f; g](inoe(x)) = f (x) and [f; g](ino/ (y)) = g(y), and so oe + o/ is a weak coproduct
of oe and o/ in LinType\Xi . We remark that the copairing constructor can also be defined as
a polymorphic term

[-; -] : \Lambda ff: (oe ( ff) ! (o/ ( ff) ! oe + o/ ( ff
of intuitionistic function type. Of course we can define an even more general copairing by
abstracting oe; o/ as well.

Lemma 2.5. If h : ! ( !0, f : oe ( ! and g : o/ ( !, then using extensionality and identity
extension, it is provable that [h ffi f; h ffi g] =oe+o/(!0 h ffi [f; g].

24 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
Proof. Since

f (eqoe ( hhi)h ffi f

g(eqo/ ( hhi)h ffi g

for any x : oe + o/ ,

(x ! !f !g)hhi(x !0 !(h ffi f ) !(h ffi g))

by identity extension, i.e., h([f; g](x)) = [h ffi f; h ffi g](x).

Lemma 2.6. Using extensionality and identity extension, [inoe; ino/ ] =oe+o/(oe+o/ id oe+o/ is
provable.

Proof. Given any !; a : oe ( !; b : o/ ( !, we have

[a; b]([inoe; ino/ ](x)) =! [[a; b] ffi inoe; [a; b] ffi ino/ ](x) =! [a; b](x)
for any x : oe + o/ . By unfolding the definition of [a; b] in the above equality we get

[inoe; ino/ ](x) ! !a !b =! x ! !a !b:
Since !; a; b were arbitrary, extensionality (and Lemma 1.37) implies [inoe; ino/ ](x) =oe+o/ x
for all x.

Proposition 2.7. For any f : oe ( !, g : o/ ( ! and h : oe + o/ ( !, if h ffi inoe =oe(! f
and h ffi ino/ =o/(! g, then it is provable using identity extension and extensionality that
h =oe+o/(! [f; g]. Thus oe + o/ is a coproduct of oe and o/ in LinType\Xi .

Proof.

[f; g] =oe+o/(! [h ffi inoe; h ffi ino/ ] =oe+o/(! h ffi [inoe; ino/ ] =oe+o/(! h

2.5. Terminal objects and products. The initial object 0 is also weakly terminal, since
for any type oe,

\Omega oe(0 = Y oe !id oe(0

is a term of type oe ( 0. In fact, using parametricity, 0 can be proved to be terminal.

Proposition 2.8. Suppose f; g : oe ( 0. Using identity extension and extensionality it is
provable that f =oe(0 g. Thus 0 is a terminal object in LinType\Xi  for any \Xi .

Proof. We will prove

8x; y : 0: x =0 y

which, by extensionality, implies the proposition. Suppose we are given x; y : 0. The term

*ffiz : 0: z 0 ( oe y
has type 0 ( oe, and thus is equal to 0oe. This means that x oe =oe x 0 ( oey. Likewise
x 0 ( oey =oe y oe, so x oe =oe y oe. Since this holds for all oe, by extensionality x =0 y.

LINEAR ABADI & PLOTKIN LOGIC 25
Suppose oe; o/ are types in the same context \Xi . Define

oe * o/ = Q ff: (oe ( ff) + (o/ ( ff) ( ff:
This defines a weak product in LinType\Xi  with projections ssoe : oe*o/ ( oe and sso/ : oe*o/ ( o/
defined as ss

oe = *ffix : oe * o/: x oe (inoe(oeidoe)
sso/ = *ffix : oe * o/: x o/ (ino/(o/ id o/ )

The pairing of terms f : ! ( oe and g : ! ( o/ is hf; gi : ! ( oe * o/ defined as

hf; gi = *ffix : !: \Lambda ff: *ffih : (oe ( ff) + (o/ ( ff): [*ffiz : oe ( ff: z ffi f; *ffiz : o/ ( ff: z ffi g] h x
Then

ssoe(hf; gi(x)) = hf; gi(x) oe (inoe(oeid oe) = (*ffiz : oe ( oe: z ffi f ) idoe x = f (x)
and so ssoe ffi hf; gi = f and likewise sso/ ffi hf; gi = g proving that oe * o/ defines a weak product.
Lemma 2.9. Using identity extension and extensionality it is provable that for any f : ! (
oe, g : ! ( o/ , k : !0 ( !,

hf; gi ffi k =!0(oe*o/ hf ffi k; g ffi ki

Proof. The lemma is easily proved by the following direct computation using properties of
coproducts established above. The notation (-ffik) below denotes the term *ffiy : ! ( ff: yffik
of type (! ( ff) ( !0 ( ff.

hf ffi k; g ffi ki(x)
=oe*o/ \Lambda ff: *ffih : (oe ( ff) + (o/ ( ff): [*ffiz : oe ( ff: z ffi f ffi k; *ffiz : o/ ( ff: z ffi g ffi k] h x
=oe*o/ \Lambda ff: *ffih: [(- ffi k) ffi (*ffiz : oe ( ff: z ffi f ); (- ffi k) ffi (*ffiz : o/ ( ff: z ffi g)] h x
=oe*o/ \Lambda ff: *ffih: (- ffi k) ffi [(*ffiz : oe ( ff: z ffi f ); (*ffiz : o/ ( ff: z ffi g)] h x
=oe*o/ \Lambda ff: *ffih: [(*ffiz : oe ( ff: z ffi f ); (*ffiz : o/ ( ff: z ffi g)] h (k(x))
=oe*o/ hf; gi ffi k(x)

Lemma 2.10. Identity extension and extensionality implies that hssoe; sso/ i =oe*o/(oe*o/ idoe*o/ .
Proof. We must show that for any x : oe * o/ , any ff and any h : (oe ( ff) + (o/ ( ff)

[*ffiz : oe ( ff: z ffi ssoe; *ffiz : oe ( ff: z ffi sso/ ] h x =ff x ff h
In fact, since we are dealing with coproducts, it suffices to show that for any l : oe ( ff and
k : o/ ( ff l(ss

oe(x)) =ff x ff (inoe(ff l)
k(sso/ (x)) =ff x ff (ino/(ff k)

We just prove the first of these equations. Since

id oe(eqoe ( hli)l
by parametricity of a polymorphic version of in,

inoe(oe(id oe)((eqoe ( hli) + (eqo/ ( hli)inoe(ff(l)
and so by parametricity of x : oe * o/

x oe (inoe(oe id oe)hlix ff (inoe(ff l)
i.e.

ssoe(x)hlix ff (inoe(ff l)

as desired.

26 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
Proposition 2.11. Suppose h : ! ( oe * o/ is such that ssoe ffi h =!(oe f and sso/ ffi h =!(o/ g
then it is provable using identity extension and extensionality that h =!(oe*o/ hf; gi. Thus
oe * o/ is a product of oe and o/ in LinType\Xi .

Proof.

h =!(oe*o/ hssoe; sso/ i ffi h =!(oe*o/ hssoe ffi h; sso/ ffi hi =!(oe*o/ hf; gi:

2.6. Natural Numbers. We define the type of natural numbers as

N = Q ff: (ff ( ff) ! ff ( ff:
We further define terms 0 : N, s : N ( N as

0 = \Lambda ff: *f : ff ( ff: *ffix : ff: x; s = *ffiy : N: \Lambda ff: *f : ff ( ff: *ffix : ff: f (y ff !f x)
and prove that (N; 0; s) is a weak natural numbers object in each LinType\Xi , and, using
parametricity and extensionality, an honest natural numbers object.

Suppose we are given a type oe, a term a : oe and a morphism b : oe ( oe. We can then
define h : N ( oe as h(y) = y oe !b a. Then clearly h(0) = a, and h(s x) = b(x oe !b a) = b(h(x)),
so (N; 0; s) is a weak natural numbers object.

We can express the weak natural numbers object property as: for all a; b, there exists
an h such that

I 0 ffi

a

ffi@
@@
@@
@@
@ N

h
ffi

s ffiN

h
ffioe b ffioe

commutes.
Lemma 2.12. Identity Extension and extensionality implies

8x : N: x N !s 0 =N x

Proof. Suppose we are given oe; a; b and define h as above. Since b ffi h = h ffi s and h 0 = a,
we have s(hhi ( hhi)b and 0hhia, by parametricity of x, (x N !s 0)hhi(x oe !b a), i.e.,

(x N !s 0) oe !b a =oe x oe !b a:
Letting oe range over all types and a; b over all terms, using extensionality and Lemma 1.37,
we have

x N !s 0 =N x;

as desired.

We can now prove that N is a natural numbers object in each LinType\Xi .

Lemma 2.13. Assuming identity extension and extensionality, given oe; a; b, the map h
defined as above is up to internal equality the unique h0 such that h0(0) = a, h0(sx) = b(h0 x).

Proof. Suppose h0 satisfies the requirements of the lemma. Then s(hh0i ( hh0i)b and 0hh0ia
(this is just a reformulation of the requirements), so for arbitrary x : N, by parametricity of
x,

x oe !b a =oe h0(x N !s 0) =oe h0(x):

Thus, by extensionality, h0 =N(oe h.

LINEAR ABADI & PLOTKIN LOGIC 27
2.6.1. Induction principle. The parametricity principle for the natural numbers implies,
that if R : AdmRel(N; N), and x : N, then

(x N)((R ( R) ! R ( R)(x N):
So if s(R ( R)s and R(0; 0), then

(x N !s 0)R(x N !s 0):
By Lemma 2.12, x N !s 0 =N x, so we can conclude that R(x; x). If OE is a proposition on
N such that (x : N; y : N): OE(x) is admissible, then from parametricity we obtain the usual
induction principle

(OE(0) ^ 8x : N: OE(x) oe OE(s(x))) oe 8x : N: OE(x):

2.7. Types as functors.
Definition 2.14. We say that ~ff ` oe : Type is an inductively constructed type, if it can be
constructed from free variables ~ff and closed types using the type constructors of PILLY ,
i.e., (; \Omega ; I; ! and Q ff:.

For example, all types of pure PILLY are inductively defined, and if oe is a closed type
then Q ff: oe * ff is an inductively constructed type. However, some models may contain
types that are not inductively constructed! For example, in syntactical models, any basic
open type, such as the type ff ` lists(ff) is not inductively constructed.

We define positive and negative occurrences of free type variables in inductively defined
types as usual. The type variable ff occurs positive in the type ff and the positive occurrences
of a type variable ff in oe ( o/ are the positive occurrences of ff in o/ and the negative in oe.
The negative occurrences of ff in oe ( o/ are the positive in oe and the negative in o/ . The
positive and negative occurrences of ff in Q fi: oe are the positive and negative occurrences
in oe for ff 6= fi. The rest of the type constructors preserve positive and negative occurrences
of type variables.

If oe(ff; fi) is an inductively defined type in which the free type variable ff appears only
negatively and the free type variable fi appears only positively, then we can consider oe as
a functor LinTypeop\Xi  * LinType\Xi  ! LinType\Xi  for each \Xi  by defining the term

Moe(ff;fi) : Q ff; fi; ff0; fi0: (ff0 ( ff) ! (fi ( fi0) ! oe(ff; fi) ( oe(ff0; fi0);
which behaves as the morphism part of a functor, i.e., it respects composition and preserves
identities. We define Moe(ff;fi) by structural induction on oe. This construction immediately
generalizes to types with fewer or more than two free type variables, each of which appear
only positively or only negatively. This idea of the functorial interpretation of types being
representable by polymorphic terms has also been used in second order lambda calculus
(see e.g. [RP90]).

For the base case of the induction, if oe(ff; fi) = fi, define

Mfi = \Lambda ff; fi; ff0; fi0: *f; g: g:
In the case oe(fi; ff) ( o/ (ff; fi) we define the term

Moe(fi;ff)(o/(ff;fi) :Q
ff; fi; ff0; fi0: (ff0 ( ff) ! (fi ( fi0) ! (oe(fi; ff) ( o/ (ff; fi)) ( oe(fi0; ff0) ( o/ (ff0; fi0)

28 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
by

Moe(fi;ff)(o/(ff;fi) = \Lambda ff; fi; ff0; fi0: *f; g:
*ffih : oe(fi; ff) ( o/ (ff; fi): (Mo/ ff fi ff0 fi0 f g) ffi h ffi (Moe fi0 ff0 fi ff g f ):
For bang types, we define:

M!oe(ff;fi) = \Lambda ff; fi; ff0; fi0: *f : ff0 ( ff: *g : fi ( fi0: *ffix : !oe(ff; fi):

let !y be x in !(Moe(ff;fi) ff fi ff0 fi0 f g y):

For tensor types, we define:

Moe(ff;fi)\Omega o/(ff;fi) = \Lambda ff; fi; ff0; fi0: *f; g: *ffiz : oe(ff; fi) \Omega  o/ (ff; fi):
let x \Omega  y : oe(ff; fi) \Omega  o/ (ff; fi) be z in (Moeff fi ff0 fi0 f g x) \Omega  (Mo/ ff fi ff0 fi0 f g y):

The last case is the case of polymorphic types:

MQ !:oe(ff;fi) = \Lambda ff; fi; ff0; fi0: *f; g: *ffiz : Q !: oe(ff; fi):

\Lambda ! : Type: Moe(ff;fi) ff fi ff0 fi0 f g (z !):

Lemma 2.15. The term Moe respects composition and preserves identities, i.e., for f : ff0 (
ff, f 0 : ff00 ( ff0, g : fi ( fi0, and g0 : fi0 ( fi00,

* Moe(ff;fi) ff fi ff00 fi00!(f ffi f 0) !(g0 ffi g) = (Moe(ff;fi) ff0 fi0 ff00 fi00 !f 0 !g0) ffi (Moe(ff;fi) ff fi ff0 fi0 !f !g);

* Moe(ff;fi)ff fi ff fi !id ff!id fi = idoe(ff;fi):

Proof. The proof proceeds by induction over the structure of oe, and most of it is the same
as in [PA93], except the case of tensor-types and !. These cases are essentially proved in
[Bar97].

Notice that in the proof of Lemma 2.15 we do not need parametricity. Suppose

\Xi  | -; - ` f : ff0 ( ff; g : fi ( fi0:
We shall write oe(f; g) for

Moe(ff;fi)ff fi ff0 fi0 !f !g:

The type of oe(f; g) is oe(ff; fi) ( oe(ff0; fi0). Notice that we apply M to !f; !g, since M is of
intuitionistic function type (! instead of (). By the previous lemma, oe defines a bifunctor
LinTypeop\Xi  * LinType\Xi  ! LinType\Xi  for each \Xi .

First we consider this in the case of only one argument:

Lemma 2.16 (Graph lemma). Assuming identity extension, for any type ff ` oe with ff
occurring only positively and any map f : o/ ( o/ 0

oe[hf i] j hoe(f )i:
Likewise, suppose ff ` oe0 is a type with ff only occurring negatively. Then identity extension
implies

oe[hf i] j hoe(f )iop;

where hoe(f )iop is (x : oe(o/ ); y : oe(o/ 0)): hoe(f )i(y; x).

Proof. We will only prove the first half of the lemma; the other half is proved the same
way. Since ff occurs only positively in oe, we will assume for readability that Moe has typeQ

ff; fi: (ff ( fi) ! oe(ff) ( oe(fi).

By parametricity of Moe, we have, for any pair of admissible relations ae : AdmRel(ff; ff0)
and ae0 : AdmRel(fi; fi0),

(Moe ff fi)((ae ( ae0) ! (oe[ae] ( oe[ae0]))(Moe ff0 fi0): (2.1)

LINEAR ABADI & PLOTKIN LOGIC 29
Let f : o/ ( o/ 0 be arbitrary. If we instantiate (2.1) with ae = eqo/ and ae0 = hf i, we get

(Moe o/ o/ )((eqo/ ( hf i) ! (eqoe(o/) ( oe[hf i]))(Moe o/ o/ 0);
using the identity extension schema. Since id o/ (eqo/ ( hf i)f ,

!id o/ !(eqo/ ( hf i)!f;
and using Moe o/ o/ 0 !f = oe(f ) we get

idoe(o/)(eqoe(o/) ( oe[hf i])oe(f );
i.e.,

8x : oe(o/ ): x(oe[hf i])(oe(f )x):

We have thus proved hoe(f )i implies oe[hf i].

To prove the other direction, instantiate (2.1) with the admissible relations ae = hf i,
ae0 = eqo/0 for f : o/ ( o/ 0. Since f (hf i ( eqo/0)id o/0,

oe(f )(oe[hf i] ! eqoe(o/0))id oe(o/0):
So for any x : oe(o/ ) and y : oe(o/ 0) we have x(oe[hf i])y implies oe(f )x =oe(o/0) y. This just means
that oe[hf i] implies hoe(f )i.

2.8. Existential types. In this section we consider existential or sum types. If \Xi ; ff ` oe is
a type, we define the type \Xi  ` ` ff: oe as`

ff: oe = Q fi: (Q ff: oe ( fi) ( fi
In fact, this defines a functor

LinType\Xi ;ff ! LinType\Xi 
with functorial action as defined in Section 2.7. In this section we show that this functor is
left adjoint to the weakening functor

LinType\Xi  ! LinType\Xi ;ff
mapping a type \Xi  ` oe to \Xi ; ff ` oe. In other words, we show that for any type \Xi  ` o/ , there is a
one-to-one correspondence between terms \Xi  ` t : (` ff: oe) ( o/ and terms \Xi ; ff ` oe ( o/ if we
consider terms up to internal equality provable using identity extension and extensionality.

First define the term

pack : Q ff: (oe ( ` ff: oe)

as \Lambda ff: *ffix : oe: \Lambda fi: *ffif : Q ff: (oe ( fi): f ff x. The correspondence is as follows. Suppose
first \Xi ; ff ` t : oe ( o/ . Then \Xi  ` ^t : (` ff: oe) ( o/ is *ffix : (` ff: oe): x o/ (\Lambda ff: t). If \Xi  `
s : (` ff: oe) ( o/ then \Xi ; ff ` ~s : oe ( o/ is defined to be *x : oe: s(pack ff x).

Now, suppose we start with a term \Xi ; ff ` t : oe ( o/ then

~^t = *ffix : oe: (*ffiy : ` ff: oe: y o/ (\Lambda ff: t)) (pack ff x)

= *ffix : oe: pack ff x o/ (\Lambda ff: t)
= *ffix : oe: (\Lambda ff: t) ff x
= t:

It remains to prove that ^~s is equal to s for any \Xi  ` s : (` ff: oe) ( o/ . For this we need to
use identity extension.

30 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
Lemma 2.17. Suppose x : ` ff: oe, o/; o/ 0 are types and f : o/ ( o/ 0; g : Q ff: oe ( o/ . Then
using identity extension and extensionality,

x o/ 0 (\Lambda ff: f ffi (g ff)) =o/0 f (x o/ g)

Proof. Using identity extension on g it is easy to see that g(Q ff: oe ( hf i)\Lambda ff: f ffi (g ff). If
x : ` ff: oe then by identity extension

x o/ ghf ix o/ 0 (\Lambda ff: f ffi (g ff))
which is what we needed to prove.

Lemma 2.18. It is provable using identity extension and extensionality that

8x : (` ff: oe): x ` ff: oe pack =` ff:oe x

Proof. Suppose we are given fi and f : Q ff: oe ( fi. We show that

x fi f =fi x (` ff: oe) pack fi f
Define f 0 = *ffix : (` ff: oe) x fi f of type (` ff: oe) ( fi. By Lemma 2.17

x fi (\Lambda ff: f 0 ffi (pack ff)) =fi f 0(x ` ff: oe pack) =fi x ` ff: oe pack fi f
so we just need to show that \Lambda ff: f 0 ffi (pack ff) is internally equal to f . But

\Lambda ff: f 0 ffi (pack ff) ff y =fi f 0 (pack ff y) =fi pack ff y fi f =fi f ff y:

Proposition 2.19. Suppose \Xi  ` s : (` ff: oe) ( o/ . It is provable using identity extension
and extensionality that ^~s is internally equal to s.

Proof. ^

~s(x) =o/ x o/ (\Lambda ff: *ffix0 : oe: s (pack ff x0)) =o/ s (x ` ff: oe pack) =o/ s x

where for the second equality we have used Lemma 2.17.

Parametricity induces the following reasoning principle for existential types.
Proposition 2.20. For x; y : ` ff: oe(ff) the following is equivalent to internal equality of x
and y.

9ff; fi; R : AdmRel(ff; fi); x0 : oe(ff); y0 : oe(fi): x = pack ff x0 ^ y = pack fi y0 ^ oe[R](x0; y0):
As a special case we get the following principle:

8x : ` ff: oe(ff): 9ff; x0 : oe(ff): x =` ff:oe(ff) pack ff x0

Proof. Let us for simplicity write O/ for
(x; y): 9ff; fi; R : AdmRel(ff; fi); x0 : oe(ff); y : oe(fi): x = pack ff x0 ^ y = pack fi y0 ^ oe[R](x0; y0):

We now prove that, for any pair of types o/; o/ 0, any admissible relation S : AdmRel(o/; o/ 0),
and any pair of maps t; t0 we have

(t; t0) : eq` ff:oe ( S
iff

(t; t0) : O/ ( S

and the two implications of the first part of the proposition follows from the case of t; t0
both being identity and taking S to be respectively O/ and eq` ff:oe.

LINEAR ABADI & PLOTKIN LOGIC 31
First notice that

\Xi  | x; y ` O/(x; y) oe S(t(x); t0(y))===============================================================

\Xi ; ff; fi | R : AdmRel(ff; fi) | x; y; x0; y0 ` oe[R](x0; y0) oe S(t(pack ff x0); t0(pack fi y0))===============================================================

\Xi ; ff; fi | R : AdmRel(ff; fi) | x0; y0 ` oe[R](x0; y0) oe S(~t(x0); ~t0(y0))
so it suffices to show that

\Xi  | x; y ` x =` ff:oe(ff) y oe S(t(x); t0(y))=================================================

\Xi ; ff; fi | R : AdmRel(ff; fi) | x0; y0 ` oe[R](x0; y0) oe S(~t(x0); ~t0(y0))
i.e., that (t; t0) preserve relations iff (~t; ~t0) do.

First assume (t; t0) preserve relations. By parametricity of pack,

(pack ff; pack fi) : oe[R] ( eq;
and so since ~t = t ffi (pack ff) and ~t0 = t0 ffi (pack fi) the pair (~t; ~t0) preserve relations. On the
other hand, if (~t; ~t0) preserve relations then

(\Lambda ff: ~t; \Lambda fi: ~t0) : 8ff; fi; R : AdmRel(ff; fi): oe[R] ( S;
and so by parametricity, if eq` ff:oe(ff)(x; y) then

(t(x); t0(y)) = (x ` ff: oe(ff) (\Lambda ff: ~t); y ` ff: oe(ff) (\Lambda fi: ~t0)) 2 S

2.9. Initial algebras. Suppose ff ` oe : Type is an inductively constructed type in which ff
occurs only positively. As we have seen earlier, such a type induces a functor

LinType\Xi  ! LinType\Xi 
for each \Xi . We aim to define an initial algebra for this type.

Define the closed type

uff: oe(ff) = Q ff: (oe(ff) ( ff) ! ff;
and define

fold : Q ff: (oe(ff) ( ff) ! (uff: oe(ff) ( ff)

as

fold = \Lambda ff: *f : oe(ff) ( ff: *ffiu : uff: oe(ff): u ff !f;

and

in : oe(uff: oe(ff)) ( uff: oe(ff)

as

in z = \Lambda ff: *f : oe(ff) ( ff: f (oe(fold ff !f ) z):

Lemma 2.21. For any algebra f : oe(o/ ) ( o/ , foldo/ !f is a map of algebras from (uff: oe(ff); in)
to (o/; f ), i.e., the diagram

oe(uff: oe(ff)) in ffi
oe(fold o/ !f)

ffi

uff: oe(ff)

fold o/ !f
ffioe(o/ ) f ffio/

commutes.

32 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
Proof. For x : oe(uff: oe(ff))

(fold o/ !f ) ffi in x = in x o/ !f = f (oe(fold o/ !f ) x);
as desired.

In words we have shown that in defines a weakly initial algebra for the functor defined
by oe in LinType\Xi  for each \Xi . Notice that parametricity was not needed in this proof.

Lemma 2.22. Suppose \Xi  | \Gamma ; - ` f : oe(o/ ) ( o/ and \Xi  | \Gamma ; - ` g : oe(!) ( ! are algebras
for oe, and \Xi  | \Gamma ; - ` h : o/ ( ! is a map of algebras, i.e., h f = g oe(h). Then, assuming
identity extension and extensionality,

h ffi (fold o/ !f ) =uff:oe(ff)(! fold ! !g:

Proof. Since h is a map of algebras

f (hoe(h)i ( hhi)g;
so by the Graph Lemma (2.16)

f (oe[hhi] ( hhi)g

and by Lemma 1.33

!f (!(oe[hhi] ( hhi))!g:

Clearly (fold; fold) 2 eqQ ff:(oe(ff)(ff)!(uff:oe(ff)(ff) , and thus, by identity extension,

(fold; fold) 2 Q ff: (oe(ff) ( ff) ! (fi ( ff)[equff:oe(ff)=fi];
so for any x : uff: oe(ff),

(fold o/ !f x)hhi(fold ! !g x);

i.e.,

h ffi (fold o/ !f ) =uff:oe(ff)(! fold ! !g;

as desired.

Lemma 2.23. Using identity extension and extensionality,

fold uff: oe(ff) !in =uff:oe(ff)(uff:oe(ff) id uff:oe(ff):

Proof. By Lemma 2.22 we know that for any type o/ , f : oe(o/ ) ( o/ and u : uff: oe(ff)

(fold o/ !f ) ffi (fold uff: oe(ff) !in) u =o/ fold o/ !f u:
The left hand side of this equation becomes

fold o/ !f (u uff: oe(ff) !in) = (u uff: oe(ff) !in)o/ !f
and, since the right hand side is simply

u o/ !f;
the lemma follows from Lemma 1.37.

Theorem 2.24. Consider an algebra \Xi  | -; - ` f : oe(o/ ) ( o/ and a map of algebras
\Xi  | -; - ` h : uff: oe(ff) ( o/ from in to f . Then if we assume identity extension and
extensionality, h =uff:oe(ff)(o/ fold o/ !f:

Proof. By Lemma 2.22 we have

h ffi (fold uff: oe(ff) !in) =uff:oe(ff)(o/ fold o/ !f:
Lemma 2.23 finishes the job.

LINEAR ABADI & PLOTKIN LOGIC 33
We have shown that in defines an initial algebra.
In the logic, the initial algebras also satisfy an induction principle. We now show the
following (relational) induction principle.

Theorem 2.25 (Induction). Suppose R : AdmRel(uff: oe(ff); uff: oe(ff)) satisfies

(in; in) : oe[R] ( R:
Then

8x : uff: oe(ff): R(x; x)

Remark 2.26. The induction principle speaks about relations since it is obtained as a consequence of binary parametricity. In case one also has unary parametricity available (for
some notion of admissible propositions), applying the proof of Theorem 2.25 to unary parametricity will yield the well-known propositional induction principle: If OE is an admissible
proposition on uff: oe(ff), then

(8x : oe(uff: oe(ff)): oe[OE](x) oe OE(in x)) oe 8x : uff: oe(ff): OE(x)

Proof of Theorem 2.25. By parametricity, for any x : uff: oe(ff),

x(8ff; fi; R : AdmRel(ff; fi): (oe[R] ( R) ! R)x
The assumption states that (in; in) : oe[R] ( R and so by Lemma 1.33

(!in; !in) : !(oe[R] ( R):
Thus

R(x uff: oe(ff) !in; x uff: oe(ff) !in):

Finally, Lemma 2.23 tells us that x uff: oe(ff) !in = x, which proves the theorem.

2.10. Final Coalgebras. As in section 2.9 we will assume that ff ` oe(ff) : Type is a type in
which ff occurs only positively, and this time we construct final coalgebras for the induced
functor.

Define

*ff: oe(ff) = ` ff: !(ff ( oe(ff)) \Omega  ff = Q fi: (Q ff: (!(ff ( oe(ff)) \Omega  ff ( fi)) ( fi
with combinators

unfold : Q ff: (ff ( oe(ff)) ! ff ( *ff: oe(ff);

out : *ff: oe(ff) ( oe(*ff: oe(ff))

defined by

unfold = \Lambda ff: *ffif : !(ff ( oe(ff)): *ffix : ff: pack ff (f \Omega  x)

out = *ffix : *ff: oe(ff): x oe(*ff: oe(ff)) r;

where

r : Q ff: !(ff ( oe(ff)) \Omega  ff ( oe(*ff: oe(ff))
r = \Lambda ff: *ffiy : !(ff ( oe(ff)) \Omega  ff: let w \Omega  z be y in oe(unfold ff w)(let !f be w in f z):

Lemma 2.27. For any coalgebra f : o/ ( oe(o/ ), the map unfold o/ !f is a map of coalgebras
from f to out.

34 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
Proof. We need to prove that the following diagram commutes

o/ f ffi
unfold o/ !f

ffi

oe(o/ )

oe(unfold o/ !f)
ffi*ff: oe(ff) out
ffioe(*ff: oe(ff)):

But this is done by a simple computation

out(unfold o/ !f x) = out(pack o/ (!f ) \Omega  x)

= pack o/ (!f ) \Omega  x oe(*ff: oe(ff)) r
= r o/ ((!f ) \Omega  x)
= oe(unfold o/ (!f )) (f x):

Lemma 2.27 shows that out is a weakly final coalgebra for the functor induced by oe on
LinType\Xi  for each \Xi . Notice that parametricity was not needed here.

Lemma 2.28. Suppose h : o/ ( o/ 0 is a map of coalgebras from f : o/ ( oe(o/ ) to f 0 : o/ 0 (
oe(o/ 0). If we assume identity extension, then the diagram

o/
h

ffi

unfold o/ !f

ffi*ff: oe(ff)

o/ 0

unfold o/0 !f0

ffinnn
nnnn

nnnn
nnn

commutes internally.
Proof. Using the Graph Lemma, the notion of h being a map of coalgebras can be expressed
as

f (hhi ( oe[hhi])f 0:

Now, by parametricity of unfold,

unfold o/ !f (hhi ( eq*ff:oe(ff))unfold o/ 0 !f 0;
which is exactly what we wanted to prove.
Lemma 2.29. Given linear contexts C and C0, suppose

8x : oe: 8y : o/: C[x \Omega  y] =! C0[x \Omega  y]:
then

8z : oe \Omega  o/: let x \Omega  y be z in C[x \Omega  y] =! let x \Omega  y be z in C0[x \Omega  y]

Proof. Consider

f = *ffix : oe: *ffiy : o/: C[x \Omega  y] f 0 = *ffix : oe: *ffiy : o/: C0[x \Omega  y]
then

f (eqoe ( eqo/ ( eq!) f 0:

If z : oe \Omega  o/ then by identity extension eqoe \Omega  eqo/ (z; z). By definition of eqoe \Omega  eqo/ we have

let x \Omega  x0 be z in f xx0 =! let x \Omega  x0 be z in f 0xx0
which proves the lemma.

LINEAR ABADI & PLOTKIN LOGIC 35
Lemma 2.30. Using extensionality and identity extension,

unfold *ff: oe(ff) !out
is internally equal to the identity on *ff: oe(ff).

Proof. Set h = unfold *ff: oe(ff) !out in the following.

By Lemma 2.27 h is a map of coalgebras from out to out, so by Lemma 2.28, h = h2.
Intuitively, all we need to prove now is that h is "surjective".

Consider any g : Q ff: (!(ff ( oe(ff)) \Omega  ff ( fi). For any coalgebra map k : ff ( ff0 from
f : ff ( oe(ff) to f 0 : ff0 ( oe(ff0), we must have, by Lemmas 2.16, 1.33, and 1.32,

(!f \Omega  x)(!(hki ( oe[hki]) \Omega  hki)(!f 0 \Omega  kx);
so by identity extension and parametricity of g,

8x : ff: g ff (!f ) \Omega  x =fi g ff0 (!f 0) \Omega  k(x):
Using this on the coalgebra map unfold ff !f from f to out we obtain

8x : ff: g ff (!f ) \Omega  x =fi g *ff: oe(ff) (!out) \Omega  unfold ff !f x:
By Lemma 1.37 this implies that

8f : !(ff ( oe(ff)); x : ff: g ff f \Omega  x =fi g *ff: oe(ff) (!out) \Omega  unfold ff f x;
which implies

8z : !(ff ( oe(ff)) \Omega  ff: g ff z =fi g *ff: oe(ff) (let f \Omega  x be z in (!out) \Omega  unfold ff f x)
using Lemma 2.29.

In other words, if we define

k : Q ff: (!(ff ( oe(ff)) \Omega  ff ( o/ );
where o/ =!(*ff: oe(ff) ( oe(*ff: oe(ff))) \Omega  *ff: oe(ff), to be

k = \Lambda ff: *ffiy :!(ff ( oe(ff)) \Omega  ff: let f \Omega  x be y in (!out) \Omega  unfold ff f x;
then

8ff: g ff =!(ff(oe(ff))\Omega ff(fi (g *ff: oe(ff)) ffi (k ff): (2.2)

Now, suppose we are given ff; ff0; R : Rel(ff; ff0) and terms f; f 0 such that

f (!(R ( oe[R]) \Omega  R)f 0:
Then, by (2.2) and parametricity of g

g ff f =fi g ff0 f 0 =fi (g *ff: oe(ff))(k ff0 f 0);
from which we conclude

g(8(ff; fi; R : Rel(ff; fi)): (!(R ( oe[R]) \Omega  R ( hg *ff: oe(ff)iop))k:
(Here we use Sop for the inverse relation of S.) Using parametricity, this implies that, for
any x : *ff: oe(ff), we have

x fi g =fi g *ff: oe(ff) (x o/ k):

Thus, since g was arbitrary, we may apply the above to g = k and get

x o/ k =o/ k *ff: oe(ff) (x o/ k) = let f \Omega  z be (x o/ k) in (!out) \Omega  unfold ff f z:
If we write

l = *x : *ff: oe(ff): let f \Omega  z be (x o/ k) in unfold ff f z;

36 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
then, since k is a closed term, so is l, and from the above calculations we conclude that we
have

8fi: 8g : Q ff: !(ff ( oe(ff)) \Omega  ff ( fi: x fi g =fi g *ff: oe(ff) (!out) \Omega  (l x):

Now, finally,

h(l x) = unfold *ff: oe(ff) !out (l x)

= pack *ff: oe(ff) !out \Omega  (l x)
= \Lambda fi: *g : Q ff: (!(ff ( oe(ff)) \Omega  ff ( fi): g *ff: oe(ff) !out \Omega  (l x)
=*ff:oe(ff) \Lambda fi: *g : Q ff: (!(ff ( oe(ff)) \Omega  ff ( fi): x fi g

= x;

where we have used extensionality. Thus l is a right inverse to h, and we conclude

h x =*ff:oe(ff) h2(l x) =*ff:oe(ff) h(l x) =*ff:oe(ff) x:

Theorem 2.31. Suppose \Xi  | -; - ` f : o/ ( oe(o/ ) is a coalgebra and \Xi  | -; - ` h : o/ (
uff: oe(ff) is a map of algebras from f to out. Then if we assume identity extension and
extensionality h =o/(uff:oe(ff) unfold ff !f .

Proof. Consider a map of coalgebras into out:

o/ f ffi

h
ffi

oe(o/ )

oe(h)
ffi*ff: oe(ff) out
ffioe(*ff: oe(ff)):

By Lemmas 2.28 and 2.30,

unfold o/ !f =o/(*ff:oe(ff) (unfold *ff: oe(ff) !out) ffi g =o/(*ff:oe(ff) g:

Theorem 2.31 shows that out is a final coalgebra for the endofunctor on LinType\Xi 
induced by oe for each \Xi .

We now show how the final coalgebras satisfy a coinduction principle.

Theorem 2.32 (Coinduction). Suppose that R : AdmRel(*ff: oe(ff); *ff: oe(ff)) is such that

(out; out) : R ( oe[R]:
We then have that

8x; y : *ff: oe(ff): R(x; y) oe x =*ff:oe(ff) y:

Proof. Suppose R : AdmRel(*ff: oe(ff); *ff: oe(ff)) satisfies (out; out) : R ( oe[R] and R(x; y).
By parametricity of

pack : Q ff: !(ff ( oe(ff)) \Omega  ff ( *ff: oe(ff)

we have

pack *ff: oe(ff) !out \Omega  x =*ff:oe(ff) pack *ff: oe(ff) !out \Omega  y

and by 2.30,

pack *ff: oe(ff) !out \Omega  x =*ff:oe(ff) x

pack *ff: oe(ff) !out \Omega  y =*ff:oe(ff) y

which proves the theorem.

LINEAR ABADI & PLOTKIN LOGIC 37
The next theorem is an interesting generalization of Theorem 2.32, stating that the
assumption of admissibility in the coinduction principle is unnecessary. A similar result
was proved by Pitts in the setting of coinductive types in the category of domains [Pit95].
To state this theorem we need again to use the general hypothesis of this section that
oe is an inductively defined type, since in this case we can define oe[R] for general (not
just admissible) relations inductively over the structure of oe using the constructions of
Section 1.2.2. Recall that for more general types oe the construction oe[R] is defined as in
Figure 4 for admissible relations R only.

Theorem 2.33 (General coinduction principle). Suppose R : Rel(*ff: oe(ff); *ff: oe(ff)) is a
relation such that (out; out) : R ( oe[R], then

8x; y : *ff: oe(ff): R(x; y) oe x =*ff:oe(ff) y

Proof. Suppose R : Rel(*ff: oe(ff); *ff: oe(ff)) is any relation satisfying (out; out) : R ( oe[R].
The idea of the proof is to use Theorem 2.32 on the admissible relation \Phi (R). Since by
Lemma 1.35 \Phi  is a functor,

(out; out) : \Phi (R) ( \Phi (oe[R]);
and since oe[\Phi (R)] is an admissible relation containing oe[R] , and \Phi (oe[R]) is the smallest
such, we have \Phi (oe[R]) ae oe[\Phi (R)] and so

(out; out) : \Phi (R) ( oe[\Phi (R)]:
Now, the coinduction principle for admissible relations gives us

8x; y : *ff: oe(ff): \Phi (R)(x; y) oe x =*ff:oe(ff) y
and so the theorem follows from R ae \Phi (R).

2.11. Recursive type equations. In this section we consider inductively constructed
types ff ` oe(ff) and construct closed types rec ff: oe(ff) such that oe(rec ff: oe(ff)) ,= rec ff: oe(ff).
In Sections 2.9 and 2.10 we solved the problem in the special case of ff occurring only positively in oe, by finding initial algebras and final coalgebras for the functor induced by oe.

This section details the sketch of [Plo93], but the theory is due to Freyd [Fre90b, Fre90a,
Fre91]. In short, the main observation is that because of the presence of fixed points, the
initial algebras and final coalgebras of Sections 2.9, 2.10 coincide (Theorem 2.39 below). This
phenomenon is called algebraic compactness, and was studied by Freyd in loc. cit.. Using
Freyd's techniques we find solutions to recursive type equations as advertised, and show
that they satisfy a universal property called the initial dialgebra property. Moreover, we
generalize the induction and coinduction properties of Theorems 2.25, 2.33 to a combined
induction/coinduction property for recursive types. In Section 2.13 we treat the case of
recursive type equations with parameters.

Before we start, observe that we may split the occurrences of ff in oe into positive and
negative occurrences. So our standard assumption in this section is that we are given a
type ff; fi ` oe(ff; fi), in which ff occurs only negatively and fi only positively, and we look
for a type rec ff: oe(ff; ff) isomorphic to oe(rec ff: oe(ff; ff); rec ff: oe(ff; ff)). In this notation,
rec ff: oe(ff; ff) binds ff in oe.

38 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
2.11.1. Parametrized initial algebras. Set !(ff) = ufi: oe(ff; fi) = Q fi: (oe(ff; fi) ( fi) ( fi.
Now, ! induces a contravariant functor from types to types.

Lemma 2.34. Assuming identity extension and extensionality, for f : ff0 ( ff, up to internal equality !(f ) : !(ff) ( !(ff0) is the unique h such that

oe(ff; !(ff))
oe(id;h)

ffi

in ffi!(ff)

h
ffi
oe(ff; !(ff0))
oe(f;id)

ffioe(ff
0; !(ff0)) in ffi!(ff0)

commutes internally.
Proof. One may define in as a polymorphic term

in : Q ff: oe(ff; !(ff)) ( !(ff)
by

in = \Lambda ff: *ffiz : oe(ff; !(ff)): \Lambda fi: *f : oe(ff; fi) ( fi: f (oe(*x : ff: x; fold fi !f ) z):

By parametricity we have

in ff0(oe(hf i; !(hf i)) ( !(hf i))in ff;
which, by the Graph Lemma (Lemma 2.16), means that

in ff0(hoe(f; !(f ))iop ( h!(f )iop)in ff;
which in turn amounts to internal commutativity of the diagram of the lemma.

Uniqueness is by initiality of in (in LinTypeff, proved as before) used on the diagram

oe(ff; !(ff))
oe(id;h)

ffi

in ffi!(ff)

h
ffioe(ff; !(ff
0)) oe(f;id)ffioe(ff0; !(ff0)) in ffi!(ff0):

2.11.2. Dialgebras.
Definition 2.35. A dialgebra for oe is a quadruple (o/; o/ 0; f; f 0) such that o/ and o/ 0 are types,
and f : oe(o/ 0; o/ ) ( o/ and f 0 : o/ 0 ( oe(o/; o/ 0) are morphisms. A morphism of dialgebras from
dialgebra (o/0; o/ 00; f0; f 00) to (o/1; o/ 01; f1; f 01) is a pair of morphisms h : o/0 ( o/1, h0 : o/ 01 ( o/ 00,
such that

oe(o/ 00; o/0)

f0

ffi

oe(h0;h)

ffi

o/0

h
ffioe(o/ 0
1; o/1) f1 ffio/1

o/ 01

f01

ffi

h0

ffi

oe(o/1; o/ 01)

oe(h;h0)
ffio/
00

f00

ffioe(o/0; o/ 00):

LINEAR ABADI & PLOTKIN LOGIC 39
Lemma 2.36. If (h; h0) is a map of dialgebras and h; h0 are isomorphisms, then (h; h0) is
an isomorphism of dialgebras.

Proof. The only thing to prove here is that (h-1; (h0)-1) is in fact a map of dialgebras,
which is trivial.

Remark 2.37. If we for the type ff; fi ` oe : Type consider for each \Xi  the endofunctor

hoeop; oei : LinTypeop\Xi  * LinType\Xi  ! LinTypeop\Xi  * LinType\Xi 
defined by (ff; fi) 7! (oe(fi; ff); oe(ff; fi)), then dialgebras for oe are exactly the algebras for
hoeop; oei, maps of dialgebras are maps of algebras for hoeop; oei and initial dialgebras correspond to initial algebras. Dialgebras as considered here are a special case of what Hagino
calls F , G-dialgebras in his thesis [Hag87], for F being hoeop; oei and G being the identity
functor.

Theorem 2.38. Assuming identity extension and extensionality, initial dialgebras exist for
all functors induced by types oe(ff; fi), up to internal equality.

Proof. In this proof, commutativity of diagrams will mean commutativity up to internal
equality.

Set !(ff) = ufi: oe(ff; fi). Then, ! defines a contravariant functor. Define

o/ 0 = *ff: oe(!(ff); ff); o/ = !(o/ 0) = ufi: oe(o/ 0; fi):
Since o/ 0 is defined as the final coalgebra for a functor, we have a morphism

out : o/ 0 ( oe(!(o/ 0); o/ 0) = oe(o/; o/ 0);
and since o/ is defined to be an initial algebra, we get a morphism

in : oe(o/ 0; o/ ) ( o/:
We will show that (o/; o/ 0; in; out) is an initial dialgebra.

Suppose we are given a dialgebra (o/0; o/ 00; g; g0). Since in is an initial algebra, there exists
a unique map a, such that

oe(o/ 00; !(o/ 00)) in ffi

oe(id;a)

ffi

!(o/ 00)

a
ffioe(o/ 0
0; o/0)

g

ffio/0;

and thus, since out is a final coalgebra, we find a map h0 making the diagram

o/ 00

g0

ffi

h0

ffi

oe(o/0; o/ 00)

oe(a;id)

ffioe(!(o/ 00); o/ 00)

oe(!(h0);h0)
ffi
o/ 0

out ffioe(!(o/ 0); o/ 0)

(2.3)

commute. Set h = a ffi !(h0). We claim that (h; h0) defines a map of dialgebras. The
second diagram of Definition 2.35 is simply (2.3). The first diagram of 2.35 follows from

40 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
the commutativity of the composite diagram

oe(o/ 0; !(o/ 0)) in ffi
oe(h0;!(h0))

ffi

!(o/ 0)

!(h0)
ffioe(o/
00; !(o/ 00)) in ffi

oe(id;a)

ffi

!(o/ 00)

a
ffioe(o/ 0
0; o/0)

g

ffio/0;

(2.4)

where the top diagram commutes by Lemma 2.34.

Finally, we will prove that (h; h0) is the unique dialgebra morphism. Suppose we are
given a map of dialgebras (k; k0) from (o/; o/ 0; in; out) to (o/0; o/ 00; g; g0). By the first diagram
of Definition 2.35, we have a commutative diagram

oe(o/ 0; o/ ) in ffi
oe(id;k)

ffi

o/

k
ffioe(o/ 0; o/
0)

oe(k0;id)

ffioe(o/ 00; o/0) g ffio/0:

Since clearly (2.4) also commutes when k0 is substituted for h0, by (strong) initiality of in,
we conclude that k =o/(o/0 a ffi !(k0). Finally, by the second diagram of Definition 2.35 we
have commutativity of

o/ 00
k0

ffi

g0

ffioe(o/0; o/ 00) oe(a;id)ffioe(!(o/ 00); o/ 00)

oe(!(k0);k0)
ffi
o/ 0

out ffioe(!(o/ 0); o/ 0):

So since out is a final coalgebra we conclude k0 =o/00(o/0 h0.

2.11.3. Algebraic compactness. As advertised in the introduction to this section, the presence of fixed points makes initial algebras and final coalgebras coincide.

Theorem 2.39 (Algebraic compactness). Assuming identity extension and extensionality,
for all types ff ` oe(ff) in which ff occurs only positively, in-1 is internally a final coalgebra
and out-1 is internally an initial algebra. Furthermore in-1 and out-1 can be written as
terms of PILLY .

Proof. By Theorems 2.24 and 2.31 in is an initial algebra, and out is a final coalgebra for
oe. Consider

h = Y (*ff: oe(ff)) ( uff: oe(ff) (*h : *ff: oe(ff) ( uff: oe(ff): in ffi oe(h) ffi out):
Since Y is a fixed-point operator, we know that

oe(*ff: oe(ff))

oe(h)

ffi

*ff: oe(ff)outffi

h
ffioe(uff: oe(ff)) in
ffiuff: oe(ff)

LINEAR ABADI & PLOTKIN LOGIC 41
commutes. Since in-1 is a coalgebra, we also have a map k going the other way, and since
out is a final coalgebra, k ffi h =*ff:oe(ff)(*ff:oe(ff) id *ff:oe(ff). Since in is an initial algebra, we

know that h ffi k =uff:oe(ff)(uff:oe(ff) id uff:oe(ff). So in-1 ,= out as coalgebras and out-1 ,= in as
algebras, internally.

Lemma 2.40. Assume identity extension and extensionality. Let (o/; o/ 0; in; out) be the initial
dialgebra from the proof of Theorem 2.38. Then (o/ 0; o/; out-1; in-1) is also an initial dialgebra
internally.

Proof. In this proof, commutativity of diagrams is up to internal equality.

Suppose we are given a dialgebra (o/0; o/ 00; g; g0). We will show that there exists a unique
morphism of dialgebras from (o/ 0; o/; out-1; in-1) to (o/0; o/ 00; g; g0).

By Theorem 2.39, for all types ff, in-1 : !(ff) ( oe(ff; !(ff)) is a final coalgebra for
the functor fi 7! oe(ff; fi), and out-1 : oe(o/; o/ 0) ( o/ 0 is an initial algebra for the functor
ff 7! oe(!(ff); ff).

Let a be the unique map making the diagram

o/ 00

g0

ffi

a

ffi

oe(o/0; o/ 00)

oe(id;a)
ffi!(o/
0)

in-1ffioe(o/0; !(o/0))

commute. Define h to be the unique map making

oe(o/; o/ 0) out

-1

ffi

oe(!(h);h)

ffi

o/ 0

h
ffioe(!(o/
0); o/0)

oe(a;id)

ffioe(o/ 00; o/0) g ffio/0

(2.5)

commute. We define h0 to be !(h) ffi a and prove that (h; h0) is a map of dialgebras. The first
diagram of Definition 2.35 is simply (2.5). Commutativity of the second diagram follows
from commutativity of

o/ 00 g

0

ffi

a

ffi

oe(o/0; o/ 00)

oe(id;a)
ffi!(o/
0)

!(h)

ffi

in-1ffioe(o/0; !(o/0))

oe(h;!(h))
ffi!(o/
0) in-

1

ffioe(o/ 0; !(o/ 0));

(2.6)

where commutativity of the last diagram follows from Lemma 2.34.

Finally, we will show that if (k; k0) is another map of dialgebras from the dialgebra
(o/ 0; o/; out-1; in-1) to (o/0; o/ 00; g; g0) then h =o/0(o/0 k and h0 =o/00(o/ k0. By the second diagram
of Definition 2.35 we know that

o/ 00

g0

ffi

k0

ffi

oe(o/0; o/ 00)

oe(k;id)

ffioe(o/ 0; o/ 00)

oe(id;k0)
ffio/ in-1
ffioe(o/ 0; o/ )

(2.7)

42 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
commutes. Clearly, if we substitute k for h in (2.6), we obtain a diagram that commutes
by Lemma 2.34. So, using the fact that in-1 is a final coalgebra on (2.7), we get k0 =o/0

0(o/!(k) ffi a.

The first diagram of Definition 2.35 implies that

oe(o/; o/ 0) out

-1

ffi

oe(!(k);k)

ffi

o/ 0

k
ffioe(!(o/
0); o/0)

oe(a;id)

ffioe(o/ 00; o/0) g ffio/0

commutes. Comparing this to (2.5) we obtain h =o/0(o/0 k, by initiality of out-1.
Theorem 2.41. Assuming identity extension and extensionality, for all types oe(ff; fi) where
ff occurs only negatively and fi only positively, there exists a type rec ff: oe(ff; ff) and an
isomorphism

i : oe(rec ff: oe(ff; ff); rec ff: oe(ff; ff)) ( rec ff: oe(ff; ff);

such that (rec ff: oe(ff; ff); rec ff: oe(ff; ff); i; i-1 ) is an initial dialgebra up to internal equality.

Proof. As usual commutativity of diagrams will be up to internal equality.

We have a unique map of dialgebras

(h; h0) : (o/; o/ 0; in; out) ! (o/ 0; o/; out-1; in-1)
We claim that (h0; h) is also a map of dialgebras from (o/; o/ 0; in; out) to (o/ 0; o/; out-1; in-1).
To prove this we need to prove commutativity of the diagrams

oe(o/ 0; o/ ) in ffi
oe(h;h0)

ffi

o/

h0
ffioe(o/; o/ 0) out-1
ffio/ 0

o/ in

-1

ffi

h

ffi

oe(o/ 0; o/ )

oe(h0;h)
ffi
o/ 0

out ffioe(o/; o/ 0)

;

but the fact that (h; h0) is a map of dialgebras tells us exactly that

oe(o/ 0; o/ ) in ffi
oe(h0;h)

ffi

o/

h
ffioe(o/; o/ 0) out-1
ffio/ 0

o/ in

-1

ffi

h0

ffi

oe(o/ 0; o/ )

oe(h;h0)
ffi
o/ 0

out ffioe(o/; o/ 0);

and these two diagram are the same as the above but in opposite order. Thus, by uniqueness
of maps of dialgebras out of (o/; o/ 0; in; out), we get h =o/(o/0 h0. Since (h; h) is a map between
initial dialgebras, h is an isomorphism.

Now define f : oe(o/; o/ ) ( o/ to be in ffi oe(h-1; id o/ ). Then clearly (id o/ ; h-1) is a morphism
of dialgebras from (o/; o/; f; f -1) to (o/; o/ 0; in; out), since the diagrams proving (id o/ ; h-1) to
be a map of dialgebras are

oe(o/; o/ )
oe(h-1;id)

ffi

oe(h-1;id)

ffi

f

ffioe(o/ 0; o/ ) in ffio/

id
ffioe(o/ 0; o/ ) in ffio/

o/ 0

out ffi

h-1

ffi

oe(o/; o/ 0)

oe(id;h-1)
ffio/ in-1
ffi

f-1

ffioe(o/
0; o/ ) oe(h;id)ffioe(o/; o/ ):

LINEAR ABADI & PLOTKIN LOGIC 43
Clearly the first diagram commutes, and the second diagram is just part of the definition
of (h; h) being a map of dialgebras. Thus (id o/ ; h-1) defines an isomorphism of dialgebras
from (o/; o/; f; f -1) to (o/; o/ 0; in; out), as desired.

Notice that the closed terms rec ff: oe(ff; ff) ( oe(rec ff: oe(ff; ff); rec ff: oe(ff; ff)) and

oe(rec ff: oe(ff; ff); rec ff: oe(ff; ff)) ( rec ff: oe(ff; ff)
always exist, independent of the assumption of parametricity. Parametricity implies that
they are each others inverses.

2.12. A mixed induction/coinduction principle. Here we prove the following reasoning principle for the recursive type rec ff: oe(ff; ff). This principle is the same as the one
obtained by Pitts for recursive types in the category domains [Pit95, Cor 4.10]. Again, as
noted before Theorem 2.33 we must assume that oe is an inductively defined type to make
sense of the relational interpretation of oe at general non-admissible relations.

Theorem 2.42. Suppose ff; fi ` oe(ff; fi) is an inductively defined type in which ff occurs
only positively and fi only negatively. Suppose further

R- : Rel(rec ff: oe(ff; ff); rec ff: oe(ff; ff)) and
R+ : : AdmRel(rec ff: oe(ff; ff); rec ff: oe(ff; ff))

are relations. Then the following principle holds

(i-1; i-1) : R- ( oe(R+; R-) (i; i) : oe(R-; R+) ( R+

R- ae eqrec ff:oe(ff;ff) ae R+
where i denotes the isomorphism

oe(rec ff: oe(ff; ff); rec ff: oe(ff; ff)) ( rec ff: oe(ff; ff):

Proof. We first prove the rule in the case of both relations being admissible. The proof in
this case is a surprisingly simple consequence of parametricity.

The proof of Theorem 2.41 is constructive in the sense that there is a construction of
the maps h; h0 constituting the unique dialgebra map out of the initial dialgebra from the
given types !; !0 and terms t; t0. In fact, from the proof we can derive terms

k : Q !; !0: (oe(!0; !) ( !) ( (!0 ( oe(!; !0)) ( rec ff: oe(ff; ff) ( !
k0 : Q !; !0: (oe(!0; !) ( !) ( (!0 ( oe(!; !0)) ( !0 ( rec ff: oe(ff; ff)

such that the maps h; h0 can be obtained as

h = k ! !0 t t0
h0 = k0 ! !0 t t0

The exact constructions of k; k0 are not of interest us right now -- what matters to us
is that we can use the assumption of parametricity on them. We consider the case ! =
!0 = rec ff: oe(ff; ff) and t = i and t0 = i-1. In this case of course h = h0 = id . If we use
parametricity of k0 by substituting the relation R- for the type !0 and R+ for ! then we
get since

id = k rec ff: oe(ff; ff) rec ff: oe(ff; ff) i i-1

(id ; id ) : R- ( eqrec ff:oe(ff;ff). Likewise, using parametricity of k we get

(id ; id ) : eqrec ff:oe(ff;ff) ( R+

44 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
which proves the theorem in the case of R- being admissible.

For the general case, we just need a simple application of the closure operator of
Lemma 1.35. So assume again

(i-1; i-1) : R- ( oe(R+; R-);
(i; i) : oe(R-; R+) ( R+;

and R+ is admissible, but R- may not be. The idea is to use the case above on \Phi (R-) and
R+ which are both admissible, but we need to check that the hypothesis still holds for this
case. First, by \Phi  being a functor

(i-1; i-1) : \Phi (R-) ( \Phi (oe(R+; R-)):
But, since oe(R+; \Phi (R-)) is an admissible relation containing oe(R+; R-),

\Phi (oe(R+; R-)) ae oe(R+; \Phi (R-))
and so

(i-1; i-1) : \Phi (R-) ( oe(R+; \Phi (R-)): (2.8)

Since oe(\Phi (R-); R+) ae oe(R-; R+) we also have

(i; i) : oe(\Phi (R-); R+) ( R+: (2.9)
Using the case of admissible relation proved above on (2.8) and (2.9), we get

\Phi (R-) ae eqrec ff:oe(ff;ff) ae R+
which together with R- ae \Phi (R-) proves the theorem in the general case.

2.13. Recursive type equations with parameters. We now consider recursive type
equations with parameters, i.e., we consider types ~ff; ff ` oe(~ff; ff) and look for types ~ff `
rec ff: oe(~ff; ff) satisfying oe(~ff; rec ff: oe(~ff; ff)) ,= rec ff: oe(~ff; ff). As before, we need to split
occurrences of the variable ff into positive and negative occurrences, and since we would
like to be able to construct nested recursive types, we need to keep track of positive and
negative occurrences of the variables ~ff in the solution rec ff: oe(~ff; ff) as well. So we will

suppose that we are given a type ~ff; ~fi; ff; fi ` oe(~ff; ~fi; ff; fi) in which the variables ~ff; ff occur
only negatively and the variables ~fi; fi only positively.

Of course, the proof proceeds as in the case without parameters. However, one must
take care to obtain the right occurrences of parameters, and so we sketch the proof here.

Lemma 2.43. Suppose ~ff; ~fi; ff; fi ` oe(~ff; ~fi; ff; fi) is a type in which the variables ~ff; ff occur
only negatively and the variables ~fi; fi only positively. There exists types ~ff; ~fi ` o/ (~ff; ~fi) in
which ~ff occurs only negatively and ~fi only positively and ~ff; ~fi ` o/ 0(~ff; ~fi) in which ~ff occurs
only positively and ~fi only negatively and terms

in : oe(~ff; ~fi; o/ 0(~ff; ~fi); o/ (~ff; ~fi)) ( o/ (~ff; ~fi)
out : o/ 0(~ff; ~fi) ( oe(~fi; ~ff; o/ (~ff; ~fi); o/ 0(~ff; ~fi))

such that for any pair of types ~ff; ~fi ` !; !0, and terms

g : oe(~ff; ~fi; !0; !) ( !
g0 : !0 ( oe(~fi; ~ff; !; !0)

LINEAR ABADI & PLOTKIN LOGIC 45
there exists unique h, h0 making

oe(~ff; ~fi; o/ 0(~ff; ~fi); o/ (~ff; ~fi))

oe(~ff;~fi;h0;h)

ffi

in ffio/ (~ff; ~fi)

h
ffioe(~ff; ~fi; !0; !) g ffi!

!0

g0

ffi

h0

ffi

oe(~fi; ~ff; !; !0)

oe(~fi;~ff;h;h0)
ffi

o/ 0(~ff; ~fi) out ffioe(~fi; ~ff; o/ (~ff; ~fi); o/ 0(~ff; ~fi))

commute up to internal equality.
Proof. Define

!(~ff; ~fi; ff) = ufi: oe(~ff; ~fi; ff; fi)

o/ 0(~ff; ~fi) = *ff: oe(~fi; ~ff; !(~ff; ~fi; ff); ff)

o/ (~ff; ~fi) = !(~ff; ~fi; o/ 0(~ff; ~fi))

Notice that we have swapped the occurrences of ~ff; ~fi in oe in the definition of o/ 0, making all
occurrences of ~ff in o/ 0 positive and all occurrences of ~fi in o/ 0 negative. The rest of the proof
proceeds exactly as the proof of Theorem 2.38.

Theorem 2.44. Suppose ~ff; ~fi; ff; fi ` oe(~ff; ~fi; ff; fi) is a type as in Lemma 2.43. Then there
exists a type rec ff: oe(~ff; ~fi; ff; ff) with ~ff occurring only negatively and ~fi only positively, and
an isomorphism

i : oe(~ff; ~fi; rec ff: oe(~fi; ~ff; ff; ff); rec ff: oe(~ff; ~fi; ff; ff)) ( rec ff: oe(~ff; ~fi; ff; ff)
satisfying the conclusion of Lemma 2.44 with

o/ (~ff; ~fi) = rec ff: oe(~ff; ~fi; ff; ff);
o/ 0(~ff; ~fi) = rec ff: oe(~fi; ~ff; ff; ff);

i = in;
out = i-1:

Proof. Using Theorem 2.39, we can prove as in the proof of Lemma 2.40 that the pair

out-1 : oe(~ff; ~fi; o/ (~fi; ~ff); o/ 0(~fi; ~ff)) ( o/ 0(~fi; ~ff)

in-1 : o/ (~fi; ~ff) ( oe(~fi; ~ff; o/ 0(~fi; ~ff); o/ (~fi; ~ff))

also satisfies the conclusion of Lemma 2.44. Proceeding as in the proof of Lemma 2.41 we
get an isomorphism o/ (~ff; ~fi) ,= o/ 0(~fi; ~ff) up to internal equality, which implies the theorem.

The mixed induction/coinduction principle of Theorem 2.42 can be generalized to recursive types with parameters as follows.

Theorem 2.45. Suppose ~R+ : AdmRel(~!+; ~!0+) and ~R- : AdmRel(~!-; ~!0-) are vectors of
admissible relations, and

S+ : AdmRel(rec ff: oe(~!-; ~!+; ff; ff); rec ff: oe(~!0-; ~!0+; ff; ff))

S- : Rel(rec ff: oe(~!+; ~!-; ff; ff); rec ff: oe(~!0+; ~!0-; ff; ff))

are relations. Then the following rule holds:

(i-1; i-1) : S- ( oe( ~R+; ~R-; S+; S-) (i; i) : oe( ~R-; ~R+; S-; S+) ( S+

S- ae rec ff: oe( ~R+; ~R-; ff; ff) rec ff: oe( ~R-; ~R+; ff; ff) ae S+

46 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
Proof. The proof proceeds as the proof of Theorem 2.42, and we start by considering the
case where S- is admissible. This time the terms generating h; h0 have types

k : Q ~ff; ~fi: Q !0; !:

(oe(~ff; ~fi; !0; !) ( !) ( (!0 ( oe(~fi; ~ff; !; !0)) ( rec ff: oe(~ff; ~fi; ff; ff) ( !
k0 : Q ~ff; ~fi: Q !; !0:

(oe(~ff; ~fi; !0; !) ( !) ( (!0 ( oe(~fi; ~ff; !; !0)) ( !0 ( rec ff: oe(~fi; ~ff; ff; ff)

Now, notice first that

k ~!+ ~!- rec ff: oe(~!+; ~!-; ff; ff) rec ff: oe(~!-; ~!+; ff; ff) i i-1 = id rec ff:oe(~!+;~!-;ff;ff) (2.10)
k0 ~!+ ~!- rec ff: oe(~!+; ~!-; ff; ff) rec ff: oe(~!-; ~!+; ff; ff) i i-1 = id rec ff:oe(~!-;~!+;ff;ff) (2.11)

k ~!0+ ~!0- rec ff: oe(~!0+; ~!0-; ff; ff) rec ff: oe(~!0-; ~!0+; ff; ff) i i-1 = id rec ff:oe(~!0+;~!0-;ff;ff) (2.12)
k0 ~!0+ ~!0- rec ff: oe(~!0+; ~!0-; ff; ff) rec ff: oe(~!0-; ~!0+; ff; ff) i i-1 = id rec ff:oe(~!0-;~!0

+;ff;ff) (2.13)

as in the proof of Theorem 2.42.

The theorem will follow from instantiating the parametricity schema of k; k0 with ~R-
substituted for ~ff, ~R+ substituted for ~fi and S+ for ! and S- for !0. This tells us that if

(i-1; i-1) : S- ( oe( ~R+; ~R-; S+; S-)

(i; i) : oe( ~R-; ~R+; S-; S+) ( S+

then (using (2.10)-(2.13) above)

(id rec ff:oe(~!+;~!-;ff;ff); id rec ff:oe(~!0+;~!0-;ff;ff)) : S- ( rec ff: oe( ~R+; ~R-; ff; ff)
(id rec ff:oe(~!-;~!+;ff;ff); id rec ff:oe(~!0-;~!0+;ff;ff)) : rec ff: oe( ~R-; ~R+; ff; ff) ( S+

which was what we needed to prove.

For the general case, dropping the assumption that S- is admissible, the proof proceeds
exactly as in Theorem 2.42.

3. Conclusion
We have presented the logic LAPL for reasoning about parametricity in the domain
theoretic case, and we have shown how in this logic Plotkin's encodings of recursive types
can be verified. In later papers we will present a general notion of model of LAPL, and
show how various earlier suggested domain theoretic models of parametric polymorphism
fit this general notion of model. These models include a model based on admissible pers
over a reflexive domain [BMP05], Rosolini and Simpson's construction in Synthetic Domain
Theory [RS04] and a model based on the language Lily [BPR00].

In all these cases, a central point in verifying that these give rise to models of LAPL
is to show that the various notions of admissible relations in the specific models satisfy
the axioms for admissible relations presented in this paper. In the case of admissible pers
the admissible relations are given by pointed chain complete subpers, in Synthetic Domain
Theory the admissible relations are given by subdomain and in the case of Lily these are
given by the ??-closed relations. Of course the axioms presented here have been constructed
to be general enough to fit all these cases.

As mentioned in the introduction, the logic LAPL can be seen as an axiomatization
of a good category of domains. An interesting question is whether this is actually a useful

LINEAR ABADI & PLOTKIN LOGIC 47
axiomatization, particularly because the solutions to recursive domain equations obtained
using LAPL satisfy universal properties with respect to linear maps of PILLY , and most
programming languages that one might want to model using domains do not correspond
to linear calculi. A recent paper by the second author [Mo/g06] provides evidence of the
usefulness of LAPL by showing how models of it give rise to models of FPC -- a simply
typed lambda calculus with general recursive types first suggested by Plotkin [Plo85] (see
also [Fio96]) -- and that these models model the expected reasoning principles for recursive
types, reflecting a famous similar result in classical domain theory.

Acknowledgments
We gratefully acknowledge discussions with Milly Maietti, Gordon Plotkin, John Reynolds, Pino Rosolini and Alex Simpson. We also thank the anonymous referees for many
helpful suggestions.

References
[Bar97] A. Barber. Linear Type Theories, Semantics and Action Calculi. PhD thesis, Edinburgh University,

1997.
[Bg05] L. Birkedal and R. E. Mo/gelberg. Categorical models of Abadi-Plotkin's logic for parametricity.

Mathematical Structures in Computer Science, 15(4):709-772, 2005.
[BMP05] L. Birkedal, R. E. Mo/gelberg, and R. L. Petersen. Parametric-domain theoretic models of Linear

Abadi & Plotkin Logic. Technical Report TR-2005-57, IT University of Copenhagen, February
2005.
[BMPV06] L. Birkedal, R. E. Mo/gelberg, R. L. Petersen, and C. Varming. Lily operational semantics and

models of linear abadi & plotkin logic. Technical Report TR-2006-83, IT University of Copenhagen,
2006.
[BPR00] G. M. Bierman, A. M. Pitts, and C. V. Russo. Operational properties of Lily, a polymorphic linear

lambda calculus with recursion. In Fourth International Workshop on Higher Order Operational
Techniques in Semantics, Montr'eal, volume 41 of Electronic Notes in Theoretical Computer Science.
Elsevier, September 2000.
[Fio96] M. Fiore. Axiomatic Domain Theory in Categories of Partial Maps. Distinguished Dissertations in

Computer Science. Cambridge University Press, 1996.
[Fre90a] P.J. Freyd. Algebraically complete categories. In A. Carboni, M. C. Pedicchio, and G. Rosolini,

editors, Category Theory. Proceedings, Como 1990, volume 1488 of Lecture Notes in Mathematics,
pages 95-104. Springer-Verlag, 1990.
[Fre90b] P.J. Freyd. Recursive types reduced to inductive types. In Proceedings of the fifth IEEE Conference

on Logic in Computer Science, pages 498-507, 1990.
[Fre91] P.J. Freyd. Remarks on algebraically compact categories. In M. P. Fourman, P.T. Johnstone, and

A. M. Pitts, editors, Applications of Categories in Computer Science. Proceedings of the LMS
Symposium, Durham 1991, volume 177 of London Mathematical Society Lecture Note Series, pages
95-106. Cambridge University Press, 1991.
[Gir72] J.-Y. Girard. Interpr'etation fonctionelle et 'elimination des coupures de l'arithm'etique d'ordre

sup'erieur. Th`ese d'Etat, Universit'e Paris VII, 1972.
[Hag87] T. Hagino. A Categorical Programming Language. Ph.D. thesis, University of Edinburgh, 1987.
[HP90] H. Huwig and A. Poign'e. A note on inconsistencies caused by fixpoints in a cartesian closed category.

Theoretical Computer Science, 73:101-112, 1990.
[Jac99] B. Jacobs. Categorical Logic and Type Theory, volume 141 of Studies in Logic and the Foundations

of Mathematics. Elsevier Science Publishers B.V., 1999.
[MBR05] R. E. Mo/gelberg, L. Birkedal, and G. Rosolini. Synthetic domain theory and models of linear Abadi

& Plotkin logic. Technical Report TR-2005-59, IT University of Copenhagen, February 2005.
[Mo/g05a] R. E. Mo/gelberg. Category theoretic and domain theoretic models of parametric polymorphism.

PhD thesis, IT University of Copenhagen, 2005.

48 L. BIRKEDAL, R.E. MO/GELBERG, AND R.L. PETERSEN
[Mo/g05b] R. E. Mo/gelberg. Parametric completion for models of polymorphic intuitionistic / linear lambda

calculus. Technical Report TR-2005-60, IT University of Copenhagen, February 2005.
[Mo/g06] Rasmus Ejlers Mo/gelberg. Interpreting polymorphic FPC into domain theoretic models of parametric polymorphism. In Michele Bugliesi, Bart Preneel, Vladimiro Sassone, and Ingo Wegener,
editors, Automata, Languages and Programming, 33rd International Colloquium, ICALP 2006,
Venice, Italy, July 10-14, 2006, Proceedings, Part II, volume 4052 of Lecture Notes in Computer
Science, pages 372-383. Springer, 2006.
[PA93] Gordon Plotkin and Mart'in Abadi. A logic for parametric polymorphism. In Typed lambda calculi

and applications (Utrecht, 1993), volume 664 of Lecture Notes in Comput. Sci., pages 361-375.
Springer, Berlin, 1993.
[Pie02] B.C. Pierce. Types and Programming Languages. MIT Press, 2002.
[Pit95] A.M. Pitts. Relational properties of domains. Information and Computation, 1995. To Appear.
[Plo85] G.D. Plotkin. Lectures on predomains and partial functions. Notes for a course given at the Center

for the Study of Language and Information, Stanford, 1985.
[Plo93] G.D. Plotkin. Second order type theory and recursion. Notes for a talk at the Scott Fest, February

1993.
[Rey74] J.C. Reynolds. Towards a theory of type structure. In Colloquium sur La Programmation, volume 19

of Lecture Notes in Computer Science, pages 408-423. Springer-Verlag, 1974.
[Rey83] J.C. Reynolds. Types, abstraction, and parametric polymorphism. Information Processing, 83:513-

523, 1983.
[Rey00] J.C. Reynolds. Private communication, June 2000.
[RP90] J.C. Reynolds and G.D. Plotkin. On functors expressible in the polymorphic typed lambda calculus.

In G'erard Huet, editor, Logical Foundations of Functional Programming, chapter 7, pages 127-151.
Addison-Wesley, 1990.
[RR94] E.P. Robinson and G. Rosolini. Reflexive graphs and parametric polymorphism. In S. Abramsky,

editor, Proc. 9th Symposium in Logic in Computer Science, pages 364-371, Paris, 1994. I.E.E.E.
Computer Society.
[RS04] G. Rosolini and A. Simpson. Using synthetic domain theory to prove operational properties of a

polymorphic programming language based on strictness. Manuscript, 2004.
[Sim06] A. Simpson. Relational parametricity for computational effects. Manuscript, 2006.
[Tak98] Izumi Takeuti. An axiomatic system of parametricity. Fund. Inform., 33(4):397-432, 1998. Typed

lambda-calculi and applications (Nancy, 1997).
[Wad04] P. Wadler. The Girard-Reynolds isomorphism (second edition). Manuscript, March 2004.

This work is licensed under the Creative Commons Attribution-NoDerivs License. To viewa copy of this license, visit

http://creativecommons.org/licenses/by-nd/2.0/ or send aletter to Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.