

J. Functional Programming, 3(2):75-85, 1997. cfl Cambridge University Press 1

Trust in the *-calculus

P. O/RBAEK AND J. PALSBERG
BRICS, Centre of the Danish National Research Foundation,

Dept. of Computer Science, University of Aarhus,

Ny Munkegade bld 540, 8000 Aarhus C, Denmark

Abstract
This paper introduces trust analysis for higher-order languages. Trust analysis encourages
the programmer to make explicit the trustworthiness of data, and in return it can guarantee
that no mistakes with respect to trust will be made at run-time. We present a confluent
*-calculus with explicit trust operations, and we equip it with a trust-type system which
has the subject reduction property. Trust information is presented as annotations of the
underlying Curry types, and type inference is computable in O(n3) time.

1 Introduction
As computers are increasingly being used to handle important transactions (such
as interchange of legal documents) in an open environment where also information
that does not pertain directly to business is transferred between the same machines
(for example e-mail), the issue of separating these two kinds of information flow has
become more and more important. The issue is usually attacked using encryption
and digital signatures for the important information flows between machines, but
what good does this do if somewhere inside a program, there is a data path between
reading a message and some dangerous operation such that the dangerous operation
depends on the contents of a message whose signature is not checked?

An example where it is important to perform validity checks on all data paths
from input to output, is in an HTTP (HyperText Transfer Protocol, the protocol
used on the world-wide web) server that allows a web-browser to start a separate
program (a so-called CGI script, for Common Gateway Interface) on the server
machine by requesting a specific URL. The usual convention is that the browser
requests a URL of the form http://www.company.com/cgi-bin/program-name.
Since a CGI script can in principle be any program, it is important that the server
checks that the requested program is one of the few programs that are allowed to
be run in this fashion. In a complicated server, like most servers today, there are
many data-paths from the initial reception of the URL request to the command to
be executed, and it is imperative that the checks for allowed programs be performed
on all these paths. The trust analysis presented in this paper is developed to help
the programmer ensure that the requisite checks are always made.

A very similar situation existed in a part of the Gopher (an earlier and simpler

2 P. O/rbaek and J. Palsberg
distributed information service than the world-wide web) server, where through one
of the provided gateways to other services one could contrive a special request to
the server and thereby get arbitrary commands executed on the server machine,
including starting a remote terminal window on that machine and thus thwarting
all security measures. This security bug was later fixed by the developers when
the second author made them aware of the problem. We believe that the use of a
trust-analysis could have helped prevent this problem in the first place.

A third example of where trust analysis could be useful is in a web browser
that must forbid the retrieval of certain URLs, for example to prevent children
from viewing on-line pornography. Since there are many ways in a typical browser
program to enter a URL, (the command line, configuration files, dialog boxes, : : :)
it's important that the checks for forbidden URLs are made on all the paths from
reading user input to getting the URL from a server.

Since we want our analysis to be generally applicable, we do not consider the
very specific tests that have to be done on input data in various situations, such as
checking digital signatures or verifying pathnames against a known pattern. Devising these tests is still up to the careful program designer. Instead our analysis offers
a "trust" construct that is meant to be applied to data after they have passed the
specific validity checks, the analysis will then propagate this knowledge around the
program. At points of the program where something dangerous is about to happen,
such as starting another program or starting a transaction against a database, the
programmer can write a "check" construct to ensure that the arguments can indeed
be trusted, which means that they only depend on data that have actually passed
the validity checks.

As an example of a run-time version of trust-checking, the programming language
Perl (Wall & Schwartz, 1991) has a switch that turns on so-called taint-checks at
run-time that will abort the program with an error message if tainted input data are
being used in "dangerous" functions such as unlink. There's also as construct to
convert tainted data to un-tainted form so that dangerous functions can be used on
it. Our trust analysis is inspired by this feature of Perl, but our analysis is entirely
static, so we can avoid run-time errors and overhead due to taint-checks.

A static check inevitably loses some flexibility as compared to run-time checking,
but in the case of trust checks, it's not very useful to get a run-time trust violation,
as such an error would typically occur too late in the datapath for corrective action
to be possible. So not much useful flexibility is lost.

In (O/rbaek, 1995) O/rbaek introduced the concept of trust analysis for a first order imperative language with pointers using abstract interpretation and constraints.
This papery investigates trust analysis as a type system for a pure functional language based on the *-calculus.

The remainder of the paper is structured as follows. First we give some intuitions
about the intended program analysis, the semantics of our example language, and
the type system. Then we present an extension of the *-calculus together with an

y An extended abstract of an earlier version of this paper appears in the proceedings of

the 1996 Static Analysis Symposium (Palsberg & O/rbaek, 1995).

Trust in the *-calculus 3
operational reduction calculus. The calculus is shown to have the Church-Rosser
property. We also give a denotational semantics for our language and relate it to
the reduction rules. We define our static trust analysis in terms of a type system.
The type system is shown to have the Subject Reduction property with respect to
the reduction rules of the semantics. We then relate our type system to the classical Curry type system for *-calculus and obtain two simulation theorems relating
reductions in our calculus to reductions in classical *-calculus, and finally we prove
that well-typed terms are strongly normalizing. Then a type inference algorithm is
presented and proved correct with respect to the type system. Finally we discuss
how to extend the type system to handle recursion, modules and polymorphism,
and we relate trust analysis to other program analyses.

1.1 Intuitions and Motivation
We distinguish two kinds of data: trusted data and untrusted data. Trusted data will
typically arise from program constants, company databases, trustworthy persons,
cryptographically verified input from a known partner etc. All other pieces of data,
such as data obtained via an insecure network connection or from world writable
files is regarded as untrusted.

Figure 1 is an abstract picture of the data-dependencies in a typical function. We
see that the result of the function depends on both the functions arguments and
its environment as symbolized by the paths entering the function through the sides
of the box. Suppose the result of that function is stored in a company database
or used in a transaction transferring money between accounts. We clearly want to
be able to trust the output of that function, regardless of how the result of the
function is derived from the arguments and the environment of the function. In
order to make the result trustworthy the programmer has inserted certain checks
in the function, symbolized by the small circles. However, there are still paths in
the function such that untrustworthy information may leak through if the function
is called with untrustworthy arguments.

The method we propose to help the programmer ensure that he inserts checks
on all the required data-paths in his program is formulated in terms of an annotated type-system. This type-system must be able to type both trusted data and
untrusted data as both kinds of data occur naturally in most programs, but still it
must be able to distinguish between these two kinds of data.

As this paper is concerned with a higher-order language, functions are data as
well so a function is itself either trusted or untrusted. Intuitively it should be clear
that if we apply an untrustworthy function then the result of that application
is untrustworthy as well, since the function itself may depend on untrustworthy
information from the outside. This leads us to our type rule for function application
as shown in Figure 8.

Our type system starts from the simply typed *-calculus and annotates each
type constructor occurring in the program with a trustworthiness. A trustworthy
boolean has the annotated type Booltr, and an untrustworthy function sending
trusted booleans to trusted booleans has the annotated type (Booltr ! Booltr)dis.

4 P. O/rbaek and J. Palsberg

Fig. 1. Dataflow example
Suppose f is a function that can accept an untrusted argument. This must mean
that f cannot use that argument in places where a trusted value is required unless
it does some checking beforehand on the argument. If we give f a trusted argument then these checks should succeed which means that if a function can accept
untrusted input then it can also accept trusted input. This leads us to a type system with subtyping, such that an expression of a trusted type can be typed as
an untrusted type. The ordering between base-types as determined by their trustworthiness is extended to higher types using the usual contra/co-variant structural
subtyping idea of Mitchell (Mitchell, 1984), Fuh and Mishra (Fuh & Mishra, 1990),
Cardelli (Cardelli, 1984) and others.

The trust type system differs from many other type systems in that given a
bare value (eg. 7) it is not possible to see by just examining the value whether it
is trustworthy or not. This is where our three extensions to the basic *-calculus
come in. They basically link the dynamic semantics of the calculus to our type
system, and they can be seen as a kind of annotations to the program that the type
inference algorithm will attempt to verify for consistency. The trust E construct
indicates to the type system that the result of E may now be trusted. Dually,
distrust E indicates that the result of E cannot be trusted, for example after a
failing validity check, and last but not least: the check E construct indicates to the
analysis that the result of E is required to be trustworthy. Well-written programs
will only have a few syntactic places where the three new constructs are used. The
type system propagates the trust information though the program, ensuring that
for any instance of check E in a well-typed program the expression E is statically
known to be trustworthy.

1.2 An Example
Consider the following piece of code written in an SML like syntax for a network
server program:

read from network :: (Clientdis ! (Reqdis, Sigtr))tr

Trust in the *-calculus 5
E; F; G; H ::= x j *x:E j EE j trust E j distrust E j check E

Fig. 2. The syntax of expressions
verify signature :: (Sigtr ! Booltr)tr
handle event :: (Reqtr ! Unittr)tr
handle wrong signature :: ((Reqdis, Sigtr)! Unittr)tr

fun get request client =

let (req, signature) = read from network(client) in

if verify signature(signature) then

handle event(trust req)
else

handle wrong signature(req, signature).

The server first reads a packet from the network client and if the signature of the
packet can be verified, then we can trust the request data and the event handler is
called with the request part of the packet. In case the signature cannot be verified
an error handler is called which may eventually display some error message on the
client's display.

The event handler could be called from many places in the program and to avoid
by accident calling it with a request that has not yet been verified, we use the trust
type system to require that the handler gets only trustworthy requests. The handler
code may then look something like:

fun handle event req =

let trusted req = check req
in ...

and it will therefore get the argument type Reqtr. Notice the small number of
program annotations of the form trust E and check E as opposed to the numerous
trust annotations on the types that are inferred by our inference algorithm.

2 Syntax and Semantics
This section presents the syntax and operational semantics of the trust language. We
have chosen to formalize our analysis in an extension of the traditional *-calculus
without any predetermined reduction order, that is, we study a pure calculus to
gain results that will specialize equally well to call-by-value implementations as to
call-by-need implementations. The drawback of this is of course that some results
require more work, for example we need a lengthy proof of the Church-Rosser
property of our calculus, something that would come essentially for free had we
chosen to study just one specific reduction strategy such as left-most inner-most
reduction for call-by-value. Figure 2 defines the syntax of our language.

Variables, *-abstraction and application behave as usual. The trust E construct
is used to introduce trusted values in a program. Symmetrically, distrust indicates

6 P. O/rbaek and J. Palsberg
untrusted values. The check construct will reduce only on trusted values, so evaluation may get stuck if an expression check(distrust E) occurs at some point during
evaluation. According to the previous section, the three new constructs should be
regarded as the interface between the dynamic semantics of the program and the
static analysis (the type system). But in order to prove the soundness of the analysis we have to give some dynamic meaning to the new constructs. This is done in
terms of fairly obvious reduction rules for the constructs defining how they interact.
One can also see the new constructs as operating on tags associated with all values
at run-time, and this is the view taken in the denotational semantics given later.

2.1 Reduction rules
The reduction (or evaluation) rules for the language are given in Figure 3. Stating
E ! E0 means that there is a derivation of that reduction in the system.

There are three kinds of values around during reduction: trusted, distrusted
and untagged. Untagged lambdas are treated as trusted program constants in the
(Lambda Contraction) rules, since lambdas stem from the program text which the
programmer is writing himself and they may therefore be trusted. As discussed in
Section 5 this may change in a larger scale situation with modules.

In order to facilitate the proof of the Church-Rosser property of the system, the
reduction rules form a reflexive "one step" transition relation. This is inspired by
the proof of Church-Rosser for the ordinary *-calculus by Tait and Martin-L"of in
(Barendregt, 1981, pp. 59-62).

The contraction rules exist to eliminate redundant uses of our new constructs
in the calculus. For example, trusting an expression twice is the same as trusting
it once (the first (Trust Contraction) rule) and checking the trustworthiness of an
expression then explicitly trusting it is the same as just checking the expression
(Check Contraction). Checking an explicitly trusted expression succeeds and yields
a trusted expression. Note that there is no rule contracting distrust(check E) since
this would allow the removal of the check on the trustworthiness of E: The reason
this particular choice of reduction rules is that we want check to act in a "call-byvalue" fashion as discussed in the next section.

In the following we always consider equality of terms modulo ff-renaming. Since
we are working with a reflexive reduction relation we have to be careful in our
definition of what is meant by a normal form. A significant reduction E ! F is a
reduction whose derivation uses at least one of the contraction rules or a fi-rule.
A term E is said to be in normal form when there are no significant reductionsz
starting from E. There are proper and improper normal forms. A normal form
containing a sub-term of the form check(distrust E) is said to be improper. All
other normal forms are proper. We will write !\Lambda  for the reflexive transitive closure
of the reduction relation !.

z A reduction E ! F may be significant even when E = F : \Omega  = (*x:xx)(*x:xx) ! \Omega  is

a significant reduction.

Trust in the *-calculus 7
E ! E (Reflex)
E ! E0
*x:E ! *x:E0
trust E ! trust E0
distrust E ! distrust E0

check E ! check E0

(Sub)

E ! trust E0
trust E ! trust E0
distrust E ! distrust E0

check E ! trust E0

(Trust Contraction)

E ! distrust E0
trust E ! trust E0
distrust E ! distrust E0

(Distrust Contraction)

E ! check E0
trust E ! check E0
check E ! check E0

(Check Contraction)

E ! *x:E0
trust E ! *x:E0
check E ! *x:E0

(Lambda Contraction)

E ! E0 F ! F 0
EF ! E0F 0
(*x:E)F ! E0[F 0=x]
(distrust (*x:E))F ! distrust E0[F 0=x]

(Application)

Fig. 3. The reduction rules.
As an example of how to extend the language with usual programming constructs, we show in Figure 4 how a reduction rule for program constants would look
and the derived rules we get for if-then-else with the usual coding of booleans in
the *-calculus. Notice how the (Constant) rules are patterned after the (Lambda
Contraction) rules, and how the trustworthiness of the condition in an if-then-else
construct affects the trustworthiness of the result. It shows that our function application rule seamlessly handles what Denning in (Denning, 1976) called indirect
data dependencies. In Section 5 we also show how to encode a rec construct in the
language.

2.2 The nature of check
The contraction rules that we have in the case where check is the inner construction
are given by the (Check Contraction) rules:

8 P. O/rbaek and J. Palsberg

E ! const
trust E ! const
check E ! const

(Constant)

T j K j *xy:x (True)

F j *xy:y (False)
if E then F else G j EF G (If)

E ! E0 F ! F 0
if T then E else F !\Lambda  E0

if F then E else F !\Lambda  F 0
if distrust T then E else F !\Lambda  distrust E0

if distrust F then E else F !\Lambda  distrust F 0

(If)

Fig. 4. Example rules.

E ! check F
trust E ! check F
check E ! check F

and most notably, there is no rule for contracting distrust(check E). There is at
least one other set of rules for this case that may come to mind, namely this set of
rules:

E ! check F
trust E ! trust F
distrust E ! distrust F

check E ! check F

The intuition for the first of these alternative rules is that if we put trust around
some expression there is really no need to perform the check inside the trust construct since the program is going to trust the resulting value anyway. The second
rule is the symmetric case, and is needed to make the resulting calculus ChurchRosser. The last rule also occurs in our system. The calculus that results from this
alternative set of rules makes fewer programs end up in a stuck configuration, because it is now possible to place a stuck expression in a context that will make it
reducible, as in trust(check(distrust E)) which is stuck in our calculus, but reduces
to trust E under the alternative rules.

One way to think about this is to view our definition of check as "call-by-value"
in that it really needs to see the (possibly implicit) tag on its subexpression before
it can be reduced away, whereas with the alternative rules, check is "call-by-name"
in that it can be reduced away, depending on its context, without considering the
trustworthiness of its argument. The "call-by-value" nature of check is also reflected
in the denotational semantics of check given later. Note, however, that for the core
*-calculus we have the full fi-rule. It's only the new construct, check, that behaves
in a "call-by-value" or "call-by-name" fashion.

Trust in the *-calculus 9
In our view the alternative rules are less intuitive to the programmer, in that
if he writes check somewhere in the program he probably wants it to check the
trustworthiness of its argument regardless of the surrounding context. But one can
argue both ways: the "call-by-name" version of check might be the most natural
choice in a lazy implementation of a functional language such as Haskell, whereas
the "call-by-value" version might be most suitable for a call-by-value language such
as SML. Either way it's easy to alter the proof of the Subject Reduction theorem
(Theorem 11) for our type system to the alternative rules, so our type system is
sound for both sets of rules.

2.3 Church-Rosser
The Church-Rosser (confluence) theorem for a reduction system states that for any
term, if the term can reduce to two different terms there exists a successor term such
that both of the two reduced terms can further reduce to that common successor.
A corollary of this is that a normal form is unique if it exists.

Theorem 1 (Church-Rosser)
For expressions E, F and G. If E !\Lambda  F and E !\Lambda  G then there is an expression
H such that F !\Lambda  H and G !\Lambda  H.

Proof
By the Diamond lemma below (Lemma 7) and Lemma 3.2.2 of (Barendregt, 1981).

Lemma 2
If E ! F and E has a certain structure then some conditions on the structure of
F hold, as made explicit below.

ffl If E = trust E1 ! F then F = ff F1 where ff 2 fcheck; trust; *x:g.
ffl If E = check E1 ! F then F = ff F1 where ff 2 fcheck; trust; *x:g.
ffl If E = distrust E1 ! F then F is of the form distrust F1.
ffl If E = *x:E1 ! F then F is of the form *x:F1.

Proof
In each case by inspection of the reduction rules.

Lemma 3 (Trust/Check Identity)
Let ff 2 ftrust; check; *x:g.
If E ! ff E1 then check E ! ff E1 and trust E ! ff E1

Proof
By inspection of the reduction rules, especially the contraction rules.

Lemma 4 (Symmetry)
Let ff; fi 2 ftrust; distrustg. If ff E ! ff E0 then fi E ! fi E0

Proof
By induction on the structure of the derivation of ff E ! ff E0, verifying that in
each case there is also a corresponding rule for the opposite combination.

10 P. O/rbaek and J. Palsberg
Lemma 5 (Pre-Substitution)
If E ! F then G[E=x] ! G[F=x].

Proof
By induction on the structure of G. This is essentially a consequence of the (Sub)
rules and the first (Application) rule.

Lemma 6 (Substitution)
If E ! F and G ! H then E[G=x] ! F [H=x].

Proof
By induction on the structure of the derivation of E ! F . If F = E by the (Reflex)
axiom, we must show that E[G=x] ! E[H=x] given that G ! H. This is the
Pre-Substitution lemma (5).

For all the rules except the (Application) case: Suppose that ff; fi, and fl are in
the set fcheck; trust; distrust; *x:g as appropriate, and fi and fl may be empty as
well. Assume the rule

E1 ! fi F1

E = ff E1 ! fl F1 = F
is the last rule in the derivation of E ! F . By the induction hypothesis we get

E1[G=x] ! (fi F1)[H=x] = fi(F1[H=x]):
Now E[G=x] = ff E1[G=x] and F [H=x] = fl F1[H=x], and we may now deduce

E1[G=x] ! fi F1[H=x]
ff E1[G=x] ! fl F1[H=x]

as required. Of course, in the case of a lambda, if the bound variable is the one
substituted for, nothing happens during substitution, i.e.

E[G=x] = E ! F = F [H=x]
as the only rule applicable to the case of ff = *x: is the (Sub) rule.

The (Application) cases: If E = E1E2 ! F1F2 = F , where E1 ! F1 and E2 ! F2
then the result follows directly from the induction hypothesis. Suppose the last rule
in the derivation of E ! F was (x 6= y):

E1 ! F1 E2 ! F2
E = (*y:E1)E2 ! F1[F2=y] = F

By the induction hypothesis E1[G=x] ! F1[H=x] and similarly for E2. Also E[G=x] =
(*y:E1[G=x])(E2[G=x]) and

F [H=x] = (F1[F2=y])[H=x] = (F1[H=x])[F2[H=x]=y]
where the last equality depends on y not being free in H. This can be assured by
ff-renaming H. We may now deduce:

E1[G=x] ! F1[H=x] E2[G=x] ! F2[H=x]
(*y:E1[G=x])(E2[G=x]) ! (F1[H=x])[F2[H=x]=y]

Trust in the *-calculus 11
Suppose the last rule in the derivation of E ! F was:

E1 ! F1 E2 ! F2
E = (*x:E1)E2 ! F1[F2=x] = F

By the induction hypothesis, E2[G=x] ! F2[H=x]. Also E[G=x] = (*x:E1)(E2[G=x])
and

F [H=x] = (F1[F2=x])[H=x] = F1[F2[H=x]=x]:
Now

E1 ! F1 E2[G=x] ! F2[H=x]

(*x:E1)(E2[G=x]) ! F1[F2[H=x]=x]
as required. Two similar cases apply to the distrust *x:E case.

Lemma 7 (Diamond)
For expressions E, F and G. If E ! F and E ! G then there is an expression H
such that F ! H and G ! H.

Proof
By induction on the derivation of E ! F and E ! G and by cases on how F and
G must look depending on E.

Depending on E there are a number of applicable rules. In all cases (Reflex) and
(Sub) are applicable.

1. E = *x:E1: none other.
2. E = trust E1:

(a) E ! trust E01 when E1 ! trust E01. (Trust Contraction)
(b) E ! *x:E01 when E1 ! *x:E01. (Lambda Contraction)

(c) E ! check E01 when E1 ! check E01. (Check Contraction)
(d) E ! trust E01 when E1 ! distrust E01. (Distrust Contraction)

3. E = distrust E1:

(a) E ! distrust E01 when E1 ! trust E01. (Trust Contraction)
(b) E ! distrust E01 when E1 ! distrust E01: (Distrust Contraction)

4. E = check E1:

(a) E ! trust E01 when E1 ! trust E01. (Trust Contraction)
(b) E ! check E01 when E1 ! check E01. (Check Contraction)

(c) E ! *x:E01 when E1 ! *x:E01. (Lambda Contraction)

5. E = (*x:E1)E2: E ! E01[E02=x] when E1 ! E01 and E2 ! E02.
6. E = (distrust *x:E1)E2: E ! distrust E01[E02=x] when E1 ! E01 and E2 ! E02.

If E ! F or E ! G by (Reflex) then there is no problem, one may just use the
rule applied in the other branch to get to the common successor. Case 1 is easy as
well: there is only one applicable rule except (Reflex) namely (Sub).

The tables below map pairs of "outgoing" reductions to proofs of the corresponding case.

12 P. O/rbaek and J. Palsberg

Case 2 2a 2b 2c 2d (Sub)

2a B B C A
2b B C A

2c C A
2d D

Case 3 3a 3b (Sub)

3a G F
3b E

Case 4 4a 4b 4c (Sub)

4a B B A
4b B A

4c A

For case 6 the argument is as follows: Here the last rules in the derivation of
E ! F and E ! G were:

E1 ! F1 E2 ! F2
E = (distrust *x:E1)E2 ! distrust F1[F2=x] = F (Application)

and

E1 ! G1 E2 ! G2
E = (distrust *x:E1)E2 ! (distrust *x:G1)G2 = G (Sub)

respectively. By the induction hypothesis there are H1 and H2 such that F1 ! H1,
G1 ! H1 and F2 ! H2, G2 ! H2. So by the Substitution lemma (Lemma 6) (and
(Sub)):

F = distrust F1[F2=x] ! distrust H1[H2=x] = H
and by (Application)

G = (distrust *x:G1)G2 ! distrust H1[H2=x] = H:
Case 5 without distrust is similar.

In each of the cases below, the quest is to find an appropriate common successor
H to F and G.

Case A. Let ff 2 ftrust; checkg and fi 2 ftrust; check; *x:g. The last rules of the
derivation of E ! F and E ! G were

E1 ! fi F1
E = ff E1 ! fi F1 = F (fi Contraction)

Trust in the *-calculus 13

E1 ! G1
E = ff E1 ! ff G1 = G (Sub)
By the induction hypothesis there is an H1 such that G1 ! H1 and fi F1 ! H1:
By Lemma 2 and the restriction on fi; H1 = fl H2 where fl 2 ftrust; check; *x:g.
By the Trust/Check Identity lemma (Lemma 3), G1 ! fl H2 implies that ff G1 !
fl H2 = H1. So we can use H = H1.

Case B. Let ff; fi; fl 2 ftrust; check; *xg as appropriate. The last rules used in the
derivation of E ! F and E ! G are:

E1 ! fi F1
E = ff E1 ! fi F1 = F (fi Contraction)

E1 ! fl G1
E = ff E1 ! fl G1 = G (fl Contraction)
By the induction hypothesis there is an H1 such that fi F1 ! H1 and fl G1 ! H1.
We may now use H1 as H.

Case C. Let ff 2 ftrust; check; *x:g. The two last rules used in the derivation of
E ! F and E ! G are:

E1 ! ff F1
E = trust E1 ! ff F1 = F (ff Contraction)

E1 ! distrust G1
E = trust E1 ! trust G1 = G (Distrust Contraction)
By the induction hypothesis we know there exists H1 such that ff F1 ! H1.
Here Lemma 2 says that H1 = fi H2 where fi 2 fcheck; trust; *x:g. Also by the
induction hypothesis we have distrust G1 ! H1. And here Lemma 2 says that
H1 = distrust H2! This is a contradiction so it cannot be the case that both
E1 ! ff F1 and E1 ! distrust G1.

Case D. The two last rules used in the derivation of E ! F and E ! G are:

E1 ! distrust F1
E = trust E1 ! trust F1 = F (Distrust Contraction)

E1 ! G1
E = trust E1 ! trust G1 = G (Sub)
By the induction hypothesis there is an H1 such that distrust F1 ! H1 and G1 !
H1. By Lemma 2 H1 = distrust H2 so

G1 ! distrust H2
trust G1 ! trust H2 (Distrust Contraction)

By Symmetry (Lemma 4) distrust F1 ! distrust H2 implies trust F1 ! trust H2. So
we can use trust H2 as H.

14 P. O/rbaek and J. Palsberg
Case E. The two last rules used in the derivation of E ! F and E ! G are:

E1 ! distrust F1
E = distrust E1 ! distrust F1 = F (Distrust Contraction)

E1 ! G1
E = distrust E1 ! distrust G1 = G (Sub)
By the induction hypothesis there is an H1 such that distrust F1 ! H1 and G1 !
H1. By Lemma 2 H1 = distrust H2. By (Distrust Contraction) G1 ! distrust H2
implies distrust G1 ! distrust H2 = H1. So we use H = H1 in this case.

Case F. The two last rules used in the derivation of E ! F and E ! G are:

E1 ! trust F1
E = distrust F1 ! distrust F1 = F (Trust Contraction)

E1 ! G1
E = distrust E1 ! distrust G1 = G (Sub)
By the induction hypothesis there is an H1 such that trust F1 ! H1 and G1 ! H1.
By Lemma 2 H1 = ff H2 where ff 2 ftrust; check; *x:g.

If ff = trust then we have G1 ! trust H2 and trust F1 ! trust H2 and by Symmetry distrust F1 ! distrust H2. By (Trust Contraction) we also get distrust G1 !
distrust H2, so here we may use H = distrust H2.

If ff = check or ff = *x: then by (Sub) we get distrust G1 ! distrust (ff H2). Since
trust F1 ! ff H2 one sees by inspection of the rules that for each ff there is just one
possible last rule for this reduction so we must have F1 ! ff H2. Now by (Sub) we
get distrust F1 ! distrust (ff H2). So here we may use H = distrust (ff H2).

Case G. The two last rules used in the derivation of E ! F and E ! G are:

E1 ! distrust F1
E = distrust E1 ! distrust F1 = F (Distrust Contraction)

E1 ! trust G1
E = distrust E1 ! distrust G1 = G (Trust Contraction)
By the induction hypothesis there is an H1 such that distrust F1 ! H1 and
trust G1 ! H1, but by Lemma 2 this is a contradiction so this case cannot arise.

This concludes the proof of the Diamond lemma.

2.4 Denotational Semantics
In this section we give a denotational semantics for the calculus and prove it sound
with respect to the calculus. Some readers may find the direct style denotational
semantics easier to comprehend than the reduction rules. However, as we saw in
the section on the nature of check, the reduction rules are easy to alter to get a
different, but justifiable, semantics of check, whereas the denotational semantics for

Trust in the *-calculus 15
D = (((D ! D) \Phi  base) \Omega  ftr; disg?) \Phi  ferrorg?:
Env = Var ! D:

[[\Delta ]] 2 Exp ! Env ! D
E; F 2 Exp

x 2 Var

ae 2 Env:

Fig. 5. Domain equations.

[[x]]ae = ae(x)
[[*x:E]]ae = h(*d : D: case [[E]]ae[x 7! d] of

j error ! error
j hv; ti ! hv; ti); tri

[[EF ]]ae = case [[E]]ae of

j error ! error
j hv; ti ! case v([[F ]]ae) of

j error ! error
j hv0; t0i ! hv0; t . t0i

[[trust E]]ae = case [[E]]ae of

j error ! error
j hv; ti ! hv; tri

[[distrust E]]ae = case [[E]]ae of

j error ! error
j hv; ti ! hv; disi

[[check E]]ae = case [[E]]ae of

j error ! error
j hv; tri ! hv; tri
j hv; disi ! error:

Fig. 6. Semantic equations.

the alternative set of rules would be substantially different, as we would have to
abandon the direct style and instead use a continuation based semantics.

In Figure 5 we define our semantic domains, using coalesced sums and smash
products. A value is either error (standing for a semantic error) or a pair consisting
of the "real" value (a function or a value of base-type from the base domain) and a
trust tag, either tr or dis. The domain ftr; disg? is the usual flat three-point domain
where ? is the bottom element. For the definition of application we define another
ordering between tr and dis, namely: tr ^ dis. We denote by . the least upper bound
according to this ordering.

16 P. O/rbaek and J. Palsberg

u; v; w ::= dis j tr
o/; oe ::= tu
s; t ::= base j o/ ! oe:

Fig. 7. Syntax of trust-types
The semantic equations are given in Figure 6. We employ a pattern matching
case construct in the semantic description language.

Lemma 8 (Environment)
For expressions E and F and environment ae we have:

[[E[F=x]]]ae = [[E]]ae[x 7! [[F ]]ae]:
Proof
By structural induction on E.

The connection between the operational calculus and the denotational semantics
is the following soundness theorem.

Theorem 9 (Semantic Soundness)
The denotation of an expression is invariant under reduction: If E ! F then [[E]] =
[[F ]].

Proof
By induction on the derivation of E ! F; applying the equational theory of the
semantic description language and using Lemma 8 in the application case.

3 The Type System
Our annotated type system is based on Currys monomorphic type system for the
*-calculus, also known as simply typed *-calculus. Figure 7 shows the mutually
recursive definition of the syntax of our types. Recall from Section 1.1 that tr
means that the value is trusted and dis means that it is untrusted.

We write u; v or w (and primed and subscripted versions thereof) for trust annotations, s and t for bare types without their outermost annotation, and oe or o/ for
annotated types. The generic term "type" will be used both for bare types without
their outermost annotation and for annotated types.

Just as was the case in the denotational semantics, trust annotations are subject
to a partial ordering ^, defined as the least partial ordering including the relation
tr ^ dis. This ordering is extended to bare types and annotated types such that two
bare base-types are ordered only if they identical; for annotated types we have:

tu ^ sv if and only if u ^ v and t ^ s;
and for bare arrow types we define:

o/ ! oe ^ o/ 0 ! oe0 if and only if o/ 0 ^ o/ and oe ^ oe0;
so argument types are ordered contravariantly. This is inspired by the work on

Trust in the *-calculus 17
A ` x : o/ if x 2 dom(A) and A(x) = o/ (Var)

A ` E : o/ o/ ^ o/ 0

A ` E : o/0 (Sub)

A[x 7! o/] ` E1 : oe
A ` *x:E1 : (o/ ! oe)tr (Lambda)

A ` E1 : (o/ ! tu)w A ` E2 : o/

A ` E1E2 : tu.w (App)

A ` E1 : tu
A ` trust E1 : ttr (Trust)

A ` E1 : tu
A ` distrust E1 : tdis (Distrust)

A ` E1 : ttr
A ` check E1 : ttr (Check)

Fig. 8. The type system.

structural subtyping by Mitchell (Mitchell, 1984), Fuh and Mishra (Fuh & Mishra,
1990), Cardelli (Cardelli, 1984) and others.

As in the denotational semantics we denote by . the least upper bound operation
on the trust lattice according to the ^ ordering. In Section 5 we discuss several
extensions of the type system to cope with recursion, modules, polymorphism and
more general lattices of annotations.

3.1 Rules
A type assumption A is a partial function which takes a program identifier to an
annotated type o/ . Figure 8 shows the inference rules for the type system. A type
judgment A ` E : o/ means that from the assumptions A we can deduce that the
expression E has type o/ .

The rule for variables and the subtyping rule should give no surprises. Since
lambda abstractions in the program are written by the programmer, we treat them
as trusted in the type system. This only means that the function is trusted, and
does not indicate how its argument and result are treated. In Section 5 we discuss
how this can be extended to a larger scale setting with multiple modules written
by multiple programmers.

In the application rule, the annotated type of the actual argument is required
to match the annotated type of the formal argument. This includes the trustworthiness. The trust of the result of the application is the least upper bound of the
result-trust from the arrow type and the trust of the function itself. The intuition
is that if we cannot trust the function, we cannot trust the result of applying it.

18 P. O/rbaek and J. Palsberg

distrust ffi check : ttr ! tdis

trust: tdis ! ttr
check: ttr ! ttr distrust: tdis ! tdis

Fig. 9. The relationship between arrow types
The three rules for trust, distrust and check show that they behave as the identity
on the underlying type. Trust makes any value trusted and distrust makes any value
untrusted. Check E has a type only if E is trusted. This means that we cannot
type improper normal forms and together with Subject Reduction (Theorem 11)
this ensures the soundness of the type system.

Figure 9 shows the ordering of arrow types and how the constructs trust, distrust
and check would fit into it.

3.2 Subject Reduction
An important part in proving the Subject Reduction theorem is that replacing an
appropriately typed term for a variable in an expression does not change the type
of the expression.

Lemma 10 (Substitution)
If A[x 7! oe] ` E : o/ and A ` F : oe then A ` E[F=x] : o/ .

Proof
By induction on the derivation of A[x 7! oe] ` E : o/ .

The main result of this section is the Subject Reduction theorem. The theorem
states that types are invariant under reduction.

Theorem 11 (Subject Reduction)
If A ` E : o/ and E ! F then A ` F : o/ .

Proof
By induction on the structure of the derivation of E ! F and by cases on the
structure of E. The (Reflex) case is trivial. In the (Sub) cases the result follows
directly from the induction hypothesis. The type rule (Sub) is applicable in all
cases, so when reasoning "backwards" (as in "when ff E has type o/ then E must
have type oe") we must take care to handle the case where the (Sub) type rule was
used in between.

For the contraction rules we show just two illustrative cases, the remaining cases
are extremely similar. Suppose the last rule used in the derivation of E ! F was

E1 ! trust F1
E = trust E1 ! trust F1 = F (Trust Contraction)

By assumption we have A ` trust E1 : tu so by the rules we must have A ` E1 : tu11

Trust in the *-calculus 19
where t1 ^ t. By the induction hypothesis we now get A ` trust F1 : tu11 and again
we must have A ` F1 : tu22 where t2 ^ t1. Now by the (Trust) rule of the type
system we get A ` trust F1 : ttr2 and finally by (Sub) we get A ` trust F1 : tu as
required.

Another case: Suppose the last rule used in the derivation of E ! F was

E1 ! distrust F1
E = distrust E1 ! distrust F1 = F (Distrust Contraction)

By assumption we know A ` distrust E1 : tu and therefore u = dis, so by the rules
we must have A ` E1 : tu11 where t1 ^ t. From the induction hypothesis we get
A ` distrust F1 : tu11 . By the (Distrust) rule we must have A ` F1 : tu22 where t2 ^ t1
and u1 = dis. By the (Distrust) rule we now get A ` distrust F1 : tdis2 which via
(Sub) yields the required result.

Regarding application: If E = E1E2 ! F1F2 = F then the result follows by two
applications of the induction hypothesis. If the last rule used in the derivation of
E ! F was

E1 ! F1 E2 ! F2
E = (distrust(*x:E1))E2 ! distrust F1[F2=x] = F (Application)

then by assumption A ` (distrust(*x:E1))E2 : tu. By definition of the type rules
this must mean that A ` distrust(*x:E1) : (oe ! sv)w and A ` E2 : oe where s ^ t
and v . w ^ u. Again, we must also have A ` *x:E1 : (oe1 ! sv11 )w1 and it must be
case that w = dis and thus u = dis. Also s1 ^ s, v1 ^ v, and oe ^ oe1. Once again
by the type rules we must have A[x 7! oe2] ` E1 : sv22 where oe1 ^ oe2, s2 ^ s1 and
v2 ^ v1. By the (Sub) rule we get A ` E2 : oe2.

We can now apply the induction hypothesis to get A[x 7! oe2] ` F1 : sv22 and
A ` F2 : oe2. By the Substitution lemma (Lemma 10) we then get A ` F1[F2=x] : sv22 .
By the (Distrust) rule we get A ` distrust F1[F2=x] : sdis2 and by (Sub) we get the
desired result as s2 ^ s1 ^ s ^ t.

The case without distrust is similar.

3.3 Comparison with the Curry System
Our type system may be viewed as a restriction of the classic Curry type system
for *-calculus. This notion is formalized in the following. Define the erasure j \Delta  j of
a term as:

jxj = x j*x:Ej = *x:jEj
jE1E2j = jE1jjE2j jtrust Ej = jEj
jdistrust Ej = jEj jcheck Ej = jEj

and likewise the erasure of an annotated type as:

jbaseuj = base j(oe ! o/ )wj = joej \Gamma ! jo/ j:
The notion of erasure is extended pointwise to environments: jAj(x) = jtj if and
only if jA(x)j = t.

20 P. O/rbaek and J. Palsberg

A `C x : t if x 2 dom(A) and A(x) = t
A[x 7! s] `C E1 : t
A `C *x:E1 : s \Gamma ! t

A `C E1 : s \Gamma ! t A `C E2 : s

A `C E1E2 : t

Fig. 10. The Curry type system.

The Curry type rules for erased expressions are defined in Figure 10. Here type
assumptions A map program identifiers to Curry types.

Lemma 12 (Erasure)
If oe and o/ are annotated types and oe ^ o/ then joej = jo/ j.

Proof
For base-types su ^ tv implies s = t. For arrow types note that by definition of ^,
oe and o/ must have the same arrow structure. So the result follows by an induction
on the common structure of oe and o/ .

Theorem 13
If A ` E : o/ then jAj `C jEj : jo/ j.

Proof
By induction on the derivation of A ` E : o/ .

E = x: By assumption we have x 2 dom(A) and o/ = A(x). Thus x 2 dom(jAj)

and jAj(x) = jo/ j.
E = ff E1: Here ff 2 ftrust; distrust; checkg. By the definition of erasure, jEj = jE1j

and the result follows from the induction hypothesis.
E = *x:E1: By assumption we must have A[x 7! oe] ` E1 : oe0 where (oe ! oe0)tr ^ o/ .

By the induction hypothesis jAj[x 7! joej] `C jE1j : joe0j. By the lambda rule
in the Curry system we get jAj `C *x:jE1j : joej \Gamma ! joe0j. By definition of
erasure and the Erasure lemma we get the desired result.
E = E1E2: By assumption we must have A ` E1 : (oe ! tu)w and A ` E2 : oe where

tu.w ^ o/ . From the induction hypothesis we get jAj `C jE1j : joej \Gamma ! jtuj
and jAj `C E2 : joej. By the application rule in the Curry system we get
jAj `C jE1E2j : jtuj. Finally by the Erasure lemma we get the desired result.

The preceding theorem also implies that the erasure of a trust-typable program
is trust-typeable, but the reverse does not hold in general. However, if there are
no sub-terms of the form check E in a program and the erasure of the program is
Curry typable then the program is trust-typable and all the trusts may be chosen
as dis. The formalisation of this and its simple proof has been elided from the paper
as it will not be used in the following.

Trust in the *-calculus 21
E ! E (Reflex) E ! E

0

*x:E ! *x:E0 (Sub)

E ! E0 F ! F 0

EF ! E0F 0
(*x:E)F ! E0[F 0=x]

(Application)

Fig. 11. Reductions in the ordinary *-calculus.

3.4 Simulation
The aim of this section is to show that for well-typed terms one may erase all
the trust, distrust and check constructs and reduce expressions according to the
ordinary *-calculus as displayed in Figure 11 (this is taken from Definition 3.2.3 in
(Barendregt, 1981).) We use the same symbol for this reduction relation as for our
own and it will be clear from the context which reduction relation is meant. Note
that the relation defined in Figure 11 is a sub-relation of the reduction relation
defined in Figure 3.

More formally the two following simulation theorems show that for well-typed
terms, reduction and erasure commute: j \Delta  jffi !\Lambda  = !\Lambda  ffij \Delta  j.

In terms of implementation this means that after type-checking, an interpreter
may erase all the constructs having to do with trust, and run the program without
them, thus no run-time performance penalty is paid.

Lemma 14 (Step)
If E !\Lambda  ff F (ff may be empty) and there is a reduction rule

E1 ! ff F1
fi E1 ! fl F1

then fi E !\Lambda  fl F .

Proof
By induction on the length of the sequence E !\Lambda  ff F . If E = ff F then by (Reflex)
we have E ! ff F and we may apply the rule to get fi E ! fl F and since !`!\Lambda 
this is the required result.

Otherwise the last step in the reduction sequence E !\Lambda  ff F must look like
E0 ! ff F , where E !\Lambda  E0 and E0 6= ff F . Now we apply the rule mentioned in the
statement of the lemma:

E0 ! ff F

fi E0 ! fl F
By the induction hypothesis one gets (via the (Sub) rule and using fi for fl): E !\Lambda  E0
implies fi E !\Lambda  fi E0. By appending the two reductions we get fi E !\Lambda  fl F as we
wanted. In effect we get this derived rule:

E1 !\Lambda  ff F1
fi E1 !\Lambda  fl F1

22 P. O/rbaek and J. Palsberg
Similarly, from

E ! G F ! H

EF ! GH we get

E !\Lambda  G F !\Lambda  H

EF !\Lambda  GH

Some notation: We write E0 = CTD\Lambda F to mean that E0 is produced by the
following grammar, where F is an ordinary term.

E0 ::= check E0 j trust E0 j distrust E0 j F
We also write distrust? E to mean either E or distrust E.
Lemma 15 (CTD)
If E = CTD\Lambda (*x:E1), A ` E : o/ and E1 !\Lambda  F1 then E !\Lambda  distrust? (*x:F1).

Proof
By induction on the length of the CTD sequence. Suppose that

CTD\Lambda *x:E1 = (ff (fi : : : (*x:E1) : : :)):
In the base case (the empty sequence) E1 !\Lambda  F1 implies (via Sub and Step) that
*x:E1 !\Lambda  *x:F1.

Otherwise, there are two cases depending on whether (fi : : :) reduces to a lambda
or a distrusted lambda.

Suppose that (fi : : :) !\Lambda  *x:F1 by the induction hypothesis then via the Step
lemma and (Lambda Contraction):

ff = trust: (trust (fi : : :)) !\Lambda  *x:F1.
ff = distrust: (distrust (fi : : :)) !\Lambda  distrust *x:F1.
ff = check: (check (fi : : :)) !\Lambda  *x:F1.

Finally, suppose that (fi : : :) !\Lambda  distrust *x:F1 by the induction hypothesis then
via the Step lemma and (Distrust Contraction):

ff = trust: (trust (fi : : :)) !\Lambda  trust *x:F1 and via a (Lambda Contraction) step:

trust *x:F1 ! *x:F1.
ff = distrust: (distrust (fi : : :)) !\Lambda  distrust *x:F1.
ff = check: As E is well-typed this case cannot occur since check(distrust E1) is

untypable.

Theorem 16 (Simulation 1)
If A ` E : o/ and jEj ! F then there is a term G such that E !\Lambda  G and jGj = F .
Graphically:

E G

jEj F

j \Delta  j
!

!\Lambda 
j \Delta  j

Trust in the *-calculus 23
Proof
By structural induction on E.

E = x: Here jEj = E and the only applicable rule is (Reflex), thus we get E =

F = G.
E = ff E1; where ff 2 ftrust; distrust; checkg. Here we have jEj = jE1j, A ` E1 : o/ 0

and jEj = jE1j ! F . So by the induction hypothesis there is a G1 such that
E1 !\Lambda  G1 and jG1j = F . By the Step lemma we can deduce:

E1 !\Lambda  G1
E = ff E1 !\Lambda  ff G1 = G (Sub)

and the erasure of G is F as required.
E = *x:E1: By the assumptions we must have A[x 7! oe] ` E1 : oe0. Also, jEj =

*x:jE1j and F = *x:F1. By the nature of the reduction rules, we must have
jE1j ! F1. By the induction hypothesis we know there is a G1 such that
E1 !\Lambda  G1 and jG1j = F1. By the (Sub) rule and the Step lemma we get

E1 !\Lambda  G1
E = *x:E1 !\Lambda  *x:G1 = G (Sub)

and jGj = *x:jG1j = *x:F1 = F as required.
E = E1E2: By the assumptions E is well-typed thus E1 and E2 are well-typed. By

definition of the reduction rules we must have jE1j ! F1 and jE2j ! F2. By
the induction hypothesis we get G1 and G2 such that E1 !\Lambda  G1, E2 !\Lambda  G2,
jG1j = F1 and jG2j = F2.
There are two cases depending on the form of jEj:

jEj = not a fi-redex: Here F = F1F2 where jE1j ! F1 and jE2j ! F2 so by the

reasoning above jG1G2j = F and we are done.
jEj = (*x:H1)H2: If F = (*x:F 01)F2 where H1 ! F 01 and H2 ! F2 then also

jE1j = *x:H1 ! *x:F 01 = F1 by (Sub). By the above statements and the
Step lemma we get E !\Lambda  G1G2 and jG1G2j = F .
Otherwise a fi-reduction happens. Here H1 ! F 01, H2 ! F2 and F =
F 01[F2=x].
Clearly, E1 must have form CTD\Lambda (*x:Q1) where jQ1j = H1. By the induction hypothesis there is a Q01 such that Q1 !\Lambda  Q01 and jQ01j = F 01.
By the CTD lemma E1 !\Lambda  distrust? (*x:Q01) and by the Subject Reduction
theorem (Theorem 11) we get that distrust? (*x:Q01) is well-typed.
We may now reason as follows:

E1 !\Lambda  distrust? (*x:Q01) E2 !\Lambda  G2

E1E2 !\Lambda  (distrust? (*x:Q01))G2 (Sub + Step)

and

Q01 ! Q01 G2 ! G2
(distrust? (*x:Q01))G2 ! distrust? Q01[G2=x] (Application)

24 P. O/rbaek and J. Palsberg

since jQ01j = F 01 and jG2j = F2:

jdistrust? Q01[G2=x]j = jQ01[G2=x]j = F 01[F2=x] = F
as required.
This concludes the proof of the Simulation theorem.
Theorem 17 (Simulation 2)
If E ! F then jEj ! jF j.

Proof
By induction on the derivation of E ! F .

ffl If E ! F by (Reflex) then jEj = jF j and the result holds trivially.
ffl If E ! F by the (Sub) rule. The subterm(s) Ei of E then must reduce

Ei ! Fi and by the induction hypothesis jEij ! jFij. We may now apply the
(Sub) rule to these erased terms and get jEj ! jF j.
ffl Let ff; fi; fl 2 ftrust; distrust; checkg. If the last rule in the derivation of E ! F

was

E1 ! ff F1

E = fi E1 ! fl F1 = F (ff-Contraction)
then jEj = jE1j and jF j = jF1j. By the induction hypothesis we know jE1j !
jF1j which is the desired result.
ffl If the last rule used in the derivation of E ! F was

E1 ! *x:F1
E = ff E1 ! *x:F1 = F (Lambda Contraction)

where ff 2 ftrust; checkg then by the induction hypothesis we get jE1j !
*x:jF1j and since jEj = jE1j and jF j = *x:jF1j this is the desired result.
ffl If the last rule used in the derivation of E ! F was

E1 ! F1 E2 ! F2
E = (distrust *x:E1)E2 ! distrust F1[F2=x] = F (Application)

We have jEj = (*x:jE1j)jE2j and jF j = jF1j[jF2j=x]. By the induction hypothesis jE1j ! jF1j and jE2j ! jF2j. We may now apply the (Application) rule
to get the desired result. The case for the trusted lambda is similar.

Well-typed terms in our extended calculus are strongly normalizing, that is: If
A ` E : o/ then there is a normal form G such that E ! G. This is proved by
an argument using Theorem 13, Strong Normalization for Curry typed *-calculus,
Theorem 1 and the two simulation theorems.

4 Type Inference
The type inference problem is:

Trust in the *-calculus 25
Given an untyped program E possibly with trust, distrust, and check expressions in it,
is E typable? If so, annotate it.

From Theorem 13 we have that trust typing implies Curry typing. Our type
inference algorithm works by first checking if the program has a Curry type and
then checking a condition that only involves trust values.

4.1 Constraints
The type inference problem can be rephrased in terms of solving a system of constraints.

Definition 18
Given two disjoint denumerable sets of variables Vy and Vr, a T-system is a pair
(C; D) where:

ffl C is a finite set of inequalities X ^ X0 between constraint expressions, where

X and X0 are of the forms V or V W11 ! V W22 , and where V1; V2 2 Vy and
W1; W2 2 Vr.
ffl D is a finite set of constraint of the forms W ^ W 0, W = tr, or W = dis,

where W; W 0 2 Vr.

A solution for a T-system is a pair of maps (ffi; '), where ffi maps variables in Vy
to types without their outermost annotation, and where ' maps variables in Vr to
trusts, such that all constraints are satisfied. If ' satisfies all constraints in D, we
say that D has solution '. 2

Given a *-term E, assume that E has been ff-converted so that all bound variables
are distinct. Let Vy be the set consisting of:

ffl A variable [[F ]]y for each occurrence of a subterm F of E; and
ffl A variable xy for each *-variable x occurring in E.

The notation [[F ]]y is ambiguous because there may be more than one occurrence
of F in E. However, it will always be clear from context which occurrence is meant.
Intuitively, [[F ]]y denotes the type of F after the use of subsumption. Moreover, xy
denotes the type assigned to the bound variable x.

Let Vr be the set consisting of:

ffl A variable [[F ]]r for each occurrence of a subterm F of E; and
ffl A variable xr for each *-variable x occurring in E.
ffl A variable hGHir for each occurrence of an application GH in E.

As before, the notation [[F ]]r is ambiguous. Intuitively, [[F ]]r denotes the trust value
of F after the use of subsumption. Moreover, xr denotes the trust value assigned
to the bound variable x. Finally, hGHir denotes the trust value of GH before the
use of subsumption.

From the *-term E, we generate the T-system (C; D) where:

26 P. O/rbaek and J. Palsberg

For each
occurrence in E We have in C We have in D

x xy ^ [[x]]y xr ^ [[x]]r
*x:F xxry ! [[F ]][[F ]]ry ^ [[*x:F ]]y

GH [[G]]y ^ [[H]][[H]]ry ! [[GH]]hGHi

r

y [[G]]r ^ [[GH]]rhGHir ^ [[GH]]

r

trust F [[F ]]y ^ [[trust F ]]y

distrust F [[F ]]y ^ [[distrust F ]]y [[distrust F ]]r = dis
check F [[F ]]y ^ [[check F ]]y [[F ]]r = tr

Denote by T (E) the T-system of constraints generated from E in this fashion.
The solutions of T (E) correspond to the possible type annotations of E in a sense
made precise by Theorem 21.

Let A be a trust-type environment. If ffi is a function assigning types to variables
in Vy and ' a function assigning trusts to variables in Vr, we say that (ffi; ') extend
A if for every x in the domain of A, we have A(x) = ffi(xy)'(xr).

As a shorthand in the following, we write (ffi; ') j= (C; D) to mean that (ffi; ') is a
solution to the constraints (C; D). Define also, for two functions ffi and ffi0 agreeing
on dom(ffi) " dom(ffi0), ffi + ffi0 as the unique function on dom(ffi) [ dom(ffi0) that agrees
with the two functions on their respective domains.

Lemma 19 (Soundness)
If (ffi; ') j= T (E), and ffi; ' extend A then A ` E : ffi([[E]]y)'([[E]]r).

Proof
By induction on the structure of E.

Lemma 20 (Completeness)
If A ` E : tu then there is a solution (ffi; ') j= T (E) with ffi and ' extending A, and
ffi([[E]]y) = t and '([[E]]r) = u.

Proof
By induction on the derivation of A ` E : tu.

E = x: As A ` x : tu we must have x 2 dom(A), A(x) = sv and s ^ t; v ^ u. In

this case T (E) = fxy ^ [[x]]y; xr ^ [[x]]rg. Put ffi(xy) = s and '(xr) = v so
that (ffi; ') extends A. Finally assign ffi([[x]]y) = t and '([[x]]r) = u to satisfy
the constraints.
E = *x:F : By the type rules we must have A[x 7! oe] ` F : sv where oe ! sv ^ t.

By the induction hypothesis we get (ffi; ') j= T (F ), ffi([[F ]]y) = s, '([[F ]]r) = v,
and (ffi; ') extends A[x 7! oe]. Now assign ffi0 = ffi[[[*x:F ]]y 7! t] and '0 =
'[[[*x:F ]]r 7! u]. Now check that oe ! sv ^ t implies

ffi0(xy)'

0(x

r) ! ffi0([[F ]]y)'

0([[F ]]

r) ^ ffi0([[*x:F ]]y)

Trust in the *-calculus 27
as required. So we get (ffi0; '0) j= T (E).
E = GH: By the type rules we must have A ` G : (oe ! sv)w, A ` H : oe where

s ^ t and v . w ^ u. By the induction hypothesis we get (ffi; ') j= T (G) and
(ffi0; '0) j= T (H) and both solutions extending A which means that they agree
on their common domain (the xy's and the xr's in dom(A)). The definition
of T (E) says

T (E) = T (G) [ T (H) [ (f[[G]]y ^ [[H]][[H]]ry ! [[GH]]hGHi

r

y g;

f[[G]]r ^ [[GH]]r; hGHir ^ [[GH]]rg) :

Define ffi00 = ffi + ffi0[[[GH]]y 7! t] and '00 = ' + '0[[[GH]]r 7! u; hGHir 7! v].
Now, (ffi00; '00) j= T (E) because

ffi([[G]]y) ^ oe ! tv = ffi0([[H]]y)'

0([[H]]

r) ! ffi00([[GH]]y)'

00(hGHi

r)

'([[G]]r) = w ^ u = '00([[GH]]r)
'00(hGHir) = v ^ u = '00([[GH]]r) :

and clearly (ffi00; '00) extend A.
E = check F : From the type rules we must have A ` F : str where s ^ t. By

the induction hypothesis we get (ffi; ') j= T (F ), ffi([[F ]]y) = s, and '([[F ]]r) =
tr. Now, T (E) = T (F ) [ (f[[F ]]y ^ [[check F ]]yg; f[[F ]]r = trg). Put ffi0 =
ffi[[[check F ]]y 7! t] and '0 = '[[[check F ]]r 7! u].
Clearly, ffi0; '0 extend A, ffi0([[F ]]y) ^ ffi0([[check F ]]y), and '0([[F ]]r) = tr as
required. The cases for trust and distrust are very similar.

Theorem 21
The judgment A ` E : tu is derivable if and only if there exists a solution (ffi; ') of
T (E) with (ffi; ') extending A such that ffi([[E]]y) = t and '([[E]]r) = u. In particular,
if E is closed, then E is typable with type t and trust u if and only if there exists
a solution (ffi; ') of T (E) such that ffi([[E]]y) = t and '([[E]]r) = u.

Proof
Combine Lemma 19 and 20.

4.2 Algorithm
Definition 22
Given a T-system (C; D), define the deductive closure ( _C; _D) to be the smallest
T-system such that:

ffl C ` _C.
ffl D ` _D.
ffl If V W11 ! V W22 ^ V W33 ! V W44 is in _C, then V3 ^ V1 and V2 ^ V4 are in _C,

and W3 ^ W1 and W2 ^ W4 are in _D.
ffl If X1 ^ X2 and X2 ^ X3 are in _C, then X1 ^ X3 is in _C.

28 P. O/rbaek and J. Palsberg

2
Lemma 23
(C; D) and ( _C; _D) have the same solutions.

Proof
Since C ` _C and D ` _D, any solution of ( _C; _D) is also a solution of (C; D). The
converse can be proved by induction on the construction of ( _C; _D).

If we remove all mentioning of trust and subtyping from the type rules in Figure 8
and from the constraints defined earlier in this section, we obtain two equivalent
formulations of Curry typability (Palsberg & Schwartzbach, 1995). Clearly, E is
Curry typable if and only if jEj is Curry typable. The constraint system (written
out below) that expresses Curry typability will be denoted Curry(E).

For each
occurrence in E We have in Curry(E)

x xy = [[x]]y
*x:F [[*x:F ]]y = xy ! [[F ]]y
GH [[G]]y = [[H]]y ! [[GH]]y
trust F [[trust F ]]y = [[F ]]y
distrust F [[distrust F ]]y = [[F ]]y
check F [[check F ]]y = [[F ]]y

To aid the definition of our type inference algorithm we define the following
operations: If s; t are bare trust types such that jsj = jtj, then define the operators
tjsj and ujtj as follows.

s tjsj t =

8!

:

base if s = t = base
(s1 ujs1j t1)u1uv1 ! (s2 tjs2j t2)u2tv2 if s = su11 ! su22

and t = tv11 ! tv22

s ujsj t =

8!

:

base if s = t = base
(s1 tjs1j t1)u1tv1 ! (s2 ujs2j t2)u2uv2 if s = su11 ! su22

and t = tv11 ! tv22 :

If t1; : : : ; tn are bare trust types, and s is a Curry type such that jtij = s for all
i 2 1::n, then define Fsi ti = t1 ts : : : ts tn. If t is a Curry type, define

small(base) = base big(base) = base
small(s ! t) = big(s)dis ! small(t)tr big(s ! t) = small(s)tr ! big(t)dis

If s is a bare trust type and t is a Curry type such that jsj = t, then s tt small(t) = s
and s ut big(t) = s. In other words, small(t) is the least bare type with erasure t.

For each constraint expression X define

L(C; X) = fV W11 ! V W22 j V W11 ! V W22 ^ X is in _Cg :

Trust in the *-calculus 29
Intuitively, L(C; X) is the set of syntactic lower bounds for X.

We also define the erasure of a constraint expression used in C, mapping trusttype constraint expressions to Curry constraint expressions:

jV j = V
jV W11 ! V W22 j = V1 ! V2

where V1; V2 2 Vy and W1; W2 2 Vr.

Lemma 24
If T (E) = (C; D), and  is a solution to Curry(E), and X1 ^ X2 is a constraint in

_C, then (jX1j) = (jX2j).

Proof
By induction on the construction of _C.

Theorem 25
Suppose T (E) = (C; D). Then T (E) is solvable if and only if E is Curry typable
and _D is solvable.

Proof
Suppose first that T (E) is solvable. By Theorem 21, E is trust typable. It follows from Theorem 13 and the remark above that E is Curry typable, and from
Lemma 23 that _D is solvable.

For the reverse implication, suppose that Curry(E) has solution  and that _D has
solution '. We define ffi inductively in the Curry types of the constraint variables.

ffi(V ) = if (jV j) = base then base

else let fV W1i1i ! V W2i2i g = L(C; V ) [ fsmall((jV j))g

in Fi(jV j)(ffi(V1i)'(W1i) ! ffi(V2i)'(W2i))

To see that ffi is well-defined, we need that the Curry types of the variables V1i and
V2i are of strictly less size than the Curry type of V . For (V W1i1i ! V W2i2i ) 2 L(C; V ),
we get by Lemma 24 that (jV W1i1i ! V W2i2i j) = (jV j) = s ! t for some s; t. This
means that (jV1ij) = s and (jV2ij) = t which are both of smaller size than s ! t,
so ffi is well-defined.

To see that (ffi; ') is a solution of T (E), consider an inequality X1 ^ X2 in C. If
(jX1j) = base, then by Lemma 24, (jX2j) = base, ffi(X1) = ffi(X2) = base, thus
ffi(X1) ^ ffi(X2) as required.

In case (jX1j) = s ! t, we have by Lemma 24 that (jX2j) = s ! t and since
_C is transitively closed we get L(C; X1) ` L(C; X2) so ffi(X1) ^ ffi(X2) as required.

Using the characterization of Theorem 25, we get a type inference algorithm:

30 P. O/rbaek and J. Palsberg

Input: A *-term E of size n.

1: Construct T (E) = (C; D) (in log space).
2: Close (C; D), yielding ( _C; _D) (in O(n3) time, see for example (Palsberg, 1995)).
3: Check if E is Curry typable (in O(n) time).
4: Check if _D is solvable (in O(n2) time).
5: If E is Curry typable and _D is solvable,

then output "typable"
else output "not typable".
The entire algorithm requires O(n3) time. To construct an annotation of a typable
program, we can use the construction of the second half of the proof of Theorem 25.

5 Extensions
In this section we discuss several possible extensions of the type system.

Recursion. The type system can be extended to handle recursion by adding a rec
rule. In the (untyped) reduction system, the rec combinator can be coded with the
classical Y combinator: rec x:E j Y(*x:E). The following reduction rule is a derived
rule in the *-calculus and in our system, and correspondingly we would have a rec
rule in the type system:

E !\Lambda  F
YE !\Lambda  F (YE)

A[x 7! o/ ] ` E1 : o/

A ` rec x:E1 : o/

Subject Reduction still holds, but Strong Normalization of course fails in this case.
The type inference algorithm can also be extended in a straightforward way to deal
with the rec construct.

Polymorphism. ML style let polymorphism can be achieved in the usual way by
replacing let bound variables with their definition. This is of course inefficient as
each definition might then be type-checked many times. The type system can be
extended along the same ideas that extend Curry types to Hindley-Milner types.
An extension of our type inference algorithm remains to be found.

Finding a good type inference algorithm for a type-system with both structural
subtyping and polymorphism is a nontrivial task although the work by Aiken and
Wimmers (Aiken & Wimmers, 1993) and by Eifrig, Smith and Trifonov (Eifrig
et al., 1995) is promising.

A Trust-case Construction. One could imagine the usefulness of a trust-case construction that would allow dynamic dispatch on the trustworthiness of a value. The
reduction rules added for such a construction could be:

E ! trust E0
trust case E F G ! F (trust E0)

E ! *x:E0
trust case E F G ! F (*x:E0)

E ! distrust E0
trust case E F G ! G(distrust E0)

Trust in the *-calculus 31
and the corresponding type-rule:

A ` E : tu A ` F : ttr ! o/ A ` G : tdis ! o/

A ` trust case E F G : o/

Church-Rosser and the Subject Reduction theorem still holds with these extensions and generating constraints for this construct is not hard either. However, this
would only make sense in the presence of a polymorphic trust type system. With
monomorphic trust-types all the trust-case choices would be statically determinable
from the type system, so such a construction would be of very limited use. And
since we have not developed an inference algorithm for a polymorphic trust type
system, this has not been an issue.

Other Lattices. The values of trust-tags may be extended from the two point lattice
used in this paper to any finite lattice. Extending the lattice to a longer linear
lattice accommodates multiple levels of trust. Extensions to non-linear orderings
may allow different properties to be modeled at once: Take the four point lattice
(P(fpath ok; signature okg); `) with the empty set denoting completely untrusted.
This could be used in a web server that can both verify digital signatures and do
consistency checking on URL paths. In such a situation one would extend check to
a construct checking for reverse subset inclusion.

Modules. In a larger scale system with many program modules and many programmers, it is useful to differentiate between functions located in different modules
such that there would be trusted and untrusted modules, where functions defined
in untrusted modules would not be trusted in any other module. This can be realized in our simple system by having a preprocessor that wraps all lambdas in an
untrusted module in the distrust construct. Some external programming environment might also be used to ensure that only trustworthy programmers get to write
trusted modules.

One might also make another distinction among modules, akin to the difference
between safe and unsafe modules in Modula-3 (Cardelli et al., 1989), where only
unsafe modules are allowed to use arbitrary type casts and unlimited address arithmetic. In a trust analysis system, unsafe modules would then correspond to modules
where the trust construct is used, and just as in Modula-3 one has to take extra
care in the unsafe modules.

6 Related Work
The original notion of trust analysis was presented in (O/rbaek, 1995) where an
abstract interpretation analysis and a constraint based analysis for an imperative,
first order language with pointers were given. This work extends trust analysis to
the higher order functional case and formalizes it in terms of an annotated type
system.

In (Mitchell, 1984) Mitchell developed the structural subtyping idea and our type

32 P. O/rbaek and J. Palsberg
system borrows some of these ideas to handle automatic coercion from trusted data
to untrusted data.

In an earlier version of the paper we used a different syntax for trust-types inspired by the work on effect systems by for example Gifford and Jouvelot, writing

for example Bool

tr dis\Gamma ! Bool # tr for what is now written (Booltr ! Booldis)tr. This

turned out to be misleading in that our type system does not involve accumulating
representations of side effects and input/output. We thank our referees for pointing
this out and making us change the syntax of types.

6.1 Why trust analysis isn't...
ffl Binding-time analysis: If trust analysis was equivalent to binding-time

analysis then one would equate tr with static and dis with dynamic, and without using any of our special constructs this analogy goes a long way. However,
the trust construct would correspond to an unrestricted "down-lift" operation
able to convert arbitrary dynamic data to static data, something that is clearly
unsound in a binding-time analysis. Our distrust construct would correspond
nicely to the lift operation, but again the check construct has no counterpart
in binding-time analysis.
ffl Security Analysis: Since the seminal papers by Denning and Denning (Denning, 1976; Denning & Denning, 1977; Denning, 1982), there has been a great
deal of work on using static analysis to ensure that classified information
would not leak out of information systems, cf. (Ban^atre et al., 1994). In security analysis, the basic distinction is between unclassified information and
classified (secret) information. The task is to prevent classified information
from being shown to unprivileged users. Usually this is done by assigning security classes to users as well as to data, and making sure that information
is never transferred from higher (more secret) security classes to lower (less
secret) classes.
Whereas security analysis focuses on preventing classified information leaking
out of the system to unprivileged users, trust analysis focuses on preventing
untrustworthy information flowing into the system. In this sense, trust analysis can be viewed as the dual of security analysis.
A simple example of a security analysis setup would have just two classes:
secret and unclassified. The key relation between these classes is that wherever
secret information is needed, unclassified information will do just as well, so
in analogy with the subtyping system for trust, one can automatically coerce
unclassified information into secret information. Continuing this analogy one
would equate unclassified with tr and secret with dis, and furthermore the trust
construct would correspond to a declassify construct, something rarely, if ever,
found in security analysis systems. We think, however, that for trust analysis,
the trust construct is a very natural construction, it is in fact the cornerstone
of the analysis.
ffl Dynamic typing: Dynamic typing also known as tagging/untagging analysis

(Aiken & Murphy, 1991; Henglein, 1992; Wright & Cartwright, 1994) aims to

Trust in the *-calculus 33
remove type tags as much as possible in a dynamically typed language. One
might be tempted to view, say, distrust as a tagging operation and trust as
the corresponding untagging operation. However, this does not explain how
check should be interpreted and it doesn't match with our application type
rule, in that applying a tagged function to an argument does not necessarily
result in a tagged result.
One idea is that trust analysis might be used as a kind of soft typing extension
to languages like C or C++ which are almost strongly typed, but contain
loopholes such as unrestricted type-casts. The idea is to essentially have two
copies of every C type, a trusted variant and an untrusted variant, such that
the compiler could guarantee no type errors for variables having a trusted
type, whereas the compiler could insert run-time checks for values of untrusted
types. However, it turns out that this kind of analysis is not equivalent to trust
analysis, as illustrated by the following C example:

if ((int) p)

x = 5;
else

x = 7;

Since type-casting is supposed to correspond to distrust and the two assignments to x are dependent on the condition; following (O/rbaek, 1995) x would
have to be treated as untrusted after the if-statement. This is not what we
want for this kind of analysis, because in both cases x would clearly contain
an integer. This illustrates that trust analysis does not serve the purpose of
this analysis.

7 Summary
We have argued for the usefulness of so-called trust analysis to help programmers
produce safer and more trustworthy software. We have presented an extension of
the *-calculus together with a reduction semantics as well as a sound denotational
semantics. The reduction calculus is proved Church-Rosser. We then gave a type
system that enables the static inference of the trustworthiness of values and the
type system was proved to have the Subject Reduction property with respect to
the semantics of our language.

We have related our extension of the *-calculus to the classical *-calculus and
obtained two simulation theorems, as well as shown that well-typed terms in our
calculus are strongly normalizing.

Then a constraint based type inference algorithm was presented and proved correct with respect to the type system.

Finally we have discussed certain possible extensions to our analysis and given
several examples of why it is different from already known analyses.

34 P. O/rbaek and J. Palsberg

7.1 Acknowledgements
Part of this work was completed while both authors were visiting the Laboratory
for Computer Science at the Massachusetts Institue of Technology. We want to
thank the anonymous referees for many valuable comments and Philip Wadler for
encouragement.

References
Aiken, Alexander, & Murphy, Brian R. (1991). Static Type Inference in a Dynamically

Typed Language. Pages 279-290 of: Proc. of the 18'th annual ACM symp. on principles
of programming languages (POPL 18). ACM.

Aiken, Alexander, & Wimmers, Edward. (1993). Type inclusion constraints and type

inference. Pages 31-41 of: Proc. conference on functional programming languages and
computer architecture.

Ban^atre, Jean-Pierre, Bryce, Ciar'an, & Metayer, Daniel Le. (1994). Compile-time detection of information flow in sequential programs. Pages 55-73 of: Gollmann, Dieter (ed),
Computer security - ESORICS 94, 3rd european symp. on research in comp. security.
Lecture Notes in Computer Science, vol. 875. Brighton, UK: Springer-Verlag.

Barendregt, Henk P. (1981). The lambda calculus: Its syntax and semantics. NorthHolland.

Cardelli, L., Donahue, J., Glassman, L., Jordan, M., Kalsow, B., & Nelson, G. 1989 (Nov.).

Modula-3 report (revised). Tech. rept. TR-52. DEC-SRC.

Cardelli, Luca. (1984). A semantics of multiple inheritance. Pages 51-68 of: Kahn, Gilles,

MacQueen, David, & Plotkin, Gordon (eds), Semantics of data types. Springer-Verlag
(LNCS 173).

Denning, Dorothy E. (1976). A Lattice Model of Secure Information Flow. Communications of the ACM, 19(5), 236-242.

Denning, Dorothy E. (1982). Cryptography and data security. Addison-Wesley.
Denning, Dorothy E., & Denning, Peter J. (1977). Certifications of Programs for Secure

Information Flow. Communications of the ACM, 20(7), 504-512.

Eifrig, Jonathan, Smith, Scott, & Trifonov, Valery. (1995). Type inference for recursively

constrained types and it application to OOP. Proc. mathematical foundations of programming semantics. To appear.

Fuh, You-Chin, & Mishra, Prateek. (1990). Type Inference With Subtypes. Theoretical

computer science, 73(1), 155-175.

Henglein, Fritz. (1992). Dynamic typing. Pages 233-253 of: Proc. esop'92, european

symposium on programming. Springer-Verlag (LNCS 582).

Mitchell, John. (1984). Coercion and type inference. Pages 175-185 of: Eleventh symposium on principles of programming languages.

O/rbaek, Peter. (1995). Can you Trust your Data? Pages 575-590 of: Mosses, P. D. (ed),

Proceedings of the TAPSOFT/FASE'95 conference. Lecture Notes in Computer Science,
vol. 915. Aarhus, Denmark: Springer-Verlag. URL: ftp://ftp.daimi.aau.dk/pub/empl/-
poe/index.html.

Palsberg, Jens. (1995). Efficient inference of object types. Information and computation,

123(2), 198-209. Preliminary version in Proc. LICS'94, Ninth Annual IEEE Symposium
on Logic in Computer Science, pages 186-195, Paris, France, July 1994.

Palsberg, Jens, & O/rbaek, Peter. (1995). Trust in the *-calculus. Pages 314-330 of:

Mycroft, Alan (ed), SAS'95: Static Analysis. Lecture Notes in Computer Science, vol.
983. Glasgow: Springer-Verlag.

Trust in the *-calculus 35
Palsberg, Jens, & Schwartzbach, Michael I. (1995). Safety analysis versus type inference.

Information and computation, 118(1), 128-141.

Wall, Larry, & Schwartz, Randal L. (1991). Programming Perl. O'Reilly and Associates.
Wright, Andrew K., & Cartwright, Robert. (1994). A Practical Soft Type System for

Scheme. Proceedings of the 1994 ACM conference on lisp and functional programming
(lfp'94). ACM. URL: ftp://cs.rice.edu/public/wright/HomePage.html.