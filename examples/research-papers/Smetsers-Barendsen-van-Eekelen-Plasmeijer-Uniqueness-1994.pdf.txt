

Guaranteeing Safe Destructive Updatesthrough a Type System withUniqueness Information for GraphsSjaak Smetsers, Erik Barendsen, Marko van Eekelen, Rinus PlasmeijerUniversity of Nijmegen\Lambda 

AbstractIn this paper we present a type system for graph rewrite systems: uniquenesstyping. It employs usage information to deduce whether an object is `unique' ata certain moment, i.e. is only locally accessible. In a type of a function it canbe specified that the function requires a unique argument object. The correctnessof type assignment guarantees that no external access on the original object willtake place in the future. The presented type system is proven to be correct. Weillustrate the power of the system by defining an elegant quicksort algorithm thatperforms the sorting in situ on the data structure.
1. IntroductionSome operations on complex data structures (such as arrays) cannot be implementedefficiently without allowing a form of destructive updating. For convenience, we speakabout those functions as `destructively using' their arguments. In case of graph-likeimplementations of functional languages without any precautions, this destructive us-age is dangerous: on the level of the underlying model of computation this appearswhen arguments are shared between two functions.However, in some specific cases destructive updates are safe, e.g. when it is knownthat access on the original object is not necessary in the future. We call such an object
(locally) `unique'.Sharing/update analysis is used to find spots where destructive updates are possible.However, some functions require that a destructive update can be done in all contextsin which the function is applied. Such updating functions are functions for file I/O,array manipulation, interfacing with existing FORTRAN or C libraries, window-basedI/O and functions that require an efficient storage management (e.g. in situ sortingof a large data structure). This requirement can be explicitly specified via a typesystem. This paper presents a type system related to linear types: uniqueness types.The uniqueness type system is defined for graph rewrite systems. It employs usage
information to deduce whether the uniqueness attribute can be assigned to a type for asubgraph. A type which has the uniqueness attribute is also called a unique type. For\Lambda Department of Computer Science, Toernooiveld 1, 6525 ED Nijmegen, The Netherlands, e-mailsjakie@cs.kun.nl, fax +31.80.652525. 1

functions that require an object of unique type, the type system guarantees that noexternal access on the original object will be possible anymore. So, (depending on theuse of the object in the function body) this information can be used to destructivelyupdate the unique object. A compiler can exploit uniqueness types by generatingcode that automatically updates unique arguments when possible. This has importantconsequences for the time and space behaviour of functional programs. The type systemhas been implemented for the lazy functional graph rewriting language ConcurrentClean. So far, it has been used for the implementation of arrays and of an efficienthigh-level library for screen and file I/O (see Achten et al. (1993)).

The structure of the paper is as follows: first graph rewrite systems are brieflyintroduced using standard terminology (Section 2). Then, a notion of typing is de-fined for graph rewrite systems in Section 3. Section 4 describes a use analysis thatprovides important information that is necessary to assign uniqueness attributes. Howuniqueness attributes are assigned is defined in Section 5. The extension to algebraictype definitions is given in Section 6. The correctness of the type system is proven inSection 7. Section 8 illustrates how reasoning about programs with uniqueness typescan be done, after which Section 9 discusses related work.
2. Graph rewritingTerm graph rewrite systems were introduced in Barendregt et al. (1987). This sectionsummarizes some basic notions for (term) graph rewriting as presented in Barendsenand Smetsers (1992).GraphsThe objects of our interest are directed graphs in which each node has a specific label.The number of outgoing edges of a node is determined by its label. In the sequel we
assume that N is some basic set of nodes (infinite; one usually takes N = N ), and \Sigma  isa (possibly infinite) set of symbols with arity in N .2.1. Definition. (i) A labeled graph (over hN ; \Sigma i) is a tripleg = hN; symb; argsisuch that(1) N ` N ; N is the set of nodes of g;(2) symb : N ! \Sigma ; symb(n) is the symbol at node n;

(3) args : N ! N \Lambda  such that length(args(n)) = arity(symb(n)).Thus args(n) specifies the outgoing edges of n. The i-th component of args(n) isdenoted by args(n)i.(ii) A rooted graph is a quadrupleg = hN; symb; args; risuch that hN; symb; argsi is a labeled graph, and r 2 N . The node r is called the rootof the graph g.(iii) The collection of all finite rooted labeled graphs over hN ; \Sigma i is indicated by G .

2

Convention. (i) m; n; n0; : : : range over nodes; g; g0; h; : : : range over (rooted) graphs.(ii) If g is a (rooted) graph, then its components are referred to as Ng, symbg, argsg(and rg) respectively.(iii) To simplify notation we usually write n 2 g instead of n 2 Ng.2.2. Definition. (i) A path in a graph g is a sequence p = (n0; i0; n1; i1; : : : ; n`) wheren0; n1; : : : ; n` 2 g are nodes, and i0; i1; : : : ; i`\Gamma 1 2 N are `edge specifications' such thatnk+1 = args(nk)ik for all k ! `. In this case p is said to be a path from n0 to n`(notation p : n0  n`).(ii) Let m; n 2 g. m is reachable from n (notation n  m) if p : n  m for some
path p in g.2.3. Definition. Let g be a graph and n 2 g. The subgraph of g at n (notation g j n)is the rooted graph hN; symb; args; ni where N = fm 2 g j n  mg, and symb andargs are the restrictions (to N ) of symbg and argsg respectively.Graph rewritingThis section introduces some notation connected with graph rewriting. For a completeoperational description the reader is referred to the papers mentioned earlier.

Rewrite rules specify transformations of graphs. Each rewrite rule is representedby a special graph containing two roots. These roots determine the left-hand side (thepattern) and the right-hand side of the rule. Variables are represented by special `emptynodes'. Let R be some rewrite rule. A graph g can be rewritten according to R if Ris applicable to g, i.e. the pattern of R matches g. A match _ is a mapping from thepattern of R to a subgraph of g that preserves the node structure. The combinationof a rule and a match is called a redex . If a redex has been determined, the graphcan be rewritten according to the structure of the right-hand side of the rule involved.This is done in three steps. Firstly, the graph is extended with an instance of the
right-hand side of the rule. The connections from the new part with the original graphare determined by _. Then all references to the root of the redex are redirected to theroot of the right-hand side. Finally all unreachable nodes are removed by performinggarbage collection.2.4. Definition. Let ? be a special symbol in \Sigma  with arity 0. Let g be a graph.(i) The set of empty nodes of g (notation gffi) is the collectiongffi = fn 2 g j symbg(n) = ?g:

(ii) The set of non-empty nodes (or interior ) of g is denoted by gffl. So Ng = gffi [ gffl.(iii) g is closed if gffi = ;.The objects on which computations are performed are closed graphs; the others areused as auxiliary objects, e.g. for defining graph rewrite rules.2.5. Definition. (i) A term graph rewrite rule (or rule for short) is a triple R =hg; l; ri where g is a (possibly open) graph, and l; r 2 g (called the left root and rightroot of R), such that(1) (g j l)ffl 6= ;;

3

(2) (g j r)ffi ` (g j l)ffi.(ii) If symbg(l) = F then R is said to be a rule for F.(iii) R is left-linear if g j l is a tree.Here condition (1) expresses that the left-hand side of the rewrite rule should notbe just a variable. Moreover condition (2) states that all variables occurring on theright-hand side of the rule should also occur on the left-hand side.Notation. We will write R j l, R j r for gR j lR, gR j rR respectively.
2.6. Definition. Let p; g be graphs. A match is a function _ : Np ! Ng such that forall n 2 pffl symbg(_(n)) = symbp(n);argsg(_(n))i = _(argsp(n)i):In this case we write _ : p !m g.2.7. Definition. Let g be a graph, and R a set of rewrite rules.(i) An R-redex in g (or just redex ) is a tuple \Delta  = hR; _i where R 2 R, and
_ : (R j l) !m g.(ii) If g0 is the result of rewriting redex \Delta  in g this will be denoted by g \Delta !R g0, orjust g !R g0.(iii) Let \Delta  = hR; _i be a redex. The redex root of \Delta  (notation r(\Delta )) is defined byr(\Delta ) = _(rR) if rR 2 R j l,= rR otherwise.Term graph rewrite systems
A collection of graphs and a set of rewrite rules can be combined into a (term) graphrewrite system. A special class of so-called orthogonal graph rewrite systems is thesubject of further investigations.2.8. Definition. (i) A term graph rewrite system (TGRS) is a tuple S = hG; Ri whereR is a set of rewrite rules, and G ` G is a set of closed graphs which is closed underR-reduction.(ii) S is left-linear if each R 2 R is left-linear.(iii) S is regular if for each g 2 G the R-redexes in g are pairwise disjoint.

(iv) S is orthogonal if S is both left-linear and regular.It can be shown that for a large class of orthogonal TGRSs (the so-called inter-ference-free systems) the Church-Rosser property holds (see Barendsen and Smetsers(1992)).Notation. Let S = hG; Ri be a TGRS. \Sigma S denotes symbols in \Sigma  that appear in Gor in R. The set of function symbols of S (notation \Sigma F ) are those symbols for whichthere exist a rule in R. Moreover, \Sigma D = \Sigma S n\Sigma F denotes the set of data symbols of S.

4

3. Typing graphsIn this section we will define a notion of simple type assignment to graphs using atype system based on traditional systems for functional languages. The approach issimilar to the one introduced in Bakel et al. (1992). It is meant to illustrate the conceptof `classical' typing for graphs. In the next section a different typing system will bedescribed.3.1. Definition. Let V be a set of type variables, and C a set of type constructorswith arity in N . Write C = C 0 [ C 1 [ : : : such that each S 2 C i has arity i.

(i) The set T of (graph) types is defined inductively as follows.ff 2 V ) ff 2 T;C 2 C k; oe1; : : : ; oek 2 T ) C(oe1; : : : ; oek) 2 T;oe; o/ 2 T ) oe ! o/ 2 T:(ii) The set TS of symbol types is defined asoe 2 T ) oe 2 TS;

oe1; : : : ; oek; o/ 2 T ) (oe1; : : : ; oek) ! o/ 2 TS:The arity of a symbol type is 0 if it is introduced by the first rule. Otherwise, the arityis k.Convention. In the sequel, ff; fi; ff1; : : : range over type variables; oe; o/; o/1; : : : rangeover (function) types.3.2. Definition. (i) A substitution is a function \Lambda  : V ! T.(ii) Let \Lambda  be a substitution, and oe 2 TS. The result of applying \Lambda  to oe (notation oe\Lambda )
is inductively defined as follows. ff\Lambda  = \Lambda (ff);(C(oe1; : : : ; oek))\Lambda  = C(oe\Lambda 1; : : : ; oe\Lambda k);(oe ! o/ )\Lambda  = oe\Lambda  ! o/ \Lambda ;((oe1; : : : ; oek) ! o/ )\Lambda  = (oe\Lambda 1; : : : ; oe\Lambda k) ! o/ \Lambda :(iii) oe is an instance of o/ (notation oe ` o/ ) if there exists a substitution \Lambda  such thato/ \Lambda  = oe.

(iv) oe and o/ are isomorphic if o/ \Lambda 1 = oe and oe\Lambda 2 = o/ for some substitutions \Lambda 1; \Lambda 2.We will usually identify isomorphic types, i.e. types that result from each other byconsistent renaming of type variables. That is, we regard types as type schemes.Applicative graph rewrite systemsIn TGRS's symbols have a fixed arity. Consequently, it is impossible to use functionsas arguments or to yield functions as a result. However, higher order functions canbe modeled in TGRS's by associating to each symbol S with arity(S) * 1 a 0-ary

5

constructor S0, and by adding a special apply rule (with function symbol Ap) to theTGRS for supplying these new constructors with arguments.For example, Combinatory Logic (CL) expressed byS xyz ! xz(yz)K xy ! xI x ! xcan be modeled in the following TGRS (using a self-explanatory linear notation).

S(x; y; z) ! Ap(Ap(x; z); Ap(y; z))K(x; y) ! xI(x) ! xAp(Ap(Ap(S0; x); y); z) ! S(x; y; z)Ap(Ap(K0; x); y) ! K(x; y)Ap(I0; x) ! I(x)Note that each new constructor symbol introduces a new rule for Ap.
3.3. Definition. Let S = hG; Ri be a TGRS.(i) Let S 2 \Sigma S with arity * 1. The above symbol S0 2 \Sigma D is called the Curryvariant of S.(ii) The set \Sigma C ` \Sigma D denotes the set of Curry variants of \Sigma D with arity * 1.(iii) We say that S is Curry complete if R contains an Ap-rule for each symbol Swith arity * 1, as described above, and no other Ap-rules.(iv) Let R 2 R. The principal node of R (notation p(R) is lR if symb(lR) 6= Ap;otherwise it is the node containing S0.
Assumption. From now on we assume that all TGRS's are Curry complete.Assigning types to symbolsIn the rest of this section we describe how types can be assigned to graphs given a fixedtype assignment to the (function and data) symbols by a so called environment .Currying imposes a restriction on type environments, that is to say, the type ofa Curry variant S0 should be related to the type assigned to S. We also assume astandard type for the symbol Ap to be declared.
3.4. Definition. (i) Let oe = (oe1; : : : ; oek) ! o/ be a function type. The curried versionof oe (notation oeC) is oeC = oe1 ! (oe2 ! (\Delta  \Delta  \Delta  (oek ! o/ ) \Delta  \Delta  \Delta )):(ii) A (type) environment for S is a function E : \Sigma S ! T such that(1) E(?) = ff,(2) E(Ap) = (ff ! fi; ff) ! fi,(3) E(S0) = (E(S))C.

6

Algebraic data typesWe consider new (basic) types to be introduced by so-called algebraic type definitions.In these type definitions a (possibly infinite) set of constructor symbols is associatedwith each new type T .The general form of an algebraic type definition for T isT ~ff = C1 ~oe1= C2 ~oe2= : : :
Here ~ff 2 V, and ~oei 2 T such that the variables appearing in ~oei are contained in ~ff.Moreover, we assume that each Ci is a fresh constructor symbol. E.g., the type of listscould be obtained as follows.List(ff) = Cons(ff; List(ff))= NilA set A of algebraic type definitions induces a type environment EA for all con-structors introduced by A. More specifically, Let Ci be the ith constructor defined bysome algebraic type T . The EA type of Ci is

EA(Ci) = ~oei ! T ~ff:Convention. Let A be a set of type definitions. \Sigma A denotes the constructor symbolsthat are defined via some definition in A.Assumption. In the sequel we will assume that all constructors in S that are not thecurried variant of some other symbol, are introduced by an algebraic type definition(i.e. \Sigma Dn\Sigma C ` \Sigma A.)Assigning types to graphs
3.5. Definition. Let g = hN; symb; argsi be a graph.(i) A type assignment to g (or g-typing) is a function T : N ! T.(ii) Let T be a g-typing, and n 2 g. The function type of n according to T (notationFT (n)) is defined as FT (n) = (T (n1); : : : ; T (nl)) ! T (n)where l = arity(symb(n)), and ni = args(n)i.(iii) Let E be an environment. T is a g-typing according to E if for each n 2 g thereexists a substitution \Lambda  such that

FT (n) = E(symb(n))\Lambda :3.6. Example. Let E be an environment containing the following type declarations.F : List(fi) ! fi;Cons : (ff; List(ff)) ! List(ff);Nil : List(ff);3 : INT: 7

Below, a graph and its typing according to E are indicated.

F

Cons

Nil3

: INT

: List(INT)
: INT : List(INT)3.7. Definition. Let S = hG; Ri be a TGRS, and A a set of algebraic type definitions.Furthermore, let E be an environment for S .(i) R 2 R is typable according to E if there exist an gR-typing T (according to E)that meets the following requirements.(1) T (l) = T (r).(2) FT (p(R)) = E(symb(p(R))):(ii) R is typable if there exists an environment E extending EA such that each R 2 R

is typable according to E.Condition (2) states that the left root node should be typed exactly with the typeassigned to the root symbol by the environment. This contrasts the requirement forapplicative occurrences of the function symbol.Notice that the latter condition also provides that the abovementioned way of typingrewrite rules is essentially the same as the Mycroft type assignment system for thelambda calculus, see Mycroft (1981). A Milner-like type assignment system (see Milner(1978)) can be obtained by stating this condition for all occurrences of a symbol F inthe rule for F.

It is possible to formulate conditions under which typing is preserved during reduc-tion; cf. Bakel et al. (1992). We will not go into this here.4. Usage analysisA first approach to a classification of `unique' access to nodes in a graph is to count thereferences to each node. In practice, however, a more refined analysis is often possible.This can be achieved by taking into account the specific evaluation order dictated bya specific reduction strategy. E.g. the standard evaluation of a conditional statement

If c Then t Else ecauses first the evaluation of the c part, and subsequently evaluation of either t or e,but not both. Hence, a single access to a node n in t combined with a single access ton in e would overall still result in a `unique' access to n. It is important to note thatthis property only holds if execution proceeds according to the chosen strategy; it maybe disturbed if one allows reduction of arbitrary redexes.We consider the following classification of function arguments.Assumption. Let S be a TGRS.
(i) Let F 2 \Sigma F , say with arity l. Assume that f1; : : : ; lg is divided into k +1 disjoint`argument classes' P; A1; : : : ; Ak:8

(ii) Arguments of each constructor C 2 \Sigma D belong to one single class A.The intended meaning is that arguments occurring in P are evaluated before anyother argument (`preliminaries') whereas A1; : : : ; Ak are groups of `alternate argu-ments': during the actual evaluation, arguments belonging to different groups are neverevaluated both. Furthermore, it is assumed that references via preliminaries to thegraph are released before the graph is accessed via one of the alternate arguments.4.1. Remark. We assume that the argument classification is consistent with eachreduction rule, i.e. the way the arguments of a left-hand side are passed to functions
in the corresponding right-hand side does not conflict with the respective argumentclassifications.We will now describe a `weighted reference count' analysis based on the aboveargument classification. First the argument dependency of functions is translated intodependency relations on nodes in graphs.4.2. Definition. (i) For each symbol S as above, and i; j ^ l, write i ,S j if i; jbelong to the same argument class of S. Moreover, i CS j if i 2 P and j =2 P .(ii) Let g 2 G . For convenience this denotation is extended to paths in g starting
with the same node. I.e.(n; i; m; : : :) , (n; j; m0; : : :) , i ,symbg(n) j;and (n; i; m; : : :) C (n; j; m0; : : :) , i Csymbg(n) j:4.3. Definition. Let g 2 G , and n; n0 2 g.(i) Let p; p0 be paths in g. Then n; n0 are joined by p; p0 (notation p ^n;n0 p0) ifp : m  n; p0 : m  n0 for some m, and p; p0 are disjoint (discarding the first node).

(ii) The relations , and C on Ng are defined byn , n0 , p , p0 for some p ^n;n0 p0;n C n0 , p C p0 for some p ^n;n0 p0:Intuitively, n C n0 indicates that n might be accessed before n0. Moreover n , n0indicates that n and n0 appear in a common argument class of a function and thusmight be accessed in any order.Each reference (`arc') in a graph is labeled with a so-called use attribute.
4.4. Definition. The set of use attributes isU = ffi; \Omega g:To get some intuition for these use attributes it is convenient to consider the objectsthat are accessed via a reference attributed with fi as being `local' and therefore allowedto be used destructively, whereas objects accessed via other references must remainunaffected. Hence, one could say that the symbol fi stands for `write access'; \Omega  for`read access'. The simple approach using reference counts would place a fi at arcspointing to a node with in-degree 1, and \Omega  otherwise. A more refined approach is
described below. 9

4.5. Definition. Let g 2 G , and n 2 g. The set of accesses of n (notation acc(n)) isacc(n) = f(m; i) j argsg(m)i = ng:4.6. Definition. Let g 2 G . The arcs of g are annotated by the function use : N !U \Lambda with length(use(n)) = arity(symb(n)), defined as follows. Let n 2 g. Say acc(n) =f(m1; i1); : : : ; (ml; il)g. Thenuse(mk)ik = \Omega  if mk , mk0 or mk C mk0 for some k0;= fi otherwise:
Note that this definition completely specifies the function use.4.7. Example. Using the standard classification of arguments of the conditional IF,and no specific assumptions about other symbols, the following use-assignments aremade.

IF
G H

C

r'
ng

ngng
ng

IF
G H

C

r'
ng

r'r'Now we can formulate which redexes are allowed to be contracted, in terms of theuse function.4.8. Definition. (i) Let g 2 G , and m; n 2 g. Then m is local for n (in g) if

8p : rg  m [n 2 p]:(ii) Let \Delta  = hR; _i be a redex in g. We say that \Delta  is applicable if for all iuseg(_(l))i = fi ) argsg(_(l))i is local for _(l):The intention is that at least the redexes chosen by the strategy are applicable.5. Uniqueness typing
Uniqueness typesThe use analysis described so far only takes the reduction strategy into account; not theparticular structure of the rewrite rules. The use attributes of arguments may changeduring reduction, e.g. the fi attribute of a certain argument may change into a \Omega  afteris redex has been contracted.However, for a function F that destructively uses one of its arguments it should beguaranteed that at the moment F is evaluated the argument has a fi attribute. Oneway to ensure this is to require that this property holds at the moment the applicationof F is built and that is remains valid during reduction.

The aim of the rest of this paper is to present a `type system' in which the above-mentioned analysis can be performed. 10

The fact that a function may use one or more of its arguments destructively isexpressed in its `uniqueness type'. The syntax of these types is given in the followingdefinition.5.1. Definition. (i) The set U of uniqueness types is defined inductively byffl ; \Theta  2 U;u; v 2 U ) u \Theta ! v 2 U;u ffl! v 2 U
(ii) The set U ffl of unique types is defined byU ffl = fu 2 U j u = ffl or u = v ffl! w for some v; w 2 Ug:Moreover, U\Theta  = UnU ffl .(iii) The set US of uniqueness symbol types is defined asu 2 U ) u 2 US;u1; : : : ; uk; v 2 U ) (u1; : : : ; uk) ! v 2 US:The constants ffl and \Theta  represent `unique use' and `potentially multiple use' respectively. The arrows are annotated to distinguish unique function objects fromunique objects without specified structure, and nonunique function objects from generalnonunique objects. In the following example this will be illustrated.5.2. Example. Suppose Upd denotes a binary function which destructively updatesits first argument with its second argument. So, the intended U-type of Upd is some-thing of the form ( ffl ; \Theta )!u. It is natural to require that the uniqueness of the updatedobject is propagated. Thus one arrives at the following type for Upd.Upd : ( ffl ; \Theta ) ! ffl
A partial application of Upd to some unique expression g results in a function Ap(Upd0; g)that may not be copied. For, if copying would be allowed, then each of the applicationsof a copy of the function would be allowed to update the first argument g destructively,as is illustrated by the expression G(Ap(Upd0; g); h) assuming the ruleG(f; x) ! Pair(Ap(f; x); Ap(f; x));which is obviously unwanted.In our type system the U-type of the above expression Ap(Upd0; g) will be \Theta  ffl! fflwhich will prevent it from being copied.

However, in any context in which a nonunique nonfunctional U-type is expected itis harmless to offer a unique object. This gives rise to a subtype hierarchy specifyingwhich types are convertible (can be coerced ) to other types. These coercions are definedas an ordering on U. They are not only depending on the demanded and offered typesof the context but also on the way the offered object is accessed. If the use informationof graphs is not taken into account, some graphs are wrongly accepted. For this reasonwe define a coercion relation that also depends on the use value of the reference viawhich the corresponding part of the graph is accessed.

11

5.3. Definition. The orderings ^fi and ^\Omega  on U are defined as follows.(i) Coercions via fi-references are generated byffl ^fi ffl ;\Theta  ^fi \Theta ;ffl ^fi \Theta ;u1 ^fi u2; v1 ^fi v2 ) u2 ffl! v1 ^fi u1 ffl! v2;u2 \Theta ! v1 ^fi u1 \Theta ! v2:

(ii) Coercions via \Omega -references are the following.\Theta  ^\Omega  \Theta ;ffl ^\Omega  \Theta ;u1 ^fi u2; v1 ^fi v2 ) u2 \Theta ! v1 ^\Omega  u1 \Theta ! v2:Since we do not have type variables the notion of type instance has to be adjustedslightly. Intuitively, a type u is an instance of a type v if u has `more structure' thanv. This is made precise in the following definition.
5.4. Definition. The relation ` on U is defined as:ffl ` ffl ; u ffl! v ` ffl ;\Theta  ` \Theta ; u \Theta ! v ` \Theta ;u1 ` u2; v1 ` v2 ) u1 ffl! v1 ` u2 ffl! v2;u1 \Theta ! v1 ` u2 \Theta ! v2:If u ` v we say that u is an (U-type) instance of v.
CurryingAs we have seen, in some cases it can be dangerous to copy references to functions. Toprevent a `dangerous' function from being copied it is distinguished from `safe' functionsby typing it with an arrow type supplied with a ffl attribute. The observation that oncea symbol has been applied to a unique argument it may not be copied anymore (seeexample 5.2) leads to the following Currying rule.5.5. Definition. (i) Let u 2 U. The uniqueness attribute of u (notation [u] is definedas follows.

[u] = ffl ; if u 2 U ffl= \Theta ; if u =2 U ffl :(ii) For ~u = (u1; : : : ; uk) and j ^ k the cumulative uniqueness attribute up to j(notation [~u]j) is defined by[~u]j = ffl if [ui] = ffl for some i ^ j,= \Theta  otherwise.

12

(iii) Let u = (u1; : : : ; uk) ! v. The set of curried versions of u (notation uC) isuC = f u1 \Theta ! (u2 [~u]1! \Delta  \Delta  \Delta  (uk [~u]k\Gamma 1! v) \Delta  \Delta  \Delta );u1 ffl! (u2 [~u]1! \Delta  \Delta  \Delta  (uk [~u]k\Gamma 1! v) \Delta  \Delta  \Delta ) g:The effect of applying a (possibly curried) function to a unique argument is thatthe result of the application itself becomes unique. One could say that uniquenessinformation `propagates upwards'.The correspondence between a symbol (with arity * 1) and its Curry variant is
given by that Ap rule. In contrast to the (ordinary) type system presented in section3, Ap can be used with different U which are not instances of one type. To make such`generic' functions possible we allow the type environment to contain more than onetype for each symbol.5.6. Definition. An (applicative) uniqueness type environment is a function E : \Sigma  !""(U) such that(1) E(?) = f ffl ; \Theta g,(2) E(Ap) = f (\Theta  \Theta ! \Theta ; \Theta ) ! \Theta ; ( ffl \Theta ! \Theta ; ffl ) ! \Theta ;

(\Theta  \Theta ! ffl ; \Theta ) ! ffl ; ( ffl \Theta ! ffl ; ffl ) ! ffl ;(\Theta  ffl! \Theta ; \Theta ) ! \Theta ; ( ffl ffl! \Theta ; ffl ) ! \Theta ;(\Theta  ffl! ffl ; \Theta ) ! ffl ; ( ffl ffl! ffl ; ffl ) ! ffl g;(3) E(S0) ` (E(S))C.Here AC = faC j a 2 Ag.Assigning uniqueness types to graphsAssigning U-types to graphs can be done in two ways. The first way is comparable
to standard type assignment (section 3). In the second way, the use attributes of thegraph as well as coercions are taken into account.5.7. Definition. Let g = hN; symb; argsi be a graph, and E be an environment. Fur-thermore, let U : N ! U.(i) Let n 2 g. The function type of n (notation FU (n)) isFU (n) = (U(n1); : : : ; U (nl)) ! U (n);where l = arity(symb(n)), and ni = args(n)i.

(ii) U is an uniqueness typing for g according to E if for each n 2 g there existsu 2 E(symb(n)) such that FU (n) ` u:(iii) Let use be the function that supplies g with use attributes. U is an weighteduniqueness typing for g according to E if for each n 2 g there exist u 2 E(symb(n)) andv1; : : : ; vk 2 U such that U (ni) ^ui vi;(v1; : : : ; vk) ! U (n) ` u;
where ni = args(n)i, and ui = use(n)i for i ^ k = arity(symb(n)).13

(iv) If U is a (weighted) uniqueness typing for g, then the type of g (notation U (g))is simply U (rg).5.8. Definition. Let S = hG; Ri be a TGRS, and A a set of algebraic type definitions.Furthermore, let E be an environment.(i) R 2 R is uniqueness-typable (according to E) if for each u 2 E(symb(l)) thereexist a function U : gR ! U such that(1) U is a uniqueness typing for R j l,(2) U is a weighted uniqueness typing for R j r,

(3) U (r) ^fi U (l),(4) FU (p(R)) = u.Such an U is called a uniqueness typing for R.(ii) R is uniqueness-typable if there exists an environment E extending EA, such thateach R 2 R is uniqueness-typable according to E.(iii) S is uniqueness-typable if there exists an uniqueness type environment E extend-ing EA such that each R 2 R as well as each g 2 G is uniqueness-typable according toE.
6. Algebraic type definitionsSince one allows pattern matching in function definitions, it is sometimes wronglyconcluded that part of a pattern is unique. This appears e.g. in the following example,taking ffl ! \Theta  for the constructor C and \Theta  ! ffl for F with rule F(C(x)) ! x.

D

F

H
CFor this reason we require that (data) symbols appearing in a pattern of a rewrite rulealso obey an `upward propagation' rule, that is to say, if such a symbol expects one ormore unique arguments the application itself is unique. E.g. in the above example Cshould be typed with ffl ! ffl , rejecting the given F-type.Since the only symbols appearing in function patterns are constructors introduced

by some algebraic type definition, the upward propagation requirement is obtained bymaking following assumption.Assumption. Let C 2 \Sigma D with uniqueness type (u1; : : : ; uk) ! v. Thenui 2 U ffl for some i ^ k ) v 2 U ffl :Consequently, a data object can only contain unique subparts if the object itself isunique. The fact that a symbol may have more than one environment type is also very

14

useful for constructors. Remember, for example, the following algebraic type definitionfor lists. List(ff) = Cons(ff; List(ff))= NilA list of which the `spine' is unique can be obtained by typing Cons byCons : (\Theta ; ffl ) ! ffl :
A list with unique elements can be specified by assumingCons : ( ffl ; ffl ) ! ffl :Notice that, because of the propagation rule, the uniqueness of elements implies theuniqueness of the spine.Allowing both types for Cons simultaneously in the present type system may causetype conflicts. E.g. in the rule F(Cons(x; y)) ! x;
F can be typed with ffl ! ffl . This is wrong, as is illustrated by the following applicationof F.

Cons

Cons
H Nil

FOne way to solve this problem is to distinguish the different types of the constructors

by introducing uniqueness type constructors. We only give an example.6.1. Example. In the extended system, Cons can be typed as follows.Cons : ( ffl ; fflList( ffl )) ! fflList( ffl );Cons : (\Theta ; fflList(\Theta )) ! fflList(\Theta ):Then, a spine-unique list is typed with fflList(\Theta ) whereas the list containing also unique
elements is typed with fflList( ffl ).This extension will not be elaborated here. However, to prevent incorrect typeassignments we make the following assumption about type environments.Assumption. If E is a uniqueness type environment, then the constructor types arechosen in such a way that the type conflicts mentioned above cannot occur.15

7. CorrectnessIn order to show that uniqueness typing is preserved during reduction, some analysiswith respect to the use function is needed. We focus on the relation between theuniqueness typing of a rewrite rule and the usage information of a graph before andafter applying this rewrite rule. We will merely give an outline of the proof. The detailswill appear separately.Fix an orthogonal TGRS S = hG; Ri.7.1. Definition. Let \Delta  = hR; _i be a redex in g.

(i) Let U : R ! U. \Delta  is U -type correct if U is a uniqueness typing for R accordingto E, and for each n 2 R j l, n 6= l (say n = args(m)i) one hasU (n) 2 U ffl ) useg(_(m))i = fi:(ii) \Delta  is type correct if \Delta  is U -type correct for some U.Note that the definition of `applicable' (see 4.8) formulates a locality condition forthe direct arguments of _(l) only. The following result extends this property to allnodes in the matching fragment of the graph.
7.2. Lemma. Let \Delta  be applicable and U -type correct. Then for all n 2 (R j l) " (R j r)with n 6= l one has U (n) 2 U ffl ) n is local for _(l):Proof. For `ordinary' reduction rules, this follows from the propagation criterion forconstructors and regularity of S. For Ap reduction rules, the specific form of currytypes and the predefined types for Ap imply the result. \Lambda 7.3. Lemma. Let m; n 2 g with (m; i) 2 accg(n). Suppose n is on a cycle not contain-ing m. Then useg(m)i = \Omega .
Proof. Examine the definition of use. \Lambda 7.4. Proposition. Let \Delta  = hR; _i be applicable in g. Say g \Delta !R h. Suppose \Delta  is U-typecorrect, with U (r) 2 U ffl . Thenacch(r(\Delta )) ` accg(_(l)):Proof (Sketch). By the following case distinction.Case 1. r(\Delta ) =2 _(R j l). Then r(\Delta ) is fresh in h, so acch(r(\Delta )) = accg(_(l)) afterredirection.

Case 2. r(\Delta ) = _(n), n 2 _(R j l). Since U (n) 2 U ffl it follows by type correctnessand lemma 7.2 that _(n) is local for _(l). Hence _(l)  m for every (m; i) 2 accg(_(n)).Now let (m; i) 2 accg(_(n)). We want to show that m is not present in h. If m 2_(R j l) this is easily seen. Otherwise, if m would be present in h (after redirectionand garbage collection), then _(n)  m ( _(n)). Hence useg(_(m0))i = \Omega  for any(m0; i) 2 accR(n), by lemma 7.3, contradicting type correctness of \Delta . Taking the effectof redirection into account it follows that acch(_(n)) ` accg(_(l)). \Lambda 16

7.5. Proposition. Let \Delta  be applicable and U -type correct in g; say g \Delta !R h.(i) Suppose U (r) 2 U ffl . Then for all (m; i) 2 accg(_(l)) such that m is present inh one has useg(m)i = fi ) useh(m)i = fi:(ii) Let n 2 R j r with n 6= r. Suppose U (n) 2 U ffl . Then for all (m; i) 2 accR(n)useR(m)i = fi ) useh( ^m)i = fi;where ^m denotes the h-node corresponding to m.Proof (Sketch). (i) Suppose useg(m)i = fi. By proposition 7.4 we only have to consider accg(m) to determine useh(m)i. If p ^m;m0 p0 in h causing useh(m)i = \Omega , then aredirection `above' _(l) has taken place. This can only occur if _(l) is on a cycle in g,contradicting lemma 7.3.(ii) By a case distinction, distinguishing the possible positions of n; m. Lemma 7.2is used in the case n 2 R j l and m =2 R j l. \Lambda 7.6. Proposition. Let \Delta  be applicable in g; say g \Delta !R h. Let n 2 g such that n =2_(R j l), and n 2 h. Then for all (m; i) 2 accg(n) with m present in h one hasuseg(m)i = fi ) useh(m)i = fi:
Proof (Sketch). Suppose, towards a contradiction, useg(m)i = fi but useh(m)i = \Omega .Suppose this is caused by m0, i.e. (m0; i0) 2 acch(m) such that m , m0 or m C m0, sayp ^m;m0 p0 with p , p0 or p C p0. Since this situation does not occur in g, these partscontain new nodes or new arcs. Distinguish two cases. If r(\Delta ) =2 p; p0 one arrives ata conflict with the argument classification (cf. remark 4.1). Assuming, on the otherhand, r(\Delta ) 2 p or r(\Delta ) 2 p0 leads to a contradiction with useg(m)i = fi. \Lambda For reduction on uniqueness-typed graphs, the above results imply a `subject re-duction' result: typing remains correct when reducing applicable redexes.
7.7. Lemma. Let g 2 G. Suppose g is uniqueness-typable. If \Delta  is applicable, then \Delta is type correct.Proof. Obvious. \Lambda 7.8. Lemma. (i) Let u; v; w 2 U. Thenu ^fi v; v ^\Omega  w ) u ^\Omega  w:(ii) Let u; v; v0 2 U. Suppose u ^fi v and v0 ` v. Then there exists u0 2 U withu0 ` u and u0 ^fi v0.
7.9. Theorem. Suppose R is uniqueness-typable according to E. Let U be a uniquenesstyping for g (according to E ). Furthermore, let g \Delta !R h with \Delta  applicable. Then thereexists a uniqueness typing U 0 for h such that U0(h) = U (g).Proof. U can be extended to a uniqueness typing of h by defining it on the new nodesaccording to the type assignment to \Delta  (proposition 7.5 (ii)). The type assigned to theother nodes remains correct, as follows from propositions 7.5 (i, ii), 7.6 and lemma 7.8,by distinguishing the different kinds of nodes in h. \Lambda 

17

8. Reasoning about programs with uniqueness typesUniqueness types can be used in several contexts. When one wants to interface func-tional languages with imperative programs, one can assign a unique type to thosearguments that are destructively updated by the imperative function. In this wayfile I/O and array updating can be incorporated without loosing the referential trans-parency. With these applications in mind it may seem that the destructive behaviourof the function has to be explicitly programmed using a non-functional programminglanguage. However, it is of course also possible for a compiler to generate destructiveupdates for pure functions defined in the functional language itself. This is of great
importance for improving the time-space behaviour of functional programs.Below an example is given in a functional programming language of which it isassumed that uniqueness types are assigned on the underlying graph rewrite system(which can be derived directly from the program by removing some syntactical sugar).The language uses underlining to indicate that a type has the uniqueness attribute ffl .[ ] in a type denotes the List type. [ ] in a rule denotes the Nil element and [ a j b ]denotes Cons a b. ( ,. . . , ) denotes standard tupling. So, [ T ] denotes a list of type Twith a unique spine.qs :: [ T ] ! [ T ]

qs [ ] = [ ]qs [ hd j tl ] = (qs left) ++ [ hd j qs right ]where(left, right) = split tl hdsplit :: [ T ] ! T ! ([ T ]; [ T ])split [ ] p = ([ ], [ ])split [ hd j tl ] p = ([ hd j left ], right), if p * hd= (left, [ hd j right ])where

(left, right) = split tl pCompared with the imperative quick-sort algorithm the functionally written quick-sort algorithm qs has the disadvantage that the split function has to construct new listsfor its result. Now, if the function split would be defined on a spine-unique list, theconstruction of the new cons nodes could be done by updating the old ones. Looking atthe actual difference between the old cons node given as an argument to split ([hd j tl])and the new cons node to be constructed (either [hd j left] or [hd j right]) it can bededuced that only the tail of the cons node has to be updated. This means that thesplit function does not create new cons nodes at all but is actually rearranging tail
pointers in such a way that the ordered list is obtained. Such in situ updating isessential to be able to handle large data structures efficiently.With respect to the updating the run-time behaviour of the functional program canbe similar to its imperative counterpart. However, the specified program will requirea relatively large recursion stack. Both split and qs can be transformed to a tailrecursive version using program transformations that also eliminate the constructionof intermediate data structures. Tail recursion is usually translated into a loop onthe machine code level. The applied transformation maintains the uniqueness of thetypes. So, for the resulting elegant functional program a compiler can generate code

18

that is as efficient as the code for an imperatively written quick-sort algorithm. Hence,this example shows that uniqueness types solve one of the challenges set at the 1990Dagstuhl seminar on functional languages (Johnsson (1990)).qs :: [ T ] ! [ T ] ! [ T ]qs [ ] tail = tailqs [ hd j tl ] tail = qs left [ hd j qs right tail ]where(left, right) = split tl hd [ ] [ ]

split :: [ T ] ! T ! [ T ] ! [ T ] ! ([ T ]; [ T ])split [ ] p left right = (left, right)split [ hd j tl ] p left right = split tl p [ hd j left ] right, if p * hd= split tl p left [ hd j right ]The reasoning about the programs above implicitly made certain assumptions aboutthe generated code. It was assumed that updating was actually done whenever thiswas possible. More specifically, it was assumed that updates could actually take placefor all objects of the same type. Using only such very general kinds of assumptionsand the uniqueness type information the storage behaviour of the functional program
was deduced and improved by a program transformation. It is important that theseassumptions are further formalised. Any compiler should obey the resulting formalrules such that reasoning about the time and space behaviour of a functional programis independent of a specific compiler. The programmer then can deduce whether or notit is worthwhile to use uniqueness types for those cases where the efficiency of the time-space behaviour is critical. It seems that such reasoning is relatively simple and can beapplied successfully to design time and space efficient purely functional programs formany kinds of real-life applications.
9. Related workThe update problem is also addressed (using linear types) in Wadler (n.d.) and Guzm'anand Hudak (1991). Both papers use lambda calculus as basic model hence requiringa more indirect kind of analysis. With the proposed approach in this paper graphsare used directly as the objects of consideration. The presented system for unique-ness types incorporates a solution to several of the questions raised in Wadler (n.d.).Uniqueness types are in a sense orthogonal to the standard type systems for functionallanguages. The uniqueness type system has been used successfully to support highlevel I/O and efficient array handling. Experience with uniqueness types has shown an
important change in the use of functional languages from academic exercises to real-life programming (ranging from a window-based text editor to a relational database).The use function presented in Section 4 has been inspired by the analysis presentedfor poly-lamst in Guzm'an and Hudak (1991) which is geared towards efficient arraymanipulation. They use Wadsworth's shared lambda calculus involving partly copyingof lambda terms when functions are shared. In a certain sense the proposed unique-ness types are a generalisation of their single-threadedness analysis to a general graphrewriting context.

19

ReferencesAchten, P.M., J.H.G. van Groningen and M.J. Plasmeijer (1993). High level specifica-tion of i/o in functional languages, Proc. of International Workshop on FunctionalLanguages, Glasgow, UK, Springer Verlag,.Bakel, S, van, S. Smetsers and S. Brock (1992). Partial type assignment in left-linearterm rewriting systems, Proc. of 17th Colloqium on Trees and Algebra in Program-ming (CAAP'92), Rennes, France, Springer Verlag, LNCS 581, pp. 300-322.
Barendregt, H.P., M.C.J.D. van Eekelen, J.R.W. Glauert, J.R. Kennaway, M.J. Plas-meijer and M.R. Sleep (1987). Term graph reduction, Proc. of Parallel Archi-tectures and Languages Europe (PARLE), Eindhoven, The Netherlands, SpringerVerlag, LNCS 259 II, pp. 141-158.Barendsen, Erik and Sjaak Smetsers (1992). Graph rewriting and copying, TechnicalReport 92-20 , University of Nijmegen.Guzm'an, Juan C. and Paul. Hudak (1991). Single-threaded polymorphic lambda calcu-lus, Proc. of Logic in Computer Science (LICS'90), Phildelphia, IEEE Computer

Society Press,, pp. 333-345.Johnsson, Thomas. (1990). Discussion summary: which analysis?, Proc. of FunctionalLanguages: Optimization For Parallelism, Dagstuhl, Germany, Dagstuhl seminar,pp. 4-5.Milner, R.A. (1978). Theory of type polymorphism in programming, Journal of Com-puter and System Sciences.Mycroft, A. (1981). Abstract interpretation and optimising transformations for applicative programs, Dissertation, University of Edinburgh.Wadler, P. (n.d.). Linear types can change the world!, Proc. of Working Conferenceon Programming Concepts and Methods.

20