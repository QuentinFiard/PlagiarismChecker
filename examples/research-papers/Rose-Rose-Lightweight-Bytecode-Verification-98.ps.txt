

Lightweight Bytecode Verification

\Lambda 

Eva Rose# and Kristoffer Ho/gsbro RoseLIP, ENS-Lyon; 46, Allee d'Italie; 69364 Lyon 7; France
E-mail: Eva.Rose@ENS-Lyon.FR and Kristoffer.Rose@ENS-Lyon.FR

September 21, 1998

Abstract
Java Bytecode Verification ensures that bytecode can be trusted to avoid var-ious dynamic runtime errors, but it requires an analysis which is currently

unrealistic to implement on systems with very sparse resources such as Sun'sJava Cards featuring a reduced Java virtual machine embedded on a smartcard (credit card with an integrated microprocessor). Commonly it is as-sumed that verification has to be performed off-card and shipped by means
of cryptographic protection techniques, e.g., digital signatures, to ensure thatthe bytecode is not tampered with after it has been verified. These techniques,
however, create a single point of failure trust because of their dependence ona secret (private) key. This is particularly serious when dealing with embedded systems with a very wide distribution such as Java Cards.This paper proposes an alternative solution by splitting the verification
process in two parts: an off-card part, where sufficient verification informa-tion is constructed as a

verification certificate to be sent together with thebytecode, and an on-card part, where the remaining verification is performed

as a check of the code and the certificate, the lightweight verification, whichhas the advantage of running in a reasonable almost constant space (and almost linear time). We give a formal specification of the two componentsfor a subset of Sun's

Java Card Language, sufficiently strong to write non-trivial down-loadable applets. We prove that the technique is

tamper-proofby showing it both sound and complete with respect to standard bytecode

verification. Finally we argue that our approach is safer than usual bytecodeverification because it isolates a non-complex safety-critical component, the
bytecode checker.

\Lambda Extended abstract for FUJ '98.

#Funded by GIE Dyade, a joint INRIA/Bull alliance.

1

JavaProgram javac VerifiedJVM

bytecode Network

JVMbytecode

Untrusted

verifier TrustedJVMbytecode execution

Figure 1: Standard bytecode verification.

JavaProgram javac+

certifier

VerifiedJVM
bytecode

Certificate

Network JVMbytecode

Certificate
Untrusted

checker TrustedJVMbytecode execution

Figure 2: Lightweight bytecode verification.
1 Introduction
There is a growing interest for using personalized smart cards, such as Sun's Java
Card (Sun 1997), because of the independence they offer their users by having an
on-card microprocessor. In particular in combination with the fast and flexible information exchange, offered by the Internet and other global networks. However,
the current standard (Sun 1997) does not support dynamic downloading of code
onto Java Cards since they represent too small a runtime environment, typically
16 kB ROM and 12 kB RAM, for hosting and running any of the Java security components which are normally applied by the code receiver to ensure that downloaded
code can be trusted. The Java bytecode verifier is considered as the basic of these
components since it ensures the received code against various, basic dynamic errors (for a comprehensive description of the verifier and the Java virtual machine,
JVM, we refer to the official specification, Lindholm & Yellin 1996). Figure 1 illustrates where the bytecode verifier traditionally works during a bytecode transfer
over a network.

Bytecode verification is inherently a data-flow analysis problem applied to individual Java methods (Lindholm & Yellin 1996). So even though some optimizations are possible, it requires that constraints are collected and resolved for all program points. Clearly, bytecode verification is not realizable on a small system in its
current form. It is commonly assumed that downloading bytecode to a Java Card
requires that verification is performed off-card, establishing trust in the bytecode
by cryptographic protection techniques, e.g., digital signatures, to ensure that the
bytecode is not tampered with after it has been verified. These techniques, however, create a single point of failure trust because of their dependence on a secret

2

(private) key. This is not only a problem when the embedded systems are widely
distributed, it is also unfortunate when designing cards where the code producer
and receiver do not necessarily trust the same sources (or each other).

In the full paper we explain "proof carrying code" (PCC, Necula 1997).
The approach chosen in this paper is inspired by the work on PCC. We propose
that bytecode, which has been verified by the code provider, is sent with a verification certificate, which makes it possible at the receiver's side simply to perform
a check of this information against the bytecode actually received, in order to ensure that it is verifiable. We call this check for lightweight verification because for
ordinary methods the receiver can perform it with modest storage requirements.
Figure 2 illustrates how the bulk of the verification is moved into the compilation
system at the cost of adding the certificate to the bytecode. (We envision extending
the existing bytecode verifier in the javac compiler to produce certificates.)

The bytecode verifier assigns a description of the types of each stack element
and local variable at each instruction. Formally, this means that bytecode verification can be seen as type reconstruction. From this point of view the certificate
becomes a typing and lightweight bytecode verifier a type checker (Rose 1998).
We will exploit these observations to give a complete formal description of the
lightweight bytecode verifier as well as a certificate. In particular we prove that
lightweight bytecode verification does not introduce any security breaches, i.e., is
tamper-proof. This is obtained by showing that lightweight verification is

Sound: If a certified bytecode method is accepted by the checker, then the same

method will pass standard bytecode verification.

Complete: If a method can be bytecode verified the ordinary way, then the certifier

can build a certificate.

As specification language, we use Natural Semantics (Kahn 1987) because it is
particularly suitable for specifications of modular inductive descriptions and proofs
of properties.

Finally, we assume that our reader is familiar with the Java language (Gosling,
Joy & Steele 1996) and has some knowledge of the virtual machine (Lindholm &
Yellin 1996).

Notation. We will apply the Backus-Naur Form (BNF) style ::= to express structural inductive sort definitions with j to separate alternatives. When inductive structure is not needed, we simply write =. We use a special font for constants and constructors, e.g., methsig. Moreover, we will use a \Lambda  mark to describe sequences of
zero or more elements of the marked sort. In particular, sequences are constructed
in equations with an infix associative "\Delta " (dot), or if empty, simply written "ffl".

Overview. In Section 2 we explain the Java subset that we use. In Section 3 we
formalize the elements of (standard) verification used in the (standard) verification inference rules presented in Section 4. Based on these we present lightweight

3

verification in Section 5, including a formal statement of equivalence of the usual
bytecode verification and the combination of the lightweight certification and verification. Finally, in Section 6, we conclude as well as discuss related work and
future directions

2 The Virtual Machine Subset
We consider a subset of the Java Virtual Machine (JVM) which is strong enough
to treat a non-trivial subset of the Java Card language (Sun 1997). (In Rose (1998),
a compiler defining our JVM subset from the source subset is specified.) A subset which focuses on object-oriented features, notably object creation, dynamic
method dispatch, and instance variables, as well as exceptions. The later deserves
special mentioning since the finally clause, in order to compile to compact bytecode, is the only reason why subroutine call instructions, jsr and ret, are required
at the machine level (Lindholm & Yellin 1996). So, since they represent a delicate (Stata & Abadi 1998) but not essential part of the Virtual Machine, and since
we do not believe that the complexity of handling it outweighs the penalty of code
duplication when compiling without, they have been omitted from our JVM subset.

Otherwise the most significant features which we have chosen to omit are static
declarations, arrays, interfaces and packages, access modifiers (protected and
private), and type structures (as provided by the Java package and interface
constructions), and hence the corresponding bytecode support. For reasons of clarity we have moreover excluded most of the "short forms" of instructions used to
make the bytecode shorter (and slightly faster). We remark that the source subset
which has dictated our JVM subset is close to the Java subset BALI of Nipkow
& von Oheimb (1998); even if they were developed independently this is hardly
surprising because both sublanguages were designed with the purpose of writing
non-trivial object-oriented programs.

An important remark is that JVM bytecode is transmitted in units called class
files corresponding to all the data needed to execute a Java class. However, no
class file format exists yet for the Java Card subset, so we have chosen to just
model the two components that are needed to perform bytecode verification: the
bytecode instruction sequence of the method to verify and the constant pool with
constant values, external reference names, and type information. A formalization
of these components is given below, followed by a formalization of the dynamic
load context, needed to formalize bytecode verification in the next sections.

2.1 Bytecode Instruction Sequences
The translation of our non-trivial Java subset into JVM results in a JVM subset
which consists of the following 24 JVM instructions:

i 2 Instruction ::= iconst 0 j iconst 1 j aconst null

j dup j pop j iadd j isub

4

j iload[n] j aload[n] j istore[n] j astore[n]
j checkcast[n] j ldc w[n] j new[n]
j putfield[n] j getfield[n]
j invokevirtual[n] j invokespecial[n]
j goto[n] j ifle[n] j ifnull[n]
j return j ireturn j areturn

where i in the sequel stands for a JVM Instruction. (For a complete description of
the translation we refer to Rose 1998).

We recall that bytecode verification is officially described per method though
applied for a given class file. Single methods are hence the smallest unit that can
be verified. Abstractly, a method at the JVM level is described as an instruction
sequence. With the sort notation given in the introduction:

c 2 MethodByteCode ::= i\Lambda 
where each instruction is identified by a program point, which is their (byte) position or address, starting from 0, within that code sequence.

pp 2 PPoints = N
PP 2 PPointSet = P(PPoints)

where P denotes the power set of the parameter set.

2.2 The Constant Pool
The constant pool contains constant arguments of bytecode instructions that are too
large to be contained in the instructions themselves, called items. For our subset
this is integer constants (for example the argument of ldc w), references to fields
(the argument of putfield and getfield), and references to methods (the argument
of invokevirtual and invokespecial). References are stored as the class name of the
referenced class.

cp 2 ConstPool ::= it\Lambda 
We write cp(n) for the nth item in the constant pool cp from the left (counting
from 0).

it 2 Item ::= int j fref j mref
int 2 Integer = Z

References to fields are tagged triples with the class name, field name, and field
type:

fref 2 FieldRef ::= fieldref(cid; id; mt)

5

cid 2 ClassId

mt 2 MType ::= int j cid

We leave the representation of class names cid unspecified; MType stands for "machine type" (JVM uses a compact string representation for this information).

Finally references to methods are also tagged triples:

mref 2 MethodRef ::= methref(cid; msig; rmt)

msig 2 MethodSig ::= methsig(id; mt\Lambda )

rmt 2 RMType ::= void j mt

(RMType stands for "returned machine type" for a method, which may be void for
a non-returning method.)

2.3 Dynamic Load Context
A dynamic load context contains the class hierarchy and the current class name.
When a class is dynamically loaded this means that the class is already known to
the execution context where it is needed. In practice this entails that its position in
the class hierarchy is already known in the dynamic load context. This information
is important for the bytecode verifier because it is needed to verify whether implicit
type-casts, e.g., when passing parameters, are legal. For simplicity we will assume
that the entire class hierarchy is known to the dynamic class load context in the
form of a subclass relation.

^: 2 SubClass = P(ClassId \Theta  ClassId)
So an ^: is a set where each element is a pair (cid1; cid2) where cid1 is a subclass
of cid2. Finally, the dynamic load context should contain the name of the class
being loaded.

A more exact formalization of dynamic class loading must include a formalization of the notion of resolution. This is beyond the scope of this paper because
resolution is not yet defined for Java Cards; instead we assume that all resolution
has happened, i.e., that the entire class hierachy is available and that no false types
are given for any method (resolution and class loading is discussed for the full Java
language by Jensen, Le M'etayer & Thorn 1998).

3 Verification vs Checking
Bytecode verification proceeds by assigning a description of the type of the stack
and local variable table, the "current frame", at each program point. We call this a
frame type. Verification succeeds if it can be checked that

ffl all instructions have the arguments they need in the frame type just before

their execution, and

6

ffl all instructions guarantee that the state just after execution has a frame type

that is "compatible" with the frame type assigned to the next program point.

ffl Entry into and exit from a method happens in a way that is compatible with

the type of the method.

"Compatibility" here means that it is acceptable that the frame description just after
an instruction has more information than is actually needed. We formalize this by
giving the definition of frame types, the approximation relation, and the result of a
verification.

3.1 Frame Types
For each instruction the verifier needs to check that all the needed arguments are
available. If the argument is in the constant pool, then that is checked. Otherwise it
is a component of the current frame. We can then check that it is always available
at execution time by verifying that the corresponding frame component's type is
right.

ft 2 FrameType = StackType \Theta  LvType

st 2 StackType = MType?\Lambda 

lvt 2 LvType = MType?\Lambda 

(the ? annotation means that a special ? ("bottom") element has been added, representing "no information available"). The local variables can be indexed individually: lvt(n) is the nth local variable type of lvt, from the left, counting from 0.

The assignment of a frame type to each program point is done by a map

md 2 MDescr = PPoints fin\Gamma ! FrameType
(the fin\Gamma ! arrow indicates that it is a finite function from program points to frame
types).

3.2 Frame Type Approximation
If, for example, md(25) = \Gamma (?; int); (cid)\Delta , then we can imply that, before the
instruction at program point 25, the stack has one element that can be any type and
one int element (at the top), and that there is exactly one local variable which is
reference to an instance of the cid class or a subclass of it. So we can execute a
pop or an ifle instruction, for example, since they have what they need on the stack,
but we can neither execute an ifnull instruction, since that requires the top stack
element to be an object reference, nor an iadd instruction because it needs two int
elements on the stack.

To capture this we define a "less defined" approximation relation v on frame
types that expresses when the right-hand frame type has sufficient information to
guarantee that the requirements represented by the left-hand one are satisfied.

7

On simple types the relation is easy: it is defined by the inference rules

cid2 ^: cid1

cid1 v cid2 ? v mt

Notice how "less defined" between classes means "superclass" in object-oriented
terminology, extended with a "bottom" element which is an artificial type that is
less defined than any other type. In particular for any class c we have that ? @
Object v c (@ is the restriction to non-equal types). It is extended point-wise to
frame types, i.e.,

mt111 v mt211 \Delta  \Delta  \Delta  mt12m1 v mt22m2

ft1 v ft2

where

fti = hmti11 \Delta  \Delta  \Delta mti1ni; mti21 \Delta  \Delta  \Delta mti2mii ; i 2 f1; 2g

n1 = n2 ^ m1 = m2

(two frame types with the same stack (type) size and the same number of local
variable (types) can be compared if all the individual types can be compared positionally).

3.3 Verification
Now we can express verification. Only one thing needs to be added: verification
must determine a maximal size of the stack and the number of local variables.

ms 2 MaxStack = N
mlv 2 MaxLVar = N

Thus standard bytecode verification can be specified as a natural semantics judgment of the form

^:; cid; cp ` msig; c; ms; mlv : md (BV)
understanding the proof of the judgment as a way to construct md. The judgment
follows the convention that the class context is to the left of the `, the local method
information is between the ` and the : after which the derived type descriptor is
written.

4 Bytecode Checking
If, however, the "result" md of a verification is already available, then (BV) can be
read as a judgment for merely checking that the verification was correct. The challenge is not to change the reading - from a logical viewpoint there is no difference,
in fact. But it is easier to specify this new interpretation of (BV) constructively,
and this is what we will present in this section. (At the end we comment on how a
constructive version of the generic verifier can be described.)

8

4.1 Method Check
Checking a method is simply checking that each of its instructions have their constraints satisfied and that the stack and local variable sizes are sufficiently large.

h^:; cp; ms; mlv;rmti ` /0; 0; c : md ! PP

^:; cid; cp ` msig; c; ms; mlv : md (1)

where

msig = methsig(rmt; mt1 : : :mtn)

lvt = f0 7! cid; 1 7! mt1; : : :; n 7! mtn;

n+1 7! ?; : : :; mlv-1 7! ?g
md(0) v hffl; lvti
Dom(md) = PP

The premise checks all the instructions in c (since none are already checked in/0

), starting from the instruction at program point 0 requiring the initial frame type
md(0) to be less defined than the initial frame type established by JVM, hffl; lvti.
For each we must verify that the information in md is correct. All the verified instructions are collected in PP such that we can check at the end that the information
in md is complete.

4.2 Sequences
We start by naming the static information about the available methods.

\Xi  2 StatMethInfo ::= h^:; cp; ms; mlv; rmti
In the rules below we will always assume that \Xi  consists of those same components,
i.e., h^:; cp; ms; mlv; rmti.

Checking of sequence statements is expressed as follows:

\Xi  ` pp; i : md ! pp0
\Xi  ` PP 0; pp0; c : md ! PP 00
\Xi  ` PP; pp; i \Delta  c : md ! PP 00 PP

0 = PP [ fppg (2)

\Xi  ` PP; pp; ffl : md ! PP (3)
The rules merely check that the constraints of each instruction are satisfied until
none are left, each time adding the program point of the checked instruction to
the accumulating set, i.e., PP 0 always contains one more program point than PP,
namely pp. Each rule below will advance the program point counter as appropriate
for the instruction, i.e., set pp0 to be the program point of the subsequent instruction
in c (thus inductively ensuring that pp =2 PP).

9

i st st0
iconst 0 st st \Delta  int
iconst 1 st st \Delta  int
aconst null st st \Delta  Object

dup st1 \Delta  mt st1 \Delta  mt \Delta  mt
pop st1 \Delta  mt st1
iadd st1 \Delta  int \Delta  int st1 \Delta  int

isub st1 \Delta  int \Delta  int st1 \Delta  int

(a)

i st st0 it
putfield[n] st0\Delta cid\Delta mt st0 fieldref(cid0;id;mt)
getfield[n] st1\Delta cid st1\Delta mt fieldref(cid0;id;mt)
invokevirtual[n] st0\Delta cid\Delta mt1\Delta \Delta \Delta mtj st0 methref(cid0;methsig(-;mt1;:::;mtj);void)
invokevirtual[n] st1\Delta cid\Delta mt1\Delta \Delta \Delta mtj st1\Delta mt methref(cid0;methsig(-;mt1;:::;mtj);mt)
invokespecial[n] st0\Delta cid\Delta mt1\Delta \Delta \Delta mtj st0 methref(cid0;methsig(-;mt1;:::;mtj);void)
invokespecial[n] st1\Delta cid\Delta mt1\Delta \Delta \Delta mtj st1\Delta mt methref(cid0;methsig(-;mt1;:::;mtj);mt)(d)

i st
ifle[n] st0 \Delta  int
ifnull[n] st0 \Delta  cid

(e)

i st Condition
return st1 rmt = void
ireturn st1 \Delta  int rmt = int
areturn st1 \Delta  cid cid ^: rmt

(f)

Figure 3: Instruction-specific constraints. Complete in full paper.

10

4.3 Simple Stack Instructions
These are the simplest instructions, with just constraints on the stack.

\Xi  ` pp; i : md ! pp0 (4)
where

pp0 = pp + 1
md(pp) = hst; lvti

ft0 = \Omega st0; lvtff
md(pp0) v ft0fi

fist0fifi ! ms

with specific instruction constraints in figure 3(a). (One obtains the exact rule for
a particular instruction by adding each table entry as an equality, i.e., one rule has
the three extra side conditions i = dup, st = st1 \Delta  mt, and st0 = st1 \Delta  mt \Delta  mt.)

The full paper has similar rules for all the instructions but in this extended
abstract we just include the four instruction groups that are most interesting from
a verification viewpoint, omitting instructions accessing the local variables and
constant pool, and the goto instruction.

4.4 Object-oriented Instructions
These are more interesting, handling access to instance fields and methods.

\Xi  ` pp; i : md ! pp0 (5)
where

pp0 = pp + 3
md(pp) = hst; lvti

ft0 = \Omega st0; lvt0ff
md(pp0) v ft0

cp(n) = it

cid ^: cid0fi
fist0fifi ! ms

with instruction specific constraints in figure 3(d). The instruction is as simple as
the others: all the typing information is in the constant pool. It is the job of the
resolver to verify that the type information in the constant pool is consistent with
the real type of that class, and we do not consider resolution here as discussed
above.

11

4.5 Branch Instructions
Conditional branch instructions have two constraints, of course.

\Xi  ` pp; i : md ! pp0 (6)
where

md(pp) = hst; lvti

pp0 = pp + 3

ft0 = \Omega st0; lvtff
md(pp0) v ft0

pp00 = pp + n
md(pp00) v ft0

with instruction-specific constraints in figure 3(e).

4.6 Return Instructions
Return instructions are peculiar in that no instruction of the method is executed
afterwards, so the instruction introduces no constraints on the frame types.

\Xi  ` pp; i : md ! pp0 (7)
where

pp0 = pp + 1
md(pp) = hst; lvti

with instruction constraints in figure 3(f); notice that an additional side condition
is included in the table.

The full paper includes an analysis of how the inference rules can be read constructively, i.e., as a checker algorithm, and how they can be read as a constraint
construction phase for a full verifier algorithm based on constraint solving.

5 Lightweight Verification
A naive "lightweight" bytecode verification would consist of defining the certificate for a method as simply the md value obtained by bytecode verification. However, this is too large for practical use. The challenge that concerns us here is to
identify a small representation of the method descriptor such that we can realistically transmit it along with the method bytecode. (In practice such a certificate can
be included as a code attribute in class files; a similar possibility should exist for
the Java Card download format once it becomes available.)

12

5.1 Certificate
The central observation is the following: consider all the v-constraints for any
concrete verification, where md is fully known. Then extract all the individual
(point-wise) constraints. They will be of the following kinds:

Next equal to constant or current. Requiring that a stack element or local variable type of md(pp0) is equal to a type in ft0 or a constant type (implicit in
the instruction or extracted from the constant pool).

Next super-type of constant or current. Requiring that a stack element or local

variable type of md(pp0) is strictly less defined (a superclass or ?) than a
constant type or a type in ft0.

Other. Requiring that a stack element or local variable type of md(pp00) is equal

to or less defined than a constant type or a type in ft0.

The lightweight certificate is based on the idea that all the constraints of the first
kind can be reconstructed by the checker without error by running sequentially
through the code, and by keeping only one "current frame type", one "previous
frame type", and in general as few frame types as possible, in the algorithm.

Then constraints of the first kind are not a problem: they are just a matter of
comparing the contents of the current and previous frame type thus there is no need
to keep them in the certificate.

Constraints of the second kind should result in a "delta" (difference) to the
current frame type, since they require the following frame type to be less defined
than what the immediately guessed, ft 0, would suggest. Again the required checks
can be reproduced without error by the checker since the information is there.

The third kind requires a bit of care. If the other program point was before ours
then we need to have saved the frame when we passed it such that the constraint can
be checked when encountered. If the other program point is after the present then
the checker must save the present program point and a demand that the constraint
be checked once the other program point is reached, but it need not be registered
in the certificate.

Formally, we express the certificate as

cert 2 Certificate ::= hffi; `i

ffi 2 \Delta  = PPoints fin\Gamma ! FrameType
` 2 Labels = P(PPoints)

Thus a certificate is a pair hffi; `i with the first component, ffi, storing differences in
the frame type from what is derived (in this paper simplified to just store full frame
types), and the second, `, stores target labels.

13

5.2 Certification
The above suggests how the certificate should be produced as a side effect to bytecode checking, thus by extending (BV) to "lightweight bytecode certification"

^:; cid; cp ` msig; c; ms; mlv : md ! cert (LBC)
The root rule (1) should then be augmented to

\Xi  ` /0; 0; c : md ! PP; cert
^:; cid; cp ` msig; c; ms; mlv : md ! cert (8)

with the same side conditions.

For instruction sequences we need to make the union of two certificates (on the
two components separately), thus:

\Xi  ` pp; i : md ! pp0; cert
\Xi  ` PP 0; pp0; c : md ! PP 00; cert0
\Xi  ` PP; pp; i \Delta  c : md ! PP 00; cert00 (9)

where PP 0 = PP [ fppg and cert00 = cert [ cert0, and the certificate starts out
empty:

\Xi  ` PP; pp; ffl : md ! PP; /0 (10)
For the single instruction rules all that needs to be done is replace pp0 with pp0; cert
in each conclusion and then add appropriate side conditions. To (4) and (5) add

cert = hffi; ffli

ffi = ffifpp

0 7! md(pp0)g if md(pp0) @ ft0

/0 otherwise

to reflect that these just use the following instruction normally, thus making it possible to exploit the default frame type if possible.

The addition to (6) is similar:

cert = hffi; `i

ffi = ffifpp

0 7! md(pp0)g if md(pp0) @ ft0

/0 otherwise

` = ffifpp

00g if pp00 ! pp

/0 otherwise

Finally we add the following to (7):

cert = hffi; `i

14

ffi = ffifpp

0 7! md(pp0)g if pp0 2 Dom(md)

/0 otherwise

where we only create a delta if there is an instruction following the return-instruction.

Notice that one cannot "compress" or "decompress" between a full MDescr,
md, and a Certificate, cert: in both cases the actual bytecode is needed since the
redundant information that is removed depends on the actual bytecode instructions.

We conclude with an example of a certificate.

Example 1 (Certification). Consider the small Java class in the left part of figure 4. The full verification of the rectoy method is shown in the right part; the
bytecode is as produced by Sun's javac compiler (except we are not using "fast"
instructions), and we have inserted the frame type "before" the program point for
each instruction. The constant pool is not shown: the only knowledge used is that

cp(4) = methref(RecToy; methsig(rectoy; int); int)
(for the invokevirtual instruction). Notice how it is clear that local variable 0 and 1
are initialized with this and the n parameter, and that local variable 2 and 3 are
used for m and r, respectively.

The certificate only has to inform the checker that the local variable number 3
may be uninitialized in instruction 30 if it is reached via the conditional branch in
instruction 5, i.e., that the last entry in lvt should be ?. If this is not the case then
the frame type comparison for the second branch in the ifle instruction fails. The
certificate thus just has a single element in the ffi component:

cert = hf 30 7! hffl; RecToy \Delta  int \Delta  int \Delta  ?ig; ffli
(In practice ffi should be compacted into something like f 30 7! f 3 : ? g g, of course,
reusing the unchanged types from the preceding instruction.) The ` component is
empty because there were no backwards jumps in the code such as would arise,
e.g., from while statements.

The full paper also includes an example using while to get a backwards jump.

5.3 Lightweight Verification
Now the certificate is produced all we need to do is use it instead of the complete
method descriptor to do bytecode checking. Operationally this means that the information in the certificate should be used to emulate the use of md in bytecode
checker rules. Fortunately the certificate is constructed such that all information
extracted from md can be available when needed. Thus we can achieve the effect by systematically modifying the bytecode checker to obtain a system for the
"lightweight bytecode verifier" judgment

^:; cid; cp ` msig; c; ms; mlv : cert (LBV)

15

class RecToy extends Object -

int rectoy(int n) -

int m;
int r;

m = 0;
if (n ? 0) -

n = n - 1;
r = this.rectoy(n);
m = n + r;
""

return m;
""
""

pp st lvt i

0 ffl RecToy \Delta  int \Delta  ? \Delta  ? iconst 0
1 int RecToy \Delta  int \Delta  int \Delta  ? istore [2]
3 ffl RecToy \Delta  int \Delta  int \Delta  ? iload [1]
5 int RecToy \Delta  int \Delta  int \Delta  ? ifle [25]
8 int RecToy \Delta  int \Delta  int \Delta  ? iload [1]
10 int \Delta  int RecToy \Delta  int \Delta  int \Delta  ? iconst 1
11 int RecToy \Delta  int \Delta  int \Delta  ? isub
12 ffl RecToy \Delta  int \Delta  int \Delta  ? istore [1]
14 int RecToy \Delta  int \Delta  int \Delta  ? aload[0]
16 RecToy RecToy \Delta  int \Delta  int \Delta  ? iload [1]
18 RecToy \Delta  int RecToy \Delta  int \Delta  int \Delta  ? invokevirtual [4]
21 int RecToy \Delta  int \Delta  int \Delta  ? istore [3]
23 ffl RecToy \Delta  int \Delta  int \Delta  int iload [1]
25 int RecToy \Delta  int \Delta  int \Delta  int iload [3]
27 int \Delta  int RecToy \Delta  int \Delta  int \Delta  int iadd
28 int RecToy \Delta  int \Delta  int \Delta  int istore [2]
30 ffl RecToy \Delta  int \Delta  int \Delta  ? iload [2]
32 int RecToy \Delta  int \Delta  int \Delta  ? ireturn

Figure 4: rectoy method source and bytecode verification.

16

The bytecode checker judgments generally have the form \Delta  \Delta  \Delta  : md ! \Delta  \Delta  \Delta . This
must be changed to a form where the certificate is used to maintain a data structure
with the subset of md that will be needed. Formally this is achieved by replacing
md in the judgments with the composite cert; ft; S; P with new sorts

S 2 SavedFrameTypes = PPoints fin\Gamma ! FrameType

P 2 PendingChecks = P(PPoints\Theta  FrameType)

with the following intentions

ffl cert = hffi; `i, as before.
ffl ft contains the "current frame type", i.e., is always equal to md(pp) in the

current context.

ffl S is a map of the saved frame types that are needed later, corresponding to

those program points that are in PP " ` (targets of backwards jumps).

ffl P contains all the pending frame type comparisons created by forward jumps

from instructions already passed.

We omit unneeded parts in each case, of course, as well as pass parts that are
updated when appropriate.

We will go through the rules, changing them to accommodate the new structure
(and thus demonstrating that the transformation is correct). As before we use \Xi 
without mentioning the components, and similarly we assume cert = hffi; `i.

5.4 Method Check
Rule (1) becomes

\Xi  ` /0; 0; c : cert; ft0; /0; /0 ! ft; S; P; PP

^:; cid; cp ` msig; c; ms; mlv : cert (11)

with the side conditions

msig = methsig(rmt; mt1 \Delta  \Delta  \Delta mtn)

lvt = f0 7! cid; 1 7! mt1; : : :; n 7! mtn;

n+1 7! ?; : : :; mlv-1 7! ?g
ft0 = hffl; lvti

which initializes the current frame type to something possibly more defined than
md(0) (if so then ffi(0) is defined).

17

5.5 Sequences
The sequence rules are essentially unchanged, except that they take care of applying a delta to the current frame type if this is appropriate, since this is uniform for
all instructions. Thus (2) becomes

\Xi  ` pp; i : cert; ft1; S; P1 ! ft0; P 0; pp0
\Xi  ` PP 0; pp0; c : cert; ft0; S0; P 0 ! ft00; S00; P 00; PP 00

\Xi  ` PP; pp; i \Delta  c : cert; ft; S; P ! ft00; S00; P 00; PP 00 (12)

where

PP 0 = PP [ fppg
cert = hffi; `i

ft1 = ffiffi(pp) if pp 2 Dom(ffi) ^ ffi(pp) v ftft otherwise

S0 = ffiS [ fpp 7! ft1g if pp 2 `S otherwise
8 ft000; \Omega pp; ft000ff 2 P : ft000 v ft1

P1 = f \Omega pp000; ft000ff 2 P j pp000 6= pp g

The third side condition applies the delta of cert, if there is one, passing the current frame type (which is now known to be equal to md(pp)) to the instruction
handling judgment (it is intentional that ft1 is not defined if ffi(pp) 6v ft since then
the checking should fail). The fourth saves the current frame type in the S used for
subsequent instructions if the program point is in the ` component of the certificate. The fifth checks any pending constraints that have waited for ft1 to become
available, and the sixth and last removes them from the P used for subsequent
instructions.

The (3) rule becomes

\Xi  ` PP; pp; ffl : cert; ft; S; /0 ! ft; /0; PP (13)
where the use of /0 for P means that all pending constraints must have been checked
for lightweight verification to succeed.

5.6 Single Instructions
The single instruction rules are changed by systematic (literal) textual replacement
as follows:

ffl Replace " md(pp) " with " ft ".
ffl Remove conditions " md(pp0) v ft0 ". This is safe because all such constraints are checked by (12).

18

ffl Replace conditions " md(pp00) v ft0 " with

\Gamma pp00 ! pp0 ^ S(pp00) v ft0 ^ P 0 = P\Delta 

. \Gamma pp00 * pp0 ^ P 0 = P [ fpp0 7! ft0g\Delta  (14)
The full paper contains all the rules.
5.7 Correctness and Safety
We can now prove that the technique is tamper-proof by showing it both sound
and complete with respect to standard bytecode verification, as explained in the
introduction. We express this using the three judgments for bytecode verification,
lightweight bytecode certification, and lightweight bytecode verification (all defined above):

^:; cid; cp ` msig; c; ms; mlv : md (BV)
^:; cid; cp ` msig; c; ms; mlv : md ! cert (LBC)

^:; cid; cp ` msig; c; ms; mlv : cert (LBV)

Our completeness lemma states that certification succeeds if an only if normal bytecode verification succeeds. This ensures that our technique has exactly
the right expressiveness (and that it should be possible to integrate a certification
algorithm into a normal bytecode verifier).

Lemma 2 (completeness). (BV) iff 9cert : (LBC).
Proof. ) follows from the fact that the construction of cert can never fail, thus
a (BV) proof can be enriched with these to become an (LBC) proof. ( is trivial
by observing that erasing all mention of cert in the (LBC) proof gives the (BV)
proof.

Our soundness lemma states that lightweight verification can only succeed if
the certificate is valid. This ensures that the technique is tamper-proof, i.e., that
one cannot fabricate a certificate that will fool the (LBV) to accept non-verifiable
bytecode.

Lemma 3 (soundness). (LBV) iff 9md : (LBC).
Proof. ) is proved by constructing an (LBC) proof from the (LBV) proof. The
md that is needed is obtained by extracting the " \Xi  ` pp; i : cert; ft1; S; P1 !
ft0; P 0; pp0 " premise of all instances of (12) in the (LBV) proof: the instantiation of the current frame type, ft1, is the value needed for md(pp). It is easy to
see that such a value must be present for all program points. We then only need to
show that all the required constraints of the (LBC) proof are already present in the
(LBV) proof. This requires a study of the values in S, P, and the ` component of
cert, treating each of the cases from Section 5.1. Notice that we do not reuse the

19

checked certificate directly to construct the one built in the (LBC) proof: this is intentional as the actual certificate in the (LBV) proof may have additional (harmless
and redundant) information.

Conversely, ( is proved by constructing an (LBV) proof from the (LBC) proof.
This essentially amounts to inserting md(pp) into the current frame type, and
to extract all side conditions of the form " md(pp00) v ft0 " into either S or P
depending on whether pp00 ! pp0 or not.

The proof details can be found in the full paper.

From this we can derive that lightweight bytecode verification is completely
equivalent to normal bytecode verification.

Theorem 4. (BV) iff 9cert : (LBC) ^ (LBV).
Proof. Immediate from soundness and completeness (Lemmas 3 and 2)

One very important remark is that we can prove the equivalence of usual and
lightweight verification without reference to the operational semantics of JVM execution: neither usual nor lightweight verification make sense without such an
operational semantics, of course, but that is not the study of this paper, and the
reported result does not depend on it.

6 Conclusions
We have demonstrated how a static semantics for bytecode checking of a Java
(sublanguage) method can be split into a "lightweight" certificate generator and a
"lightweight" bytecode verifier.

6.1 Assessment
The certificate generator has the complexity of the usual bytecode verifier, however,
only the code producer needs to run it. The critical component is the checker for
which we have shown

Completeness. A certificate always exists for bytecode that goes through the normal verifier.

Soundness. If the lightweight bytecode verifier accepts a certificate/method bytecode pair then the bytecode can be verified normally - the method is tamperproof.

Compact certificates. The lightweight certificate is much smaller than the full set

of frame types assigned by the bytecode verification: it only has to contain

ffl the program point and difference to the derived frame type where there

is a such, and

20

ffl the program point numbers of all backward jump targets;
we remarked that compactness can be improved by elimination goto and
return instructions.

High speed. The lightweight bytecode verifier runs in time almost-linear in the

length of the verified method plus the certificate: each rule has to check a
constant number of entries in the frame type against the saved frame type
and the certificate.

Low space. The lightweight bytecode verifier only needs the space taken up by

the certificate, saved frame types, and the single current frame type.

In summary we have shown a way to realize safe downloading of applets to very
tight environments such as Java Cards with the need for cryptographic methods.

6.2 Assurance Issues
In fact, the separation of the generation and check of the certificate means that only
the checker is safety-critical: soundness assures that if a code producer cheats by
trying to fake a certificate then the checker will reject it.

This should be contrasted with the current situation for Java, where even "small" Java environments, such as in web browsers, must contain a complete bytecode
verifier to conform to the Java standard. Since the entire verifier is safety critical,
this essentially makes it necessary for companies providing such environments to
need to trust a large and complicated portion of the code, a portion for which they
might not even have the source.

Our approach offers a backwards-compatible method: systems with a full bytecode verifier can ignore any lightweight certificate and do conventional verification,
whereas systems with only a lightweight verifier can either

ffl reject the non-certified code as insecure, or

ffl submit the code to an external lightweight certifier, which does not have to

be trusted, because the result is checked anyway.

In fact this means that it would make sense to make a standard out of lightweight
certificates. Owners of source of full bytecode verifiers could then offer lightweight
certification services, for example in the form of a web proxy that certifies all class
files that passes by.

The full paper includes a list of future work, notably extending the language with
exceptions and protection, and an account of the relation to work on formalizing
the JVM (Bertelsen 1997, Pusch 1998) on Java type soundness (Drossopoulou,
Eisenbach & Khurshid 1997, Drossopoulou & Eisenbach 1997, Oheimb & Nipkow
1998, Nipkow & von Oheimb 1998), class loading (Jensen et al. 1998), safety
in connection with downloading (Leroy & Rouaix 1998), and surely other work
reported in the FUJ '98 meeting.

21

Acknowledgements. The authors would like to thank Xavier Leroy, Pierre Lescanne, Christine Paulin-Mohring, and the anonymous FUJ '98 referees, for helpful
comments and interactions.

References
Bertelsen, P. (1997), Semantics of java byte code, Student report, Technical University of Denmark.

Drossopoulou, S. & Eisenbach, S. (1997), Java is type safe - probably, in `European Conference of Object Oriented Programming', LNCS, Springer-Verlag.

Drossopoulou, S., Eisenbach, S. & Khurshid, S. (1997), Is java type safe, Technical

report, Imperial College.

Gosling, J., Joy, B. & Steele, G. (1996), The Java Language Specification, The

Java Series, Addison-Wesley.

Jensen, T., Le M'etayer, D. & Thorn, T. (1998), A formalisation of visibility and

dynamic loading in java, in `ICCL '98', IEEE. Also published as a IRISA
Technical Report no 1137, October 1997.

Kahn, G. (1987), Natural semantics, Rapport de Recherche 601, INRIA, SophiaAntipolis, France.

Leroy, X. & Rouaix, F. (1998), Security properties of typed applets, in `POPL

'98--25th Annual ACM Symposium on Principles of Programming Languages', SIGPLAN Notices, pp. 391-403.

Lindholm, T. & Yellin, F. (1996), The Java Virtual Machine Specification, The Java

Series, Addison-Wesley.

Necula, G. C. (1997), Proof-carrying code, in `POPL '97--24th Annual ACM

Symposium on Principles of Programming Languages', SIGPLAN Notices.

Nipkow, T. & von Oheimb, D. (1998), Javalight is type-safe - definitely, in `POPL

'98--25th Annual ACM Symposium on Principles of Programming Languages', SIGPLAN Notices, pp. 161-170.

Oheimb, D. v. & Nipkow, T. (1998), Machine-checking the Java specification:

Proving type-safety, in J. Alves-Foss, ed., `Formal Syntax and Semantics of
Java', LNCS, Springer. To appear, available from http://www4.informatik.tumuenchen.de/~isabelle/bali/doc/Springer98.html.

Pusch, C. (1998), Formalizing the java virtual machine in isabelle/hol, Technical

Report TUM-I9816, Institut f"ur Informatik, Technische Universit"at M"unchen.

22

Rose, E. (1998), Towards secure bytecode verification on a java card, Master's

thesis, DIKU, University of Copenhagen.

Stata, R. & Abadi, M. (1998), A type system for java bytecode subroutines, in

`POPL '98--25th Annual ACM Symposium on Principles of Programming
Languages', SIGPLAN Notices.

Sun (1997), Java Card 2.0 Language Subset and Virtual Machine Specification,

revision 1.0 final edn. ftp://ftp.javasoft.com/docs/javacard/JC20-Language.ps.

23