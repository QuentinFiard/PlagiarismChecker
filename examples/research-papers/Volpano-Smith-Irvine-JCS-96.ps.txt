

Journal of Computer Security draft printout, (29 Jul 1996), 1-20
IOS Press

1

A SOUND TYPE SYSTEM FOR SECURE FLOW
ANALYSIS

Dennis Volpano
Computer Science Department
Naval Postgraduate School
Monterey, California 93943, U.S.A.

Geoffrey Smith
School of Computer Science
Florida International University
Miami, Florida 33199, U.S.A.

Cynthia Irvine
Computer Science Department
Naval Postgraduate School
Monterey, California 93943, U.S.A.

Abstract
Ensuring secure information flow within programs in the context of multiple sensitivity levels has been widely studied. Especially noteworthy is Denning's work in
secure flow analysis and the lattice model [6][7]. Until now, however, the soundness
of Denning's analysis has not been established satisfactorily. We formulate Denning's
approach as a type system and present a notion of soundness for the system that can
be viewed as a form of noninterference. Soundness is established by proving, with
respect to a standard programming language semantics, that all well-typed programs
have this noninterference property.

Keywords: type systems, program security, soundness proofs

1. Introduction
The problem of ensuring secure information flow within systems having multiple
sensitivity levels has been studied extensively, beginning with the early work of Bell
and LaPadula [3]. This was extended by the lattice-model work of Denning [5][6][7]
who pioneered program certification, an efficient form of static analysis that could
be easily incorporated into a compiler to verify secure information flow in programs.
Denning's analysis has been characterized as an extension of an axiomatic logic for
program correctness by Andrews and Reitman [1]. Other more recent efforts have
been aimed at extending the analysis to properly handle language features like

2 D. Volpano, G. Smith, C. Irvine
procedures [15][16] and nondeterminism [2], while others have focused on integrity
analysis only [18][19].

So far there has not been a satisfactory treatment of the soundness of Denning's analysis. After all, we want to be assured that if the analysis succeeds for a
given program on some inputs, then the program in some sense executes securely.
Denning provides intuitive arguments only in [7][8]. Although a more rigorous account of information flow in terms of classical information theory is given in [8], no
formal soundness proof is attempted. Andrews and Reitman [1] do not address the
soundness of their flow logic at all. Soundness is considered in O/rbaek [18], but the
treatment depends on an "instrumented semantics" where every value is tagged
with a security class. These classes are updated for values at run time according
to Denning's certification conditions. A similar approach is taken by Mizuno and
Schmidt [17]. However, these approaches are unsatisfactory. By modifying the semantics in this way, there is no longer any basis for justifying the soundness of the
analysis. Proving soundness in this framework essentially amounts to proving that
the analysis is consistent with the instrumented semantics. But then it is fair to
ask whether class tags are updated correctly in the instrumented semantics. There
is no justification for tag manipulation in the semantics.

We take a type-based approach to the analysis. The certification conditions of
Denning's analysis [7][8] are formulated as a simple type system for a deterministic
language. A type system is basically a formal system of type inference rules for
making judgments about programs. They are usually used to establish the type
correctness of programs in a strongly-typed language, for example, Standard ML
[20]. However, they are not limited to reasoning about traditional forms of type
correctness. They can be regarded, in general, as logical systems in which to reason
about a wide variety of program properties. In our case, the property of interest is
secure information flow.

Characterizing the analysis as a type system has many advantages. It serves
as a formal specification that cleanly separates the security policies from the algorithms for enforcing them in programs. The separation also admits a notion
of soundness for the analysis that resembles traditional noninterference [9]. Intuitively, soundness states that variables in a well-typed program do not "interfere"
with variables at lower security levels. This is formalized as a type soundness
theorem and proved. It is interesting to point out that the soundness proof justifies a more flexible treatment of local variables--in some cases, there is an implicit flow to a local variable, but the flow is actually harmless, so it need not
be rejected. The secure flow typing rules merge some traditional type correctness
concerns with secure-flow enforcement. Upward information flows are easily accommodated through subtyping. And finally, though not addressed in this paper,
the type system can be automated, using standard type inference techniques, to
analyze programs for secure flows.

We begin with an overview of Denning's lattice model followed by an informal
treatment of the type system. Examples are given to show how the typing rules
are used. Then we turn our attention to a formal treatment of the type system and
prove a soundness theorem with respect to a standard semantics for the language.
Other soundness efforts will then be discussed along with language extensions and
some directions for future research.

A Sound Type System for Secure Flow Analysis 3
2. The Lattice Model of Information Flow
The lattice model is an extension of the Bell and LaPadula model [3]. In this model,
an information flow policy is defined by a lattice (SC; ^), where SC is a finite set
of security classes partially ordered by ^. SC may include secrecy classes, like low
(L) and high (H ), as well as integrity classes, like trusted (T ) and untrusted (U ),
where L ^ H and T ^ U . There may be combinations of them as well, like HT.

Every program variable x has a security class denoted by x. It is assumed that
x can be determined statically and that it does not vary at run time. If x and y
are variables and there is a flow of information from x to y then it is a permissible
flow iff x ^ y.

Every programming construct has a certification condition. It is a purely syntactic condition relating security classes. Some of these conditions control explicit
flows while others control implicit flows. For example, the statement y := x has
the condition x ^ y, that is, the flow of information from the security class of x
to that of y must be permitted by the flow policy. This is an example of a condition controlling an explicit flow. The conditions for other constructs, such as if
statements and while loops, control implicit flows. For example, there is always
an implicit flow from the guard of a conditional to its branches. For instance, in
the statement

if x ? y then z := w else i := i + 1

there is an implicit flow from x and y to z and i. So the statement has the
certification condition x \Phi  y ^ z \Omega  i where \Phi  and \Omega  denote least upper bound and
greatest lower bound operators respectively. The lattice property makes it possible
to enforce these conditions using a simple attribute grammar with synthesized
attributes only.

3. An Informal Treatment of the Type System
A type system consists of a set of inference rules and axioms for deriving typing
judgments. A typing judgment, for our purposes, has the form

fl ` p : o/
This judgment asserts that program (or program phrase) p has type o/ with respect
to identifier typing fl. An identifier typing is a map from identifiers to types; it
gives the types of any free identifiers of p. A judgment follows from the type system
if it is the last in a sequence of judgments where each judgment in the sequence is
an axiom or one that follows from preceding judgments by a type inference rule.

For example, consider a simple type system for integer-valued expressions. It
might contain the following three rules: an axiom fl ` i : int, which asserts that
every integer literal i has type int, an inference rule

fl ` x : o/ if fl(x) = o/
giving us the type of any free identifier x, and the inference rule

fl ` e : int;
fl ` e0 : int

fl ` e + e0 : int

4 D. Volpano, G. Smith, C. Irvine
for deducing the types of expressions of the form e + e

0. In inference rules, the

judgments above the horizontal line are hypotheses and the judgment below the
line is the conclusion. So if fl(z) = int, then

fl ` z + 1 : int
is a judgment that follows from the type system. We say z + 1 is well typed with
respect to fl in this case and that it has type int. But if fl(z) = bool then the
judgment no longer follows from the system and we say z + 1 is not well typed with
respect to fl.

The preceding example illustrates a traditional type system. Our secure flow
type system is also composed of types and type inference rules, but now the rules
enforce secure flow as opposed to data type compatibility. The rules allow secureflow judgments to be made for expressions and commands in a block-structured,
deterministic language.

3.1. Secure Flow Types
The types of our system are stratified into two levels. At one level are the data
types, denoted by o/ , which are the security classes of SC . We assume that SC
is partially ordered by ^. At the other level are the phrase types, denoted by
ae. These include data types, which are the types given to expressions, variable
types of the form o/ var, and command types of the form o/ cmd. As one would
expect, a variable of type o/ var stores information whose security class is o/ or
lower. More novelly, a command c has type o/ cmd only if it is guaranteed that
every assignment within c is made to a variable whose security class is o/ or higher.
This is a confinement property, needed to ensure secure implicit flows. We extend
the partial order ^ to a subtype relation which we denote `. The subtype relation
is antimonotonic (or contravariant) in the types of commands, meaning that if
o/ ` o/ 0 then o/ 0 cmd ` o/ cmd . As usual, there is a type coercion rule that allows a
phrase of type ae to be assigned a type ae0 whenever ae ` ae0.

3.2. Secure Flow Typing Rules
The typing rules guarantee secure explicit and implicit flows as do certification
rules in the lattice model. Consider, for example, the typing rule for assignment:

fl ` e : o/ var;
fl ` e0 : o/

fl ` e := e0 : o/ cmd

This rule essentially says that in order to ensure that the explicit flow from e0 to
e is secure, e0 and e must agree on their security levels, which is conveyed by o/
appearing in both hypotheses of the rule. Note, however, that an upward flow from
e0 to e is still allowed; if e : H var and e0 : L, then with subtyping, the type of e0
can be coerced up to H and the rule applied with o/ = H.1

1 Keep in mind that secrecy and integrity are treated uniformly in our type system

[4][11], as they are in the lattice model. Examples throughout the paper will be
given for secrecy only, but they could alternatively be stated for integrity.

A Sound Type System for Secure Flow Analysis 5

Notice that in the preceding typing rule, the entire assignment is given type
o/ cmd . The reason for this is to control implicit flows. Here is a simple example.
Suppose x is either 0 or 1 and consider

if x = 1 then y := 1 else y := 0
Although there is no explicit flow from x to y, there is an implicit flow because x
is indirectly copied to y. To ensure that such implicit flows are secure, we use the
following typing rule for conditionals:

fl ` e : o/;
fl ` c : o/ cmd;
fl ` c0 : o/ cmd

fl ` if e then c else c0 : o/ cmd
The intuition behind the rule is that c and c0 are executed in a context where
information of level o/ is implicitly known. For this reason, c and c

0 may only

assign to variables of level o/ or higher. Although the rule requires the guard e and
branches c and c0 to have the same security level, namely o/ , it does not prevent
an implicit upward flow from e to branches c and c0. Again subtyping can be used
to establish agreement, but unlike the case with assignment statements, there are
now two ways to get it. The type of e can be coerced to a higher level, or the
types of the branches can be coerced to lower levels using the antimonotonicity of
command types. In some situations both kinds of coercions are necessary. Observe
that no coercions will lead to agreement if there is downward flow from e. The
typing rule must reject the conditional in this case.

For example, suppose fl(x) = fl(y) = H var. By the preceding typing rule
for assignment, we have fl ` y := 1 : H cmd and fl ` y := 0 : H cmd . This
means that each statement can be placed in a context where high information is
implicitly known through the guard of a conditional statement. An example is
if x = 1 then y := 1 else y := 0. With o/ = H, the secure flow typing rule for
conditionals gives

fl ` if x = 1 then y := 1 else y := 0 : H cmd
So the statement is well typed, as is expected, knowing that since x and y are high
variables, the implicit flow from x to y is secure. The resulting type H cmd assures
us that no low variable is updated in either branch (no write down). This would
permit the entire statement to be used where high information again is implicitly
known. Now if fl(x) = L var, then the implicit flow is still secure, but establishing
this fact within the type system now requires subtyping. One option is to use the
antimonotonic subtyping of command types where H cmd ` L cmd since L ^ H.
Each branch then is coerced from type H cmd to L cmd so that we can let o/ = L
and get

fl ` if x = 1 then y := 1 else y := 0 : L cmd

On the other hand, we might coerce the type of x upward from L to H and let
o/ = H instead. Then once again the conditional has type H cmd . This would be
our only choice if we had to successfully type the conditional, say, as the branch
of yet another conditional whose guard is high. And finally, if fl(x) = H var and
fl(y) = L var, then the conditional is not well typed, which is what we would expect
since now the implicit flow is downward.

6 D. Volpano, G. Smith, C. Irvine

if x = 1 then

letvar y := 1 in c
else

letvar y := 0 in c0

Figure 1. An implicit flow from x to y
3.3. Local Variable Declarations
Our core language includes a construct for declaring local variables. A local variable, say x, in our language is declared as

letvar x := e in c
It creates x initialized with the value of expression e. The scope and lifetime of x is
command c. The initialization can cause an implicit flow, but it is always harmless.

Consider, for instance, the program fragment in Figure 1, for some commands
c and c0. If x is high and each instance of y is low, then it might appear as though
the program should be rejected because there is a downward implicit flow from x
to y. But if c and c0 do not update any low variables, that is, each can be typed
as high commands, then the program is actually secure, despite the downward
flow. The contents of x cannot be "laundered" via y. To see this, suppose x is
high. Then the rule for typing conditionals given above forces c and c0 to be typed
as high commands. By the confinement property, then, neither c nor c0 has any
assignments to low variables and thus y cannot be assigned to any low variables.

3.4. Type Soundness
We prove two interesting security lemmas for our type system, namely Simple
Security and Confinement. Simple Security applies to expressions and Confinement
to commands. If an expression e can be given type o/ in our system, then Simple
Security says, for secrecy, that only variables at level o/ or lower in e will have
their contents read when e is evaluated (no read up). For integrity, it says that
every variable in e stores information at integrity level o/ . On the other hand, if a
command c can be given type o/ cmd, then Confinement says, for secrecy, that no
variable below level o/ is updated in c (no write down). For integrity, it states that
every variable assigned to in c can indeed be updated by information at integrity
level o/ .

These two lemmas are used to prove the type system is sound. Soundness is
formulated as a kind of noninterference property. Intuitively, it says that variables
in a well-typed program do not interfere with variables at lower security levels. That
is, if a variable v has security level o/ , then one can change the initial values of any
variables whose security levels are not dominated by o/ , execute the program, and
the final value of v will be the same, provided the program terminates successfully.

3.5. Type Inference
It is possible to check automatically whether a program is well typed by using
standard techniques of type inference. While a detailed discussion of type inference
is beyond the scope of this paper, the basic idea is to use type variables to represent

A Sound Type System for Secure Flow Analysis 7
unknown types and to collect constraints (in the form of type inequalities) that the
type variables must satisfy for the program to be well typed. In this way, one can
construct a principal type for the program that represents all possible types that
the program can be given.

4. A Formal Treatment of the Type System
We consider a core block-structured language described below. It consists of
phrases, which are either expressions e or commands c:

(phrases) p ::= e j c
(expressions) e ::= x j l j n j e + e0 j e \Gamma  e0 j e = e0 j e ! e0
(commands) c ::= e := e0 j c; c0 j if e then c else c0 j

while e do c j letvar x := e in c

Metavariable x ranges over identifiers, l over locations (addresses), and n over
integer literals. Integers are the only values. We use 0 for false and 1 for true, and
assume that locations are well ordered.

There are no I/O primitives in the language. All I/O is done through free
locations in a program. That is, if a program needs to "read input" then it does
so by dereferencing an explicit location in the program. Likewise, a program that
needs to "write output" does so by an assignment to an explicit location. Locations
may also be created during program execution due to local variable declarations.
So a partially-evaluated program may contain newly-generated locations as well as
those used for I/O.

The types of the core language are stratified as follows.

(data types) o/ ::= s
(phrase types) ae ::= o/ j o/ var j o/ cmd

Metavariable s ranges over the set SC of security classes, which is assumed to be
partially ordered by ^. Type o/ var is the type of a variable and o/ cmd is the type
of a command.

The typing rules for the core language are given in Figure 2. We omit typing
rules for some of the expressions since they are similar to rule (arith). Typing
judgments have the form

*; fl ` p : ae

where * is a location typing and fl is an identifier typing. The judgment means that
phrase p has type ae, assuming * prescribes types for locations in p and fl prescribes
types for any free identifiers in p. An identifier typing is a finite function mapping
identifiers to ae types; fl(x) is the ae type assigned to x by fl. Also, fl[x : ae] is a
modified identifier typing that assigns type ae to x and assigns type fl(x0) to any
identifier x0 other than x. A location typing is a finite function mapping locations
to o/ types. The notational conventions for location typings are similar to those for
identifier typings.

The remaining rules of the type system constitute the subtyping logic and are
given in Figure 3. Properties of the logic are established by the following lemmas.

8 D. Volpano, G. Smith, C. Irvine

(int) *; fl ` n : o/
(var) *; fl ` x : o/ var if fl(x) = o/ var
(varloc) *; fl ` l : o/ var if *(l) = o/

(arith)

*; fl ` e : o/;
*; fl ` e0 : o/

*; fl ` e + e0 : o/

(r-val) *; fl ` e : o/ var*; fl ` e : o/

(assign)

*; fl ` e : o/ var;
*; fl ` e0 : o/

*; fl ` e := e0 : o/ cmd

(compose)

*; fl ` c : o/ cmd ;
*; fl ` c0 : o/ cmd

*; fl ` c; c0 : o/ cmd

(if)

*; fl ` e : o/;
*; fl ` c : o/ cmd ;
*; fl ` c0 : o/ cmd

*; fl ` if e then c else c0 : o/ cmd

(while)

*; fl ` e : o/;
*; fl ` c : o/ cmd

*; fl ` while e do c : o/ cmd

(letvar)

*; fl ` e : o/;
*; fl[x : o/ var ] ` c : o/ 0 cmd

*; fl ` letvar x := e in c : o/ 0 cmd

Figure 2. Typing rules for secure information flow
Lemma 4.1 (Structural Subtyping) If ` ae ` ae0, then either

(a) ae is of the form o/ , ae0 is of the form o/ 0, and o/ ^ o/ 0,

(b) ae is of the form o/ var and ae0 = ae, or
(c) ae is of the form o/ cmd , ae0 is of the form o/ 0 cmd, and o/ 0 ^ o/ .

Proof. By induction on the height of the derivation of ` ae ` ae0. If the derivation
ends with rule (base) then (a) is true by the hypothesis of the rule. If it ends with
(reflex), then ae = ae0. So if ae is of the form o/ , then (a) holds since ^ is reflexive.
And if ae is of the form o/ var or o/ cmd, then (b) or (c) hold, respectively.

Now suppose the derivation ends with rule (trans). Then there is a ae

00 such

that ` ae ` ae00 and ` ae00 ` ae0 by the hypotheses of the rule. There are three cases:

1. If ae is of the form o/ , then by induction ae00 is of the form o/ 00 and o/ ^ o/ 00. So by

A Sound Type System for Secure Flow Analysis 9

(base) o/ ^ o/

0

` o/ ` o/ 0
(reflex) ` ae ` ae

(trans) ` ae ` ae

0; ` ae0 ` ae00

` ae ` ae00

(cmd\Gamma ) ` o/ ` o/

0

` o/ 0 cmd ` o/ cmd

(subtype)

*; fl ` p : ae;
` ae ` ae0

*; fl ` p : ae0

Figure 3. Subtyping rules
induction again, ae0 is of the form o/ 0 and o/ 00 ^ o/ 0. And since ^ is transitive,
o/ ^ o/ 0.

2. If ae is of the form o/ var, then by induction ae00 = ae. So by induction again,

ae0 = ae00, and hence ae0 = ae.

3. If ae is of the form o/ cmd, then by induction ae00 is of the form o/ 00 cmd and

o/ 00 ^ o/ . So by induction again, ae0 is of the form o/ 0 cmd and o/ 0 ^ o/ 00. So, since
^ is transitive, o/ 0 ^ o/ .

Finally, suppose the derivation ends with (cmd\Gamma ). Then ae is of the form
o/ cmd , ae0 is of the form o/ 0 cmd , and ` o/ 0 ` o/ by the hypothesis of the rule.
By induction, o/ 0 ^ o/ . tu

Lemma 4.2 ` is a partial order.
Proof. Reflexivity and transitivity follow directly from rules (reflex) and
(trans). Antisymmetry follows from Lemma 4.1 and the antisymmetry of ^. tu

5. The Formal Semantics
The soundness of our type system is established with respect to a natural semantics
for closed phrases in the core language. We say that a phrase is closed if it has
no free identifiers. A closed phrase is evaluated relative to a memory _, which is
a finite function from locations to values. The contents of a location l 2 dom(_)
is the value _(l), and we write _[l := n] for the memory that assigns value n to
location l, and value _(l0) to a location l0 6= l; note that _[l := n] is an update of _
if l 2 dom(_) and an extension of _ otherwise.

The evaluation rules are given in Figure 4. They allow us to derive judgments
of the form _ ` e ) n for expressions and _ ` c ) _0 for commands. These
judgments assert that evaluating closed expression e in memory _ results in integer
n and that evaluating closed command c in memory _ results in a new memory _0.
Note that expressions cannot cause side effects and commands do not yield values.

10 D. Volpano, G. Smith, C. Irvine

(base) _ ` n ) n
(contents) _ ` l ) _(l) if l 2 dom(_)

(add) _ ` e ) n; _ ` e

0 ) n0

_ ` e + e0 ) n + n0

(update) _ ` e ) n; l 2 dom(_)_ ` l := e ) _[l := n]

(sequence) _ ` c ) _

0; _0 ` c0 ) _00

_ ` c; c0 ) _00

(branch) _ ` e ) 1; _ ` c ) _

0

_ ` if e then c else c

0 ) _0

_ ` e ) 0; _ ` c0 ) _0
_ ` if e then c else c0 ) _0

(loop) _ ` e ) 0_ ` while e do c ) _

_ ` e ) 1;
_ ` c ) _0;
_0 ` while e do c ) _00

_ ` while e do c ) _00

(bindvar)

_ ` e ) n;
l is the first location not in dom(_);
_[l := n] ` [l=x]c ) _0

_ ` letvar x := e in c ) _0 \Gamma  l

Figure 4. The evaluation rules
We write [e=x]c to denote the capture-avoiding substitution of e for all free
occurrences of x in c, and let _ \Gamma  l be memory _ with location l deleted from its domain. Note the use of substitution in rule (bindvar), which governs the evaluation
of letvar x := e in c. A new location l is substituted for all free occurrences of x in
c. The result [l=x]c is then evaluated in the extended memory _[l := n], where n is
the value of e. By using substitution, we avoid having to introduce an environment
mapping x to l. One can view [l=x]c as a partially-evaluated command, perhaps
containing other free locations.

6. Type Soundness
We now establish the soundness of the type system with respect to the semantics
of the core language. The soundness theorem states that if *(l) = o/ , for some
location l, then one can arbitrarily alter the initial value of any location l0 such

A Sound Type System for Secure Flow Analysis 11

(r-val

0)

*; fl ` e : o/ var ;

o/ ^ o/ 0

*; fl ` e : o/ 0

(assign

0)

*; fl ` e : o/ var ;
*; fl ` e0 : o/;
o/ 0 ^ o/

*; fl ` e := e0 : o/ 0 cmd

(if

0)

*; fl ` e : o/;
*; fl ` c : o/ cmd;
*; fl ` c0 : o/ cmd;
o/ 0 ^ o/

*; fl ` if e then c else c0 : o/ 0 cmd

(while

0)

*; fl ` e : o/;
*; fl ` c : o/ cmd;
o/ 0 ^ o/

*; fl ` while e do c : o/ 0 cmd

Figure 5. Syntax-directed typing rules
that *(l0) is not a subtype of o/ , execute the program, and the final value of l will
be the same provided the program terminates successfully.

To facilitate the soundness proof, we introduce a syntax-directed set of typing
rules. The rules of this system are just the rules of Figure 2 with rules (r-val),
(assign), (if), and (while) replaced by their syntax-directed counterparts in Figure 5. The subtyping rules in Figure 3 are not included in the syntax-directed
system. We shall write judgments in the syntax-directed system as *; fl `s p : ae.
The benefit of the syntax-directed system is that the last rule used in the derivation of a typing *; fl `s p : ae is uniquely determined by the form of p and of ae. For
example, if p is a while loop, then the derivation can only end with rule (while0),
as opposed to (while) or (subtype) in the original system. The syntax-directed
rules also suggest where a type inference algorithm should introduce coercions.

Next we establish that the syntax-directed system is actually equivalent to our
original system. First we need another lemma:

Lemma 6.1 If *; fl `s p : ae and ` ae ` ae0, then *; fl `s p : ae0.
Proof. By induction on the height of the derivation of *; fl `s p : ae.

If the derivation ends with *; fl `s n : o/ by rule (int), then by Lemma 4.1 ae0 is
of the form o/ 0, and *; fl `s n : o/ 0 by rule (int).

If the derivation ends with *; fl `s e : o/ var either by rule (var) or (varloc),
then ae0 = ae by Lemma 4.1.

If the derivation ends with *; fl `s e + e0 : o/ by rule (arith), then *; fl `s e : o/
and *; fl `s e0 : o/ . By Lemma 4.1, ae0 is of the form o/ 0. So by induction, *; fl `s e : o/ 0

12 D. Volpano, G. Smith, C. Irvine
and *; fl `s e

0 : o/ 0. Thus, *; fl `

s e + e

0 : o/ 0 by rule (arith). The cases where the

derivation ends with rule (compose) or (letvar) are similar.

If the derivation ends with *; fl `s e : o/ by rule (r-val0), then there is a type
o/ 00 such that *; fl `s e : o/ 00 var and o/ 00 ^ o/ . By Lemma 4.1, ae0 is of the form o/ 0 and
o/ ^ o/ 0. Since ^ is transitive, o/ 00 ^ o/ 0 and so *; fl `s e : o/ 0 by rule (r-val0).

If the derivation ends with *; fl `s e := e0 : o/ cmd by rule (assign0), then
there is a type o/ 00 such that *; fl `s e : o/ 00 var , *; fl `s e0 : o/ 00 and o/ ^ o/ 00. By
Lemma 4.1, ae0 is of the form o/ 0 cmd and o/ 0 ^ o/ . Since ^ is transitive, o/ 0 ^ o/ 00
and so *; fl `s e := e0 : o/ 0 cmd by (assign0). Derivations ending with (if0) and
(while0) are handled similarly. tu

Equivalence is now expressed by the following theorem.

Theorem 6.2 *; fl ` p : ae iff *; fl `s p : ae.
Proof. If *; fl `s p : ae, then it is easy to see that *; fl ` p : ae, because each use of
the syntax-directed rules (r-val0), (assign0), (if0), or (while0) can be simulated
by a use of (r-val), (assign), (if), or (while), followed by a use of (subtype).
For example, a use of (assign0)

*; fl ` e : o/ var;
*; fl ` e0 : o/;
o/ 0 ^ o/

*; fl ` e := e0 : o/ 0 cmd

can be simulated by using (assign) to show *; fl ` e := e0 : o/ cmd, using (base)
and (cmd\Gamma ) to show ` o/ cmd ` o/ 0 cmd , and using (subtype) to show *; fl ` e :=
e0 : o/ 0 cmd.

Now suppose that *; fl ` p : ae. We will prove that *; fl `s p : ae by induction on
the height of the derivation of *; fl ` p : ae.

If the derivation ends with (int), (var) or (varloc), then *; fl `s p : ae is
immediate, and it follows directly by induction if the derivation ends with (arith),
(compose) or (letvar).

If the derivation ends with (r-val), (assign), (if), or (while), then *; fl `
p : ae follows by an application of the corresponding syntax-directed rule, using the
fact that ^ is reflexive.

Finally, suppose the derivation of *; fl ` p : ae ends with (subtype). Then
by the hypotheses of this rule, there is a type ae0 such that *; fl ` p : ae0 and
` ae0 ` ae. By induction, *; fl `s p : ae0. Thus, *; fl `s p : ae by Lemma 6.1. tu

From now on, we shall assume that all typing derivations are done in the
syntax-directed type system, and therefore shall take ` to mean `s .

As final preparation, we establish the following properties of the type system
and semantics.

Lemma 6.3 (Simple Security) If * ` e : o/ , then for every l in e, *(l) ^ o/ .
Proof. By induction on the structure of e. Suppose * ` l : o/ by rule (r-val0).
Then there is a type o/ 0 such that * ` l : o/ 0 var and o/ 0 ^ o/ . Now *(l) = o/ 0 by rule
(varloc), so *(l) ^ o/ .

A Sound Type System for Secure Flow Analysis 13

Suppose * ` e + e

0 : o/ . Then * ` e : o/ and * ` e0 : o/ . By two uses of induction,

*(l) ^ o/ , for every l in e, and for every l in e0. So *(l) ^ o/ for every l in e + e0. tu

Simple security applies to both secrecy and integrity. In the case of secrecy, it
says that only locations at level o/ or lower will have their contents read when e is
evaluated (no read up). So if L ^ H and o/ = L, then e can be evaluated without
reading any H locations.

In the case of integrity, it says that if e has integrity level o/ , then every location
in e stores information at integrity level o/ . For example, if T ^ U , where T is
trusted and U untrusted, and o/ = T , then the lemma states that every location in
e stores trusted information.

Lemma 6.4 (Confinement) If *; fl ` c : o/ cmd, then for every l assigned to in c,
*(l) * o/ .

Proof. By induction on the structure of c. Suppose *; fl ` l := e : o/ cmd by
(assign0). Then there is a type o/ 0 such that *; fl ` l : o/ 0 var , *; fl ` e : o/ 0 and
o/ ^ o/ 0. By rule (varloc), *(l) = o/ 0, so *(l) * o/ .

The lemma follows directly by induction if c is the composition of two commands or a letvar command.

Suppose *; fl ` while e do c0 : o/ cmd by (while0). Then there is a type o/ 0
such that *; fl ` e : o/ 0, *; fl ` c0 : o/ 0 cmd and o/ ^ o/ 0. By induction, *(l) * o/ 0
for every l assigned to in c0. So, since * is transitive, *(l) * o/ for every l
assigned to in c

0 and hence for every l assigned to in while e do c0. The case

when c is a conditional is handled similarly. tu

Confinement applies to both secrecy and integrity as well. In the case of
secrecy, it says that no location below level o/ is updated in c (no write down). For
integrity, it states that every location assigned to in c can indeed be updated by
information at integrity level o/ . So, for example, if o/ = U , then the lemma says
that no trusted location will be updated when c is evaluated.

The following lemma is a straightforward variant of a lemma given in [10].

Lemma 6.5 (Substitution) If *; fl ` l : o/ var and *; fl[x : o/ var] ` c : o/ 0 cmd, then
*; fl ` [l=x]c : o/ 0 cmd .

Lemma 6.6 If _ ` c ) _0, then dom(_) = dom(_0).
Lemma 6.7 If _ ` c ) _0, l 2 dom(_), and l is not assigned to in c, then
_(l) = _0(l).

The preceding two lemmas can be easily shown by induction on the structure
of the derivation of _ ` c ) _0. Now we are ready to prove the soundness theorem.

Theorem 6.8 (Type Soundness) Suppose

(a) * ` c : ae,

(b) _ ` c ) _0,
(c) * ` c ) *0,
(d) dom(_) = dom(*) = dom(*), and

(e) *(l) = _(l) for all l such that *(l) ^ o/ .

Then *0(l) = _0(l) for all l such that *(l) ^ o/ .

14 D. Volpano, G. Smith, C. Irvine
Proof. By induction on the structure of the derivation of _ ` c ) _

0. Here

we show just three cases: (update), (loop), and (bindvar). The remaining
evaluation rules are treated similarly.

(update). Suppose the evaluation under _ ends with

_ ` e ) n;
l 2 dom(_)

_ ` l := e ) _[l := n]

and the evaluation under * ends with

* ` e ) n0;
l 2 dom(*)

* ` l := e ) *[l := n0]

and the typing ends with an application of rule (assign0):

* ` l : o/2 var;
* ` e : o/2;
o/1 ^ o/2

* ` l := e : o/1 cmd

There are two cases:

1. o/2 ^ o/ . By the Simple Security Lemma, *(l0) ^ o/2 for every l0 in e. Since ^ is

transitive, *(l0) ^ o/ for every l0 in e. Thus, by hypothesis (e), _(l0) = *(l0) for
every l0 in e, so n = n0. Therefore, _[l := n](l0) = *[l := n0](l0) for all l0 such
that *(l0) ^ o/ .

2. o/2 6^ o/ . By rule (varloc), *(l) = o/2, so *(l) 6^ o/ . So by hypothesis (e),

_[l := n](l0) = *[l := n0](l0) for all l0 such that *(l0) ^ o/ .

(loop). Suppose _ ` while e do c ) _0, * ` while e do c ) *0, and the
typing derivation ends with an application of rule (while0):

* ` e : o/2;
* ` c : o/2 cmd ;
o/1 ^ o/2

* ` while e do c : o/1 cmd

Again there are two cases:

1. o/2 ^ o/ . By the Simple Security Lemma, *(l) ^ o/2 for every l in e. Since ^

is transitive, *(l) ^ o/ for every l in e. Thus, by hypothesis (e), _(l) = *(l)
for every l in e, and hence _ ` e ) n and * ` e ) n. Therefore, either the
evaluation under _ ends with

_ ` e ) 0
_ ` while e do c ) _

A Sound Type System for Secure Flow Analysis 15

and under * with * ` e ) 0

* ` while e do c ) *
or it ends under _ with

_ ` e ) 1;
_ ` c ) _1;
_1 ` while e do c ) _2

_ ` while e do c ) _2

and under * with * ` e ) 1;

* ` c ) *1;
*1 ` while e do c ) *2

* ` while e do c ) *2
In the first case, _(l) = *(l) for all l such that *(l) ^ o/ by hypothesis (e), so
we're done. In the second case, by induction, _1(l) = *1(l) for all l such that
*(l) ^ o/ . By Lemma 6.6, dom(_) = dom(_1) and dom(*) = dom(*1). So
by hypothesis (d), dom(_1) = dom(*1) = dom(*). Thus, by induction again,
_2(l) = *2(l) for all l such that *(l) ^ o/ .

2. o/2 6^ o/ . By the Confinement Lemma, *(l) * o/2 for every l assigned to in c.

Thus, for every l assigned to in c, *(l) 6^ o/ since otherwise we would have
o/2 ^ o/ since ^ is transitive. So if l 2 dom(*) and *(l) ^ o/ , then l is not
assigned to in c, and hence is not assigned to in while e do c. By Lemma 6.7,
we have _0(l) = _(l) and *0(l) = *(l) for all l such that *(l) ^ o/ . Therefore,
_0(l) = *0(l) for all l such that *(l) ^ o/ by hypothesis (e).

(bindvar). Suppose the evaluation under _ ends with

_ ` e ) n;
l is the first location not in dom(_);
_[l := n] ` [l=x]c ) _0

_ ` letvar x := e in c ) _0 \Gamma  l

and, since dom(_) = dom(*), the evaluation under * ends with

* ` e ) n0;
l is the first location not in dom(*);
*[l := n0] ` [l=x]c ) *0

* ` letvar x := e in c ) *0 \Gamma  l

and the typing ends with an application of rule (letvar):

* ` e : o/1;
*; [x : o/1 var] ` c : o/2 cmd

* ` letvar x := e in c : o/2 cmd

16 D. Volpano, G. Smith, C. Irvine
Clearly *[l : o/1] ` l : o/1 var by (varloc). By hypothesis (d) and since l 62 dom(_),
we have l 62 dom(*). Thus, *[l : o/1]; [x : o/1 var] ` c : o/2 cmd. So by Lemma 6.5,
*[l : o/1] ` [l=x]c : o/2 cmd . Also, dom(_[l := n]) = dom(*[l := n0]) = dom(*[l : o/1]).
To apply induction, we just need to show that

*[l := n

0](l0) = _[l := n](l0)

for all l0 such that *[l : o/1](l0) ^ o/ . If l0 6= l then it follows by hypothesis (e).
Otherwise, if l0 = l, then we must show n = n0 if o/1 ^ o/ . By the Simple
Security Lemma, *(l

00) ^ o/

1 for every l

00 in e. So, if o/

1 ^ o/ , then *(l

00) ^ o/

for every l00 in e, since ^ is transitive. Thus by hypothesis (e), _(l00) = *(l00) for
every l00 in e, hence n = n0. So by induction, *0(l00) = _0(l00) for all l00 such that
*[l : o/1](l00) ^ o/ . Therefore, *0 \Gamma  l(l00) = _0 \Gamma  l(l00) for all l00 such that *(l00) ^ o/ . tu

7. Discussion
The early work of Denning [5][6][7] and Andrews and Reitman [1] treated soundness intuitively. More recently, Mizuno and Schmidt [17] and O/rbaek [18] have
attempted to give rigorous soundness proofs for Denning-style secure flow analysis. However, both of these works take as their starting point an "instrumented
semantics", in which every value is tagged with a security class at runtime; the
security tags are updated at runtime in accordance with Denning's certification
conditions. Soundness then amounts to the issue of whether their static flow analysis is consistent with the instrumented semantics. But this approach begs the
question of whether the flow analysis embodied in the instrumented semantics is,
in fact, correct.

In contrast, we use a completely standard semantics for the language, and
the type soundness theorem gives a precise operational characterization of the
significance of the flow analysis: it tells us that altering the initial values of locations
of type o/ cannot affect the final values of any locations of type o/ 0, provided that
o/ 6^ o/ 0. This approach allows us to adopt typing rules whose correctness is not
intuitively obvious. For example, our (letvar) rule allows the program of Figure 1
to be typed with x : H and y : L, even though there is an implicit flow from x to
y. But this is not a problem, because our soundness theorem assures us that the
implicit flow is harmless. If we had instead used an instrumented semantics, then
our (letvar) rule would essentially be incorporated into the semantics, where its
correctness would have to be taken on faith.

Ban^atre et al. [2] also take a noninterference approach to soundness, but they
consider a nondeterministic language. They associate with a program variable v,
a set called the security variable of v, denoted _v. Roughly speaking, it is the set of
all variables whose values can influence the value of v, either directly or indirectly.
They describe an axiomatic, information flow logic for deducing whether a variable
is a member of _v, for some variable v. For example, one can deduce that

`1 fx 62 _zg y := z fx 62 _yg
A soundness proposition (Proposition 1, p. 58 [2]) is given that basically says that
if x 62 _y, for a given program, then executing the program with any two initial

A Sound Type System for Secure Flow Analysis 17
values of x will produce the same sets of final values for y, as long as the program
may terminate successfully under both initial values. However, the proposition is
actually false. The problem is that their language is nondeterministic and although
there may be an execution path that leads to successful termination, other paths
may not terminate. So it is possible to get different sets of final values for y. For
instance, consider the statement

[true ! y := 1

tu
true ! \Lambda [x = 1 ! skip]; y := 2
]

The statement is a nondeterministic alternative statement with two guards, each of
which is true. The body of the second guard is a repetitive statement with just one
guard, that being x = 1. If S denotes this statement, then one can show, using the
flow logic, that `1 fInitg S fx 62 _yg, where Init is defined as 8x; y: x 6= y ) x 62 _y.
Yet, the set of final values for y when x = 0 is y = 1 and y = 2, and when x = 1 is
just y = 1 because the loop does not terminate.

Denning has used concepts such as uncertainty (entropy) from information
theory to formalize the notion of information flow in programs [8]. Basically, if
a program, executed in state s, yields a state s0, then the execution causes an
information flow from x to y if new information about x in state s is available
from y in state s0. In other words, we are more certain about the contents of
x knowing y after execution than knowing y before. In this setting, soundness
seems to require an information-theoretic characterization. It is unclear how such a
characterization could be proved with respect to a standard programming language
semantics. Such a semantics does not make explicit notions like uncertainty. We
have demonstrated that it is possible to formulate and prove soundness without
resorting to information theory to get a handle on intuitive ideas like information
flow. All that one needs to know about what kind of security is guaranteed by our
type system is captured entirely by the type soundness theorem.

7.1. Core Language Extensions
The core language we consider has been kept simple, perhaps even emasculate, to
better explain our basic proof technique. Although one can imagine many ways to
extend the language, there is an obligation to also extend the type system and to
prove that well-typed programs preserve the security properties of interest. Many
interesting research questions arise. For instance, are there extensions of the type
system to handle other features like concurrency and nondeterminism? If so, what
is the proper notion of soundness, or, in other words, what security guarantees can
be made for all well-typed programs?

Some extensions have straightforward typing rules whose soundness can be
shown with only minor changes to the soundness theorem. Two examples are
procedures and arrays. Adding arrays is fairly easy with variables already in the
language. Procedures, though, require a bit more effort, depending on calling
conventions. We have extended the core language with procedures in the style of

18 D. Volpano, G. Smith, C. Irvine
Ada 83. A procedure has the form

proc(in x1, inout x2, out x3) c
where c is a command. We limit the number of parameters to three, one for each
kind of parameter-passing mode, only to simplify the discussion. Procedure types
have the form

o/ proc(o/1; o/2 var; o/3 acc)

where acc is a new antimonotonic type constructor that stands for acceptor in
the spirit of Forsythe [21]. An acceptor is a variable that can be assigned to
but not evaluated. This is true of out parameters in Ada 83 but not Ada 95;
consequently, acc is not antimonotonic in Ada 95. Type o/ comes from typing
command c as o/ cmd, assuming x1, x2 and x3 have types o/1, o/2 var and o/3 acc
respectively. Mode in requires a small change in the type soundness theorem but
the proof methodology is basically the same.

Other language features pose more serious problems for our type soundness
theorem. One is the idea of explicit type casting within programs. Palsberg and
O/rbaek [19] propose a system for integrity analysis in programs. They introduce a
cast operator called trust that can be used to explicitly coerce an untrusted value
to a trusted value. (Note that the opposite coercion, from trusted to untrusted,
can always be made implicitly, since T ^ U .) While such a coercion seems useful
pragmatically, including it in the language rules out our type soundness theorem.
It seems quite difficult to characterize what is being guaranteed by the flow analysis
with such a coercion.

Another source of difficulty is the proper treatment of nondeterminism. Observe, for instance, that if we try to extend the core language with a primitive
random number generator rand( ) and allow an assignment such as z := rand ( )
to be well typed when z is low, then the soundness theorem no longer holds. (Executing this assignment twice from the same memory may produce different final
values for z.) A weakness of traditional noninterference is that it is unable to model
security in nondeterministic systems [13][14]. So perhaps it is not surprising that
nondeterministic language features also cause a problem. As mentioned above,
Ban^atre et al. encountered difficulty when attempting to prove a form of noninterference for nondeterministic programs. New security models, such as Generalized
Noninterference [12] should be explored as potential notions of type soundness for
new type systems that deal with nondeterministic programs.

8. Summary
We have formulated Denning's secure flow analysis as a type system and proved
it sound with respect to a standard programming language semantics for a core
deterministic language. The type system cleanly separates the specification of
secure flow analysis from its implementation. We expect the core language and
type system to serve as a basis for provably-secure programming languages.

9. Acknowledgments
This material is based upon activities supported by the National Security Agency
and by the National Science Foundation under Agreements No. CCR-9400592 and

A Sound Type System for Secure Flow Analysis 19
CCR-9414421. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the authors and do not necessarily reflect
the views of the National Science Foundation. We would like to thank the referees
for their helpful comments.

10. References
[1] G. Andrews, R. Reitman, "An Axiomatic Approach to Information Flow in Programs", ACM Transactions on Programming Languages and Systems 2, 1, (1980),
56-76.

[2] J. Ban^atre, C. Bryce, D. Le M'etayer, "Compile-time Detection of Information Flow

in Sequential Programs", pp. 55-73 in Proceedings of the European Symposium on
Research in Computer Security, Lecture Notes in Computer Science 875, Springer
Verlag, Berlin, 1994.

[3] D. Bell, L. LaPadula, Secure Computer System: Mathematical Foundations and

Model, MITRE Corp. Technical Report M74-244, 1973.

[4] K. Biba, Integrity Considerations for Secure Computer Systems, MITRE Corp.

Technical Report ESD-TR-76-372, 1977.

[5] D. Denning, Secure Information Flow in Computer Systems, Purdue University

Ph.D. Thesis, 1975.

[6] D. Denning, "A Lattice Model of Secure Information Flow", Communications of

the ACM 19, 5, (1976), 236-242.

[7] D. Denning, P. Denning, "Certification of Programs for Secure Information Flow",

Communications of the ACM 20, 7, (1977), 504-513.

[8] D. Denning, Cryptography and Data Security, Addison-Wesley, 1983.
[9] J. Goguen, J. Meseguer, "Security Policies and Security Models", pp. 11-20 in

Proceedings of the 1982 IEEE Symposium on Security and Privacy, 1982.

[10] R. Harper, "A Simplified Account of Polymorphic References", Information Processing Letters 51, (1994), 201-206.

[11] T. Lunt, P. Neumann, D. Denning, R. Schell, M. Heckman, W. Shockley, Secure

Distributed Data Views Security Policy and Interpretation for DMBS for a Class
A1 DBMS, Rome Air Development Center Technical Report RADC-TR-89-313,
Vol I, 1989.

[12] D. McCullough, "Specifications for Multi-level Security and a Hook-up Property",

in Proceedings of the 1987 IEEE Symposium on Security and Privacy, 1987.

[13] D. McCullough, "Noninterference and the Composability of Security Properties",

pp. 177-186 in Proceedings of the 1988 IEEE Symposium on Security and Privacy,
1988.

[14] J. McLean, "Security Models and Information Flow", pp. 180-187 in Proceedings

of the 1990 IEEE Symposium on Security and Privacy, 1990.

[15] M. Mizuno, "A Least Fixed Point Approach to Inter-Procedural Information Flow

Control", pp. 558-570 in Proceedings of the 12th National Computer Security
Conference, 1989.

[16] M. Mizuno, A. Oldehoeft, "Information Flow Control in a Distributed ObjectOriented System with Statically-Bound Object Variables", pp. 56-67 in Proceedings of the 10th National Computer Security Conference, 1987.

20 D. Volpano, G. Smith, C. Irvine
[17] M. Mizuno, D. Schmidt, "A Security Flow Control Algorithm and its Denotational

Semantics Correctness Proof", Formal Aspects of Computing 4, 6A, (1992), 722-
754.

[18] P. O/rbaek, "Can You Trust Your Data?", pp. 575-589 in Proceedings of the 1995

Theory and Practice of Software Development Conference, Lecture Notes in Computer Science 915, 1995.

[19] J. Palsberg, P. O/rbaek, "Trust in the *-calculus", in Proceedings of the 1995 Static

Analysis Symposium, Lecture Notes in Computer Science 983, 1995.

[20] L. Paulson, ML for the Working Programmer, Cambridge, 1991.
[21] J. Reynolds, Preliminary Design of the Programming Language Forsythe, Carnegie

Mellon University Technical Report CMU-CS-88-159, 1988.