

A System F with exceptions

Sylvain LebresnePreuves, Programmes et Syst`emes (PPS), CNRS, Universit'e Paris 7, Paris, France, and
Projet Logical, LIX, 'Ecole Polytechnique, Palaiseau, France

sylvain.lebresne@pps.jussieu.fr

AbstractWe present an extension of System F with call-by-name exceptions. The type system is enriched with two syntactic constructs:a union type

A !! {!} for programs of type A whose execution mayraise the exception

! at top level, and a corruption type A{"} forprograms that may raise the exception

! in any evaluation context(not necessarily at top level). We present the syntax and reduction

rules of the system, as well as its typing and subtyping rules. Wethen study its properties, such as confluence and subject-reduction,
from which we deduce that the typing of exceptions is correct inthe sense that a well-typed program whose type does not mention
an exception cannot raise this exception. Finally, we construct a re-alizability model using orthogonality techniques, from which we
deduce that well-typed programs are weakly normalizing.

1. IntroductionExceptions are a convenient mechanism for handling errors in programming languages. Most modern languages use it: Java [7],C++ [15], C# [8], Objective Caml [9], . . . . One of the basic properties of an exception is that it can be raised instead of any otherexpression of the language. Hence, typing of the

raise1 construc-tion must be performed with care. The solution currently used by

languages of the ML family consists in letting this construction tohave any type. (In imperative languages like Java, no real typing
difficulty arises since throwing an exception is an instruction.) Forexample, in Caml, the type of

raise is exn -> 'a. There are sev-eral advantages to this solution: using exceptions is simple and it

requires no change neither in the type system nor in the type in-ference algorithm. However, this design choice has a major drawback; the type system no longer ensures that a well-typed programwill not produce errors during computation. In particular, in ML
languages, a program of type int can exit abruptly without return-ing a proper natural number. While this drawback is considered
acceptable for most programming activities, it becomes unaccept-able when we need strong correctness criteria on programs. One
particular field where such guarantees are needed is type theory.However the solution consisting in giving the

raise construc-tion all types, used by ML languages, is no coincidence. Let us

1 Or throw, according to the terminology of Java.

[Copyright notice will appear here once 'preprint' option is removed.]

indeed consider an inhabited type A, with a any inhabitant of A,and let us consider the term

R = ("x. a) raise.If
T is a type of the raise expression, "x. a has type T " Aand consequently

R has type A. But in ML the term R reducesto
raise, implying that raise has type A. To summarize, this ex-ample shows that the construction

raise is indeed in all inhabitedtypes. But let us detail which conditions are needed to derive this

example:1. the typing rules for the introduction and elimination of arrow

types are the usual ones;2. we have a reduction of

M raise to raise (we will call thisrule the "CBV raise" rule in the following);

3. the raise construction has at least one type (T in our example);4. the subject-reduction property holds.

So, if we do not want the raise construction to have all types, weshould relax at least one of these conditions.

Relaxing one of the last two conditions seems unreasonnablesince our goal is precisely to type the

raise construction andsince a calculus without subject-reduction would hardly meet the

strong correctness requirements we aim at. In [12], F. Pessaux andX. Leroy modified the typing rules of functions and applications
in the type system of Objective Caml in order to detect uncaughtexceptions. Basically, they annotate the type of a function with the
set of exceptions that might "escape" from it when applied. Andthey allow universal quantification on these sets of exceptions. For
example, they type the map function by

map : ##, $, %.(# #" $) !" (# list #" $ list)where

# and $ range over types and % ranges over sets of excep-tions. This should be understood as: the

map function takes forargument a function from which can escape any given set of exceptions and will return a function from which can escape exactlythe same set of exceptions, and the

map function itself raising noexception in this process. This allows the typing of exceptions to

work with higher-order functions. Moreover, they develop an ef-ficient inference algorithm for this non-standard type system and
show that this solution is sound. A similar work for the detection ofuncaught exceptions in the SML language has been developed by
M. F"ahndrich and A. Aiken [3]. These solutions are both precise(in the detection of exceptions) and efficient and thus nicely suited
for the programming languages they are designed for.However, our motivation in this paper is to study exceptions in
type theoretical frameworks. And we believe that in such frame-works, keeping the typing rules for arrow types unmodified and
relaxing the second condition is preferable. This belief is moti-vated by two considerations. Firstly, if we keep the "CBV raise"
rule along with the "CBN raise" one (which is the name we give to

1 2008/1/29

the rule that reduces raise M to raise), the reduction system isno longer confluent. Secondly, according to the Curry-Howard isomorphism, the arrow type is the logical implication. So, modifyingthe arrow type breaks this interpretation (we do not say that it is not
possible to recover it, but the interpretation is not direct anymore).In particular, these considerations are crucial if we want a type system that can hopefully be later extended to the dependent product.Indeed, the conversion rule that such an extension would need, depends upon the confluence property, and the meaning of a modi-fied dependent product (with annotation for example) is not clear.
Motivated by similar reasons, R. David and G. Mounier proposedin [2] a

"-calculus with typed exceptions based on an extension of
AF2 which does not have the "CBV raise" rule. However, in theircalculus, the use of exceptions is limited to data types; the

raiseconstruction cannot be used where a function is expected. We do

not want such a limitation.In this paper we present the

Fx calculus, which is a "-calculuswith typed exceptions whose type system is an extension of System F. In this calculus, and unlike the one of R. David and G.Mounier, the

raise construction is allowed by the type system toappear anywhere in a term. In

Fx, this property holds thanks to thenew notion of corruption of type.

The remainder of this paper is organized as follows. We firstgive in Section 2 an informal presentation of

Fx, how it handlesexceptions and in particular this section gives the main properties,

and the associated intuitions, of the central notion of corruption.The syntax and reductions of the calculus are presented in Section 3
where we also state the confluence property of the reduction. Thenwe formally present the type system of

Fx in Section 4 and givesome examples of use of the calculus in Section 5. In Section 6, we

present a realizability model of Fx, model designed using orthogo-nality techniques. In Section 7 we discuss the addition of evaluation
functions, that can be useful when dealing with corruption. Finally,in Section 8 we discuss possible and planned extensions of

Fx.

2. Informal presentation2.1 Description of

FxThe
Fx calculus is an extension of Girard's System F [4, 14](in fact, we extend the System F with subtyping: F

& (see [11]and [17])) with a typed mechanism of exceptions and a System Tlike [6] type of primitive natural numbers. (See Section 5 for adiscussion about this choice.) Moreover, to handle some properties
of the typing of the exceptions mechanism, Fx uses a subtypingrelation (denoted $) whose purpose will be discussed in the next
subsection.In

Fx, exceptions are dealt with using two constructions thatare usual in ML languages: the

raise ! construction that raises theexception named
!, and the try M with ! %" N construction2 thatevaluates the term

M, possibly catching the exception ! (if raisedby
M) and branching on the evaluation of N in this case.In languages of the ML family (and also in Java), the evaluation of exceptions is deeply rooted in the call-by-value discipline:exceptions are not only caught when they appear in head position,
but also when they appear in argument position. In Fx, exceptionsare treated in the spirit of call-by-name, in the sense that they are
caught only when appearing in weak head position. (Unlike in ML,the program

S (raise !), where S is the primitive successor func-tion, does not raise an exception in

Fx. The meaning of such acorrupted natural number will be precised in the forthcoming subsection.)

2 In standard ML this construction is called handle but only differ by thesyntax.

From the reduction side, our exceptions should be comparedto the one defined in [13]. In this paper, S. Peyton Jones et al.
present an extension of Haskell with exceptions (where the raiseconstruction is in all types) and discuss in particular the use of
exceptions in a lazy functional language. They remark that in lazylangugage "exceptions are associated with data values, rather than
with control flow". This is also the case in our calculus wherethe expression

raise ! should only be seen as a specific valuewhich have specific typing rules. However, the reduction rules of

our calculus are confluent, so we can use any reduction strategy.So, since the behavior of our exceptions system is somewhat
non-standard, let us specify the meaning we give to some usualnotions. We call the expression

raise ! an exception, ! being itsname, and as an abuse of terminology, we will also sometimes

use the term exception for !. And when we say that a term raisethe exception

!, we mean that a this term actually reduces to theexception named

! (see Section 3 for the exact reduction rules ofthe calculus).

2.2 CorruptionIn

Fx, we add the type construction A !! {!} to the types of Sys-tem F. Terms of type

A !! {!} are terms of type A or terms that raisethe exception
! (so A $ A !! {!} in particular). Then, for example,
S 0, raise ! or ("x. x 0) raise ! are all terms of type N !! {!}.If such a term actually raises an exception, it can be caught by the

try construction. In the term try M with ! %" N, M must be oftype

A !! {!} and N of type A for the whole term to be well-typedof type

A. Notice that the term raise ! always raises the excep-tion
! and is thus of type (##. #) !! {!}. But also notice that withthis type for

raise !, the above example ("x. x 0) raise ! can-not, for now, be typed with N

!! {!}. How we can give the type#

#. # " ((##. #) !! {!}) to the term raise !, and thus type thisexample, will be explained in Section 4.

But the construction A !! {!} is not enough to type all the termof
Fx. For example, as mentioned earlier, the term S (raise !)does not raise the exception

!. But it is not a natural number ei-ther and consequently does not have the type N

!! {!}. This term iscalled a corrupted term and is typed using the corruption construction A{"} by the type N{"}.The intuition behind corruption is that if a term has type

A{"},it is a term of type
A in which some subterms have been replacedby the expression
raise !. Or, equivalently, it is a term that mayraise an exception in any evaluation context. Note that in particular

A{"} is a broader type than A !! {!}, the terms of A !! {!} beingterms that may raise an exception only at top level. This property
is expressed by the subtyping rule A !! {!} $ A{"}. For example,the terms

raise !, "x. raise !, "x. (S (raise !)) and "x. 0 allhave the corrupted type

(N " N){"}.The notion of corruption is central in

Fx. Its main purpose isin fact to answer the question `what to do with a term of type

(A " B) !! {!}?'. Indeed, a term of type (A " B) !! {!} is eithera function of type

A " B or a term that raises the exception !. Butwe still want to be able to use such a term as a function (note that

the raise construction is also a function, just one that discards itsarguments). So, and as we do not want to modify the typing rule of
application, we must be able to type a term of type (A " B) !! {!}with a functional type. That is exactly what corruption does. As we
have already said, a term of type (A " B) !! {!} is also of type
(A " B){"}. And the main property of corruption is to verify

(A " B){"} = A{"} " B{"}.
A corrupted function, of type (A " B){"}, is a function that mayraise an exception in any evaluation context. A function of type

A{"} " B{"} is a function that, applied to an argument that may

2 2008/1/29

raise an exception in any evaluation context, will return a termthat may raise an exception in any evaluation context. The above
equation means that in Fx, both notions coincide. Note that thisequation is only a shortcut for the two subtyping rules

(A " B){"} $ A{"} " B{"}
A{"} " B{"} $ (A " B){"}On the practical side, this allows for modularity. Let us consider

a function f : A " B. With the properties of corruption explainedbefore we have

A " B $ (A " B) !! {!} $ (A " B){"} = A{"} " B{"}and consequently

f has also the type A{"} " B{"}. This meansthat a function in

Fx which does not mention an exception canbe used with this exception anyway. But when taking a potentially

corrupted argument, as the type system does not know what thefunction does, it warns that the result will be potentially corrupted.
Functions in Fx are always allowed to handle exceptions. And thetype system does not need to retype the function to allow that, it
does not need the actual code of the function, thus allowing formodularity. This is particularly convenient for functions that have
no code, like the primitive successor function S. So, the corruptionpermits the handling of inductive data types in

Fx.Note that in all the example shown above, we only use the

subtyping rule

(A " B){"} $ A{"} " B{"}.One can wonder why we have chosen to add the subtyping rule

A{"} " B{"} $ (A " B){"} (arrc)To show the usefulness of this rule, let us momentarily assume that
this rule does not holds and then consider the term

M = "x. "y. xThis term has the type
A " (B " A) and, using the subtypingrules presented above, has also the type

A{"} " (B " A){"}.So, applying the usual typing rule of application, we have that

M (raise !) has type (B " A){"}. But this term reduces to theterm

"y. raise ! which has the type B " A{"}. And if we do nothave the rule (arrc), this type is not a subtype of

(B " A){"}. So,to summarize, the rule (arrc) is necessary for the

Fx calculus tosatisfy the subject-reduction property.

One of the fundamental properties we can expect when usingexceptions is to be authorized by the type system to raise an exception instead of any other term (and thus without losing all thetyping information). In

Fx this property holds thanks to the notionof corruption, as more formally stated by the Theorem 2 of Section 4.On the theoretical side, corruption and in particular its distributivity with respect to the arrow construction is justified by boththe theorem of subject-reduction in Section 4 and the realizability
model presented in Section 6.In this subsection we have introduced the most important rules

of the subtyping of Fx. The full subtyping of Fx uses other ruleslike the usual rule of identity, transitivity and arrows contravariance
and covariance, as well as rules to manage more than one exceptionin a term. The set of all the rules defining the subtyping is given in
Section 4.

3. Syntax, reductions and associated properties3.1 Syntax of terms

We consider a countable set E of names of exceptions and a distin-guished set of variable V. Terms of

Fx are defined by the following

grammar:

M, N ::= x | "x. M | M N|

raise ! | try M with ! %" N|
0 | S | RecIn this de

finition, x stands for a term variable (x & V) and ! standsfor an exception name (

! & E). The notions of free and boundvariables are defined as usual, as well as the external operation of

substitution (written M{x := N}). The set of all closed terms isdenoted T . Terms are considered up to

#-equivalence. Note thatthe construction
try M with! %" N does not bind the occurrencesof
!. The term raise ! is called an exception, ! being its name. Asan abuse of terminology we shall often also use the word exception

to speak of !. In the term try M with ! %" N we will sometimescall

M the body and N the handler of the try construction.

3.2 Computation in FxValues are the terms of

Fx defined by
V ::= "x. M | 0 | S | S N | Rec | Rec M | Rec M Nand results are the terms de

fined by
R ::= V | raise !The notion of reduction for the calculus is given by the rules of

Figure 1. The usual call-by-name $-reduction is extended with the

("x. M) N > M{x := N}
(raise !) M > raise !

try (raise !) with ! %" N > N
try (raise !") with ! %" N > raise !"
try V with ! %" N > V

Rec X Y 0 > X
Rec X Y (S N) > Y N (Rec X Y N)
Rec X Y (raise !) > raise !

Figure 1. Notion of reduction for Fx
rules for the try and raise construction on the first hand, and bythe rules for the System T-like recursor

Rec on the second hand.Computation in
Fx is defined from the notion of reduction bythe relation of reduction ' whose rules are given in Figure 2. We

note '# the transitive and reflexive closure of '.

M > M"
M ' M"

M ' M"
"x. M ' "x. M"

M ' M"
M N ' M" N

N ' N"
M N ' M N"

M ' M"
try M with ! %" N ' try M" with ! %" N

N ' N"
try M with ! %" N ' try M with ! %" N"

Figure 2. Relation of reduction for Fx
Note that, as it is usual, the scope of capture of the try con-struction is dynamic. In the term

("x. try x with ! %" 0) (raise !),

3 2008/1/29

even if the expression raise ! does not appear in the body of the
try construction, the exception is caught during reduction and thewhole term reduces to

0.We will say that a term

M raises the exception ! if M reducesto the exception named
! (or, more formally, M '# raise !).We prove con

fluence using a proof similar to the one of Tait andMartin-L"of that can be found in [1]. This proof uses a notion of parallel reduction ((), and the adapted version of parallel reductionfor our calculus is defined in Figure 3. We denote (# the transitive
and reflexive closure of (.

M ( M

M ( M"
"x. M ( "x. M"

M ( M" N ( N"

M N ( M" N"

M ( M" N ( N"
("x. M) N ( M"{x := N"}

N ( N"
try (raise !) with ! %" N ( N"

try (raise !") with ! %" N ( raise !"

M ( M" N ( N"
try M with ! %" N ( try M" with ! %" N"

V (V V "
try V with ! %" N ( V "

X ( X"
Rec X Y 0 ( X"

X ( X" Y ( Y " N ( N"
Rec X Y (S N) ( Y " N" (Rec X" Y " N")

0 (V 0 S (V S Rec (V Rec
M ( M"
"x. M (V "x. M"

N ( N"
S N (V S N"

M ( M"
Rec M (V Rec M"

M ( M" N ( N"
Rec M N (V Rec M" N"

Figure 3. Parallel reduction in Fx
This reduction satisfies the diamond property.Lemma 1 (Diamond property for (). Let

M, N and N" be anyterms, if
M ( N and M ( N", then there exists a term P suchthat

N ( P and N" ( P.
Proof. The proof proceeds by simultaneous induction on M ( Nand

M ( N".

Moreover, it can be easily shown that '# = (#, by inductionon the rules defining these two relations. Thus, a corollary of the

previous lemma is the confluence theorem.Theorem 1 (Con

fluence). The relation ' is confluent: if M, Nand
N" are terms such that M '# N and M '# N", then thereexists a term

P such that

N '# P and N" '# P.

4. Typing and subtypingThe syntax of types for

Fx is built upon the one of System F byadding two new type constructions:

A, B ::= # | N | A " B | ##. A | A !! ! | A!

In the constructions A !! ! and A!, ! is a finite set of exceptionnames (hence

! ) E). Moreover, # stands for a type variable takenfrom the set ot type variable A. The notion of free and bound type

variable is defined as usual, as well as the external operation ofsubstitution (written

A{# := B}). We denote by F V (A) the setof all the free type variables of the type

A. Types are considered upto
#-equivalence. By convention, and unless otherwise specified,we will use roman letters

x, y, . . . to denote terms variables, greekletters
#, $, . . . to denote type variables, the greek letter ! forexception names and

! for a set of exceptions. Precedences forthe arrow construction and the universal quantifier are the usual

one; the precedences of A !! ! and A! being higher. For example
A " B !! ! is understood A " (B !! !).In the following, we will use the notation * for the type #

#. #.The construction
A! reads `A corrupted by the exceptions of !'.

4.1 SubtypingThe subtyping relation between two types

A and B, written A $
B, is inductively defined by the rules of Figure 4. The equality
A = B is defined as short for "A $ B and A + B", and theinference rules with an equality on conclusion is a notation for the

two expected inference rules.The subtyping relation is a preorder (rules (st-id) and (st-trans)).
Moreover, as usual, functional arrows are contravariant on the leftside and covariant on the right side (rule (st-arrow)). The rules
(f-gen), (f-inst) and (f-arr) are the subtyping rules that handle theconstruction #

#. A of System F. The rest of the rules are specific to
Fx and handle subtyping for the construction A !! ! and A!. Therule (ex-uni) expresses that,

A !! ! being either a term of type Aor an exception from name in

!, terms of type A are also of type
A !! !. The rule (ex-corrupt) states that terms of type A !! ! arealso of type

A!. Note that with these two rules, we can derive thesubtyping

A $ A!.The rule (eq-arrc) expresses the distributivity of corruption over arrow types. As explained in Section 2, this rule allows any functionto take an argument corrupted with any exception (the return type
being then also corrupted). The other rules are more "bureaucratic"rules. The rules (eq-uu) and (eq-cc) are used to isolate a particular exception from a set of exceptions or conversely, to gather twosets of exceptions together. The rules (eq-uc) and (eq-fallc) express
the commutation of the corruption construction with the construc-tions

A !! ! and ##. A. The rule (ex-noex) (along with the easilydeducible rule

A $ A !! {}) simply expresses that A !! {} is Aand the rule (ex-ctx) expresses that the construction

A !! ! is sta-ble with respect to subtyping. Finally, the rule (ex-empty) expresses

that the two notions A !! ! and A! coincide on the empty type.We will see in the following subsection that the term

raise ! hastype *
!! {!}. With the rules of corruption and the definition of theempty type, we can show that

raise ! can be used as a functionbecause it has a functional type:

* !! {!} $ (A " *){"} $ A{"} " *{"} $ A " *{"}.Hence, if

M is a term of type A, (raise !) M has type *{"}.Consequently, the term

try (raise !) M with ! %" 0 will havethe type N{
"} (see the next subsection for the exact typing rule ofthe

try construction) even if it reduces to 0. But using the rule (ex-empty) we are more precise since the term

raise ! has then also thetype
A " * !! {!}, and thus the term try (raise !) M with ! %" 0has type N.

4.2 TypingA typing context is a

finite set of declarations of the form
" , x1 : A1, . . . , xn : An

4 2008/1/29

Standard subtyping rules :

A $ A (st-id)

A $ B B $ C

A $ C (st-trans)

A" $ A B $ B"
A " B $ A" " B" (st-arrow)System F rules :

A $ B # /& F V (A)

A $ ##. B (f-gen) ##. A $ A{# := B} (f-inst)

# /& F V (A)
##. (A " B) $ A " ##. B (f-arr)Exception related rules :

*! $ * !! ! (ex-empty) A !! * $ A (ex-noex)

A $ B
A !! ! $ B !! ! (ex-ctx)

A $ A !! ! (ex-uni) A !! ! $ A! (ex-corrupt)Exception related equality rules :

(A !! !) !! !" = A !! (!!!") (eq-uu) (A!)!! = A(!$!!) (eq-cc) (A !! !)!! = A!! !! (! - !") (eq-uc)

(##. A)! = ##. A! (eq-fallc) (A " B)! = A! " B! (eq-arrc)

Figure 4. The subtyping relation
where x1, . . . , xn are pairwise distinct term variables and where
A1, . . . , An are arbitrary types. The set of free type variables of atyping context

", denoted F V ("), is the union of the sets of freetype variables for the types used in

":

F V (") = [

x=1..n

(F V (Ax)).

The type system of Fx is defined from the typing judgment

" . M : Athat reads `in the typing context

", the term M has type A'. Thisjudgment is defined inductively by the rules given in Figure 5.

4.3 Properties of typingWe de

fine the relation between terms M /! M" which reads`
M" is more corrupted than M with exceptions of !' by the rulesof Figure 6. Let us remark that if

M /! M" then M" is Mwhere some subterms have been replaced by exceptions. Hence

Theorem 2 expresses that in term of programming, exceptions canbe used in any place, but with the added cost of corrupting the type
of the expression where they are used.

M /! M M /! raise ! ! & !

M /! M"
"x. M /! "x. M"

M /! M" N /!! N"

M N /(!"!!) M" N"

M /! M" N /!! N"
try M with ! %" N /(!"!!) try M" with ! %" N"

Figure 6. Corruption of terms

Theorem 2. If M and M" are two terms, A a type and ! a set ofexceptions such that

" . M : A and M /! M", then

" . M" : A!.We
finally show that Fx enjoys the subject-reduction property.Theorem 3 (subject-reduction). Let

M and M" be two terms and
A a type, if " . M : A and M '# M", then

" . M" : A.The dif
ficulty added by our system to the usual proof of subject-reduction for System F is due to our stronger subtyping relation.

In particular, subtyping derivations mentioning arrow types can bequite complicated. The difficult case of the proof is the

$-reductioncase. We give in Appendix A the intuition of the proof for this case

and in particular, we show how to resolve the difficulties specific toour calculus.

As a consequence of the subject-reduction property, and be-cause we can easily prove that in the empty typing context, the
term raise ! cannot be typed with the type N, we can show thefollowing corollary:

Corollary 1 (Safety of typing for N). If a term M is of type Nin the empty typing context, then

M cannot raise an exception: if.
M : N, then

M 0'# raise !.In fact, we can even show a more general corollary which

expresses that, in some sense, our typing system is safe with respectto exceptions:
Corollary 2 (Safety of typing). If the type A of a term M doesnot mention a particular exception

!, then M cannot raise thisexception
!: if . M : A and ! /& A, then

M 0'# raise !.Note that this corollary is even true if the term

M is put in anycall-by-name evaluation context.

5 2008/1/29

System F typing rules:

(x : A) & "

" . x : A (ax)

", x : A . M : B
" . "x. M : A " B (abs)

" . M : A " B " . N : A

" . M N : B (app)

" . M : A # /& F V (")

" . M : ##. A (gen)Natural numbers typing rules:

" . 0 : N (zero) " . S : N " N (succ) " . Rec : ##. # " (N " # " #) " N " # (rec)Exceptions handling typing rules:

" . raise ! : * !! {!} (raise)

" . M : A !! {!} " . N : A

" . try M with ! %" N : A (try)

" . M : A A $ B

" . M : B (subs)

Figure 5. Typing judgments
5. ExamplesIn this section, we show some examples of use of

Fx for program-ming with exceptions.

5.1 Natural numbersIn the following, we will sometimes use natural numbers in their
arabic notation, i.e. 1 is S 0, 2 is S (S 0), . . . . A simple yet classicalfunction on natural numbers which can raise an exception is the
predecessor function. In Fx, we can define:

pred , Rec (raise !) ("x. "y. x) : N " N !! {!}It has the expected reductions, i.e.

pred 0 '# raise ! and
pred (S N) '# N. We can then define a "safe" predecessor
pred" from pred which returns 0 when applied to 0:

pred" , "n. try (pred n) with ! %" 0 : N " NReductions are

pred" 0 '# 0 and pred" (S N) '# N.
Since Fx is an extension of System F, we can use second-order encodings of data types (see [6]). In particular, we can use

the second-order encoding of natural numbers. It is well knownthat this encoding is less efficient than having primitive natural
numbers. The usual example is the predecessor function whosecomputation time is not constant. But let us first recall the encoding
for natural numbers:

nat , ##. (# " (# " #) " #)

0 , "z. "s. z : nat
1 , "z. "s. s z : nat
n , "z. "s. s . . . s| {z }

n

z : nat

succ , "n. "z. "s. s (n z s)In these encodings, natural numbers are their own iterators. One

of the known drawbacks is that the predecessor function has noother choice than to entirely deconstruct the natural number and
then reconstruct it, "forgetting" the last successor in the process.The predecessor is coded by the following term:

pred , "n. "z. "s. (n ("x. z) ("x. "y. y (x s))) ("x. x)This predecessor function returns

0 when applied to 0. A differencein
Fx with the primitive version of natural numbers is that, becauseof the way

pred computes its result, there is no simple modificationof it in order to have an exception raised when applied to

0. Still, aworkaround consists in defining a new predecessor
pred" whichdirectly raises an exception when applied to
0 and calls predotherwise:

pred" , "n. n (raise !) ("y. pred n) : nat " nat !! {!}

This example demonstrates that in Fx we could rely on thesecond-order encoding of natural numbers and use exceptions with
it. In fact, the downside of such encodings in Fx is the same thanin System F: some basic functions are harder to program than with
primitive definitions (and even a bit harder in Fx than in System F ifwe want to use exceptions, as seen with the predecessor example).
Besides, these functions are less efficient.When designing

Fx, one of the goals we had was to be able touse inductive data types. And it should be noted that this possibility

in Fx (we only have numerals for now but extending Fx to otherinductive data types is definitively considered) heavily relies on the
notion of corruption. We use corruption to be able to apply S or Recto a

raise. The possibility to use inductive data types in Fx is aconsequence of the modularity offered by the notion of corruption.

5.2 ListsWe now show an example of use of exceptions with lists. We start
by recalling the second-order encoding of list:

list , #$. ##. (# " ($ " # " #) " #)

nil , "n. "c. n : list
cons , "i. "l. "n. "c. c i (l z c) : #$. $ " list($) " list($)where we use the following notation as a shortcut:

list(A) , ##. (# " (A " # " #) " #).We will use the standard notation with square brackets for lists, we
will write [3; 0; 4] for the list

cons 3 (cons 0 (cons 4 nil)) = "n. "c. c 3 (c 0 (c 4 n)).Hence, the list

[3; 0; 4] is of type list(N).We can now define "true"

head and tail functions. By "true",we mean that they raise an exception when applied to the empty

list. Notice that the code of the tail function relies on the same"trick" than the one of the predecessor for natural numbers in their
second-order encoding version:

head , "l. l (raise !) ("i. "r. i) : list " #$. $ !! {!}
tail" , "l. "n. "c.

(l ("x. n) ("e. "x. "y. y i (x c))) ("x. "y. y)
tail , "l. l (raise !) ("n. "c. tail" l)

: list " list !! {!}Notice here that there is room for another version of the tail function:

tail2 , "l. "n. "c. l (raise !) ("e. "r. (tail" l) n c)The spirit behind these two versions is different: while the

firstone uses the list taken as argument as an iterator over the whole

type list !! {!}, the second one uses it as an iterator over the type

6 2008/1/29

# !! {!}. But tail2 does not raise an exception when applied tothe empty list, it returns a corrupted list (

"n. "c. raise ! actually)as stated by its type:

tail2 : list " list{"}We now de
fine the mapping of a function on natural numbers toa list (of natural numbers):

map : (N " N) " list(N) " list(N)

= "f. "l. "n. "c. l n ("i. "r. c (f i) r)We can easily check that

map pred [3; 0; 4] '# [2; raise !; 3] : list(N !! {!})It should be noted that the returned list is a perfectly well formed
list. The exception inside it acts as a simple value as long as it doesnot come in head position. In particular, one can retrieve the first
element of the list:

head (map pred [3; 0; 4]) '# 3The same program in Objective Caml would have reduced to an

exception.The examples above show the difference between a corrupted
list and a list with corrupted elements. If l is a list of naturalnumbers, there is a difference between the result of

tail2 l whichis a corrupted list (it has the type
list{"}(N)) and the resultof
map ("n. S (pred n)) l which is a well-formed list but withcorrupted elements (it has the type

list(N{"})).

6. Realizability modelWe de

fine a realizability model for Fx using techniques of orthog-onality (see [16] for examples of use of such techniques). Before

presenting our model, we need to define the notion of contexts.Moreover, we add a daimon to the system. One of its purpose will
be to inhabit all type interpretations and the empty type's one (*) inparticular.

6.1 Daimon, weak head reduction and contexts
Daimon The daimon is a new term we add to Fx (it is similarto the daimon of [5]) denoted by !. Let us note that it is only

a technical addition in the sense that it cannot appear in a termduring reduction. Moreover, the daimon has no typing rule and so
cannot be used in well-typed terms. This daimon is an uncatchableexception. The reduction rules of ! are given in Figure 7. It should
be noted that the confluence theorem still holds with the addition ofthe daimon since, from a pure term point of view, the daimon can
be simulated by a "fresh" exception caught by no try.

! M > !
try ! with ! %" N > !
Rec X Y ! > !

Figure 7. Reduction rules of !
Weak head reduction To prove the correctness of our model, weneed to consider weak head normal forms and thus weak head
reduction. Since our model will only consider closed term, we onlyconsider the weak head normal form of closed term. A term is in
weak head normal form (whnf ), if it is in one of the following forms(where

R is a result): whnf

::= R | !A useful property of terms in weak head normal form in

Fx isfact 1:

Fact 1. if a closed term M is in weak head normal form, then
try M with ! %" N ' M or try M with ! %" N ' N.Rules for weak head reduction ('

h) are given in Figure 8. Thetransitive and reflexive closure of '
h is noted '#h. Given a termM, we will use the notation M 1h for 2M", M '#

h M" and thenotation whnf (M) for its weak head normal form, if it exists.

M > M"
M 'h M"

M 'h M"
M N 'h M" N

M 'h M" N 'h N"
try M with ! %" N 'h try M" with ! %" N"

M 'h M"
Rec X Y M 'h Rec X Y M"

Figure 8. Weak head reduction
Let us remark that we need a specific rule for reducing the mainargument of the recursor

Rec since the rule for application does nothandle it anymore.

The following lemmas hold:Lemma 2. The weak head reduction is included in the reduction:
for all terms M and M", if M 'h M", then M ' M".Lemma 3. If a term reduces to an exception, it will also weakly
reduce to this exception: for all term M and for all exceptionname

!, if M ' raise !, then M 'h raise !Lemma 4. If a term reduces to the daimon, it will also weakly

reduce to it: for all term M, if M ' !, then M 'h !Proofs of lemmas 3 and 4 follow from the standardization
Lemma 5. To express this lemma we define the internal paral-lel reduction denoted by (

i and defined by the rules of Figure 9.(#
i is the transitive and reflexive closure of (i.Lemma 5 (Standardization lemma). A step of parallel reduction

can be simulated by some steps of weak head reduction followed bya step of internal parallel reduction: if

M and N are terms suchthat
M (# N, then there exists a term P such that

M '#h P (#i N.The proof of this lemma is inspired from the one of the standardization lemma found in [10].

M (i M

M ( M"
"x. M (i "x. M"

M (i M" N ( N"

M N (i M" N"

M (i M" N ( N"
try M with ! %" N (i try M" with ! %" N"

Figure 9. Internal parallel reduction
Contexts As usual, a context is a term with a hole (the hole isdenoted by

[ ]), but not every term with a hole is a valid context. Acontext of
Fx is defined by the following grammar:

C ::= [ ] | C N | try C with ! %" ! | Rec M N CThe set of all contexts is noted C and the term obtained by

fillingthe hole of a context
C with the term M is noted C[M].

7 2008/1/29

The hole can only appear in head position. Moreover, for the
try construction, we only allow ! as handler. With this restriction,we ensure the following fact:

Fact 2. #

C & C, C[!] '# !#
C & C, C[raise !] '# ! or raise !Notice that, up to the restriction to

! in the handler of try, thesecontexts are exactly the evaluation contexts of the call-by-name

reduction.We have the following lemma:

Lemma 6. If a term has a weak head normal form in some context,then it has a weak head normal form: for all term

M and context C,if
C[M] 1h, then M 1h.

6.2 Operations on setsWe de

fine some operations on sets of contexts. We start by definingthe orthogonal of a set of contexts

S, denoted S%:

S% = { M | # C & S, C[M] '# ! }Then we de

fine the two standard notions of concatenation of a setof terms
A with a set of contexts S (written A * S) and compositionof two sets of contexts (written

S 3 T ):

A * S = { C^[ ] N~ | C & S, N & A }

S 3 T = { C[D[ ]] | C & S, D & T }If

! is the set of exception names {!0, . . . , !n}, we use thenotation

try [ ] with ! %" N for

try . . . try [ ] with !0 %" N . . . with !n %" N.And in particular, we have that

try [ ] with * %" N = [ ].Remark that
! being a set of exception name, the construction
try [ ] with ! %" N does not represent only one context. But thecontexts of the model are considered up to the order of the

tryconstruction in the construction above.

We can now define the two following operators:1

! S = S 3 { try [ ] with ! %" ! }4
! S = { try [ ] with ! %" ! } 3 S

6.3 A model for FxWe call valuation function any function

' from type variables tothe powerset of C minus the empty set (

' : A " (P(C))+). Toeach type
A we associate two sets:A set of contexts |

A |$ ) CA set of terms !
A "$ ) TThe set !

A "$ is uniformly defined from | A |$ by!
A "$ = | A |$% = { M | #C & | A |$, C[M] '# ! }.The set |

A |$ is defined by induction on A with:|

# |$ = '(#)|
N |$ = { Rec ! ("y. "x. x) [ ] }

| A " B |$ = [

! & E

(| A! |$)% * | B! |$

| A !! ! |$ = 1! | A |$|

A! |$ = 4! | A |$| #

#. A |$ = [

S & C+ |

A |$; % ' S

Note that the interpretation in the model of the construction
A !! ! and A! follows, to some extends, the idea that terms oftype

A !! ! are terms that may raise an exception only at top level,where the terms of

A! are those that may raise an exception in anyevaluation context. This is emphasized by the "opposition" of the

operations 1! and 4! . The first one tries to catch the exceptionsbefore putting the term in an evaluation context, while the second
one puts the term in the evaluation context and then tries to catchthe exceptions. More formally, the only terms not in !

A "$ thatwill reduce to the daimon when put in any context of 1
! | A |$ arethe terms that reduce directly to the expression
raise ! (! & !),while the terms that will reduce to the daimon when put in any

context of 4! | A |$ are the terms that reduce to the daimon or tothe expression

raise ! (! & !) when put in a context of | A |$.The other interesting point of the model is our interpretation of

arrow types. In Fx, a fonction f who has type A " B has also allthe types

A! " B! where ! is any set of exception names. So,we do not use the realisability arrow to interpret the arrow of

Fx. Ifwe had done so, the term (who are not well-typed)

"x. try x with ! %" ("y. y)would be in the interpretation of

N " N but not in the one ofN
! " N!, which is not compatible with our subtyping. If wedenote by

R-" the realisability arrow, our interpretation of thearrow type is:!

A " B "$ = \!&E! A! "$ R-" ! B! "$
So, our arrow type is smaller than the usual realizability one and assuch, functions of

Fx are in particular realizability functions. Thisis formally stated by the following lemma:

Lemma 7. If A and B are two types and ' a valuation function,then !

A " B "$ ) { M | #N & ! A "$, M N & ! B "$ }.
The properties of this model are the following:Lemma 8. If a term is in the interpretation of a given type, it has

a weak head normal form: if M is a term, A is a type and ' avaluation function such that

M & ! A "$, then

M 1h .

Proof. By expanding definitions, if M & ! A "$, we have

M & { M | # C & | A |$, C[M] '# ! }.So, if we take a context

C & | A |$, using Lemma 6, we canconclude that, indeed,
M has a weak head normal form. So, weonly have to show that for every

A, | A |$ is not empty. This iseasily proven by induction on
A (we just need here the hypothesisthat the image of a type variable by a valuation function is never

empty).
The daimon inhabits all type interpretations:Lemma 9. If

A is a type and ' a valuation function, then

! & ! A "$.Our intuition that the meaning of

A !! ! is to be either a term oftype
A or an exception is validated in the model:Lemma 10. If

A is a type, ! a set of exceptions names and ' avaluation function, then!

A !! ! "$ = ! A "$ ! { M | M '# raise !, ! & ! }.Moreover, the natural numbers are what we expect:

8 2008/1/29

Lemma 11. If ' is any valuation function, then!

N "$ = { M | M '# Sn 0 } ! { M | M '# Sn ! }.We can also characterize the corrupted natural numbers:

Lemma 12. A corrupted natural number is either a natural num-ber or a sequence of successors applied to an exception. If

' is anyvaluation function, then!

N! "$ = ! N "$ ! { M | M '# Sn (raise !), ! & ! }.
To show the soundness of the subsumption rule in our model,we need to show the lemma 13.
Lemma 13. The subtyping rules are valid for the model: If A and
B are two types such that A $ B, then!

A "$ ) ! B "$.

Proof. The proof of this lemma consists in showing sets inclusionsand it uses most of the lemmas of this section. Since we have
already stressed that the most uncommon, and we believe mostimportant, rule of the system is the rule (eq-arrc), we will only
give the proof that!

(A " B)! "$ = ! A! " B! "$.The proof is quite simple thanks to our de

finition of the arrow type.We first start by unfolding definitions and, using some simply stated

equality like 4! (A * B) = A * 4! B or 4! (4!! A) =4(!$!!) A,we show that:

| (A " B)! |$ = [

!! & E

(4!! | A |$)% * 4!! $ ! | B |$

| A! " B! |$ = [

!! & E

(4!! $ ! | A |$)% * 4!! $ ! | B |$

It follows directly that

| A! " B! |$ ) | (A " B)! |$,but since we can show for all

! & E that
(4!! | A |$)% ) (4!! $ ! | A |$)%,we can also show that

| (A " B)! |$ ) | A! " B! |$.

An interesting note is that one could have wanted to show that if
A $ B, then | A |$ 5 | B |$ (property that, if it holds, implies thepreceding lemma). However this proposition is false. For example,

| A !! ! |$ /6 | A |$ (in particular, it does not hold when A = N).But we can still prove that !

A "$ ) ! A !! ! "$ by using reductionproperties of the calculus.

Before expressing the soundness of our model, we have to de-fine the interpretation of a typing context. But because we will need
to consider corrupted typing context due to our specific intepreta-tion of arrow types, we directly give the intepretation of such corrupted typing context, where ! is any set of exception names (pos-sibly the empty set):!

"! "$ = { ( | # (x : A) & ", ((x) & ! A! "$ }Moreover, if

( is a substitution of term variables and M is a term,we use the notation

M[(] for the parallel substitution of M by (.

This operation is inductively defined by:

x[(] = ((x)
("x. M)[(] = "x. M[(]

(M N)[(] = M[(] N[(]
(raise !)[(] = raise !
(try M with ! %" N)[(] = try M[(] with ! %" N[(]

0[(] = 0
S[(] = S
Rec[(] = RecTheorem 4 (Model soundness). Our model is sound in the sense

that if M is a term, A a type and " a typing context such that
" . M : A, then for all valuation function ', for all set of exceptionnames

! ) E and for all substitution ( & ! "! "$ we have

M[(] & ! A! "$.

Proof. We use a proof by induction on the derivation of the typingjudgement

" . M : A. We will only give here the proof for thetyping rules specific to

Fx as well as the typing rules relative to thearrow type since our interpretation of such type is non-standard:

* the (abs) rule: let C & | (A " B)! |$, we have to show that

C["x. M[(]] '# !. By definition of | (A " B)! |$, 2 !" ) Esuch that

C = D[[ ] N] with N & ! A!! "$, D & | B(!$!!) |$.Let
) = ( + {x " N}, we easily show that ) & ! "(!$!!) "$and so, by induction hypothesis,

M[)] & ! B(!$!!) "$. Butsince
("x. M[(]) N ' M[)] and we can show that ! B(!$!!) "$is closed by anti-reduction,

("x. M[(]) N & ! B(!$!!) "$.Consequently,
C["x. M[(]] '# !.* the (app) rule: application of the induction hypothesis gives

that M[(] & ! (A " B)! "$ and N[(] & ! A! "$. But, usingLemma 13 we have that !

(A " B)! "$ ) ! A! " B! "$ andby Lemma 7,!

A! " B! "$ ) { M | #N & ! A! "$, M N & ! B! "$ }.So,

M[(] N[(] & ! B! "$.* the (raise) rule: showing that

raise ! & ! (* !! {!})! "$ isquite straightforward using Lemma 10 and Lemma 13.

* the (try) rule: application of the induction hypothesis gives that

M[(] & ! (A !! {!}!) "$ and N[(] & ! A! "$. We start byusing Lemma 13 to show that

M[(] & ! A! !! ({!} - !) "$and then Lemma 10 to show that either

M[(] & ! A! "$or
M '# raise !. If we have M[(] '# raise !, then wecan conclude since

try M[(] with ! %" N[(] '# N[(]. If
M[(] & ! A! "$, we use the Lemma 8 to show that M[(] hasa weak head normal form, and then we use the Fact 1 to show

that the term try M[(] with ! %" N[(] will reduce to M[(] or
N[(], both of these terms being in ! A! "$.* the (subs) rule: the proof is a direct application of the induction

hypothesis along with the Lemma 13.

Note that the usual soundness theorem is simply recover bytaking

! = * in the theorem above. Also note that in this model,we only consider closed term by construction. For this reason, we

cannot etablish a strong normalization theorem using this model.But we have a weak head normalization theorem for closed terms:

Theorem 5 (Weak head normalization). Well-typed terms of Fxare weakly normalizing: if

M is a term, A a type and " a typingcontext such that
" . M : A, then

M 1h .

9 2008/1/29

Proof. The proof is a direct application of the model soundnessalong with Lemma 8.

Let us remark that using the model soundness and Lemma 11,we deduce that

if . M : N, then M '# Sn 0.It means in particular that a program of type

N will never raise anexception. This fact has been shown to be a consequence of the

subject-reduction theorem but however, it is interesting to note thatthe soundness of our realizability model does not use the subject
reduction property. Hence, while the subject-reduction is a syntaxicproof of the "safety" of our typing, the model is a more semantic
one.

7. EvaluationWhen programming in

Fx, corrupted terms arise rapidly. For ex-ample, reusing functions and notations defined in Section 5, we

have:

pred (raise !) : N{"}
map pred [2; raise !; 4] : list{"}When dealing with such values, we sometimes want to trigger

the exception, if there is one, for the term to raise it. In otherwords, what we want is a function of type #

#. (#! " # !! !).Such a function would take a term and would deconstruct it in

search of nested exceptions. But such a deconstruction has nosense for functional types. But if a term has a functional type,
corruption ensures that it can still be used as a function, postponingthe problem to the term result of the function. The only thing we
really need is an "evaluation" function for data types.If we have a term

M of type N!, we want a function evalwhich "scans"
M and returns M only if it is a well formed naturalnumber, raising the exception inside it otherwise. Operationally,

this function is defined by eval M = evalAcc 0 M where
evalAcc has the following reduction rules:

evalAcc acc (raise !) > raise !
evalAcc acc 0 > acc
evalAcc acc (S N) > evalAcc (S acc) NWe could easily check that any term of

Fx which has the same re-ductions than
eval is in the interpretation of the type N! " N !! !for our model (this result comes from Lemmas 10, 7, 11 and 12).

And a term of Fx which has the same reductions than eval is

"n. (Rec ("x. x) ("x. "f. "a. f (S a)) n) 0But in
Fx this term has type N " N (or N! " N!), but notN
! " N !! !. Hence, in a realistic version of Fx we should callthis term

eval and add to the type system the special rule:

" . eval : N! " N !! !And as we already mentioned, this typing rule is justi

fied by ourmodel.

Of course, to extend Fx to other inductive data types, one shouldconsider the addition of typing rules for evalution functions for
these data types.We should mention as a side note that we believe that evaluation

functions can also be defined with second-order encodings of datatypes, up to the same typing problem. Mainly, reusing the definitions of Section 5, eval can be defined as:

eval , "n. (n ("x. x) ("f. "a. f (succ a))) 0This term has the same reductions than

eval (up to the use ofsecond-order encoded numerals) and its type is

nat " nat. But to

ensure that giving it the type nat! " nat !! ! is safe, we shouldshow that

eval & ! nat! " nat !! ! "$, which requires to be ableto characterize terms of !

nat "$ and ! nat! "$.

8. Conclusion and future worksWe have presented the

Fx calculus which is a extension of Sys-tem F with a typed mechanism of exceptions. The

$ reduction andthe reductions of exceptions follow the call-by-name discipline. Its

type system uses two constructions for handling the exceptions, oneof which, the type corruption, is a new notion. We show that the
type system is modular and allows the raise construction to beused instead of any other term. We show that this calculus is confluent, satisfies the subject-reduction property and is safe in the sensethat a well-typed program whose type does not mention an exception cannot raise this exception (and this in any evaluation con-text). Finally, we have exhibited a realizability model from which
we have deduced that terms of Fx are weakly normalizing.We believe that the

Fx calculus can at least be extended in thefollowing ways:

* Our realizability model only handles closed terms. Conse-quently, our actual model only allows to state a weak head

normalization theorem. To turn this realizability model into astrong normalisation one, we need to find a suitable notion of
satured sets (that can handle open terms).* The exception system of

Fx could be extended to allow anexception to carry information. Let us remark that in Caml, for

example, it is known that exceptions carrying arguments can beused to encode a non-normalizing term. But we believe that we
will not encounter such a problem in Fx since this encodinguses a recursive positive type, that we do not want to add to our
calculus.* A natural extension would be to add dependent product to our

calculus. We have good hopes that such an extension can bedone for two reasons. Firstly, the confluence is a necessary
condition to have a conversion rule and Fx enjoys this property.Secondly, we already know how to extend our realizability
model to handle the dependent product: if T is a type and Ux atype family indexed by

x, we will take

| #x : T. U |$ = { M * C | M & ! T "$ 7 C & | UM |$ }

* Fx is an extension of System F, for which type inference andtype checking is known to be undecidable [18]. Consequently

we have no hope of finding an inference algorithm for the fullcalculus. However,

Fx could be easily restricted to first ordertypes (to do that we only have to add a specific empty type for

the typing of the raise construction). The type inference forthis restriction remains to be studied. In particular, we do not
know if it has a notion of principal type.

References[1] H.P. Barendregt. The lambda calculus. North-Holland, 1984.

[2] R. David and G. Mounier. An intuitionistic !-calculus withexceptions. Journal of Functional Programming, 15(01):33-52,

2004.[3] M. F"ahndrich and A. Aiken. Program analysis using mixed term and

set constraints. Proceedings of the 4th International Symposium onStatic Analysis, 1302:114-126, 1997.
[4] J.Y. Girard. Une extension de linterpretation de Godel alanalyse, etson application alelimination des coupures dans lanalyse et la theorie

des types. Proceedings of the Second Scandinavian Logic Symposium,63:63-92, 1971.

10 2008/1/29

[5] J.Y. Girard. Locus Solum: From the rules of logic to the logic ofrules. Mathematical Structures in Computer Science, 11(03):301-

506, 2001.[6] J.Y. Girard et al. Proofs and types. Cambridge University Press New

York, 1989.[7] J. Gosling, B. Joy, and G.L. Steele. The Java Language Specification.
Addison-Wesley Longman Publishing Co., Inc. Boston, MA, USA,1996.
[8] A. Hejlsberg, S. Wiltamuth, and P. Golde. C# Language Specification.Addison-Wesley Longman Publishing Co., Inc. Boston, MA, USA,

2003.[9] X. Leroy et al. The Objective Caml system release 3.10. Documentation and users manual. Projet Cristal, INRIA, 2007.[10] J. McKinna and R. Pollack. Some Lambda Calculus and Type Theory
Formalized. Journal of Automated Reasoning, 23(3):373-409, 1999.[11] J.C. Mitchell. Polymorphic type inference and containment.
Information and Computation, 76(2-3):211-249, 1988.[12] F. Pessaux and X. Leroy. Type-based analysis of uncaught exceptions.
Proceedings of the 26th ACM SIGPLAN-SIGACT symposium onPrinciples of programming languages, pages 276-290, 1999.
[13] S. Peyton Jones, A. Reid, F. Henderson, T. Hoare, and S. Marlow.A semantics for imprecise exceptions. ACM SIGPLAN Notices,

34(5):25-36, 1999.[14] J.C. Reynolds. Towards a theory of type structure. Lecture Notes In

Computer Science, pages 408-423, 1974.[15] B. Stroustrup et al. The C++ programming language. AddisonWesley Reading, MA, 1997.[16] J. Vouillon and P.A. Melli`es. Semantic types: a fresh look at the ideal
model for types. Proceedings of the 31st ACM SIGPLAN-SIGACTsymposium on Principles of programming languages, pages 52-63,
2004.[17] J.B. Wells. The undecidability of Mitchells subtyping relation.

Technical Report 95-019, Boston University, Boston, Massachusetts,1995.
[18] J.B. Wells. Typability and type checking in System F are equivalentand undecidable. Annals of Pure and Applied Logic, 98(1-3):111-

156, 1999.

A. Intuition of the proof of subject-reduction forthe

!-reduction case.We give the intuition, for the

$-reduction case, of the subject-reduction proof for
Fx. In the following, we will let some technicaldetails aside and focus on the problems specific to our calculus

(and, in particular, to our subtyping of exceptions).We want to show that if for some terms

M and M and sometype
A we have " . ("x. M) N : A then

" . M{x := N} : A.We
first show the following inversion properties:

* if " . M N : A, then there exists X such that " . M : X " Aand

" . N : X;* if

" . "x. M : A, then there exists X and Y such that
X " Y $ A and ", x : X . M : Y .We use these two properties with the judgment

" . ("x. M) N : Ato show that there exists some types
X, C and D such that

" . N : X ", x : C . M : D C " D $ X " AUsually, at this point, we would like to prove that the subtyping

C " D $ X " A implies that

X $ C and D $ A,

allowing for conclusion. Unfortunately, in the Fx calculus, thisproperty is false (consider the subtyping N " N $ N

! " N!).However, we can show the property expressed by Lemma 14:

Lemma 14. Let A, B, A" and B" be some types. If we can de-rive the subtyping

A " B $ A" " B", then there exists a set ofexception names
! such that

A" $ A! and B! $ B".The dif
ficulty of the proof of this lemma comes from thefact that, because of the (eq-arrc) subtyping rule, a derivation of

A " B $ A" " B" can be quite complicated. The idea is to de-fine a traduction of types that pushes the corruption to the leaf of
types. For example, if we note A the traduction for the type A, then
((N " N){"} " (N " N)){"!} is

(N{","!} " N{","!}) " (N{"!} " N{"!}).This traduction is inductively de

fined by:
N = N N! = N!
# = # #! = #!
A " B = A " B (A " B)! = A! " B!
A !! ! = A !! ! (A !! !")! = A! !! (!" - !)#

#. A = ##. A (##. A)! = ##. A!

(A!!)! = A(!$!!)This traduction sends types of

Fx to the types defined by thefollowing grammar:

A, B ::= # | N | #! | N! | A " B | ##. A | A !! !Then, we de

fine a new relation " on these types, which is similarto the subtyping relation but adapted to these new types (we do not

have counterparts in this relation of the rules (eq-cc), (eq-uc), (eq-arrc) and (ex-corrupt)), with however two noticeable difference in
the counterparts of the rules (f-inst) and (st-arrow). This relation isinductively defined by:

A " A

A " B B " C

A " C

A" " A! B! " B"

A " B " A" " B"

A " B # /& F V (A)

A " ##. B

##. A " A{# := B} ##. #! " (##. #) !! !

# /& F V (A)
##. (A " B) " A " ##. B A !! {} " A

A " B
A !! ! " B !! ! A " A !! !

(A !! !) !! !" " A !! (!!!") A !! (!!!") " (A !! !) !! !"We show the following lemmas on this reduction:

Lemma 15. Let A and B be two types of Fx, if A $ B, then thereexists a set of exceptions

! such that

A! " B.Lemma 16. Let
A and B be two types of Fx, if A " B, then

A $ B.Lemma 17. Let
A, B, A" and B" be some types of Fx, if we have
A " B " A" " B", then there exists a set of exceptions ! suchthat

A" " A! and B! " B".

11 2008/1/29

Proofs of Lemmas 15 and 16 is done by induction on the types
A and B. The proof of the lemma 17 is easy in the new relation "since only one rule (up to transitivity) can have been applied to

show that

A " B " A" " B".We can now prove the Lemma 14 since, if

A " B $ A" " B",then Lemma 15 says that for some
!,

(A " B)! , A! " B! " A" " B" , A" " B".Thus,

A" " A!! and B!! " B"by Lemma 17 and

finally, by Lemma 16,

A" $ A!! and B!! $ B".

We can then show that with Lemma 14, we can conclude the
$-reduction case of the subject-reduction proof.

12 2008/1/29