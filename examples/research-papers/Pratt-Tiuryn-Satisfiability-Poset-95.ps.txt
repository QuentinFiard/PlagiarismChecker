

Satisfiability of Inequalities in a Poset

Vaughan Pratt\Lambda 
Computer Science Department

Stanford University
Stanford, CA 94305
(pratt@cs.stanford.edu)

Jerzy Tiuryny
Institute of Informatics

Warsaw University

Banacha 2
02-097 Warsaw, POLAND

(tiuryn@mimuw.edu.pl)

September 29, 1995

Abstract
We consider tractable and intractable cases of the satisfiability
problem for conjunctions of inequalities between variables and constants in a fixed finite poset. We show that crowns are intractable.
We study members and closure properties of the class of tractable
posets. We define a feasible poset to be one whose potential obstacles
to satisfiability are representable by a certain formula of the first-order
extended by the least fixed operator. For bipartite posets we give a
complete classification of hard posets and feasible ones.

1 Introduction
We investigate the computational complexity of the P -satisfiability problem.
This is the problem of deciding whether a given finite set of inequalities is
simultaneously satisfiable in a given poset P , which we assume throughout
to be finite. The permitted operands of the inequalities are constants and

\Lambda The first author is supported by ONR under grant number N00014-92-J-1974.

yThe second author is partly supported by NSF Grants CCR-9417382, CCR-9304144,

and by Polish KBN Grant 2 P301 031 06.

1

variables. The permitted constants are the elements of P . An assignment
of elements of P to variables satisfies the set of inequalities when it makes
all of them true. The set of inequalities is called P -satisfiable when there
exists such a satisfying assignment.

0\Omega 

\Omega \Omega 

1

JJ

J2

Figure 1.1. Poset P1.
For example take P = P1 as per Figure 1.1, and consider the inequalities
x ^ 0, x ^ y, y ^ z. Assigning either 1 or 2 to x would falsify x ^ 0,
whence x = 0 in any satisfying assignment. Since 0 ^ 2 does not hold in P ,
y and z must each be either 0 or 1. Of these four possibilities, y ^ z rules
out y = 1; z = 0, and the remaining three assignments are all satisfying
assignments. Hence this set of inequalities is P -satisfiable, in three ways.

We write P -SAT for the set of those P -satisfiable sets of inequalities that
have a "succinct certificate," namely a satisfying assignment. Such an assignment when straightforwardly presented can be checked in time linear in
the size of the presentation in symbols, simply by evaluating each inequality to verify its truth for that assignment. It follows that for all posets P ,
P -SAT is in the class NP of problems solvable on a Turing machine in time
nondeterministic in the size of the set of inequalities. When P -SAT is in the
class PTIME of problems solvable in deterministic polynomial time, we say
that P is tractable. We introduce a notion of feasible poset: P is feasible
when there exists a predicate on sets of inequalities asserting in a certain
language that the given set is P -satisfiable; this predicate can be evaluated
for each given set in time polynomial in the length of presentation of the
set.

In section 2 we shall show that there exist posets P for which P -SAT is
an NP-complete problem, namely crowns. Section 3 introduces and treats
aspects of tractable and feasible posets. Section 4 gives several transformations of posets and shows constructively that they preserve feasibility, by
showing how to transform the predicate associated to that poset. In section 5 we give a complete classification of bipartite posets with respect to
tractability of the satisfiability problem.

2

1.1 Background
Our interest in the poset satisfiability problem is motivated by the area of
type reconstruction problems1 for the case of simply typed lambda calculus
with subtyping. The reader is referred to J. Mitchell's paper [Mitchell84]
for introduction to that area as well as the basic reduction of the original
problem of type reconstruction to the problem of poset satisfiability. O'Keefe
and Wand [OKeefeWand89] treat a similar reduction.

The NP-hardness result of section 2 of this paper has been used by Mitchell
and Lincoln [MitchellLincoln92] to show that the type reconstruction problem for simply typed *-calculus with subtyping is NP-hard for certain posets
of atomic subtypes.

The second author has shown [Tiuryn92] that solving inequalities in simple
types (more general than the atomic types treatable with the results of the
present paper) is PSPACE-hard, and that when the poset of atomic subtypings is a disjoint union of lattices then the type reconstruction problem is in
PTIME.

With M. Wand [TiurynWand93], the second author has investigated the
problem of type reconstruction for simple types with subtyping and recursive
types. This naturally leads to a generalization of the problem of solving
inequalities: instead of solving finite systems of inequalities in a finite poset
one can consider solving an infinite system presented as a regular expression
(or finite-state automaton). This problem is PSPACE hard for nontrivial
posets and in PTIME otherwise.

M. Benke generalizes [Tiuryn92] in two ways. He shows [Benke93] that the
PTIME property holds for a larger class of posets, namely those satisfying
the Helly property, which include trees.2 And in [Benke95] he generalizes the
PSPACE-hardness construction of [Tiuryn92] via a suitable generalization
of the conditions under which the NP-hardness result for the "flat" system
treated in this paper can be transferred to the general subtype inequality
system (over the same poset) yielding a PSPACE lower bound on complexity.

1The problem of type reconstruction for a type system T is: given a term M of pure
(untyped) lambda calculus, decide whether M can be decorated with types so that is
becomes correctly typable in T . This problem has practical motivations coming from
typed functional programming languages, such as ML.

2These posets naturally arise in connection with class inheritance.

3

More recently, Hoang and Mitchell have shown [HoangMitchell95] that the
general algebraic problem of solving subtype inequalities (see [Tiuryn92]) is
PTIME equivalent to the type reconstruction problem for simple types with
subtyping.

A natural generalization of the satisfiability problem for posets is satisfiability in an arbitrary relational structure, which has been studied by Feder
and Vardi [FederVardi93].

1.2 Satisfiability and Retractibility
The P -satisfiability problem is of a logical nature. However it has a straightforward translation into an equivalent algebraic problem, that of P -retractability.

A function f is idempotent when f ffi f = f , equivalently when its image
or range coincides with the set of its fixpoints. A retraction of a poset Q
is an idempotent monotone function f : Q ! Q; we say that f retracts Q
onto its image f (Q), and call f (Q) a retract of Q. For a given poset P , the
P -retractability problem is that of deciding whether P is a retract of a given
extension Q of P .

The example above of P -satisfiability has an evident reformulation as a P retractability problem. We extend P1 to Q by adjoining to P the variables
x; y; z treated as new points, ordered as in the inequalities, as shown in
Figure 1.2.

0\Omega 

\Omega \Omega 

1

JJ

J2

\Omega \Omega 
\Omega x
JJ

J

y

z

Figure 1.2. Poset Q.
Theorem 1 P -SAT is polynomial-time equivalent to the P -retractibility
problem.

4

Proof: To reduce the P -retractibility problem to P -SAT, translate the
given extension Q of P to a set of inequalities by taking the set of variables
to be Q \Gamma  P and taking the set of inequalities to be the graph of Q, i.e.
all q ^ q0 holding in Q. Then Q retracts to P if and only if the set of
inequalities is simultaneously satisfiable in P .

To reduce P -SAT to P -retractibility, translate the given set of inequalities
to an extension Q of P whose non-P elements are the variables appearing
in the inequalities, ordered according to the reflexive transitive closure of
the given inequalities. Q is a preordered set: reflexive and transitive but
not necessarily antisymmetric. Identify all equivalent elements, those pairs
x; y such that x ^ y ^ x. (This extension might not be conservative, in the
sense that for some p 6= q 2 P , p ^ q might hold in Q but not in P , in which
case Q cannot retract to P .) The given inequalities are then satisfiable in
P if and only if Q retracts to P .

Viewing a poset P , defined as an irreflexive transitive relation, as an acyclic
directed graph, we associate to P the undirected graph formed by "erasing
arrowheads." (A common source of confusion here is that the Hasse diagram
for x ^ y ^ z conventionally omits the third edge x ^ z, obscuring the fact
that the associated undirected graph forms a triangle.) More formally, we
define the graph of P (understood henceforth to be undirected) to be the
symmetric closure of P , whose cycles of length two constitute the undirected
edges.

We define the distance between two points in a poset as that in its graph,
namely the length in edges of the shortest path, or infinity if the points are
not in the same connected component. This notion of distance can be seen
to make a connected poset a metric space. A monotone function (including
retractions) between connected posets is therefore a contraction or lengthnonincreasing function (but not conversely since the contractions of a poset
include the antimonotone functions x ^ y oe f (x) * f (y)). The diameter
of a poset is the greatest distance between any two of its points, whence a
chain of n * 2 elements has unit diameter.

A zigzag of length n is a poset whose graph is a simple path of length n,
equivalently n + 1 elements in alternating order, either as x0 ^ x1 * x2 ^
: : : xn or x0 * x1 ^ x2 * : : : xn, these being the two minimal posets of
diameter n connecting x0 to xn. We refer to the former zigzag as an upper

5

zigzag from x0 to xn and to the latter zigzag as a lower zigzag from x0 to xn.
Call a zigzag proper if all its elements are pairwise different. We shall make
frequent use of zigzags as bits of string tying elements together; these create
nonlinear constraints on retractions when the strings go taut, the basis for
our NP-complete problems.

2 Intractable Cases
An n-crown Cn is a poset with 2n elements 0; 1; 2; : : : ; 2n\Gamma 1 partially ordered
such that the only comparisons are 2i ^ 2i \Sigma  1 (using addition modulo 2n
so that 2n \Gamma  1 ^ 0 is in the order). The 4-crown C4 can be depicted as in
Figure 2.1(a), but is less cluttered if we permit duplication of elements as
in Figure 2.1(b).

0\Omega 

\Omega \Omega 

6\Omega 

\Omega \Omega 

2\Omega 

\Omega \Omega 

4

7

JJ

J

1

JJ

J

5

JJ

J

3

0\Omega 

\Omega \Omega 

1

JJ

J2\Omega \Omega 

\Omega 

3

JJ

J4\Omega \Omega 

\Omega 

5

JJ

J6\Omega \Omega 

\Omega 

7

JJ

J0

Figure 2.1. The 4-crown C4 (a) usual view (b) unrolled.

Theorem 2 Cn-SAT is NP-complete for n * 2.

Proof: We reduce 3SAT3 to Cn-SAT. We give separate though similar
proofs for n = 2 and n * 3. The common geometric intuition underlying
the respective constructions is clearer for the latter and so we give it first.

Assume n * 3. For each CNF formula ' with v variables (hence at most 2v
literals) and k clauses we construct a formula  with (9n\Gamma 3)v +nk variables
and (17n \Gamma  2)v + (n + 2)k inequalities which is satisfiable in Cn if and only
if ' is satisfiable in f0; 1g.

The basic idea will be to simulate each literal of ' with a copy of Cn intended
to retract bijectively to Cn itself. We then give constructions that (i) permit

33SAT is the set of satisfiable conjunctive normal form formulas having 3 literals per
clause.

6

only two such retractions of each copy, which we associate with the two
possible truth values of the corresponding literal; (ii) interpret : standardly
by forcing each literal x to retract oppositely to its negation :x; and (iii)
enforce the constraints implied by the k clauses of '.

Associate to each of the 2v literals x (which if negative will be of the form

_y) a copy of Cn. Thinking of Cn as a circular crown, rotate the copy 1=2n
of a full circle; Figure 2.2 illustrates the case n = 3. Each element of the
copy that is midway between p and p + 2 (mod 2n) of the original Cn is
named xp;p+2. At this stage we have 2n variables per literal so 4v variables
altogether.

0\Omega 

\Omega \Omega 

\Omega \Omega 

\Omega 

x02\Omega 

\Omega \Omega 

\Omega \Omega 

\Omega 

2\Omega 

\Omega \Omega 

\Omega \Omega 

\Omega 

x24\Omega 

\Omega \Omega 

\Omega \Omega 

\Omega 

4\Omega 

\Omega \Omega 

\Omega \Omega 

\Omega 

x40\Omega 

\Omega \Omega 

\Omega \Omega 

\Omega 

0

x51

JJ

JJ

JJ

1

JJ

JJ

JJ

x13

JJ

JJ

JJ

3

JJ

JJ

JJ

x34

JJ

JJ

JJ

5

JJ

JJ

JJ

x51

Figure 2.2. Cn and one copy of Cn.
We now impose constraints (i)-(iii).
(i) At the 2n places where the edges of Cn intersect the edges of the copy,
place 2n additional elements, as shown in Figure 2.3. The element on the
edge connecting p to p + 1 (mod 2n) is named xp;p+1. This doubles the
number of variables, to 8nv. We can now count the inequalities; thus far we
have 16nv.

0\Omega 

\Omega \Omega 

x01

JJ

Jx

02\Omega 

\Omega \Omega 

x12

JJ

J 2\Omega \Omega 

\Omega 

x23

JJ

Jx

24\Omega 

\Omega \Omega 

x34

JJ

J 4\Omega \Omega 

\Omega 

x45

JJ

Jx

40\Omega 

\Omega \Omega 

x50

JJ

J 0

x51

JJ

J \Omega \Omega 

\Omega 1JJ

J \Omega \Omega 

\Omega x

13J

JJ \Omega \Omega \Omega 

3

JJ

J \Omega \Omega 

\Omega x

35J

JJ \Omega \Omega \Omega 

5

JJ

J \Omega \Omega 

\Omega x

51

Figure 2.3. Connecting Cn to its copy.
Now consider the possible retracts of the poset of Figure 2.3 to Cn. If 50
is sent to 0 then so is 40, whence 45 is sent to 5, whence so is 35, and

7

so on. Conversely if 50 is sent to 5 then so is 51, whence 01 is sent to 0,
whence so is 02, and so on. It follows that this poset has just two retracts
to P , one sending every xpq to p, the other sending every xpq to q. These
will correspond, as poset valuations of xpq in P , to truth valuations of x in
f0; 1g.

(ii) For each of the v variables x of ', we tie the literal pair x and _x together
in such a way that when xpq retracts to p, _xpq can retract only to q. That is,
the x and _x crowns can only rotate in opposite directions when retracted,
corresponding to always having opposite truth values. This is accomplished
by a mechanism that can be visualized as a piece of string connecting a
point of the x crown to a diametrically opposite point of the _x crown (in the
unretracted position). We use the fact that if these two crowns retract in
the same direction (which we want to avoid), these diametrically opposite
points remain diametrically opposite. The trick is to prevent this possibility
by making the string one "notch" shorter than a half-perimeter of the crown.

The "string" is realized as a zigzag of length n \Gamma  2 from x2n\Gamma 1;1 to _xn\Gamma 1;n+1,
as shown in Figure 2.4, for n = 5 (where x2n\Gamma 1;1 = x91 and xn\Gamma 1;n+1 = x46)
and again for n = 6 (x2n\Gamma 1;1 = x11;1 and xn\Gamma 1;n+1 = x57) to illustrate the
treatment of odd and even n respectively. The n \Gamma  3 variables a; b; c; : : : per
variable of ' are new variables not used elsewhere, bringing the variable
count to (9n \Gamma  3)v. The n \Gamma  2 inequalities bring the inequality count to
(17n \Gamma  2)v.

x91

JJ

Ja\Omega \Omega 

\Omega 

b

JJ

J_x

46

x11;1

JJ

Ja\Omega \Omega 

\Omega 

b

JJ

Jc\Omega \Omega 

\Omega _

x57

Figure 2.4. Inequalities making :x the complement of x.
Any retraction to Cn must conform the string to one side or the other of Cn.
Now the distance around Cn from 2n \Gamma  1 to n \Gamma  1 is n (whichever way we
go around), while the distance from 2n \Gamma  1 to n + 1 is n \Gamma  2 when measured
around the n + 2; n + 3; : : : side (and n + 2 around the other side). Hence if
a retract sends x2n\Gamma 1;1 to 2n \Gamma  1 it must send _xn\Gamma 1;n+1 to n + 1 in order that
the "string" be able to retract to Cn. Likewise if x2n\Gamma 1;1 retracts to 1 then

_xn\Gamma 1;n+1 must retract to n \Gamma  1. This achieves this desired contrary motion
of x and _x.

8

(iii) We implement each clause x . y . z of ' by a more elaborate version of
the above diameter trick. We first run a string of length 4 from an arbitrary
point on x to a suitable point on _y in such a way that the string becomes
taut (in the sense of having a unique retraction) just when both x and y are
false. We then run a second string, of length n \Gamma  2, from the midpoint of the
first string to a point on z, such that when the first (short) string becomes
taut the second (long) string forces z to the true position. When there is
slack in the first string, this gives the second string just enough extra slack
that it does not constrain z.

The length 4 string runs from x2n\Gamma 1;0 to _y01, while the length n \Gamma  2 string
runs from the midpoint w of the first string to zn\Gamma 2;n. This is illustrated for
n = 5 in Figure 2.5.

x90\Omega 

\Omega \Omega 

u

JJ

Jw\Omega \Omega 

\Omega vJJ

J_y

01\Phi 

\Phi \Phi \Phi 

\Phi \Phi  aJ

JJ

b\Omega 

\Omega \Omega 

z35

Figure 2.5. Poset for clause x . y . z, case n = 5.
Now x false forces u = n \Gamma  1, while y false forces v = 1. Hence both false
forces w = 0, which in turn forces zn\Gamma 2;n = n \Gamma  2, i.e. z true. If however x
is true, i.e. x2n\Gamma 1;0 = 0, then u = 1, w = 2 becomes possible regardless of
the truth of y. Then zn;n\Gamma 2 can be either n (z false, making the long string
taut) or n \Gamma  2 (z true, and the first zigzag of the long string can "idle" by
setting b = w). When x is false but y is true, i.e. _y01 = 0, then v = n \Gamma  1,
w = n \Gamma  2, u = n \Gamma  1 becomes possible. In this case the long string can
be run around the n \Gamma  2; n \Gamma  3; : : : side, allowing zn\Gamma 2;n to be either n \Gamma  2
(making the long string taut) or n (slack).

Hence no retract makes all of x; y; z false, and this is the only constraint
on the truth values of variables imposed by this construct. The construct
adds n variables and n + 2 inequalities per clause, making the final totals
(9n \Gamma  3)v + nk variables and (17n \Gamma  2)v + (n + 2)k inequalities.

(Side remark: For n * 5 the length 4 string could have been attached to
crown tips; attaching it to crown intersections in effect further shortens the
string to length 2 when x and y are both false, preventing it from going

9

around the other side of the crown when n is 3 or 4. This yields a uniform
construction for all n * 3.)

This completes the proof for the case n * 3. We now treat the case n = 2.
We proceed as for n * 3, but omit the explicit representation of _x.

The formula ' having v variables and k clauses translates to a formula 
having 8v+3k variables and 16v+6k inequalities. We retain construction (i),
which gives 8v variables and 16v inequalities. Without _x construction (ii)
is no longer relevant. In place of construction (iii) we use the construction
of Figure 2.6 for each of the k clauses, giving the remaining 3k variables (3
new variables per clause) and 6k inequalities (6 edges per clause).

x10\Omega 

\Omega \Omega 

u

JJ

J

0\Omega 

\Omega \Omega 

w

JJ

Jz20

\Omega \Omega 

\Omega vJJ

Jy30

Figure 2.6. Poset for clause x . y . z when n = 2.
This works as follows. When x and y are both false, u = 1 and v = 3,
forcing w = 0 (since 0 ^ w) and hence z20 = 0, i.e. z is forced to true.
But if x is true, then u = v = w = 3 becomes possible, which removes all
constraints on y and z. Similarly y true permits u = v = w = 1, removing
all constraints on x and z.

This completes the proof.

3 Tractable Cases
This section introduces the notion of obstacle for a poset as a formula characterizing its non-retractible extensions. Subsection 3.1 motivates the notion
of obstacle, 3.2 defines it and establishes its reliability as an indicator of
non-retractibility.

10

3.1 Some Motivating Examples
By way of motivation, we start with the simplest case, that of a lattice. Let
us first notice the following easy observation which implies that every lattice
is a tractable poset.

Proposition 3 If Q extends a lattice P , then Q retracts to P .

Proof: Retract every point q 2 Q to meet of all points in P which are
above q.

Next, consider the poset P1 of Figure 1.1. Again it is easy to check for
P -retractability.

Proposition 4 Let Q extend P1. Q retracts to P1 iff f0; 2g has no lower
bound in Q.

Proof: The necessity is obvious. For sufficiency, retract every point q 2 Q
to meet of all points in P1 which are above q. This leaves unretracted points
whose set of upper bounds in P1 is P1. By the assumption there are no such
points in Q.

For the next example take the following four element zigzag P2 presented in
Fig.3.2.

0\Omega 

\Omega \Omega 

1

JJ

J2\Omega \Omega 

\Omega 3

Figure 3.2. Poset P2.
Again it follows from the next result that P2 is tractable.

11

Proposition 5 Let Q extend P2. Q retracts on P2 iff there are no elements
x; y 2 Q which satisfy the following constraints 0 * x ^ y * 3.

Proof: Such x and y clearly prevent any retraction, so it suffices to show
that their absence permits a retraction. Their absence immediately implies
the retractibility to 3 of the elements above 3, and to 0 of those below 0,
which we therefore perform. No element strictly below 3 can be above either
0 or 1, and therefore all such may retract to 2. No element not yet retracted
to P2 can be below either 0 or 2, or above 3, whence all such may retract to
1, yielding the desired retraction to P2.

The following example illustrates a different form of condition. Let P3 =
f0; 1g be the discrete two-element poset, for which the distance from 0 to 1
is infinite.

Proposition 6 Let Q extend P3. Q retracts to P3 iff there is no path in Q
which connects 0 and 1.

Proof: If 0 is not connected to 1 then it is possible to retract to 0 the
elements connected to 0, and everything else to 1, Conversely, when 0 is
connected to 1 in Q their distance is finite, which retraction cannot increase,
but this contradicts the infinite distance from 0 to 1 in P3.

In section 4 we will present machinery for producing some tractable posets,
P1 through P3 being special cases.

As the last example, take the poset P4 of Fig.3.3

4
\Gamma \Gamma  @@3

\Gamma \Gamma 

\Gamma 
@@
@

1

0 2
Figure 3.3. Poset P4.

12

Proposition 7 Let Q extend P4. Q retracts to P4 iff there is no path in Q
which connects 0 and 2 and whose all points are bounded above by 1 and 3.

Proof: Necessity is easily shown by induction on the length of such a
path. For sufficiency, retract each point q 2 Q to the meet in P4 of the
set of elements of P4 above q in Q, when that meet exists. This leaves
unretracted only those points whose set of upper bounds is either P or
f1; 3; 4g. The path condition rules out existence of a point of the former
kind. Any point q of the latter kind can lie only on a path of points of the
latter kind reaching at most one of 0 or 2: retract q to that one, or to 0 by
default if q is connected to neither 0 or 2.

The common feature of the above examples was that we were able to single
out some finite set of obstacles which prevented Q from being retracted onto
P and proved that these were the only possible obstacles for the existence of
a retraction on P . Each such obstacle was decidable in time polynomial in
the size of the given extension Q, giving a polynomial-time algorithm for P retractability. In this section we will generalize this method by introducing
a language for expressing obstacles. This will be a fragment of the first-order
language with the least fixed-point operator. We prove that the obstacles
expressible in this fragment are always guaranteed to be sound (i.e. closed
under retractions) and that they are decidable in polynomial time for any
poset. We call a poset P feasible if there is a finite set of obstacles expressible
in the above-mentioned language such that any extension Q of P retracts
to P iff none of the obstacles holds in Q. In section 4 we study some ordertheoretic constructions under which feasible posets are closed.

3.2 Feasible Posets
We assume that we have a countable set of individual variables x; y; z; : : :
and a countable set of predicate variables X; Y; Z; : : : for each arity n ? 0.

Let P be a fixed poset. Our language has one constant symbol cp for each
element p 2 P . A P -term is either an individual variable or a constant
symbol cp.

The set of P -formulas is the least set of formulas which satisfies the following
conditions.

13

ffl Every atomic formula, t1 ^ t2, t1 = t2, or X(t1; : : : ; tn) is a P -formula,

where t1; : : : ; tn are P -terms, and X is n-ary predicate variable.

ffl If ' and  are P -formulas, then so are (' . ); (' ^ ), and (9x:').
ffl If ' is a P -formula, X is n-ary predicate variable, ~x = x1; : : : ; xn is

a vector of n individual variables, and ~t = t1; : : : ; tn is a vector of n
P -terms, then (_X; ~x: ')(~t) is also a P -formula.

We interpret P -formulas as follows. A P -model Q is any poset which contains
P as a subposet. A valuation v in Q assigns to each individual variable x an
element v(x) 2 Q, and to each n-ary predicate variable X an n-ary predicate
v(X) ` Qn. All valuations assign to the constant cp the element p. We write
vdx for the valuation differing from v only at the individual variable x, where
it satisfies vdx(x) = d and otherwise satisfies vdx(y) = v(y) and vdx(X) = v(X).

A similar notation applies to predicate variables X and predicates S in Q as
well, namely vSX . This notation is naturally extended to vectors of elements

and individual variables, namely v ~d~x.

The semantics of P -formulas is defined recursively with the help of the
predicate Q j= '[v], where Q is a P -model, ' is a P -formula and v is a
valuation in Q. These data suffice to determine a truth value for Q j= '[v],
defined by induction on the height of '. Q and v determine in the evident
way the truth value of atomic P -formulas as well as that of P -formulas of the
form (' . ); (' ^ ), and (9x:'), leaving only one more form of P -formula
to be explained.

The P -formula (_X; ~x: ')(~t) asserts X(~t) where the n-ary relation X is
defined recursively by X(~x) j ' where ' may refer recursively to X and
any or all of the variables in ~x. As an example of its use consider the paths
described in Proposition 7. We state formally that such a path exists by
asserting X(0; 2) where the binary relation X is defined recursively by

x ^ y . y ^ x ! X(x; y)
9z[X(x; z) ^ X(z; y) ^ z ^ 1 ^ z ^ 3] ! X(x; y)

By taking the recursive definition for ' we may combine it and the assertion
in the one P -formula (_X; x; y:(x ^ y . y ^ x ! X(x; y)) ^ (9z[X(x; z) ^
X(z; y) ^ z ^ 1 ^ z ^ 3] ! X(x; y)))(0; 2). The latter form is less convenient
for application, but more convenient for metatheory.

14

If m distinct variables other than those in ~x occur free in ', and if the sum
of the arities of the free predicate symbols other than X occurring free in
' is w, then Q j= ' is a predicate on Qm+n \Theta  2Q

w+n, that is, a function

F' : Qm \Theta  2Q

w . We reorganize this by moving the portion associated with

X and ~x inwards to make it F' : Qm \Theta  2Q

w \Theta  2Qn \Theta  Qn ! 2 and then

further "curry" it to yield F 0' : Qm \Theta  2Q

w ! (2Qn ! 2Qn). Hence each

possible valuation v of all variables and predicate symbols determines an
element q 2 Qm \Theta  2Q

w and hence a function F

';v : 2Q

n ! 2Qn, namely

F 0'(q). We then define the n-ary relation _X; ~x: ' to be the least fixpoint
of F';v. The logical connectives of our language all being monotone, F';v
must be monotone on the complete lattice 2Q

n, whence by Tarski-Knaster

this fixpoint exists. When q = jQj as in our application, the fixpoint is given
explicitly by F (q

n)

';v (;) where F (k) denotes the k-fold composition of F with

itself. This yields a simple algorithm for computing the fixpoint which can
then be tuned for greater efficiency.

Now _X; ~x: ' takes two arguments, namely the valuation v and the n-tuple
over Q at which the fixpoint is to be evaluated. Alternatively we may assume
that the n-tuple consists of P -terms, since we may then apply v to map
them to elements of Q. The latter convention leads naturally to the order
of application (_X; ~x: ')(~t)[v]. Omitting the valuation then leaves us with
a P -formula (_X; ~x: ')(~t)[v] whose interpretation for any given valuation v
is (_X; ~x: ')(~t)[v] as just defined.

A special situation of using the least fixed point operator is that of a transitive closure operator of a 2n-ary relation. Let n * 1 and let ' be a
P -formula, let ~x; ~y be n-vectors of individual variables and let ~t1; ~t2 be nvectors of P -terms. By T C(* ~x; ~y: ')(~t1; ~t2) we will denote the P -formula4

(_X; ~x; ~y: ' . 9~z: (X(~x; ~z) ^ X(~z; ~y)))(~t1; ~t2)

We introduce a subset of the set of all P -formulas. Transitive closure P formulas form the least set of P -formulas which satisfies the following conditions.

ffl Every atomic formula t1 ^ t2, or t1 = t2 is a transitive closure P formula.
4We assume that X does not occur free in '.

15

ffl If ' and  are transitive closure P -formulas, then so are

(' . ); (' ^ ); (9x:'); and T C(* ~x; ~y: ')(~t1; ~t2)
where ~x; ~y are n-vectors of individual variables and ~t1; ~t2 are n-vectors
of P -terms.

A P -retraction consists of a pair of P -models Q1; Q2 forming a chain of
P ` Q2 ` Q1 of poset embeddings, together with a retraction of Q1 onto
Q2.

Let f : Q1 ! Q2 be a function and let v be a valuation in Q1. Define a
valuation f v in Q2, as follows.

f v(x) = f (v(x))
and

f v(X) = f(f (d1); : : : ; f (dn)) j (d1; : : : ; dn) 2 v(X)g

Theorem 8 Let f : Q1 ! Q2 be a P -retraction. For every P -sentence ',
we have the following equivalence: Q1 j= ' iff Q2 j= '.

Proof: Let f : Q1 ! Q2 be a P -retraction.
Let ' be a P -formula, v a valuation in Q1, and u a valuation in Q2. We
prove by induction on ' the following two statements.

if Q1 j= '[v], then Q2 j= '[f v] (1)

if Q2 j= '[u], then Q1 j= '[u] (2)
The case of ' being an atomic formula, a disjunction, conjunction, or existential quantification is obvious and we omit the details.

Let us consider ' being of the form (_X; ~x: )(~t), and let

Q1 j= (_X; ~x: )(~t)[v] (3)

16

Let F;v be the functional in Q1, associated with  and v (with respect to
the choice of X and ~x). And similarly, let F;fv be the functional in Q2,
associated with  and f v. We prove by induction on k * 0 that for all~
d 2 Qn1 ,

if ~d 2 F k;v(;), then f ( ~d) 2 F k;fv(;) (4)

For k = 0 (4) is obvious. Assume that (4) holds for k and let

~d 2 F k+1;v (;) = F;v(F k;v(;))

Hence,

Q1 j= [v

F k;v(;);~d

X;~x ]

By induction assumption (1) for  we get

Q2 j= [f (v

F k;v(;);~d

X;~x )] (5)

It follows that

f (v

F k;v(;);~d

X;~x ) = (f v)

S;f(~d)
X;~x (6)

where

S = ff (~e) j ~e 2 F k;v(;)g

hence by induction assumption (4),

S ` F k;fv(;)
Since X occurs only positively in , it follows from the above inclusion, (5)
and (6) that

Q2 j= [(f v)

F k;fv(;);f(~d)

X;~x )]

Hence, by the definition of F;fv, we conclude that

f ( ~d) 2 F;fv(F k;fv(;)) = F k+1;fv(;)
This proves (4). From (4) and (3) we immediately get

Q2 j= (_X; ~x: )(~t)[f v]
This completes proof (1). Proof of (2) is just the same.

Call a poset P feasible if there is a P -sentence ' such that for every P -model
Q, Q retracts to P iff Q 6j= '. We call such a ' a complete obstacle for P . A

17

P -obstacle is any P -sentence ' such that P 6j= '. It follows from Theorem 8,
that if ' is a P -obstacle and Q j= ', then Q does not retract to P . Call a
poset P TC-feasible if it has a complete obstacle which is a transitive closure
P -formula.

It follows from Proposition 3 that every lattice is TC-feasible. By Propositions 4, 5, 6, and 7 we conclude that posets P1, P2, P3, and P4 are TCfeasible. For example, a complete obstacle for P4 is

T C(*x; y: (x ^ y . y ^ x) ^ x ^ 1 ^ x ^ 3 ^ y ^ 1 ^ y ^ 3)(0; 2)

Proposition 9 Every feasible poset is tractable. Moreover the retraction
problem for every TC-feasible poset is in NLOGSPACE.

Proof: It is well known that validity of a sentence of the first-order language with least fixed-point operator in a finite model can be checked in
time polynomial in the size of the model. If the sentence is a transitive
closure P -formula then validity can be checked in NLOGSPACE.

For any P -model Q, let oeQ be 9x1 : : : xn: oe0Q, where fx1; : : : ; xng = Q \Gamma  P
and oe0Q is the conjunction of all formulas of the form t ^ t0, where t; t0 2 Q
and t ^ t0 holds in Q. The next result is a corollary of Theorem 8.

Proposition 10 For every P -model Q, Q retracts to P iff Q j= oeQ, i.e. iff
oeQ is not a P -obstacle.

Proof: If Q retracts to P , then since oeQ is a P -sentence which holds in Q,
by Theorem 8 it must hold in P . Conversely, if P j= oeQ, then the solution
to oe0Q defines a retraction of Q to P .

It follows that if we were allowed to write in our language infinite disjunctions (which make sense and yield formulas which still are preserved under
retractions, but are hardly polynomial-time computable), then the infinite
disjunction .

Q does not retract to P

oeQ

would always be a complete obstacle for P . Feasible posets are those where
this disjunction can be replaced by one P -sentence.

18

4 Constructions Preserving Feasibility
In this section we will study several constructs on posets which preserve feasibility: finite products, disjoint union, and retractions. We also show that
feasible posets are closed under taking dual posets and under isomorphism,
and that they properly contain posets satisfying Helly property.

4.1 Duality and Isomorphism
Proposition 11 The class of feasible posets is closed under isomorphisms.
Also the class of TC-feasible posets is closed under isomorphisms.

Proof: Let f : P1 ! P2 be an isomorphism of posets. For every P1-
formula ' let 'f be a P2-formula which is obtained from ' by replacing
each constant cp for p 2 P1 by a constant cf(p). Clearly if ' is a transitive
closure P1-formula, then 'f is a transitive closure P2-formula.

For a P1 model Q let Qf denote a P2-model which is obtained from Q by
replacing each element p 2 P1 by f (p). Let gf : Q ! Qf be the isomorphism
resulting from the above construction. The proof now follows from the
following two obvious observations.

For every poset Q which extends P1,

Q retracts to P1 iff Qf retracts to P2

For every poset Q which extends P1, for every valuation v in Q, and for
every P1-formula ',

Q j= '[v] iff Qf j= 'f [gf v]

It follows from the above two observations that ' is a complete obstacle for
P1 iff 'f is a complete obstacle for P2.

Proposition 12 A poset dual to a feasible poset is feasible. A poset dual
to a TC-feasible poset is TC-feasible.

19

Proof: Let P ? be the dual of a poset P . A complete obstacle '? for P ?
is obtained from a complete obstacle ' for P by replacing every occurence
of ^ in ' by ^\Gamma 1 (i.e. by *). The details are left for the reader.

4.2 Finite Products
In this section we show that feasible (TC-feasible) posets are closed under
finite products. Let P1 and P2 be two finite posets.

Proposition 13 Let Q be a poset which extends P1 \Theta  P2. Let a 2 P1 and
b 2 P2 be arbitrary elements. Then Q retracts on P1 \Theta  P2 iff Q retracts on
both: P1 \Theta  fbg and fag \Theta  P2.

Proof: The "if" part follows from the observation that P1 \Theta  P2 retracts
on P1 \Theta  fbg via retraction which sends (x; y) to (x; b). Similarly P1 \Theta  P2
retracts on fag \Theta  P2.

For the proof of "only if" take two retractions f1 : Q ! P1 \Theta  fbg and
f2 : Q ! fag \Theta  P2 and define f : Q ! P1 \Theta  P2 by f (q) = (ss1f1(q); ss2f2(q)),
for q 2 Q, where ssi denotes the projection on i-th component. It is easy to
check that f is a retraction.

Theorem 14 If P1 and P2 are feasible, then so is P1 \Theta P2. Also TC-feasible
posets are closed under finite products.

Proof: Take any a 2 P1 and b 2 P2. Let '1 be a complete obstacle for P1.
Since P1 \Theta  fbg is isomorphic to P1 it follows that ^'1 is a complete obstacle
for P1 \Theta  fbg, where ^'1 is obtained from '1 by replacing each constatnt cp by
c(p;b), for p 2 P1 (see Proposition 11). By a similar construction we obtain a
complete obstacle ^'2 for fag \Theta  P2. By Proposition 13 it follows that ^'1 . ^'2
is a complete obstacle for P1 \Theta  P2.

20

4.3 Helly Posets
In this section we show that a broad class of posets which satisfy Helly
property is contained in TC-feasible posets. We start with some definitions.

A disc D in a poset P is specified by its center p 2 P and by a pair of non
negative integers n1; n2. Given the above data, D is defined as the set of all
points of P which are reachable from p via a lower zigzag of length at most
n1 and via an upper zigzag of legth at most n2. Of course if the difference
between n1 and n2 is larger than 1, then D can be equally specified by
n1; n1 + 1, if n1 ! n2, or by n2 + 1; n2, if n2 ! n1.

A poset P satisfies Helly propoerty (see [Benke93, NevermannRival85]) if for
every finite family D1; : : : ; Dk of discs, if D1 " : : : Dk = ;, then for some
i; j 2 f1; : : :kg, Di " Dj = ;.

Call an extension Q of P isometric if for every two points p1; p2 2 P and
for every n, if p2 is accessible in Q from p1 via a lower (resp. upper) zigzag
of length n, then it is also accessible in P from p1 via a lower (resp. upper)
zigzag of length n.

The following result shows that Helly posets are feasible.

Theorem 15 (Benke93)
Let P be a poset satisfying Helly property. An extension Q of P retracts on
P iff Q is isometric over P .

Corollary 16 Every poset satisfying the Helly property is TC-feasible.

Proof: A complete obstacle for P is a disjunction of formulas which express
the property that p2 is accessible from p1 via a lower (or an upper) zigzag of
length at most n \Gamma  1, where n is the length of the shortest lower (or upper)
zigzag in P from p1 to p2.

Poset P4 of Fig.3.3 is an example of a TC-feasible poset which doesn't satisfy
Helly property. For p 2 f0; 2g let Dp = fx 2 P4 j p ^ xg and for q 2 f1; 3g
let Dq = fx 2 P4 j x ^ qg. The reader can easily check that D0; D1; D2; D3

21

are discs such that D0 " D1 " D2 " D3 = ;, but every two (even every three)
discs have non empty intersection.

We conclude this section with a result which will be used at the end of the
paper. Let's call a poset P a generalized zigzag if for every two points p1; p2 2
P there is at most one proper zigzag from p1 to p2. For example posets
represented at Figures: 1.1, 2.4, 2.5, and 3.2 are all generalized zigzags,
while poset P4 of Fig.3.3 is not since there are two zigzags from 0 to 2:
0,3,2 and 0,1,2. Let us also observe that every generalized zigzag contains
no chain of length greater than 1. Indeed, if a ! b ! c then we have two
different proper zigzags from a to b: a; b and a; c; b.

Proposition 17 If P is a generalized zigzag, then it satisfies Helly property.

Proof: Take any family of discs D1; : : : ; Dn in P such that D1": : :"Dn = ;,
but Di " Dj 6= ; for all i; j 2 f1; : : :; ng. Let n be the smallest with this
property. Let A = D1 " : : : " Dn\Gamma 1. It follows that A 6= ;.

Take the family of all proper zigzags from the center d of Dn to an element
in A. This family is non empty sine Dn has nonempty intersection with each
Di for i ! n. Take a proper zigzag from this family of a minimal length.
Let a 2 A be the right end of that zigzag. Since A " Dn = ; it follows
that d 62 A. Let b 6= a be the element adjacent to a on that zigzag. By the
minimality condition it follows that b 62 A. Hence there is k 2 f1; : : :; n \Gamma  1g
such that b 62 Dk.

We claim that Dk " Dn = ;. Assume that c 2 Dk " Dn. Take the unique
zigzag connecting d with the center e of Dk. By the zigzag uniqueness
condition it follows that a; b and c belong to that zigzag. Since a 2 Dk, and
b 62 Dk, again it follows by the zigzag uniqueness condition that c being an
element of Dk must be positioned on that zigzag to the right of b. On the
other hand since a 62 Dn and since a is a right neighbor of b on that zigzag,
it follows that no element to the right of b can belong to Dn. Obtained
contradiction proves the claim that Dk " Dn = ;.

22

4.4 Disjoint Union
In this subsection we show the following result.

Theorem 18 Feasible posets are closed under taking disjoint unions. Also
TC-feasible posets are closed under disjoint unions.

Proof: Let P1, P2 be disjoint feasible posets with complete obstacles '1
and '2, respectively. Let P = P1 [ P2. It is very easy to prove that a
P -model Q retracts to P iff there is no path in Q which connects points in
P1 and P2 and if for i = 1; 2, Qi retracts to Pi, where Qi is the set of all
elements of Q which are connected by a path to an element in Pi. What we
have to do is to make this observation into a P -formula.

Let oe(z) be any P -formula such that z is its only free variable. For every
P -formula ' we define its relativization 'oe as follows.

ffl If ' is atomic, then 'oe is '.
ffl ('1 ^ '2)oe is ('oe1 ^ 'oe2 ), and similar for ..
ffl (9x: ')oe is 9x: (oe(x=z) ^ 'oe).
ffl ((_X; ~x: ')(~t))oe is (_X; ~x: 'oe)(~t).

In case of transitive closure formulas the relativization of TC is slightly
different.

ffl (T C(*~x; ~y: '))oe(~t1; ~t2) is

T C(*~x; ~y: 'oe ^ Vni=1 oe(xi=z) ^ Vni=1 oe(yi=z))(~t1; ~t2).

The above construction has the following property. Let Q be a P -model and
let oe(z) be a P -formula such that z is its only free variable. Let Qoe = fa 2
Q j Q j= oe[a]g be a subposet of Q with its partial order being a restriction
of that in Q. Let Poe = P " Qoe. Then for every valuation v in Qoe and for
every Poe-formula ' the following equivalence holds:

23

Q j= 'oe[v] iff Qoe j= '[v] (7)
The proof of (7) is by routine induction on '.
Now, to conclude the proof of our Theorem, let P ath be the following predicate.

T C(*x; y: x ^ y . y ^ x)

Let oe be the disjunction

.

a2P1; b2P2

P ath(a; b)

and for i = 1; 2, let oei(x) be the formula

.

a2Pi

P ath(x; a)

It follows from the above that

'oe11 . 'oe22 . oe
is a complete P -obstacle.

4.5 Retractions
Let P1 be an extension of a poset P and let Q be a P -model. We construct
a P1-model Q+ as follows. Add to Q the new elements in P1 \Gamma  P , (without
loss of generality we may assume that P1 \Gamma  P and Q are disjoint). The order
relation ^+ in Q+ is defined as follows. x ^+ y iff one of the following holds.

ffl x ^ y holds in Q.
ffl There exists z 2 P , such that x ^ z holds in Q and z ^ y holds in P1.
ffl There exists z 2 P , such that x ^ z holds in P1 and z ^ y holds in Q.
ffl x ^ y holds in P1.

24

We have the following easy result.
Proposition 19 (i) ^+ is a partial order in Q+.
(ii) P + is order-isomorphic to P1.
(iii) If Q retracts to P , then Q+ retracts to P1.
(iv) If P1 retracts to P , then for every P -model Q, Q retracts to P , iff Q+
retracts to P1.

Proof: (i) is proved by case analysis. (ii) is obvious. The proof of (iii)
is also easy. Let f : Q ! P be a retraction and let g : Q+ ! P1 be the
extension of f which is identity on elements in P1\Gamma P . A simple case analysis
shows that g is monotone and therefore a retraction on P1. (iv) obviously
follows from (iii).

Now, let us assume that P has at least two elements, say 0; 1 2 P and let k
be the least integer such that jP1\Gamma P j ^ 2k. Given any P -model Q we encode
a 2 Q+ by ^a 2 Qk+1 as follows. Every a 2 Q is encoded by ^a = (0; a; : : : ; a)
(0 followed by k a's). Every a 2 P1 \Gamma  P is encoded by ^a = (1; "1; : : : ; "k),
where "1; : : :; "k is a binary encoding of a.

We now give a P -formula D describing the domain of encoding, i.e., the set
of all k + 1-tuples of elements of Q which are codes of the elements of Q+.
We define D(x; y1; : : :; yk) to be

(x = 0 ^ y1 = : : : = yk) . .

a2P1\Gamma P

(x = 1 ^ y1 = (^a)1 ^ : : : ^ yk = (^a)k):

The P -formula LE below translates the definition of a ^+ b as defined on Q+
into the definition of inequality between the codes of a and b, respectively.
That is, LE defines a binary relation between k + 1-tuples of elements of Q
each coding an element of Q+.

Define LE(x; ~y; x0; ~y0) to be

D(x; ~y) ^ D(x0; ~y0) ^ disjunction of clauses defining ^+ :

For example, the first clause in the definition of ^+ takes the form

x = 0 ^ x0 = 0 ^ y1 ^ y01;

25

while the second clause becomes

x = 0 ^ x0 = 1 ^ .

(a;b)2A

(y1 ^ a ^ y01 = (^b)1 ^ : : : ^ y0k = (^b)k)

where A = f(a; b) j a 2 P; b 2 P1 \Gamma  P; a ^ bg.
Next, for every P1-formula ' with n free variables we construct a P -formula

^' with n(k +1) free variables. The role of ^' when evaluated in Q is to mimic
the evaluation of ' in Q+. Since the variables of ^' are confined to Q, we
use k + 1-tuples of elements of Q to code single elements of Q+. The coding
is accomplished with the help of the formulas D and LE defined earlier.

The construction is by induction on '. To simplify the notation, for every individual variable x, let ^x denote the (k+1)-vector of variables (x0; x1; : : : ; xk).
We assume that the variables (x0; x1; : : : ; xk) are all pairwise different and
that the assignment of ^x to x is one-to-one. This gives us an obvious transformation which maps every P1-term t into a (k + 1)-vector ^t of P -terms,
i.e. a P1 constant a is transformed to ^a and a variable x is transformed to ^x.
Similarly, for every n-ary predicate variable X, let ^X denote a n(k + 1)-ary
predicate variable. The construction of ^' follows.

ffl t ^ t0 is translated into LE(^t; ^t0).
ffl X(t1; : : : ; tn) is translated into ^X( ^t1; : : :; ^tn) ^ D( ^t1) ^ : : : ^ D( ^tn).
ffl (' . ) is translated into ^' . ^, and similarly (' ^ ) is translated into

^' ^ ^.

ffl 9x: ' is translated into 9^x: (D(^x) ^ ^').
ffl Finally, (_X; z1 : : : ; zn: ')(t1; : : : ; tn) is translated into

(_ ^X; ^z1 : : : ; ^zn: ^')( ^t1; : : : ; ^tn).

For the case of transitive closure formulas we have the following defining
condition.

ffl T C(*x1; : : : ; xn; y1; : : : ; yn: ')(t1; : : : ; tn; s1; : : : ; sn) is translated into

T C(* ^x1; : : : ; ^xn; ^y1; : : : ; ^yn: ^' ^ Vni=1 D( ^xi) ^ Vni=1 D( ^yi))( ^t1; : : : ;

^tn; ^s1; : : : ; ^sn).

26

Theorem 20 Feasible posets are closed under retractions. Also TC-feasible
posets are closed under retractions.

Proof: One first proves by induction on ' the following property. For
every P1-formula ', for every P -model Q and every valuation v in Q+,

Q+ j= '[v] iff Q j= ^'[^v] (8)
where ^v is any valuation which satisfies the following two conditions for
every free variable x in ' and free predicate variable X in ',

v(x) = a iff (^v(x0); : : : ; ^v(xk) = ^a)
where ^x = x0; : : : ; xk is the (k + 1)-tuple of variables associated with x, and

if (a1; : : : ; an) 2 v(X); then ( ^a1; : : :; ^an) 2 ^v(X)

The proof of (8) is routine and we omit the details. Now, to complete the
proof let's assume that P1 retracts to P and let ' be a complete P1-obstacle.
It follows from (8) and Proposition 19 (iv) that ^' is a complete P -obstacle.

5 Bipartite Posets
Call a poset P bipartite if for all p; q; r 2 P , if p ^ q ^ r, then either p = q
or q = r, i.e. these are the posets with all proper chains having at most two
elements.

Let us observe that every n-crown Cn is a bipartite poset. Posets P1; P2
and P3 introduced in Section 3.1 are also bipartite. In this section we give a
complete classification of bipartite posets with respect to the retractability
problem.

Theorem 21 Let P be a bipartite poset.
(i) If for some n * 2, P contains a crown Cn as a subposet, then P -SAT is
NP-complete.
(ii) If P contains no crown, then it is TC-feasible, and therefore P -SAT is
in NLOGSPACE.

27

Proof: For the proof of (i) let us assume that P contains a crown Cn,
and let n be the smallest number with this property. We proceed just the
same as in the proof of NP-completeness for Cn-SAT (see Theorem 2). The
property that P is bipartite ensures that there are exactly two retractions of
the "double crown" of variables. Since Cn is minimal, there are no shortcuts
in P which would make the distance between two points of Cn smaller. Thus
the "locking mechanism" for expressing negation will work in this encoding.

Also the encoding of clauses works here correctly. For n = 2 the encoding
works (see Fig. 2.6) since the forbidden assignment: x10 = 1; y30 = 3
and z20 = 2 for this clause, yields a contradiction with the assumption that
P is bipartite (retractability under this assignment implies that there is an
element w which is below 1 and 3 and above 0 and 2). For n ? 2 the encoding
works as well, though for a slightly different reason. Take, for example, the
poset of Fig. 2.5 which encodes a clause for case n = 5. Retractability under
the assignment x10 = 1; y90 = 9 and z53 = 5 would imply that there exists
an element w which is below 1 and 9. It cannot be 0 since the distance
conditions prevent this possibility. Hence f0; w; 1; 9g is a crown C2 ` P .
This yields a contradiction with the assumption that P does not contain
C2.

In order to prove (ii) let us assume that P contains no crown. Call a set
A ` P decomposable if there is a sequence P1 ` P2 ` : : : Pn such that
A = Pn, P1 has exactly one element, and for every 1 ! i ^ n, there exists
p 2 Pi such that Pi \Gamma  Pi\Gamma 1 = fpg and p is comparable to exactly one element
of Pi\Gamma 1.

Clearly every decomposable set, treated as a poset, is connected. Also,
by a routine induction on the number of elements one proves that every
decomposable set, treated as a poset, is a generalized zigzag. The routine
argument is left for the reader. Thus, by Corollary 16 and Proposition 17
every decomposable set is TC-feasible.

Now, let A ` P be a maximal decomposable subset. If A is properly
contained in a connected component of P which contains it, then it follows that there is an element p in that component such that A [ fpg is
not decomposable. Hence, p must be comparable to at least two elements
a1; a2 2 A. Let a1; q1; : : : ; qn; a2 be a path in A which connects a1 and a2.
Then a1; q1; : : :; qn; a2; p is a crown. The obtained contradiction proves that
A must be equal to a connected component of P . Thus P is a disjoint union

28

of TC-feasible posets and therefore (see Theorem 18) is TC-feasible as well.
References
[Benke93] Marcin Benke. Efficient Type Reconstruction in the Presence of Inheritance. In: A. M. Borzyszkowski, S. Sokolowski (Eds.) MFCS'93: Mathematical Foundations of Computer science, Proc. 18th Intern. Symp.,
pages 272-280, Springer Verlag, LNCS 711, 1993.

[Benke95] Marcin Benke. Subtyping and Alternation. To appear as Technical

Report, Institute of Informatics, Warsaw University, 1995.

[FederVardi93] T.A. Feder and M. Vardi. Monotone monadic SNP and constraint

satisfaction. In Proc. 25th ACM Symp. on Theory of Computing, pages
612-622, 1993.

[HoangMitchell95] My Hoang and John C. Mitchell. Lower Bounds on Type Inference with Subtypes. In Conf. Rec. 22nd ACM Symposium on Principles
of Programming Languages, pages 176-185, 1995.

[Mitchell84] John C. Mitchell. Coercion and Type Inference (summary). In Conf.

Rec. 11th ACM Symposium on Principles of Programming Languages,
pages 175-185, 1984.

[MitchellLincoln92] Patrick Lincoln and John C. Mitchell. Algorithmic Aspects of

Type Inference with Subtypes. In Conf. Rec. 19th ACM Symposium
on Principles of Programming Languages, pages 293-304, 1992.

[NevermannRival85] P. Nevermann and I. Rival. Holes in ordered sets. Graphs and

Combinatorics, pages 339-350, 1985.

[OKeefeWand89] Mitchell Wand and Patrick M. O'Keefe. On the Complexity of

Type Inference with Coercion. In Conf. on Functional Programming
Languages and Computer Architecture, 1989.

[Tiuryn92] Jerzy Tiuryn. Subtype Inequalities. In Proc. 7th IEEE Symposium on

Logic in Computer Science, pages 308-315, 1992.

[TiurynWand93] Jerzy Tiuryn and Mitchell Wand. Type reconstruction with recursive types and atomic subtyping. In: M.-C. Gaudel and J.-P. Jouannaud (Eds.) TAPSOFT'93: Theory and Practice of Software Development, Proc. 4th Intern. Joint Conf. CAAP/FASE, Springer-Verlag
LNCS 668, 1993, pp.686-701.

29