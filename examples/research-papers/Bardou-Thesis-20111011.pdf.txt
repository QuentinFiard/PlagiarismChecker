

ORSAY
Nffi d'ordre: XXX

UNIVERSITE' DE PARIS-SUD 11

CENTRE D'ORSAY

THE`SE

pre'sente'e
pour obtenir

le grade de docteur en sciences DE L'UNIVERSITE' PARIS XI

PAR
Romain BARDOU-!-
SUJET :

Ve'rio/cation de programmes avec pointeurs

a` l'aide de re'gions et de permissions

Verio/cation of Pointer Programs Using Regions and Permissions

soutenue le XX octobre 2011 devant la commission d'examen

MM. Peter Mu"ller

Franc,ois Pottier
Jean Goubault-Larrecq
Burkhart Woloe
Claude Marche'

2

Acknowledgements
This thesis is the result of more than four years of work with my advisor Claude Marche',
to who I wish to express my deepest gratitude. Claude was always available for advice and
guidance, was always abundantly helpful and supportive, and knocking on his door to abuse
his time was a favorite passtime of mine.

I of course wish to thank my reviewers Peter Mu"ller and Franc,ois Pottier, who dedicated
so much of their time to try and understand even the most obscure parts of this thesis.
They also ooeered invaluable advice. My gratitude also goes to Jean Goubault-Larrecq and
Burkhart Woloe for accepting to be part of the supervisory committee.

The atmosphere at ProVal is unique. Hearing Jean-Christophe and Sylvain arguing joy-
fully in the corridor while eating a cake baked by Sylvie or Evelyne is a rather common scene
that I'm sure Guillaume, Louis, Kim and Andrei have and will continue to enjoy. I'll also
keep a fond memory of all other PhD students or other non-permanent-without-children with
who I shared many restaurants: Franc,ois, Florence, Yannick, Johannes, Ste'phane, Wendy,
Nicolas, Nicolas and Nicolas (sic), Alain, Tuyen, Matthieu, Thierry, Alexandre, Asma, Mo-
hamed... The list goes on.

Last but not least, I would like to thank my father for letting me watch him program in
Pascal, on his knees late in the evening, twenty years ago. And I would like to thank my
mother for pretending not to know despite the fact that I should have already been in bed.

4
Contents
1 Introduction 9

1.1 Static Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.2 Deductive verio/cation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3 Data Invariants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
1.4 Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

2 Technical Background 15

2.1 The ML Type System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
2.2 Hoare Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

2.2.1 Hoare Triples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.2.2 Weakest Pre-Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . 19
2.3 Alias-Free Program Verio/cation . . . . . . . . . . . . . . . . . . . . . . . . . . 20

2.3.1 The Why Intermediate Language . . . . . . . . . . . . . . . . . . . . . 21
2.3.2 The Boogie Intermediate Language . . . . . . . . . . . . . . . . . . . . 23
2.4 Memory Models for Programs with Alias . . . . . . . . . . . . . . . . . . . . . 25

2.4.1 Heap as a Single Array . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.4.2 Need for Separation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
2.4.3 Component-as-Array: One Array Per Field . . . . . . . . . . . . . . . 27
2.4.4 Regions: One Array Per Region . . . . . . . . . . . . . . . . . . . . . . 29
2.5 Preservation of Data Invariants Using Ownership . . . . . . . . . . . . . . . . 30
2.6 Permissions: Linear Information About Regions . . . . . . . . . . . . . . . . . 32

3 Informal Presentation of Capucine 35

3.1 Separation Using Regions and Permissions . . . . . . . . . . . . . . . . . . . . 35
3.2 Modularity Using Region Ownership . . . . . . . . . . . . . . . . . . . . . . . 39
3.3 Invariants Using Permissions and Ownership . . . . . . . . . . . . . . . . . . 41
3.4 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

3.4.1 Bounded Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
3.4.2 Bounded Arrays: Proof Obligations . . . . . . . . . . . . . . . . . . . 46
3.4.3 Sparse Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
3.4.4 Function Memoization Using Hash Tables . . . . . . . . . . . . . . . . 55
3.4.5 Courses and Students . . . . . . . . . . . . . . . . . . . . . . . . . . . 61

4 Capucine Language Syntax and Semantics 67

4.1 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

4.1.1 Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
4.1.2 Logic Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68

5

6 CONTENTS

4.1.3 Regions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
4.1.4 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
4.1.5 Logic Function and Predicate Declarations . . . . . . . . . . . . . . . 69
4.1.6 Terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
4.1.7 Predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
4.1.8 Axioms and Lemmas . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
4.1.9 Permissions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
4.1.10 Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
4.1.11 Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
4.1.12 Function Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
4.2 Typing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74

4.2.1 Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
4.2.2 Terms and Predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
4.2.3 Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
4.2.4 Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
4.3 Intuitive Memory Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
4.4 Coherence Preservation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
4.5 Separated Memory Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103

4.5.1 Separated Operational Semantics . . . . . . . . . . . . . . . . . . . . . 103
4.5.2 Intuitive and Separated Model Equivalence . . . . . . . . . . . . . . . 108
4.6 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113

5 Generation of Verio/cation Conditions 115

5.1 The Why Intermediate Language . . . . . . . . . . . . . . . . . . . . . . . . . 115

5.1.1 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
5.1.2 Terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
5.1.3 Predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
5.1.4 Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
5.1.5 Logic Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
5.1.6 Program Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
5.1.7 Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
5.2 Direct Encoding of the Separated Model . . . . . . . . . . . . . . . . . . . . . 119

5.2.1 Pointers, Regions, Types and Objects . . . . . . . . . . . . . . . . . . 119
5.2.2 Expressions and Region Expressions . . . . . . . . . . . . . . . . . . . 121
5.2.3 Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
5.2.4 Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
5.2.5 Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
5.2.6 Illustration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
5.2.7 Soundness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
5.3 Support for Recursive Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
5.4 Simplify Singleton Regions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141

5.4.1 Singleton Maps Are Values . . . . . . . . . . . . . . . . . . . . . . . . 141
5.4.2 Illustration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
5.4.3 Soundness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
5.5 Flattening Regions for More Separation . . . . . . . . . . . . . . . . . . . . . 146

5.5.1 Generalizing The Component-as-Array Model . . . . . . . . . . . . . . 146
5.5.2 Computing Preo/x Trees . . . . . . . . . . . . . . . . . . . . . . . . . . 148
5.5.3 Using Preo/x Trees When Translating . . . . . . . . . . . . . . . . . . . 149

CONTENTS 7

5.5.4 Illustration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
5.5.5 Soundness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
5.6 Experiments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
5.7 Using Typing Information in Proofs . . . . . . . . . . . . . . . . . . . . . . . 158

5.7.1 Invariants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
5.7.2 Region Disjointness . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
5.7.3 Pointer Region . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
5.7.4 Pointer Equalities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
5.7.5 Pointer Disequalities . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
5.8 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162

6 Inference of Region Annotations 163

6.1 Need for Inference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
6.2 There Is No Principality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
6.3 Inferring Most Region Annotations . . . . . . . . . . . . . . . . . . . . . . . . 166
6.4 Termination, Soundness and Completeness . . . . . . . . . . . . . . . . . . . . 175
6.5 Simplify Allocation and Focus . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
6.6 Experiments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
6.7 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179

7 Conclusion 181

7.1 Related Work and Contributions . . . . . . . . . . . . . . . . . . . . . . . . . 181

7.1.1 Other Memory Models . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
7.1.2 Data Groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
7.1.3 Spec# Ownership Methodology for Data Invariants . . . . . . . . . . 182
7.1.4 Ownership Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
7.1.5 Universe Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
7.1.6 Regions, Capabilities and Alias Types . . . . . . . . . . . . . . . . . . 185
7.1.7 Separation Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
7.1.8 Dynamic Frames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189
7.1.9 Implicit Dynamic Frames . . . . . . . . . . . . . . . . . . . . . . . . . 190
7.1.10 Regional Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
7.1.11 Considerate Reasoning . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
7.1.12 Liquid Types for Invariant Inference . . . . . . . . . . . . . . . . . . . 193
7.2 Future Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193

7.2.1 Encoding Mainstream Languages Into Capucine . . . . . . . . . . . . 193
7.2.2 Conditional Permissions . . . . . . . . . . . . . . . . . . . . . . . . . . 194
7.2.3 Combine With Other Approaches for Group Regions . . . . . . . . . . 194
7.2.4 More Adoption Operations . . . . . . . . . . . . . . . . . . . . . . . . 195
7.2.5 Multiple Focus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
7.3 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197

8 CONTENTS
Chapter 1
Introduction
Software is invading your everyday life. Your cellphone for instance, or smartphone, grants
you access to many applications which are not so phone-related. Those applications are
themselves managed by a single program: the operating system. Similarly, your car is no
longer just a car: you cannot put on your mechanic clothes and open it to understand why
this black smoke emerges from the engine. You also need programmer clothes, as your car is
driven not only by gears and wheels, but also by complicated pieces of software such as GPS
or speed limiters.

Some programs can be considered critical. Programs which control your car or your plane
might cause injuries or deaths if they ever were not to behave as expected. Other examples
include software in health-related systems such as X-ray devices, which should not send more
radiation than needed. Critical programs also include programs which entail huge losses of
money if they fail. Software which controls rockets is a good example.

All those programs, in particular critical ones, must be trusted to behave correctly if
they are to be used. A good question is: what is the condition for a program to be trusted?
Current methods to certify critical programs involve a lot of tedious work from programmers.
Their code has to be written in very specio/c ways to ensure it will be easily readable by other
programmers who will then be able to say whether the program is safe or not. But humans
are very good at failing to detect simple programming errors. And even changing a single
character in a ten million lines-of-code software can be disastrous. So these methods are not
suOEcient. Testing programs on some well-chosen inputs is currently the primary certio/cation
method in software industry. Testing has become a wide area of research in computer science.
Unfortunately, by deo/nition testing cannot prove that a program behaves correctly on all
inputs.

While humans may easily fail at detecting programming errors, machines are very good
at executing tedious tasks... as long as you tell them what to look for, and how. This
observation has led to several o/elds of research for static analysis of programs such as model-
checking, abstract interpretation, proof assistants and deductive verio/cation. All of them
have in common that the verio/cation is done on the program code before it is executed.

1.1 Static Analysis
Model-checking considers a program as involving a o/nite number of states, even if each
individual state represent an ino/nite number of actual program states. One says which of

9

10 CHAPTER 1. INTRODUCTION
these states are unsafe, and then one computes whether these states are reachable. The set of
states is computed from the program and unsafe states are given by a logic formula. If these
logic formulas can be decided, since there is a o/nite number of states, these computations
terminate and the property: ican my program enter an unsafe state?j is decidable.

Abstract interpretation [Cousot77] deals with ino/nite numbers of states by abstracting
over them. The program is then executed symbolically in the abstract space. We obtain an
over-approximation of the reachable states of the program. We can then check whether this
over-approximation contains unsafe states. Computing the over-approximation is decidable,
but if it does contain unsafe states, it does not mean that the program will reach them.
Moreover, we cannot prove any property: the abstract domain must obey certain rules.

Proof assistants such as Coq [Coq] provide a very rich logic in which to write programs,
their specio/cation and their proofs. The assistant will check proofs for you, but as the logic
used is largely undecidable, you will have to do most of the proof by hand.

Deductive verio/cation is based on Hoare logic [Hoare69]. Using this logic, one can specify
the behavior of programs using pre-conditions and post-conditions. The program is valid with
respect to this specio/ed behavior if, from any state in which the pre-condition holds, execut-
ing the program leads to states in which the post-condition holds as well. By computing the
weakest pre-condition of a program given its post-condition [Dijkstra76], and then proving
that the user-specio/ed pre-condition implies the weakest pre-condition, one proves that the
program verio/es its specio/cation. Deductive verio/cation tools thus provide: a specio/cation
language in which to write pre-conditions and post-conditions, a tool which computes weakest
pre-conditions, and tools to prove that this weakest pre-condition is implied by the specio/ed
pre-condition. The Why platform [Fillia^tre07] and Spec# [Barnett04a] are examples of exist-
ing deductive verio/cation tools. Those tools include proof assistants and automatic theorem
provers such as Alt-Ergo [AltErgo], Z3 [Z3], CVC3 [Barrett07] or Simplify [Detlefs05].

There is a trade-ooe between automation and expressiveness. In model-checking, expres-
siveness is low as the state space is o/nite and it must be decidable whether a given state
verio/es a logic specio/cation. On the other hand and thanks to these limitations, automation
is high: once the program and its specio/cation are written, the verio/cation is automatic,
although it can take some time. Abstract interpretation allows more expressiveness for pro-
grams, but the properties that can be checked depend on the abstract state space being
used. The level of automation is comparable to the one of model-checking. The language
used by proof assistants both to write programs and to specify them is very expressive. As
a consequence, proof assistants provide almost no automation.

Deductive verio/cation is an attempt at increasing expressiveness while keeping some au-
tomation. Programs may be written in mainstream languages such as C or Java, and we
consider the memory to be unbounded so the state space is ino/nite. Program specio/cations
are written using o/rst-order logic, which is not decidable. The proofs themselves can be
done by hand, using proof assistants, or discharged by automatic provers if they are simple
enough.

1.2 Deductive verio/cation
This thesis contributes to deductive verio/cation, which we now detail further. We want to
prove some properties for every program, such as: no memory error (segmentation fault) will
occur, no division by zero will occur, arrays won't be read outside of their bounds. These are
generic safety properties. Note that some of them, in some languages, are ensured by typing.

1.2. DEDUCTIVE VERIFICATION 11
For instance, a well-typed Java or OCaml [OCaml] program will not produce a segmentation
fault [Damas82, Pottier05], at least when using the default compiler options.

Some properties, however, are program-specio/c. They say something about the behavior
of the program. As an example, consider the following C function:

int max(int i, int j)
{

if (i >= j)

return i;
else

return j;
}

A behavior of this function is that it always returns an integer greater or equal than its
arguments i and j. Another behavior is that the result is always either i or j. Those two
combined behaviors tell us that this function is the mathematical max function.

Now let's use our max function in a context where safety is involved:

void main()
{

printf("%d", 10 / max(1, 2));
}

To prove the safety of the main function, we need to know that max(1, 2) won't return
0. This can be seen as a pre-condition of the division operator a / b stating that b must
be dioeerent than 0.

To prove our program in a modular fashion, we want to hide the implementation of max.
Instead of checking that max(1, 2) is not 0 in this particular implementation of max, we
specify its behavior as a post-condition:

int max(int i, int j)

/*@ ensures \result >= i && \result >= j @*/
{

if (i < j)

return j;
else

return i;
}

This example uses a syntax close to ACSL [Baudin09]. The ensures clause in the comment
will be interpreted by the verio/cation tool as a post-condition stating that the result is
greater or equal than both i and j. Note that this post-condition does not describe the full
behavior of the max function, but it is suOEcient to prove that the call to max(1, 2) will
not return 0. Also note that this implementation of max is dioeerent, but both verify this
same post-condition.

Verifying the max function consists in proving the following proof obligation:

8i, j. (i < j ) j >= i ^ j >= j) ^ (~(i < j) ) i >= i ^ i >= j)
Intuitively, this is the post-condition of max where \result is replaced by the actual re-
turned value, and the conjunction is introduced by the if statement. This logic formula is

12 CHAPTER 1. INTRODUCTION
obtained by computing the weakest pre-condition [Dijkstra76, Leino05] of the function, based
on Hoare logic [Hoare69]. We will detail both Hoare logic and the computation of weakest
pre-conditions in Section 2.2. This formula is valid, so the max function verio/es its specio/-
cation. This particular proof obligation is simple enough to be discharged automatically by
automatic theorem provers.

Verifying the main function consists in proving the following proof obligation:

8r. r >= 1 ^ r >= 2 ) r 6= 0
Intuitively, the integer r represents the value returned by the call to max(1, 2). So r
verio/es the post-condition of max where \result is replaced by r, i by 1 and j by 2. The
proof obligation itself comes from the pre-condition of the division operator. It can also be
discharged automatically.

1.3 Data Invariants
Data invariants are a handy tool for specifying programs [Barnett04b, Drossopoulou08, Sum-
mers09]. Here are some examples of data invariants. A sorted list is always sorted: being
sorted is an invariant of the sorted list data structure. In a search tree, the contents of each
node is greater than all nodes in the left subtree, and less than all nodes in the right subtree:
this is an invariant of the search tree data structure. In a balanced tree, each node also has
about as many nodes in the left subtree than in the right subtree: this is again an invariant
of balanced trees. Invariants capture design intentions of the programmer. For instance, a
type named pos_int may be implemented using integers int, but the programmer may
intend all variables of type pos_int to be positive.

As invariants are assumed to hold, it is necessary to maintain them. For instance, the
function which inserts a new node in a search tree assumes the invariant of the tree and
maintains it. Then, the function which looks for a node in a search tree assumes the invariant
and uses it to avoid having to look everywhere in the tree. If this function is given a tree
which is not a search tree, it may not return the expected result.

Let's see how invariants can be specio/ed in the context of deductive verio/cation. Assume
a set data structure with a given invariant predicate inv. Thus, inv(s) states that the
invariant of set s holds. For instance, if sets are implemented using trees, this invariant can
state that the tree is a balanced search tree. We can annotate the add function using pre-
and post-conditions to specify that it maintains the invariant:

void add(set s, int i)

/*@ requires inv(s);

ensures inv(s) */

The requires clause states the pre-condition of add: the invariant of the set argument
s must hold when calling add on s; and the ensures clause states the post-condition:
the invariant of the set argument s holds after calling add on s. In a similar fashion, a
function mem(s, i) which tests whether integer i is in set s will require the invariant as a
pre-condition.

One could argue that invariants are simply automatic pre- and post-conditions on all
arguments, but this methodology raises several issues. The o/rst issue is that invariants
must then be proved before each call. One could argue that the proof obligations coming

1.3. DATA INVARIANTS 13
from the invariant in pre-conditions could be ignored, using the following wrong argument:
as invariants are added as post-conditions everywhere, they will hold after each call, and
thus will hold everywhere. But the following counter-example shows that this policy is
inconsistent:

void f(set s)

/*@ requires inv(s);

ensures inv(s) */

void g(set s)

/*@ requires inv(s);

ensures inv(s) */
{

... /* do something to break the invariant of s */
f(s); /* we cannot ignore the pre-condition of f here */
}

This example makes this issue obvious, but in object-oriented languages the s argument would
be implicit and thus this problem would appear less clearly. To sum up, if we don't want to
have to prove invariants everytime we call a function, we need to use another methodology.

Another issue is that function arguments are not the only available data structures in the
function context. For instance, consider the following data structure:

typedef int positive;

/*@ invariant(positive p) = p > 0 */

typedef struct {

positive first;
positive second;
} pair;

/*@ invariant(pair p) = p.first < p.second */

Type positive is the type of positive integers: it is equal to type int, but we specify that
all positive values have an invariant, which is that they are positive. Type pair is the
type of sorted positive pairs. It is composed of two positive values, the first and the
second one. It also has one invariant: the first o/eld must be lesser than the second
o/eld for all pair values. Now consider the following function:

void h(pair p)
What are the pre- and post-conditions that must be added to h to take invariants into
account? If we strictly follow the idea that invariants are automatic pre- and post-conditions
on all arguments, then we obtain the following specio/cation for h:

void h(pair p)

/*@ requires p.first < p.second;

ensures p.first < p.second */

But what about the invariants of p.first and p.second? They are values of type
positive, so they should be required and ensured to be positive. So we add these re-
quirements in the specio/cation:

void h(pair p)

14 CHAPTER 1. INTRODUCTION

/*@ requires

p.first < p.second
&& p.first > 0
&& p.second > 0;
ensures

p.first < p.second
&& p.first > 0
&& p.second > 0 */

This is o/ne for o/nite structures. But what about linked lists or trees? What about containers
such as lists of pair values? It quickly becomes impossible to decide which values are
accessible to h.

This brings us to the third issue: modularity. What if we want to hide the first and
second o/elds of the pair data structure to make it an abstract type? It is then even more
diOEcult to decide which pointers are accessible to h, as h does not even know about p.first
and p.second. Moreover, as the invariant of pair values is unfolded in the requires and
ensures clauses of h, the first and second o/elds are exposed and modularity is broken.

1.4 Contributions
The main contribution of this thesis is the following:

A type system using regions and permissions to structure the heap in a
modular fashion, control pointer aliasing and data invariants and produce proof

obligations where pointers are separated.

This thesis introduces a language called Capucine which uses this type system (Chapter 4).
It also introduces a model and a semantics for this language and proves its soundness. The
Capucine language has been implemented in a prototype tool and experimented on some
examples (Chapter 3).

The type system is based on the already-existing notion of regions to separate pointers
statically. It is extended with region parameters and polymorphism for more expressiveness.

The notion of region is extended with region ownership to construct a region hierarchy.
One region may own, i.e. contain, other regions. This allows modular reasoning.

Permissions, i.e. aOEne pieces of information about regions, are used to track the state of
regions. This also allows easy tracking of the state of data invariants.

Capucine programs are interpreted as Why programs to compute proof obligations (Chap-
ter 5). Using information from the type system, it is possible to avoid some of the proof
obligations needed to maintain data invariants in existing approaches. Moreover, pointers
can be separated in proof obligations using typing information to simplify them.

This thesis also introduces an inference algorithm for region annotations and operations
(Chapter 6). It is quite helpful in practice.

I claim that this methodology alleviates the need for logic specio/cation annotations about
pointer aliasing and data invariants. Indeed, this kind of information can often be handled
by the type system instead, and inference helps to ensure that the burden of annotating the
program with region operations is light. This also reAEects on proof obligations. I also claim
that this methodology structures the program in a modular fashion and thus has a chance
to scale.

Chapter 2
Technical Background
In this chapter, we give technical background which we need in this thesis. The type system
of Capucine borrows parametric polymorphism from ML which we detail o/rst. We then
present the foundations of deductive verio/cation. Finally, we detail existing work on data
invariants, regions and permissions from which the thesis is largely inspired.

2.1 The ML Type System
The type system of Capucine features many properties inspired by the ML language family,
including OCaml [Pottier05, OCaml]. The features which we borrow are: type parameters,
polymorphism with implicit prenex quantio/cation and inference. In this section, we introduce
those features informally. All examples are written using the OCaml syntax.

Polymorphism Consider the following function which takes a pair as an argument and
returns the o/rst component of the pair:

let f (x , .) = x
One possible type for this function is:

int * int ! int
In other word, it is a function which takes a pair of two integers as an argument and returns
an integer. Another possible type is:

float * string ! float
In fact, function f can accept any type for the o/rst component x of the pair, and any type for
the second component. It returns a value which is of the same type than x . A more general
type for f is thus:

8ff, fi. ff * fi ! ff
This type is polymorphic: ff and fi can be instanciated with any type. For instance, we can
instanciate ff with float and fi with string, and we obtain float * string ! float, which is
one of the type we had given to f above.

15

16 CHAPTER 2. TECHNICAL BACKGROUND

In ML, and also in Capucine, type variables are always quantio/ed at the head of types.
For instance, int * (8fi. fi) ! int is not a valid ML type. Because of this, we actually omit
the quantio/cation on type variables, which are implicitely universally quantio/ed at the head
of types. Thus, the type of f is actually written:

ff * fi ! ff
Polymorphism allows the programmer to avoid duplicating code. It thus allows to avoid
duplicating errors as well, and is a key feature for modularity [Hughes89].

Type Parameters Consider the following linked list data structure.
type list =|

Nil|
Cons of int * list

This deo/nes the type of integer lists, with two constructors. The o/rst constructor is Nil, which
is the value denoting the empty list. The second constructor is Cons, with two arguments.
The o/rst argument has type int: it is the value stored in the o/rst node of the list. The
second argument has type list: it is the remaining of the list, also called its tail. For instance,
Cons(42, Nil) is the list with one element: the integer 42. The remaining of the list is empty.

The o/rst argument of constructor Cons can be replaced by any type: float, string... This
does not change the structure of the list itself, only the type of its contents. Instead of
copy-pasting the list for every type we need, we may use a type parameter.

type ff list =|

Nil|
Cons of ff * ff list

Type ff list can be instanciated with any type for ff. For instance, int list is the type of lists
of integers, float list is the type of lists of AEoats, and string list list is the type of lists of lists
of strings.

Type parameters are especially useful when combined with function polymorphism. In-
deed, one can write functions which operate on any list. For instance, the length function
takes a list and computes its length. It does not have to read the contents of the nodes of
the list, and thus length operates in exactly the same way on lists of integers, lists of strings
and so on. The type of function length is:

ff list ! int
It is polymorphic in the type ff of the contents of the list.

Inference Any ML expression e has a principal type o/ . If e also has type o/ 0, then o/ 0 is
an instance of o/ . In other words, we can obtain all types of e by instanciating the type
variables of o/ . For instance, type ff * fi ! ff is the principal type of function f above, and
type float * string ! float is an instance of this principal type.

Inference algorithms such as the so-called Algorithm W [Damas82] of Luis Damas and
Robin Milner, also called the Hindley-Milner algorithm, are capable of automatically com-
puting the principal type of any ML expression. A simple inference algorithm consists in
assigning every sub-expression a type variable, and then applying the type system rules to
extract constraints on type variables. We then apply a unio/cation algorithm on those con-
straints to obtain a substitution oe from type variables to types, which solves the constraint

2.2. HOARE LOGIC 17
system. If the type variable given to expression e was ff, then the inferred type of e is oe(ff).
The unio/cation algorithm can be written in such a way that oe(ff) is the principal type of e.

2.2 Hoare Logic
In Section 1.2, we introduced deductive verio/cation using an example. We showed pre-
and post-conditions and said that proof obligations could be computed from them, proof
obligations being logic formulas which imply that the program verify its specio/cation. This
methodology is based on Hoare logic [Floyd67, Hoare69], which we introduce quickly in this
section to show how proof obligations are actually computed.

2.2.1 Hoare Triples
A Hoare triple is a triple of the form:

{P }C{Q}
where C is a command, i.e. an operation of the programming language being considered,
and P and Q are logic formulas. Formula P is the pre-condition and formula Q is the post-
condition. These logic formulas depend on the program state. Note that Hoare logic can be
applied to many programming languages, as well as many logic languages, including but not
limited to o/rst-order logic. This also means that the program state can take dioeerent forms.
Here, we consider it to be a simple map from variable names to their values. A Hoare triple
is valid if, for any program state S such that P holds in S, if C executed on S leads to the
new program state S0, then Q holds in S0. Hoare logic deo/nes rules to build Hoare triples.
Hoare logic is shown sound: triples built from these rules are always valid.

Skip The o/rst Hoare logic rule is trivial:

{P }skip{P }
where P is any predicate and skip is the command which does nothing. Indeed, the program
state is not modio/ed by skip, so if P holds before skip is executed, it still holds after.

Sequence A rule allows to compose Hoare triples:

{P }C1{Q} {Q}C2{R}{

P }C1; C2{R}

where C1; C2 is the sequence of C1 followed by C2. Indeed, if C1 transforms a state where P
holds into a state where Q holds, and if C2 transforms a state where this same Q holds into
a state where R holds, then C1 followed by C2 transforms a state where P holds into a state
where R holds.

Consequence The consequence rule allows to strengthen the pre-condition or weaken the
post-condition:

P 0 ) P {P }C{Q} Q ) Q0{

P 0}C{Q0}

18 CHAPTER 2. TECHNICAL BACKGROUND
Assignment A most fundamental rule is the rule for variable assignment:

{Q[x 7! v]}x := v{Q}
where Q[x 7! v] denotes predicate Q where all free occurences of x are replaced by v. Here
is an example of this rule being applied:

{x + y = 3 ^ y = 2}x := x + y{x = 3 ^ y = 2}
which, using the consequence rule, is equivalent to:

{x = 1 ^ y = 2}x := x + y{x = 3 ^ y = 2}
It is important to note that we need to know whether x and y are separated, i.e. whether
they are the same variable. In this example we assume x and y are dioeerent variables.

Test Now let's show the rule for the if statements:

{e ^ P }C1{Q} {~e ^ P }C2{Q}{

P }if e then C1 else C2{Q}

Note how the if condition e is added to the pre-condition of C1 and C2. Here is an instance
inspired by function max of Section 1.2, where r is the returned value:

{i >= j}r := i{r >= i ^ r >= j} {i < j}r := j{r >= i ^ r >= j}{?}

if i >= j then r := i else r := j{r >= i ^ r >= j}

Note that we also applied the consequence rule to replace i >= i ^ i >= j into i >= j and to
weaken j >= i ^ j >= j into i < j in the post-condition of each premise, respectively.

Loops The rule for while loops is the following:

{P ^ e}C{P }{
P }while e do C{P ^ ~e}

Predicate P is called the loop invariant: it is preserved by the body C of the loop. Thus,
if P holds at the beginning of the loop, then it still holds at the end of the loop. We prove
that C preserves P if the condition e holds, as the body of the loop is only run if e evaluates
to true. At the end of the loop, e evalutes to false, so the negation of e is available in the
post-condition.

Note that the above version does not check that the loop terminates. To check termina-
tion, one can tweak the rule to add a variant requirement. A variant is an expression which
evaluates in a well-founded order and which strictly decreases with each iteration.

Function Calls Assume a function f with body C and such that the following Hoare triple
is valid:

{P }C{Q}

2.2. HOARE LOGIC 19
Predicate P is called the pre-condition, and predicate Q is called the post-condition. They
depend on the formal parameters x1, . . . , xn of f .

The rule for function call is the following:

Dom(oe) = {x1, ..., xn} forall i, oe(xi) = ei{

oe(P )}f(e1, . . . , en){oe(Q)}

We use substitution oe to replace, in the pre-condition and post-condition, the formal param-
eters of f with the actual arguments.

2.2.2 Weakest Pre-Conditions
Given a command C and a logic formula Q, the weakest pre-condition wp(C, Q) is a logic
formula such that: {

wp(C, Q)}C{Q}

and forall P such that: {

P }C{Q}

then P ) wp(C, Q). In other words, the weakest pre-condition is the unique pre-condition
which is implied by all other pre-conditions.

To prove {P }C{Q} it is suOEcient to prove P ) wp(C, Q), as we can then apply the
consequence rule:

P ) wp(C, Q) {wp(C, Q)}C{Q} Q ) Q{

P }C{Q}

Thus, one way of verifying a program deductively is to compute its weakest pre-condition. If
the user annotated program C with a pre-condition P and a post-condition Q, we generate
P ) wp(C, Q) as a proof obligation.

Sequence The algorithm to compute weakest pre-conditions can be deduced from Hoare
logic rules. For instance, from the composition rule:

{P }C1{Q} {Q}C2{R}{

P }C1; C2{R}

we deduce the rule to compute the weakest pre-condition of a sequence:

wp((C1; C2), Q) = wp(C1, wp(C2, Q))

Assignment From the assignment rule:

{Q[x 7! v]}x := v{Q}
we deduce the rule to compute the weakest pre-condition of an assignment:

wp((x := v), Q) = Q[x 7! v]

20 CHAPTER 2. TECHNICAL BACKGROUND
Test The weakest pre-condition of an if statement is not straightforward from the Hoare
logic rule:

wp((if e then C1 else C2), Q) = (e ) wp(C1, Q)) ^ (~e ) wp(C2, Q))
It can easily be shown using the consequence rule that this is a valid pre-condition. It is also
the weakest. Note that this is not the only method to compute the weakest pre-condition. In
particular, eOEcient weakest pre-condition avoids duplicating the post-condition Q [Leino05].

While To the weakest pre-condition of a while statement is only deo/ne if a loop invariant
is given. Guessing the loop invariant is undecidable in general, so we usually require the
programmer to give one. Here is one way to compute the weakest pre-condition of a loop,
without checking termination, with loop invariant I and where x is the set of variables being
assigned by the body C:

wp((while e do C), Q) = I ^ 8x, (e ^ I ) wp(C, I)) ^ (~e ^ I ) Q)

Function Calls Assume a function f with body C and such that the following Hoare triple
is valid:

{Pf }C{Qf }
Assume the formal parameters of f are x1, . . . , xn. Assume n expressions e1, . . . , en. Assume
a substitution oe such that for all i, oe(i) = ei. Assume the call to f (e1, . . . , en) assigns
variables x. Here is how we compute the weakest pre-condition of a call to f with arguments
e1, . . . , en:

wp(f (e1, . . . , en), Q) = oe(Pf ) ^ (8x, oe(Qf ) ) Q)

Example Let's apply this algorithm on the max function:

wp((if i >= j then r := i else r := j), r >= i ^ r >= j)
= (i >= j ) wp(r := i, r >= i ^ r >= j)) ^ (i < j ) wp(r := j, r >= i ^ r >= j))
= (i >= j ) i >= i ^ i >= j) ^ (i < j ) j >= i ^ j >= j)

2.3 Alias-Free Program Verio/cation
In Section 2.2 was introduced the Hoare logic rule for assignment:

{Q[x 7! v]}x := v{Q}
As we already noted, this rule is trickier than it seems. Indeed, it relies on variable substitution
Q[x 7! v], which can only be deo/ned when all variables of Q can clearly be said to be equal
or dioeerent to x. In this section, we present two languages which implement Hoare logic in a
context where two variables with dioeerent names are always separated. References, pointers,
objects are not part of these languages and must be encoded.

2.3. ALIAS-FREE PROGRAM VERIFICATION 21
2.3.1 The Why Intermediate Language
Why [Fillia^tre07] is a tool and an alias-free programming language for deductive verio/cation
based on weakest pre-condition computation. There is no distinction between statements
and expressions, as in the ML language family. Specio/cation language is o/rst-order logic,
and the user may deo/ne or declare his own logic types, logic functions and predicates to use
in the program specio/cation annotations.

To specify his program, the user may annotate it using:

* pre-conditions for functions, which are assumed true when proving the function and

must be showned to hold at call site;

* post-conditions for functions, which must be proved when proving the function and can

be assumed to hold after a call to the function;

* loop invariants, which are predicates which must be shown to hold at the beginning of

the loop and at the end of each iteration, and will be thus also hold at the end of the
loop, and which cannot be inferred by the weakest pre-condition algorithm;

* loop variants (optionally), which are terms which must decrease in a well-founded order

after each iteration of a loop, and can be used to prove total correctness;

* assertions, which are predicates which must hold at a given program point.
Assertions are a way to set ibreakpointsj in the resulting proof obligation. They may help
automatic provers and make the proof obligation more readable.

The Why tool can produce proof obligations for several automatic theorem provers, includ-
ing Alt-Ergo [AltErgo], Z3 [Z3], CVC3 [Barrett07], Simplify [Detlefs05] or Gappa [Gappa].
It can also produce proof obligations for a proof assistant such as Coq [Coq]. The Why tool
can also apply transformations to proof obligations. For instance, it can split conjunctions,
resulting in several simpler proof obligations. This is very handy to understand which part
of the proof obligation is not proved by automatic theorem provers.

Why features mutable variables, which are called references in the Why language, but the
type system ensures that they may not be aliased. In other words, if two mutable variables
x and y are in the context, then because the names ixj and iyj are dioeerent we know that
x and y are not the same references. Thus, if we modify x, then y is untouched.

To enforce the absence of aliases, the type system imposes some restrictions. In particular:

* when calling a function which takes two references as arguments, the references given

at call site must not be aliased;

* a reference cannot contain another reference.
The former ensures that functions can assume their arguments to be separated. The later
is quite restrictive as complex data structures such as linked lists cannot be written without
some encoding of a memory model.

Translating From Imperative To Functional The Why tool can be seen as a tool which
transforms an imperative program into a pure program. The transformation introduces a new
immutable variable xi for each assignment to a variable x. Variable xi will be used when
reading from x until x is assigned again. Let's illustrate the idea using an example:

22 CHAPTER 2. TECHNICAL BACKGROUND
int x = 1;
int y = 2;
x = x + y;
y = 3;
x = x + y;

Here is what we obtain:
let x1 = 1 in
let y1 = 2 in
let x2 = x1 + y1 in
let y2 = 3 in
let x3 = x2 + y2 in
()

This is a purely functional program which simulates the original imperative one. Note that
this also looks a lot like the hypotheses that would be available to prove a post-condition
on the program, using deductive verio/cation: we can view the successive values of mutable
variables as successive immutable variables.

To translate functions with side-eoeects, we encode them as functions which return not
only their return value but also the new values of the variables they modify. For instance,
the following imperative function:

int f(int* x, int* y)
{

*x = *x + *y;return

*x - *y;}

becomes the following pure function:
let f (x: int, y: int) =

let x1 = x + y in
(x1 - y, x1)

The o/rst component of the returned pair is the return value of the function, i.e. the translation
of *x - *y. The second component is the new value of x. Now consider the following caller:

int x = 1;
int y = 2;
int z = f(&x, &y);
return x + y + z

This call is translated into the following pure program:
let x = 1 in
let y = 2 in
let (z, x1) = f(x, y) in
x1 + y + z

The new value of x is retrieved from the pair returned by the call.

2.3. ALIAS-FREE PROGRAM VERIFICATION 23
2.3.2 The Boogie Intermediate Language
Boogie [Barnett05] is similar to Why in that it is an intermediate programming language:
C# programs are encoded in the Boogie programming language (Boogie PL), and programs
in Boogie PL are themselves encoded in the lower-level Boogie language. The Boogie tool
then computes proof obligations from these intermediate programs. Proof obligations can be
discharged automatically by the Z3 automatic prover. Boogie PL is also alias-free.

However the Boogie language itself, contrary to Why, is not an expression language but a
statement language. Its main instructions are havoc, assume and assert. It is remarkable
that these three operations are quite expressive. In this section we describe their semantics
and show how they can be used to encode basic constructions such as function calls and
loops.

The havoc x operation takes a variable x as an argument and assigns it to some value.
This value is unspecio/ed: this operation is non-deterministic. If we see the execution of the
program as a path, havoc is a crossroads: execution can continue on any path where nothing
has changed but, maybe, variable x.

The assert P operation takes a predicate P as an argument. Predicate P must hold
at the current program point: assert P produces P as a proof obligation. If we see the
execution of the program as a path, assert is a checkpoint. It does not restrict or add new
paths to the execution.

The assume P operation takes a predicate P as an argument and inserts it as an hy-
pothesis in the proof obligation. This predicate does not have to be proven. If we see the
execution of the program as a path, assume restricts possible paths by removing all paths
where P does not hold.

We can encode assignment x := e, if x does not appear in e, using havoc and assume:

havoc x
assume x = e

Indeed, the havoc operation allows the program execution to take any path where the value
of variable x has changed, but these paths are immediatly restricted by assume to those
where predicate x = e holds. Thus, the program will take the unique path where value of x
has changed and is now e.

We can encode the following while loop:

...
while (x > 0)

/*@ invariant P */
{

y = x;
x = y - 1;
};
...

using two Boogie programs. The o/rst program proves the body of the loop:
// assume loop invariant
assume P;
// assume we are in the loop
assume x > 0;
// assign y

24 CHAPTER 2. TECHNICAL BACKGROUND
havoc y;
assume y = x;
// assign x
havoc x;
assume x = y - 1;
// prove loop invariant is maintained
assert P;

The second program abtracts the loop as a black box and can be used to replace the loop in
the remaining of the program encoding:

...
// loop invariant must hold
assert P;
// the loop modio/es some variables x
havoc x;
// assume we are leaving the loop
assume x <= 0;
// the loop invariant holds
assume P;
...

Finally, we show how to encode functions and function calls. Say we have the following
function:

void incr(int* x)

//@ requires x >= 0
//@ ensures x > 0
{

int y = *x;

*x = y + 1;}

We can encode the function as:
// pre-condition
havoc x;
assume x >= 0;
// body
havoc y;
assume y = x;
havoc x;
assume x = y + 1;
// post-condition
assert x > 0;

Notice that the pre-condition is assumed, and the post-condition must be proved. Now say
we want to have the following call:

z = 42;
incr(&z);

This can be encoded as:

2.4. MEMORY MODELS FOR PROGRAMS WITH ALIAS 25
havoc z;
assume z = 42;
// pre-condition
assert z >= 0;
// function modio/es its argument
havoc z;
// post-condition
assume z > 0;

Notice that now, the pre-condition must be proved, and the post-condition is assumed. Notice
also that it is necessary to know which variables the call may modify. Here, incr modio/es
its argument z, hence the havoc z instruction.

2.4 Memory Models for Programs with Alias
To take into account the fact that pointers may or may not point to the same address, we
need to introduce a model of the heap in proof obligations. Several models are possible, and
we discuss some of them in this section.

2.4.1 Heap as a Single Array
A simple model is to represent the whole heap as an array H indexed by pointer addresses.
To this end, we introduce the theory of arrays. We model arrays using two functions select
and store. Given an array a and an index i, select(a, i) is the value of the cell of a at index
i. Given an array a, an index i and a value v, store(a, i, v) is a copy of the array a where the
contents of the cell at index i is replaced by v. We pose two axioms to reason about select
and store: 8

a, i, v. select(store(a, i, v), i) = v

and: 8

a, i, j, v. i 6= j ) select(store(a, i, v), j) = select(a, j)

This is enough to describe the whole heap if we represent the address of pointers as indexes
i in such an array a.

Consider the following function f:

void f(int* x, int* y)

/*@ ensures *x == 1 @*/
{

*x = 1;
*y = 2;}

Using the above model, the proof obligation for function f is:

8H, x, y. select(store(store(H, x, 1), y, 2), x) = 1
Intuitively, H is the heap at the beginning of the function. After the assignment to x, the heap
is then store(H, x, 1). After the assignment to y, the heap is then store(store(H, x, 1), y, 2).
This proof obligation cannot be discharged. Indeed, we cannot apply any of our two axioms
as we don't know whether x = y.

26 CHAPTER 2. TECHNICAL BACKGROUND

Here is one way to o/x the specio/cation of f:
void f(int* x, int* y)

/*@ ensures x <> y ==> *x == 1 @*/
{

*x = 1;
*y = 2;}

The proof obligation becomes:

8H, x, y. x 6= y ) select(store(store(H, x, 1), y, 2), x) = 1
Because we now have x 6= y as an hypothesis, we can apply our second axiom and simplify
the proof obligation as: 8

H, x. select(store(H, x, 1), x) = 1

which is an instance of our o/rst axiom with v = 1.

2.4.2 Need for Separation
The o/rst issue with the above naive approach is that proof obligations become quite compli-
cated. Indeed, consider what the programmer may have in mind for function f:

8x, y. x = 1 ^ y = 2 ) x = 1
Now consider the actual proof obligation:

8H, x, y. x 6= y ) select(store(store(H, x, 1), y, 2), x) = 1
This is much less readable and obvious, although it is still simple enough to be discharged
by automatic theorem provers.

Now consider a program which assigns a lot of variables:

{

*x0 = v0;
*x1 = v1;...

*xn = vn;}

To prove that *x0 is equal to v0, we have to prove that x0 is dioeerent than all variables
x1 to xn. This requires not only more work for the proof but also additional specio/cation
annotations in the program, to state that all variables are dioeerent. This quickly becomes
quite heavy and does not scale to bigger programs.

Another reason this approach does not scale is because it breaks modularity. Say you have
designed a library implementing some data structure set to represent sets of integers. Maybe
you used linked lists, maybe you used trees, but you want to hide this implementation to
ensure that you will be able to change it later if needed without adapting the whole program.
Say your library provides a function to add a new element into the set:

void add(set s, int i)

2.4. MEMORY MODELS FOR PROGRAMS WITH ALIAS 27
This function assigns some pointers belonging to the internal representation of the set. Now
let's use this function add:

void f(int* x)

/*@ ensures x = 0 */
{

*x = 0;add(l, 42);

}
Because add may modify any pointer of the heap H, including x, the proof obligation is not
provable: 8

x, H, H0, H00. H0 = store(H, x, 0) ) select(H00, x) = 0

Here, H is the heap at the beginning of function f, H0 is the heap after the assignment to
x, and H00 is the heap after the call to add. Because we do not know which pointers add
may assign, we know nothing about H00. To ensure the proof obligation for f is provable,
we need to specify which pointers add may assign, or, in other words, which pointers it will
leave unchanged. This can be specio/ed using an assigns clause. For instance, if add only
modio/es a o/eld named contents of set s:

void add(set s, int i)

/*@ assigns s.contents */

This assigns clause is comparable to a post-condition stating that the value of all locations
except s.contents has not changed. However, this assigns clause exposes the contents
o/eld of the set s, and thus modularity is broken.

To reason modularly about a data structure, we can view the set of locations representing
the data structure as a frame. From outside of the data structure, it is suOEcient to know that
only the locations of the frame may be modio/ed. The assigns clause is another instance of
a frame, used when applying a function. When we apply function add above, we know that
only the frame specio/ed by the assigns clause may be modio/ed by add. In logics with a
notion of frames such as separation logic [Reynolds02], dynamic frames [Kassios06] or regional
logic [Banerjee08], frame rules state that if the Hoare triple {P }C{Q} is valid, if C only
modio/es frame f and if R mentions no location of f , then the Hoare triple {P ^ R}C{Q ^ R}
is valid as well.

2.4.3 Component-as-Array: One Array Per Field
The Burstall-Bornat component-as-array [Bornat00] model is a simple way to achieve some
separation when records with multiple o/elds (C structures or Java objects, for instance) are
involved. The idea is that instead of using one single array for the whole heap, we use one
array per o/eld. For instance, say the programmer declared a pair record with two o/elds
first and second:

typedef struct {

int first;
int second;
} pair;

Assume two pair pointers p and q. There is no way for p->first to denote the same
memory cell as q->second unless type casts are allowed. This static information is used to

28 CHAPTER 2. TECHNICAL BACKGROUND
separate the heap into one array per declared o/eld. This way, if p->first is modio/ed, the
only part of the heap which is changed in the proof obligation is the array corresponding to
the first o/eld. The array for second is statically untouched.

Let's see an example of a program using the pair structure and compute its proof
obligation using the component-as-array model.

void incr(pair* p)

/*@ ensures p->first == \old(p->first) + 1 */
{

p->first = p->first + 1;
p->second = p->second + 1;
}

In the post-condition, \old(e) denotes the value of e before the call.

Without the component-as-array approach, the program is transformed into the following:

void incr(pairarray* h, pair* p)

/*@ ensures

select(*h, p).first == select(\old(*h), p).first + 1 */
{

*h = store(*h, p,setfirst(select(

*h, p), select(*h, p).first + 1));
*h = store(*h, p,setsecond(select(

*h, p), select(*h, p).second + 1));}

where pairarray, select and store form the array theory with type pointer for
indexes and type pair for values, and where setfirst and setsecond return a new
pair with o/eld first or second, respectively, being changed to the given value. Variable
h denotes the heap. To prove the post-condition we need to know that setsecond does not
modify o/eld first.

Using the component-as-array approach, we transform this program into the following:

void incr(intarray* first, intarray* second, pointer p)

/*@ ensures select(*first, p) == select(\old(*first), p)+1 */
{

*first = store(*first, p, select(*first, p) + 1);
*second = store(*second, p, select(*second, p) + 1);}

where intarray, select and store form the array theory with type pointer for indexes.
Heap h has been split into first and second. This version is compatible with the Why
no-alias restriction, as to assume first and second are separated is exactly what we want.
Here is the proof obligation which we can compute using Hoare logic rules given in Section 2.2:

8first, second, first0, second 0, p.
first0 = store(first, p, select(first, p) + 1)^
second0 = store(second, p, select(second, p) + 1))
select(first0, p) = select(first, p) + 1

There is no longer a single heap H, as it is separated into two arrays: first and second .
Because first and second are syntactically two dioeerent variables, when second is modio/ed

2.4. MEMORY MODELS FOR PROGRAMS WITH ALIAS 29
first is unchanged. Thus we do not have to prove that p->second and p->first represent
dioeerent memory cells.

Note that this model does not allow o/ner pointer arithmetic. It requires typing to ensures
record o/elds are separated from each other, which is not true in C if casts are allowed, but
is true in higher-level languages such as Java or OCaml. For instance, if p is a pointer on a
pair structure, the expression:

(int*) (((int) p) + sizeof(int))
may, in a o/ner memory model for the C language, actually be an integer pointer whose
pointed memory cell is physically the same as p->second. Such casts are incompatible
with the Burstall-Bornat component-as-array model and will not be considered in this thesis.

2.4.4 Regions: One Array Per Region
Another method we can use to split the heap into several arrays is regions, and has been
used in the Why platform by Thierry Hubert and Claude Marche' [Hubert07, Hubert08]. All
pointer types are given a unique region variable. These variables are then unio/ed using the
same unio/cation mechanism used in ML. After this unio/cation is done, if two variables x and
y still have dioeerent region variables, then we assume that x and y are separated, i.e. are
denote dioeerent memory cells. We then split the heap using one array per region.

Here is a program which illustrates the region mechanism:

void incr3(int* i, int* j, int* k)

/*@ ensures

*i = \old(*i) + 1&&
*j = \old(*j) + 1&&
*k = \old(*k) + 1 */{

*i = *i + 1;if (i != j)

*j = *j + 1;
*k = *k + 1;}

The three pointer variables i, j and k are each given a unique region variable, ri, rj and
rk. The unio/cation algorithm is then executed, and because of pointer comparison i != j,
region variables ri and rj are unio/ed into a single variable rij. So after unio/cation there are
only two regions: rij and rk, and the program is transformed into:

void incr3(intarray* rij, intarray* rk, pointer i,

pointer j, pointer k)
/*@ ensures

select(*rij, i) = select(\old(*rij), i) + 1
&& select(*rij, j) = select(\old(*rij), j) + 1
&& select(*rk, k) = select(\old(*rk), k) + 1 */
{

*rij = store(*rij, i, select(*rij, i) + 1);if (i != j)

*rij = store(*rij, j, select(*rij, j) + 1);

30 CHAPTER 2. TECHNICAL BACKGROUND

*rk = store(*rk, k, select(*rk, k) + 1);}
and here is the proof obligation, slightly re-arranged to avoid the duplication due to the if
statement: 8r

ij, r0ij, r00ij, rk, r0k, i, j, k.
r0ij = store(rij, i, select(rij, i) + 1)^

i 6= j ) r00ij = store(r0ij, j, select(rij, j) + 1)^
i = j ) r00ij = r0ij)
select(r00ij, i) = select(rij, i) + 1^
select(r00ij, j) = select(rij, j) + 1^
select(r0k, k) = select(rk, k) + 1

To prove the i and j parts of the post-condition, because they are in the same region, we
need to do a case split on whether i = j. To prove the k part we do not have to prove any
pointer dioeerence as k is in a fully separated region.

Note that this mechanism is not modular, as regions are unio/ed globally. This is a
limitation of the approach. In Capucine, we build upon this mechanism and add region
polymorphism to ensure we can verify each function without knowing the body of the others.

2.5 Preservation of Data Invariants Using Ownership
In Section 1.3 we introduced the notion of data invariants and showed why they were a
challenging problem. The key issue is to control which and when objects verify their in-
variants. To this end, methodologies have been proposed. In this section we present the
ownership methodology used in the Spec# platform [Barnett04b]. Boogie being an interme-
diate language of Spec#, this ownership methodology is sometimes refered to as the Boogie
methodology.

The Spec# ownership methodology can be summarized as follows:

1. objects may own other objects;
2. an object can only be owned by one other object (its owner);
3. objects may be open or closed;
4. a closed object must verify its invariant, and when closing an object, its invariant must

be shown valid;

5. a closed object cannot be modio/ed;
6. the invariant of a closed object may only depend on the objects it owns;
7. a closed object may only own closed objects.
In other words, objects are boxes which can contain other boxes. Obviously a given box
cannot be inside two boxes A and B at the same time, unless A is itself inside B or vice-
versa. And we cannot leave an open box inside a closed box.

Items 1 and 2 create an ownership tree between objects. This tree is dynamic in that it
may change during program execution.

Items 3, 4 and 5 allow to know which object verify their invariants. If an object is closed,
it must verify its invariant. If an object is open, its invariant may or may not hold. Open

2.5. PRESERVATION OF DATA INVARIANTS USING OWNERSHIP 31
objects are objects being modio/ed: their invariant is temporarily broken and will be restored
before closing the object.

Items 6 and 7 control what invariants may depend on. If the invariant of an object A
depends on the value of an object B, then modifying B might break the invariant of A.
To ensure this does not happen, the ownership methodology requires A to own B. If the
invariant of A is supposed to hold (i.e. A is closed), then B is also closed and may not be
modio/ed. To modify B, it must be opened o/rst, and to open B we must open A before.

Let's review a slightly modio/ed version of the example of Section 1.3:

typedef struct {

int value;
} positive;

/*@ invariant(positive p) = p.value > 0 */

typedef struct {

positive* first;
positive* second;
} pair;

/*@ invariant(pair p) =

p.first->value < p.second->value */

Because the invariant of the pair data structure depends on its o/elds first and second,
it must own them. These o/elds cannot be modio/ed if the pair structure is closed. This also
helps solving the problem of knowing which invariants hold. Indeed, if a pair is closed, then
its first and second o/elds should be closed too, as they are owned by the pair. Thus,
if a function takes a closed pair as an argument, we do not have to explicitly say that the
first and second o/elds of the pair are closed too. This also applies to recursive data
structures such as linked lists or trees.

In its original presentation [Barnett04b], the Spec# methodology is implemented in a
purely dynamic way: information about the open or closed state of objects is added as an
actual o/eld, named inv, in every object.

The inv o/eld can have three states: open, closed or committed1. If inv is open,
then the object is open; if inv is closed, then the object is closed and is not owned by
a closed object; if inv is committed, then the object is closed, and is owned by a closed
object.

This o/eld can then be referred to in the program specio/cation, in particular pre- and
post-conditions. For instance, a pre-condition of a function f which takes an argument x can
require x.inv to be closed or committed if the function requires the invariant of x to
hold. When calling f, it is usually easier to show this than to show the invariant of x holds.
Moreover, the caller does not have to know what the invariant actually is.

A pack operation can be used to change the state of an object from open to closed.
The invariant of the object being packed must be proven before. Thus, if x owns one o/eld
f, pack x can be encoded as:

assert x.inv == open;
assert x.f.inv == closed;

1The original presentation [Barnett04b] actually uses two boolean o/elds: inv which states whether the
object is closed, and committed which states whether the object is owned by a closed object. Moreover, inv
is actually a class name. All invariants of the class of inv and its ancestors hold.

32 CHAPTER 2. TECHNICAL BACKGROUND
assert invariant(x);
x.inv = closed;
x.f.inv = committed;

Note the third assert instruction which requires to prove the invariant of x actually holds.
The opposite operation, unpack x, can be encoded as:

assert x.inv == closed;
x.inv = open;
x.f.inv = closed;

We do not need to prove that x.f.inv is committed before, as the methodology will ensure
this always holds.

2.6 Permissions: Linear Information About Pointers or

Regions

Permissions, or capabilities, are a way to statically reason about variables. Unlike usual type
systems, which ensure that the type of a given expression will never change throughout the
reduction of the expression, permissions keep track of changes. At any given point of the
program, a set of permissions is available. Operations consume some of them and produce
some others. Because permissions cannot be duplicated, one cannot both consume it and keep
it for the rest of the program.

Garbage Collection A o/rst application of permissions is to keep track of which memory
cells are being used and which can be garbage collected, i.e. re-assigned for some other
purpose. For example, in the following C program:

int* x = malloc(sizeof(int));
int* y = malloc(sizeof(int));

*x = 42;
*y = *x + 69;free(x);

}
the memory cell denoted by pointer x is no longer used after the assignment to *y. Thus, x
can be safely freed.

To keep track of which memory cells can be freed, we associate a permission to each
variable. Here is the same program annotated with permissions:

// No permission is available here
int* x = malloc(sizeof(int));
// Permission x is available
int* y = malloc(sizeof(int));
// Permissions x and y are available

*x = 42;
*y = *x + 69;free(x);

// Permission y is available

2.6. PERMISSIONS: LINEAR INFORMATION ABOUT REGIONS 33
To sum up: the malloc operation produces a permission, the free operation consumes a
permission, and access *x requires permission x.

Using some inference mechanism, one can insert the free(x) operation automatically.
Indeed, if a permission is not required after a given program point, then its corresponding
variable can be freed, i.e. garbage collected.

Permissions and Regions An important issue is pointer aliasing. In the above example,
what if malloc returned the same pointer, i.e. the same memory address, to both x and
y ? Then we would have two permissions on the same memory cell. After the free(x)
operation, both pointers x and y would be freed and should no longer be read or written.
But permission y would still be available, and thus y could still be accessed, which is unsafe.
So we require the language to ensure that either aliases never happen, or they are controlled.

One way of controlling aliases is to use regions. We already introduced regions in Sec-
tion 2.4.4 to control aliasing in proof obligations. We use a type system where the type of
pointers is annotated by a region. Then, we use one permission per region: when the region is
created, its permission is introduced; when a pointer is added to or accessed from the region,
its permission is required; when a pointer is freed, all pointers of the region are actually freed
at the same time and the permission is consumed.

Translating Imperative Programs to Functional Programs Recent work by Arthur
Chargue'raud and Franc,ois Pottier [Chargue'raud08] uses permissions on regions to encode
imperative programs into a purely functional language. The idea is that because permissions
denote information about variables, and because permissions are capable of following changes
of such information during the execution of the program, such information can actually
represent the knowledge of the value of the variable.

The translation is based on the one we presented in Section 2.3.1, and extends it to handle
aliasing. This is done by representing regions as functional maps from locations to values.
Each time a permission is produced, a new map is produced to represent the new value of
the region. For instance, if the region of x is r, the assignment:

x = 1;
consumes the existing permission on r. In other words, the current value of the map rep-
resenting r is not used anymore. The operation produces the exact same permission on r.
This new permission is translated as a new map representing the new value r0 of r. So the
assignment is translated to the following pure program:

let r' = store(r, x, 1) in
...

As usual, store(r, x, 1) builds a map where each location has the same value as in r,
except x which now has value 1.

Also noteworthy are the allocation and deallocation operations. Allocation produces a
new permission, and thus a new map to represent the region in which the pointer is allocated.
Deallocation consumes the permission of a region, thus disabling the corresponding map, and
the region and all its locations are no longer accessible.

34 CHAPTER 2. TECHNICAL BACKGROUND
Chapter 3
Informal Presentation of the
Capucine Approach

3.1 Separation Using Regions and Permissions
In Section 2.3, we presented alias-free languages which require that, given two variables x
and y, those two variables are separated if, and only if the names x and y are dioeerent.
In Section 2.4 we presented how maps can encode aliasing in proof obligations, and how
pointers can be statically separated into dioeerent such maps. In Section 2.4.4 we showed how
those two approaches can be combined using regions. Say pointer p1 belongs to region r1
and pointer p2 to region r2. The approach of Thierry Hubert and Claude Marche' [Hubert07,
Hubert08] uses the names of regions r1 and r2 to know whether p1 may be aliased with p2
or not. If the names r1 and r2 are dioeerent, then p1 and p2 are statically separated: we know
thanks to typing that they will never denote the same memory cell. Thus we can use two
dioeerent maps to encode these pointers: one for each region. However, their approach is
limited as the region of a pointer cannot change during execution.

Capucine is based on the approach of Section 2.4.4, extended with permissions as intro-
duced in Section 2.6 to allow greater AEexibility. In this section, we show the region language
of Capucine and how permissions are used to specify separation. We also present region
operations which can be used to move pointers from their current region to another, with
some restrictions expressed using permissions.

Example of Capucine Program In Capucine, regions are explicit in pointer types. Let's
review the example of Section 2.4.4 in the Capucine language. First, let's introduce the Long
class1:

class Long{

1We use term class to denote records associated with owned regions and invariants. Owned regions and
invariants are introduced in Section 3.2 and Section 3.3 respectively. In this thesis, term class is thus not
related to object-oriented programming. In particular, inheritance is not considered. However, as this thesis
is based on work about object invariants where invariants are attached to classes, we choose to stick with
this terminology.

35

36 CHAPTER 3. INFORMAL PRESENTATION OF CAPUCINE

value: int;}
This class is a simple record with one integer o/eld named value. This is how integer references
are encoded in Capucine. This is similar to OCaml references, as they are actually mutable
records with one o/eld.

Now let's see how function incr3 is written:

fun incr3 [ae1 : Long, ae2 : Long](i: [ae1 ], j : [ae1 ], k : [ae2 ]): unit

consumes ae1 ae2
produces ae1 ae2{

i.value  i.value + 1;
if (i 6= j ){

j .value  j .value + 1;}
else {};
k.value  k.value + 1;}

Function incr3 takes three pointers as arguments: i, j and k . Pointers i and j have type
[ae1 ] while pointer k has type [ae2 ]. Type [ae] reads iat aej and is the type of pointers of region
ae. Here, ae1 and ae2 are parameters of function incr3 , of class Long. This means that i, j
and k are objects of class Long.2

Separation Because i and j belongs to the same region ae1 , they may be the same pointer.
However, k belongs to ae2 and will never be equal to i or j .

To ensure ae1 and ae2 are dioeerent regions, function incr3 consumes two permissions:
one on ae1 and one on ae2 . The type system ensures that permissions cannot be duplicated.
Function incr3 cannot be called with ae1 = ae2 , as then two permissions on the same region
ae1 would be required.

The Why language introduced in Section 2.3.1 ensures absence of aliases by requiring that
a reference cannot appear as two arguments of the same function call. In Capucine we use
the same kind of restriction, but on regions instead of pointers.

To sum up, to call incr3 we not only need three pointer arguments i, j and k. We also
need their regions ae1 (for i and j ) and ae2 (for k ) and permissions on these two regions.
These permissions are consumed by the call, but are also produced: in fact, they are merely
required.

Singleton and Group Permissions In the above example, we denoted permission on ae1
by ae1 , and permission on ae2 by ae2 . But in Capucine the language of permission is actually
richer and there is no such thing as a permission ae. Let's introduce two possible permissions
for a given region ae: permissions ae* and aeG.

Permission ae* not only denotes that we have a permission on region ae, but also that ae is
a singleton region, while permission aeG denotes that ae is a group region. A singleton region
contains exactly one pointer. It is thus exactly the same as a reference in a language such

2As we use term class, it seems natural to use term object for values of class types. Again, this is not
necessarily related to object-oriented programming.

3.1. SEPARATION USING REGIONS AND PERMISSIONS 37
as Why. A group region may contain any number of pointers, zero and one included. Thus
permission ae* is strictly stronger than permission aeG. The header of function incr3 should
actually be written:

fun incr3 [ae1 : Long, ae2 : Long](i: [ae1 ], j : [ae1 ], k : [ae2 ]): unit

consumes ae1 G ae2 *
produces ae1 G ae2 *

Indeed, ae1 may contain at least two pointers i and j . If ae1 * was required instead of ae1 G,
function incr3 could only be called with i = j . Permission ae2 G could be required instead of
ae2 *, but as incr3 does not expect several pointers in ae2 we might as well require ae2 to be
singleton.

Empty Permission Permission ae; denotes the fact that region ae is empty, i.e. it contains
exactly zero pointers. As ae*, it is strictly stronger than aeG. Permission ae; is the permission
which is produced when introducing a new region using the following operation:

let region ae: Long
This operation introduces a new region ae, with permission ae;, containing pointers of class
Long. The scope of ae is the current statement block. In particular, ae and its current
permission is no longer available outside the function it is declared in.

Because ae; and ae* are stronger than aeG, Capucine provides weakening operations which
weakens permissions ae; and ae* into aeG:

weaken empty ae

weaken single ae

The o/rst operation consumes ae; and produces aeG. The second operation consumes ae* and
produces aeG. This is sometimes useful, for instance if a function consumes a group region
and all you have is a singleton region.

Allocation To create a new object, Capucine provides the following operation:

let x = new [ae]
where ae is an empty region, i.e. permission ae; is consumed. A pointer is allocated in region
ae which thus becomes singleton: permission ae* is produced. The address of the pointer is
put in variable x , which has type [ae]. There is no null pointer as in, for instance, Java or C.

Assignment An assignment such as x .f  e can only be done if x is a pointer in a singleton
region. The intuition behind this restriction is that if a pointer is potentially aliased, i.e. is in
a group region, we don't know exactly which variables of the program are actually modio/ed
when the pointer is assigned to another value. Whereas if a pointer is in a singleton region
ae, we know that the only variables of the program which may be modio/ed are exactly all
variables of region ae.

Focus and Unfocus Function incr3 uses several assignments, some in singleton region
ae2 :

k .value  k .value + 1

38 CHAPTER 3. INFORMAL PRESENTATION OF CAPUCINE
and some in group region ae1 :

i.value  i.value + 1
j .value  j .value + 1

However, we just said in the above paragraph that the only pointers which can be assigned
are pointers belonging to singleton regions. To allow assignment of pointers in group regions,
we introduce operations allowing to move pointers from their regions to other regions. This
justio/es the need for permissions instead of simply separating regions using their names.

The focus operation transfers a pointer p from a group region ae to an empty region oe,
which then becomes singleton. The transfered pointer then belongs to several regions at the
same time: its original group region ae and the target region oe. To ensure that pointers of
region ae are not accessed while pointer p is focused, region ae is temporarily disabled: its
permission aeG is consumed and permission oe -ffi ae is produced to replace it. Permission
oe -ffi ae is inspired by linear implication of linear logic, and its intuitive meaning is: if you
give oe*, you can get aeG back. To sum up, the following operation:

focus x : ae as oe
assumes x has type [ae], consumes aeG and oe;, and produces oe -ffi ae and oe*. The type of x is
changed into [oe].

The unfocus operation is the opposite of the focus operation: it takes a focused pointer
and puts it back in its original region. The following operation:

unfocus x : oe as ae
assumes x has type [oe], consumes oe* and oe -ffi ae, and produces aeG. The type of x is changed
into [ae]. No permission on oe is produced: the region is no longer usable. Usually, focus
operations are used to assign a pointer which is in a group region; target region oe is thus
temporary.

Now that we have introduced singleton and group regions, as well as focus and unfocus
operations, we can actually assign pointers in group regions. Here is how we can assign
i.value in the incr3 example:

let region aei: Long; aei ;, ae1 G, ae2 *
focus i: ae1 as aei ; aei *, aei -ffi ae1 , ae2 *
i.value  i.value + 1; aei *, aei -ffi ae1 , ae2 *
unfocus i: aei as ae1 ; ae1 G, ae2 *

On the right side are the available permissions at the current program point.

Adoption The adoption operation can be used to transfer a pointer from a singleton region
to a group region:

adopt x : oe as ae
It is similar to the unfocus operation, except that pointer x was not originally in ae. This
operation consumes permissions oe* and aeG, as pointer x of singleton region oe is transfered
to group region ae. Permission aeG is produced, but no permission on oe is available after the
adoption: the region is no longer usable.

A typical sequence used in Capucine is allocation followed by adoption, to create a new
pointer in a group region ae:

3.2. MODULARITY USING REGION OWNERSHIP 39
let region oe: Long; oe;, aeG
let x = new [oe]; oe*, aeG
x .value  69; oe*, aeG
adopt x : oe in ae; aeG

After this sequence, region ae contains a new Long pointer of value 69.

3.2 Modularity Using Region Ownership
Capucine features region ownership. Region ownership is similar to object ownership which
can be used to allow object invariants to mention other objects, as was discussed in Sec-
tion 2.5. However, while with object ownership, objects own other objects, with region
ownership objects own regions. If an object owns a group region, it owns all the objects of
the region. Capucine also uses ownership to extend the expressiveness of invariants, and we
will discuss this in Section 3.3. In this section, we introduce region ownership as a way to
improve modularity.

Motivation Let's motivate ownership using an example. Consider class Pair , which con-
tains two Long o/elds:

class Pair [ae1 : Long, ae2 : Long]{

left: [ae1 ];
right: [ae2 ];}

Regions ae1 and ae2 are region parameters of class Pair . This is similar to the type parameters
of ML, and is a form of polymorphism: class Pair can be used with several regions for its
left and right o/elds.

Now consider function incrPair , which increments the two o/elds of a Pair object:

fun incrPair [ael : Long, aer : Long, aep: Pair [ael , aer ] ] (p: [aep])

consumes aep* ael * aer *
produces aep* ael * aer *{

let l = p.left;
l.value  l .value + 1;
let r = p.right;
r.value  r .value + 1;}

As you can see, function incrPair must take three region parameters: not only the region
aep of its Pair argument p, but also the regions ael and aer of the left and right o/elds. On
more complex data structures, it quickly becomes tedious to enumerate all involved regions.
Moreover, it is impossible in some cases such as linked lists where the number of involved
objects is not known statically.

But the most important motivation for ownership is being able to write data invariants
which depend on more locations than just the o/elds of the class. Consider the following
invariant for class Pair :

40 CHAPTER 3. INFORMAL PRESENTATION OF CAPUCINE
invariant left.value < right.value
To maintain such an invariant, we have to ensure that o/eld value of pointers left and right
cannot be modio/ed without the invariant being checked. As we have shown in Section 2.5,
ownership is one way to ensure this property.

Ownership It is natural to think of o/elds left and right as belonging to their Pair object.
They are owned by it. Instead of using region parameters for o/elds left and right, Capucine
allows class Pair to encapsulate their regions using region ownership:

class Pair{

single ael : Long, aer : Long;
left: [ael ];
right: [aer ];}

This class declaration contains two owned singleton regions ael and aer , which are used for
o/elds left and right respectively.

If given a Pair object, say a variable x of type [ae] with ae being a Pair region, region
expressions x .ael and x .aer denote the owned regions of x . Thus x .left has type [x .ael ] and
x .right has type [x .aer ].

Permission ae* encapsulates permissions on owned regions x .ael * and x .aer * for x of type
[ae]. To access these permissions we need to unpack x using the unpack operation. This
operation consumes ae* and produces aeffi, x .ael * and x .aer *. Permission aeffi denotes that ae is
singleton, but is currently unpacked. The opposite operation is pack. Packing x consumes
aeffi, x .ael * and x .aer * and produces ae*.

Function incrPair can then be implemented as:

fun incrPair [aep: Pair ] (p: [aep])

consumes aep*
produces aep*{

unpack p; p.ael *, p.aer *, aepffi
let l = p.left; p.ael *, p.aer *, aepffi
l.value  l .value + 1; p.ael *, p.aer *, aepffi
let r = p.right; p.ael *, p.aer *, aepffi
r.value  r .value + 1; p.ael *, p.aer *, aepffi
pack p; aep*}

To assign l .value and r.value, we need permissions on p.ael and p.aer . This is why we unpack
p at the beginning of the function. We pack it at the end to restore permission aep*.

Allocation Allocating a new Pair pointer p in a region ae produces permissions aeffi, p.ael ;
and p.aer ;. Indeed, the object is not initialized, and so the ael and aer regions are empty.
Region ae is still open, as to be packed it requires permissions p.ael * and p.aer *.

We extend permission aeffi to carry information about which o/elds are initialized. We
denote by aeffi{f1 , * * *, fk } the permission stating that ae contains a unique location to an

3.3. INVARIANTS USING PERMISSIONS AND OWNERSHIP 41
object whose o/elds are all initialized but f1 , * * *, fk . Permission aeffi is a shortcut for aeffi{}.
Assignment x .f  e removes f from the set of uninitialized o/elds.

Here is a constructor for a Pair :

fun create [aep: Pair ] (): [aep]

consumes aep;
produces aep*{

let p = new [aep]; p.ael ;, p.aer ;, aepffi{left, right}
let l = new [p.ael ]; p.ael ffi{value}, p.aer ;, aepffi{left, right}
l.value  0; p.ael ffi, p.aer ;, aepffi{left, right}
pack l; p.ael *, p.aer ;, aepffi{left, right}
p.left  l ; p.ael *, p.aer ;, aepffi{right}
let r = new [p.aer ]; p.ael *, p.aer ffi{value}, aepffi{right}
r.value  0; p.ael *, p.aer ffi, aepffi{right}
pack r; p.ael *, p.aer *, aepffi{right}
p.right  r ; p.ael *, p.aer *, aepffi
pack p; aep*
return p; aep*}

Modularity Ownership opens up abstraction possibilities. Indeed, objects encapsulate
their owned objects. Functions which do not access the owned objects need not know about
their existence. For instance, consider the following function:

fun twice [aep: Pair ] (p: [aep])

consumes aep*
produces aep*{

incrPair [aep] (p);
incrPair [aep] (p);}

Function twice does not need to know anything about the implementation of Pair and of
incrPair . This means that the Pair type could be abstract: o/elds left and right, as well
as owned regions ael and aer , could be hidden and yet function twice would not need to be
adapted.

Several module systems could be considered to extend Capucine with abstraction: reo/ne-
ment and functors for instance are good candidates. The choice is orthogonal to the work of
this thesis though, and we will not discuss it here.

3.3 Invariants Using Permissions and Ownership
Capucine features object invariants. Permissions are used to track which invariants hold, and
ownership is used to allow invariants to depend on other objects.

Permissions Track Invariant States Let's illustrate the invariant mechanism on a simple
example: positive integers. We deo/ne class PosInt:

42 CHAPTER 3. INFORMAL PRESENTATION OF CAPUCINE
class PosInt{

value: int;
invariant value >= 0;}

This class has only one integer o/eld value which, according to the invariant, should always
be positive (or zero).

To track the state of invariants, we use permissions aeffi and ae*. They have already been
introduced in previous sections. They both imply region ae is singleton, but aeffi means that ae
is open while ae* means that ae is closed. Until now, we only used this distinction because of
ownership. Now we add a new meaning to permission ae*: if ae* is available, the pointer of
ae must verify its invariant. If aeffi is available, the invariant may be broken. The invariant is
checked when packing.

Moreover, we now require permission aeffi to assign the o/elds of the pointer of ae. This is
the same requirement than the one which was used in Section 2.5: only open pointers may
be modio/ed, as their invariant is not required to hold. However, instead of using a special
state o/eld we use permissions.

Here is an example of function which maintains the invariant of a PosInt object:

fun incr [ae: PosInt] (p: [ae]): unit

consumes ae*
produces ae*{

unpack p; aeffi
p.value  p.value + 1; aeffi
pack p; ae*}

Because incr consumes permission ae*, the invariant of p must hold when incr is called.
Because incr produces permission ae*, the invariant is maintained by a call to incr .

Here is an example of function which does not require the invariant of a PosInt object,
but which nevertheless ensures the invariant holds after the call:

fun abs [ae: PosInt] (p: [ae]): unit

consumes aeffi
produces ae*{

if p.value < 0 then{

p.value  -p.value;}
;
pack p;}

Because this function consumes aeffi, and not ae*, the invariant of p is not required to hold
at the beginning. However, it holds at the end, and this is reAEected by the fact that ae* is
produced by abs.

A typical example of function which initializes the invariant of an object is its constructor,
i.e. a function which allocates and initializes the object:

3.3. INVARIANTS USING PERMISSIONS AND OWNERSHIP 43
fun create [ae: PosInt] (i: int): [ae]

pre i >= 0
consumes ae;
produces ae*{

let p = new [ae]; aeffi{value}
p.value  i; aeffi
pack p; ae*}

This constructor takes an empty region ae and an integer i. The pre-condition requires i to
be positive or null. The function returns a new pointer, allocated in region ae, with initial
value i. The invariant is thus verio/ed, and this is reAEected by the fact that ae* is produced.
Note that allocation produces permission aeffi, and not ae*. This is important in our system.
Indeed, allocation does not initializes invariants.

An object of a group region is always closed. Permission aeG states that all objects of ae
verify their invariant.

Ownership Extends Invariant Expressiveness If the invariant of an object A depends
on the value of an object B, then B should not be modio/ed without checking that the mod-
io/cation does not break the invariant of A. As we have already discussed in Section 2.5,
ownership is a means to achieve exactly this goal: if A owns B, and if the ownership method-
ology prevents B from being modio/ed if the invariant of A is supposed to hold, then the
invariant of A cannot be broken.

In Capucine, the invariant of a class may only depend on o/elds which are transitively
owned by the class. A o/eld is transitively owned by a class if either it is a o/eld of the class,
or it is the o/eld of an object which is in a region owned by the class. For instance, if a classC

owns a region r of class C0, if C has a o/eld f of type [r ], and if C0 has a o/eld g, then C
transitively owns f .g and its invariant may thus depend on f .g.

Then the region ownership system of Capucine prevents invariants from being broken
unexpectedly. Indeed, to modify an object B owned by an object A, we require the open
permission aebffi on the region aeb of object B. But this permission can only be available if A
has been unpacked o/rst, and thus if permission aea ffi on the region aea of object A is available.
Thus the invariant of A is not expected to hold when B can be modio/ed.

For instance, let's add an invariant to class Pair :

class Pair{

single ael : Long, aer : Long;
left: [ael ];
right: [aer ];
invariant left.value < right.value;}

The invariant only depends on the value o/eld of the left and right o/elds, which are owned by
the Pair , so the invariant is valid.

As we have introduced the new requirement that pointers should be open before their
o/elds are modio/ed, we have to rewrite incrPair :

fun incrPair [aep: Pair ] (p: [aep])

44 CHAPTER 3. INFORMAL PRESENTATION OF CAPUCINE

consumes aep*
produces aep*{

unpack p; p.ael *, p.aer *, aepffi
let l = p.left; p.ael *, p.aer *, aepffi
unpack l ; p.ael ffi, p.aer *, aepffi
l.value  l .value + 1; p.ael ffi, p.aer *, aepffi
pack l; p.ael *, p.aer *, aepffi
let r = p.right; p.ael *, p.aer *, aepffi
unpack r ; p.ael *, p.aer ffi, aepffi
r.value  r .value + 1; p.ael *, p.aer ffi, aepffi
pack r; p.ael *, p.aer *, aepffi
pack p; aep*}

As you can see, before modifying p.left.value, we have to unpack p.left, and before unpacking
p.left we have to unpack p. So the invariant of p is not required to hold before the pack p in-
struction. In fact, this invariant can be temporarily broken if p.left.value = p.right.value - 1
at the beginning of the function. But the invariant is re-established before p is packed and
its invariant is required to hold again.

3.4 Examples
3.4.1 Bounded Arrays
As a o/rst example, we deo/ne the bounded arrays data structure in Capucine. Bounded arrays
are arrays of constent length. Pre-conditions prevent reading or writing outside of the array.

Logic Arrays First we deo/ne logic arrays in Capucine. This is the theory of arrays which
we introduced in Section 2.4.1. Here is the corresponding Capucine code:

type larray (ff)

logic store (a: larray (ff), i: int, v: ff): larray (ff)
logic select (a: larray (ff), i: int): ff
axiom selectEq:8

a: larray (ff).8
i: int.8
v: ff.
select(store(a, i, v ), i) = v

axiom selectNeq:8

a: larray (ff).8
i: int.8
j : int.8
v: ff.

3.4. EXAMPLES 45

i 6= j )
select(store(a, i, v ), j ) = select(a, j )

This code illustrates how Capucine features logic type declarations using the type keyword,
logic functions declarations using the logic keyword and axiomatizations of them using the
axiom keyword. This allows the user to introduce new pure types using o/rst-order logic
axiomatizations. Here, arrays are polymorphic: the ff argument of type larray is a type
parameter as in ML.

Bounded Arrays: Class Deo/nition We now deo/ne mutable bounded arrays in Capucine.
A bounded array is a reference to a logic array and a size.

class array (ff){

length: int;
contents: larray (ff);
invariant length >= 0}

The invariant states that the size of an array is always positive or null.
Bounded Arrays: Creation Function arrayCreate returns a new bounded array. It takes
a region argument ae in which the new array will be created, and an integer size which will
be the size of the array.

fun arrayCreate [ae: array (ff)] (size: int): [ae]

consumes ae;
produces ae*
pre size >= 0
post result.length = size{

let res = new array (ff) [ae];
res.length  size;
return res}

As the consumes and produces clause states, region ae must be empty before the call and is
singleton after. Indeed, in Capucine pointers are allocated in empty regions, which thus be-
come singleton. Note that we omitted the pack res statement, which is inferred by Capucine
just before the return statement.

Bounded Arrays: Reading Function arrayGet takes a bounded array a in a region ae
and an index i, and returns the item stored at index i:

fun arrayGet [ae: array (ff)] (a: [ae], i: int): ff

consumes ae*
produces ae*
pre 0 <= i ^ i < a.length
post result = select(a.contents, i){

46 CHAPTER 3. INFORMAL PRESENTATION OF CAPUCINE

return select(a.contents, i)}
This function returns the stored value using logic function select. Function arrayGet also
requires the index i to be inside the array. This is how we model array bound checks.

Bounded Arrays: Writing Similarly to the arrayGet function, arraySet encapsulates
logic function store for bounded arrays:

fun arraySet [ae: array (ff)] (a: [ae], i: int, v: ff): unit

consumes ae*
produces ae*
pre 0 <= i ^ i < a.length
post

a.contents = store(a.contents@pre, i, v ) ^
a.length = a.length@pre{

use invariant a;
unpack a;
a.contents  store(a.contents, i, v);
pack a;}

The post-condition states that the length o/eld has not changed. Term t@pre is term t at
position pre, which is the position corresponding to the beginning of the function. It is thus
the value of t before the call. The post-condition also states how contents is modio/ed.

Statement use invariant a requires permission ae*, which is indeed required by function
arraySet, and introduces the invariant of a in the hypotheses of proof obligations. Here, there
are two proof obligations: the post-condition and the invariant. Indeed, the pack statement
generates the invariant of the new a as a proof obligation. To prove this invariant (size is
positive or null) we use the hypothesis introduced by the use invariant statement (size was
positive or null).

3.4.2 Bounded Arrays: Proof Obligations
We now show the verio/cation conditions which are produced by the bounded arrays example
to give an intuition of what the user has to prove and what the memory model looks like.

Regions, Locations and Objects We use the approach of Section 2.4.4 to model region.
Regions are encoded as maps from locations to objects. Their type is region (ff) where ff is
a type parameter corresponding to the type of objects, which we will hide in this section to
ease reading. Locations are values of a type called location. An object is a tuple where each
component corresponds to a o/eld of the data structure.

Function get is similar to select, and function set is similar to store. Term get(r, p)
returns the object at location p in region r ; and set(r , p, o) returns a copy of region r where
the object at location p is now o.

Chapter 4 formalizes the memory model, i.e. the notion of region and objects. Chapter 5
formalizes how verio/cation conditions are computed.

3.4. EXAMPLES 47
Bounded Arrays: Creation The inferred pack statement of function arrayCreate gen-
erates the invariant of res as a proof obligation, which is ensured by the pre-condition. Here
is the (slightly simplio/ed) logic formula:

8ae: region, 8size: int, 8res: location,

size >= 0 )
length(get(ae, res)) = size )

length(get(ae, res)) >= 0

This formula is valid and is simple enough to be discharged automatically by most SMT
solvers. We obtain the object at location res in region ae using get(ae, res). We read the
length o/eld of this object using a function which we call length.

The second proof obligation of function arrayCreate corresponds to the post-condition:

8ae: region, 8size: int, 8res: location,

size >= 0 )
length(get(ae, res)) = size )

length(get(ae, res)) = size

This formula is valid as well.

Bounded Arrays: Reading There is only one proof obligation for function arrayGet,
which corresponds to the post-condition:

8ae: region, 8a: location, 8i: int,

0 <= i < length(get(ae, a)) )
select(contents(get(ae, a)), i) = select(contents(get(ae, a)), i)

The contents function returns the value of the contents o/eld, i.e. a logic array. This formula
is valid.

Bounded Arrays: Writing Here is the proof obligation due to the pack statement of
function arraySet:

8ae: region, 8a: location, 8v: ff, 8i: int,

0 <= i < length(get(ae, a)) )

length(get(ae, a)) >= 0 )8

ae0: region,
ae0 = set(ae, a, setcontents(get(ae, a), store(contents(get(ae, a)), i, v))) )

length(get(ae0, a)) >= 0

Hypothesis length(get(ae, a)) >= 0 was introduced by the use invariant statement. The new
value ae0 of region ae is due to the assignment. Function setcontents takes an object and
modio/es its contents o/eld, leaving its length o/eld unchanged. This is part of the memory
model, and axioms are provided to state this separation property. This formula is, once
again, valid and can be proved automatically by most SMT solvers.

The second proof obligation of function arraySet corresponds to the post-condition. It
has similar hypotheses, but instead of having to prove that the length is positive or null, we
need to prove the post-condition:

48 CHAPTER 3. INFORMAL PRESENTATION OF CAPUCINE

8ae: region, 8a: location, 8v: ff, 8i: int,

0 <= i < length(get(ae, a)) )

length(get(ae, a)) >= 0 )8

ae0: region,
ae0 = set(ae, a, setcontents(get(ae, a), store(contents(get(ae, a)), i, v))) )

contents(get(ae0, a)) = store(contents(get(ae, a)), i, v )^

length(get(ae0, a)) = length(get(ae, a))

This formula is also valid and can be proved automatically by theorem provers.

Component-as-Array Another version of the proof obligation due to the pack statement
of function arraySet can be obtained by using further separation techniques inspired by the
component-as-array model [Bornat00]:

8aelength : region, 8aecontents: region, 8a: location, 8v : ff, 8i: int,

0 <= i < get(aelength , a) )

get(aelength , a) >= 0 )8

aecontents 0: region,
aecontents0 = set(aecontents , a, store(get(aecontents, a), i, v)) )

get(aelength , a) >= 0

The idea is that ae is decomposed into aelength and aecontents, where aelength is a map from
pointers to the value of the length o/eld of their object, and aecontents is a map from pointers
to the value of the contents o/eld of their object. This version does not require axioms stating
that length and contents are separated, and is thus much easier to prove. It is valid and can
be proved automatically.

3.4.3 Sparse Arrays
In this section we illustrate the Capucine approach on the constant-time sparse arrays chal-
lenge of the VACID benchmarks [Leino10]. These benchmarks are a collection of short
programs proposed by K. Rustan M. Leino and Michal/ Moskal which illustrate some of the
challenges in modular deductive verio/cation. They involve data structures with aliases as
well as data invariants.

The Sparse Arrays Challenge The sparse arrays challenge is posed on the code of
Figure 3.1. It is written using a syntax close to Java, but the use of classes is not important
and, as indicated in the article [Leino10], we assume arrays allocated using new are not
initialized. Array are of constant length. We have altered the original code slightly, by
replacing the implicit array allocation of Java by explicit allocations in the constructor. This
allows the creation of arrays of any size sz given as parameter, instead of a constant size
MAXLEN.

Class SparseArray implements a sparse array data structure. It provides the usual
array functions create, get and set. What is interesting about sparse arrays is that,
as read and write functions get and set do, allocation create runs in constant time.
Indeed, create does not initialize internal arrays, yet reading an uninitialized index with
get returns DEFAULT.

Sparse arrays are implemented using three arrays val, idx and back and two integers
size and n. Array val contains actual values of the sparse array. Value n is the number of

3.4. EXAMPLES 49
class SparseArray {

static final int DEFAULT = 0;
int val[];
uint idx[], back [];
uint n, uint size;

static SparseArray create(uint sz) {

SparseArray t = new SparseArray();
val = new int[sz];
idx = new uint[sz];
back = new uint[sz];
n = 0;
size = sz;
return t;
}

int get(uint i) {

if (idx[i] < n && back[idx[i]] == i)

return val[i];
else

return DEFAULT;
}

void set(uint i, int v) {

val[i] = v;
if (!(idx[i] < n && back[idx[i]] == i)) {

assert(n < size);
idx[i] = n;
back[n] = i;
n = n + 1;
}
}

static void sparseArrayTestHarness() {

SparseArray a = create(10), b = create(20);
assert(a.get(5) == DEFAULT && b.get(7) == DEFAULT);
a.set(5, 1); b.set(7, 2);
assert(a.get(0) == DEFAULT && b.get(0) == DEFAULT);
assert(a.get(5) == 1 && b.get(7) == 2);
assert(a.get(7) == DEFAULT && b.get(5) == DEFAULT);
}
}

Figure 3.1: Pseudo-Java code for the Sparse Arrays challenge

50 CHAPTER 3. INFORMAL PRESENTATION OF CAPUCINE

val b a c

idx 1 0 2
back 9 4 12

Figure 3.2: Example of State of a Sparse Array Structure
dioeerent cells which have been assigned using set. Array back contains, in cells 0 to n - 1,
the indexes of these assigned cells. Array idx allows to know where in back these indexes
appear. Thus, cells 0 to n - 1 of back are in bijection with the corresponding cells of idx.

Figure 3.2 illustrates the state of the structure after three items a, b and c have been
added, in this order, in indexes 9, 4 and 12 respectively. Darker cells are cells which have
not been assigned yet. First item a, of index 9, was associated with index 0 in array idx,
and its actual index 9 is stored at index 0 of array back.

Method get reads index d using the following method. First, read the internal index i
stored in idx[d]. Then, if not 0 <= i < n then we are sure that cell i has not been initialized
and thus that no item was inserted at index d, and the default value should be returned.
Else if 0 <= i < n then read index d0 stored in back[i]. If d0 = d then an item has indeed
been inserted at index d, so val[d] should be returned. Else the default value should be
returned.

The assert statements are verio/cations to be made. A o/rst one appears in method
set. The others appear in method sparseArrayTestHarness which tests the structure
on simple data. This could feel easy at o/rst sight _ indeed it would be suOEcient to run
the program and check that these assertions hold _ but the goal is to verify the program
modularly and statically. We should thus be capable of specifying pre- and post-conditions
for methods get and set, suOEcient to establish the assertions.

Please note that we have added an additional assertion to the original code [Leino10]:
the last one, which is the only one which tests that a and b are actually separated. Indeed,
what makes this program even harder to verify is that method create must be specio/ed
such that variables a and b of method sparseArrayTestHarness do not share data. For
instance, how can we ensure that a.idx and b.idx are not the same arrays? Capucine
and its type system using regions and permissions provides a methodology to annotate the
program using such separation information.

Sparse Arrays: Class Deo/nition We use the bounded arrays that we introduced in
Section 3.4.1 to implement sparse arrays:

class sparse (ff){

3.4. EXAMPLES 51

single Rvalue: array (ff), Ridx : array (int), Rback: array (int);
value: [Rvalue];
idx : [Ridx ];
back : [Rback];
n: int;
default: ff;
size: int;

invariant

0 <= n <= size ^
value.length = size ^
idx .length = size ^
back.length = size ^8

i: int.
0 <= i < n )
0 <= select(back .contents, i) < size ^
select(idx .contents, select(back .contents, i)) = i}

Class sparse owns three singleton regions: Rvalue, Ridx and Rback . It contains six o/elds.
The o/rst three are the three internal arrays of the sparse array data structure: value, idx
and back. They are implemented using our bounded arrays, and are thus pointers. Their
respective regions are Rvalue, Ridx and Rback . Field n is the number of inserted values in the
sparse array. Field default replaces constant DEFAULT of the original code. It is necessary
as our sparse arrays are polymorph (type variable ff). The default value will be given to the
constructor. Finally, o/eld size contains the size of the sparse array.

The invariant states that n is between 0 and size (included). If n = size, the array is full.
The invariant also states that the length of internal arrays is size. This will be used to prove
the pre-condition when calling arrayGet. Finally, the invariant states the relation between
idx and back, which is that for all already-inserted index i, we have idx [back [i] ] = i.

Sparse Arrays: Model We express the specio/cation of our sparse array functions using
an abstract model deo/ned as follows. First we introduce the isElt predicate, which takes an
array a and an integer i, and states that i was inserted in a before:

logic isElt [ae: sparse (ff)] (a: [ae], i: int) =

0 <= select(a.idx .contents, i) < a.n ^
select(a.back .contents, select(a.idx .contents, i)) = i

As isElt takes pointer a as an argument, it also takes its region ae. Indeed, a pointer can only
be read from a given region. Here, a.idx actually means that we read the idx o/eld of pointer
a in region ae. And a.idx .contents actually means that we read the contents o/eld of pointer
a.idx in region a.Ridx , which is itself read from the Ridx region of pointer a in region ae.

Then we axiomatize the model logic function, which takes a sparse array a and an integer
i, and returns the value stored at index i in a. It is thus the equivalent of select for sparse
arrays.

logic model [ae: sparse (ff)] (a: [ae], i: int): ff

52 CHAPTER 3. INFORMAL PRESENTATION OF CAPUCINE
Again, logic function model also takes a region ae as parameter, as it reads o/elds from pointer
argument a. This logic function is deo/ned using two axioms:

axiom modelIn:8

region ae: sparse (ff).8
a: [ae].8
i: int.
isElt [ae] (a, i) )
model [ae] (a, i) = select(a.value.contents, i)

axiom modelOut:8

region ae: sparse (ff).8
a: [ae].8
i: int.~

isElt [ae] (a, i) )
model [ae] (a, i) = a.default

These axioms state that if i was inserted in a, then its value is stored in the value array,
otherwise its value is the default value. Note how region ae is quantio/ed to allow the axiom
to be applied to whatever region array a is in.

Sparse Arrays: Creation The Capucine code for the sparse array constructor create is:
fun create [ae: sparse (ff)] (sz : int, def : ff): [ae]

consumes ae;
produces ae*
pre 0 <= sz
post

result.size = sz ^8

i: int. model [ae] (result, i) = def{

let a = new sparse (ff) [ae];
let value = arrayCreate [a.Rvalue] (sz );
a.value  value;
let idx = arrayCreate [a.Ridx ] (sz );
a.idx  idx ;
let back = arrayCreate [a.Rback] (sz );
a.back  back;
a.n  0;
a.default  def ;
a.size  sz ;
assert 8i: int. ~(isElt [ae] (a, i));
return a}

It expects an empty region ae and allocates a new sparse array in it. A pack statements
is inferred before the return statement. The assert statement helps automatic provers to
establish the proof obligations. There are two: one for the invariant of the returned sparse
array, and one for the post-condition, which states that the returned array is of size sz and
no value has been inserted yet.

3.4. EXAMPLES 53
Sparse Arrays: Reading The code for reading is:
class Ref (ff){

refValue: ff;}

fun sget [ae: sparse (ff)] (a: [ae], i: int): ff

consumes ae*
produces ae*
pre 0 <= i < a.size
post result = model [ae] (a, i){

use invariant a;
let index = arrayGet(a.idx , i);
let region Rres: Ref (ff);
let res = new sparse (ff) [Rres];
if 0 <= index ^ index < a.n then{

let backIndex = arrayGet(a.back, index );
if backIndex = i then{

let valuei = arrayGet(a.value, i);
res.refValue  valuei;}

else{

res.refValue  a.default;}
;}

else{

assert ~(isElt [ae] (a, i));
res.refValue  a.default;}
;
return res.refValue}

The Ref class is introduced because in Capucine, the return statement can only be put once,
at the very end of functions. So we need a temporary variable to store the result. And
in Capucine, let-bound variables are immutable. So we deo/ne a simple reference class and
use it to store the result. The sget function requires permission ae* even though it does not
modify the array, because reading also requires some permission, and because it requires the
invariant of a. Again, the assert statement is here to help automatic provers. This function
simply follows the deo/nition of logic function model , and thus the post-condition holds.

Sparse Arrays: Writing The code for writing is:

54 CHAPTER 3. INFORMAL PRESENTATION OF CAPUCINE
fun sset [ae: sparse (ff)] (a: [ae], i: int, v : ff): unit

consumes ae*
produces ae*
pre 0 <= i < a.size
post

a.size = a.size@pre ^
(8j : int. j 6= i ) model [ae] (a, j ) = model [ae] (a, j )@pre) ^
model [ae] (a, i) = v{

use invariant a;
let x = arraySet [a.Rvalue] (a.value, i, v);
let index = arrayGet [a.Ridx ] (a.idx , i);
if 0 <= index ^ index < a.n then{

let backIndex = arrayGet [a.Rback] (a.back, index );
if ~(backIndex = i) then{

assert a.n < a.size;
let x = arraySet [a.Ridx ] (a.idx , i, a.n);
let x = arraySet [a.Rback] (a.back, a.n, i);
a.n  a.n + 1;}
;}

else{

assert a.n < a.size;
let x = arraySet [a.Ridx ] (a.idx , i, a.n);
let x = arraySet [a.Rback ] (a.back , a.n, i);
a.n  a.n + 1;}
;
assert isElt [ae] (a, i);}

The post-condition not only states that the value of index i in a is now v, it also states that
all other values have not been changed. Proof obligations are: the invariant, and the post-
condition. Again, the three assert statements are here to help the provers prove these proof
obligations. However, the two a.n < a.size assertions are not proved automatically. It re-
quires to prove the so-called pigeon-hole lemma. We proved this using the Coq proof-assistant.
A lot of code is duplicated in this implementation because our prototype implementation of
Capucine does not support side-eoeects, and thus calls, in expressions. With this features, we
could use a lazy conjunction to avoid duplication.

Sparse Arrays: Test Harness The test harness code is implemented as follows:
fun test(x : unit): unit{

let region Ra: sparse (int);
let region Rb: sparse (int);
let default = 0;

3.4. EXAMPLES 55

let a = create [Ra] (10, default);
let b = create [Rb] (10, default);
let x = sget [Ra] (a, 5);
let y = sget [Rb] (b, 7);
assert x = default ^ y = default;
let ignore = sset [Ra] (a, 5, 1);
let ignore = sset [Rb] (b, 7, 2);
let x = sget [Ra] (a, 5);
let y = sget [Rb] (b, 7);
assert x = 1 ^ y = 2;
let x = sget [Ra] (a, 7);
let y = sget [Rb] (b, 5);
assert x = default ^ y = default;
let x = sget [Ra] (a, 0);
let y = sget [Rb] (b, 0);
assert x = default ^ y = default;
let x = sget [Ra] (a, 9);
let y = sget [Rb] (b, 9);}

The ignore variables are only there because the call statement in Capucine is syntactically
required to be let-bound. All assertions are proved automatically.

There is one proof obligation per assert statement, and one for each call to sget and
sset to check array bounds. In all proof obligations, sparse arrays a and b are separated.
Indeed, they belong to two dioeerent regions, which are encoding using two dioeerent variables
in the proof obligations. This means that when one of the array is modio/ed, the other is left
unchanged, and this fact can immediately be used very easily in proof obligations.

Conclusion All proof obligations except the a.n < a.size assertions of the sset function are
proved automatically. We proved the more diOEcult assertions using the Coq proof assistant.
To sum up, the specio/cation is proved entirely, including safety of array bounds. The region
separation provided by Capucine helps with proof obligations, which are either pre-conditions
at call sites, user assertions or invariants when packing objects. All of these are intuitive cases
where a proof obligation makes sense.

3.4.4 Function Memoization Using Hash Tables
The goal of our next example is to encode and prove in Capucine the Java program of
Figure 3.3, which is a data structure which computes the Fibonacci function. Memoization
is used to speed up computation: results are stored in a table to avoid computing them again
later on. This is obviously not the most eOEcient way to encode the Fibonacci function, but
this memoization technique applies to any function, and illustrates some features of Capucine.

The main problem is that once keys are entered in the table, they should not be modio/ed
or the table data structure will be broken. Another issue is that the table manipulates
references to the values which are associated to keys, but the table should not own these
values.

Long We need the class Long that we have already introduced before:

56 CHAPTER 3. INFORMAL PRESENTATION OF CAPUCINE
class FibMemo {

private HashMap<Long,Long> memo;

FibMemo () {

memo = new HashMap<Long,Long>();
}

long fib(long n) {

if (n <= 1) { return 1; }
Long x = memo.get(n);
if (x != null) { return x.longValue(); }
Long y = fib(n-1) + fib(n-2);
memo.put(n,y);
return y.longValue();
}
}

Figure 3.3: Java code for the memoized Fibonacci function

class Long{

value: int;}

Options We now introduce the option type. An option is either none or some(x ), where x
is any term. We may retrieve the value x using logic function getSome, which is unspecio/ed
on value none.

type option (ff)

logic none: option (ff)
logic some (x : ff): option (ff)

logic getSome (x : option (ff)): ff
axiom getSomeSome:8

x : ff.
getSome (some (x )) = x

axiom noneOrSome:8

x : option (ff).
x = none . 9y: ff. x = some (y)

axiom noneXorSome:8

x : ff. none() 6= some (x )

3.4. EXAMPLES 57
Maps We also introduce the logic type of o/nite maps and its axiomatization, which is
similar to the theory of arrays we introduced in Section 3.4.1 except that the keys to the
array are also polymorphic, that we have the empty map at our disposal and that function
select returns an option. It returns none if the required key is not in the map, and some(x )
where x is the associated value to the key if the key is in the map.

type map (ff, fi)

logic emptyMap: map (ff, fi)
logic store (x : map (ff, fi), y: ff, z : fi): map (ff, fi)
logic select (x : map (ff, fi), y: ff): option (fi)

We shall not write the axioms again here.

Table We now introduce the Table class. We implement it using maps. Its goal is to
simulate a more complex implementation using hash tables, for instance.

class Table [Rval : Long]{

group Rkeys: Long;
contents: map ([Rkeys], [Rval]);}

The Table class is implemented using logic maps from Long pointers of region Rkeys to Long
pointers of region Rval. Region Rval is a parameter of the class: it is not owned. This
reAEects the fact that the invariant of a more precise implementation of Table would not need
to depend on the user values in Rval . However, the keys to the map are in region Rkeys
which is owned by the class. Once a key is in the map, one cannot modify the key without
unpacking the map o/rst. In other words, all modio/cations to the keys are controlled by the
table itself.

We introduce logic function model which allows to read a table without knowledge of the
actual implementation. Function model assumes that the keys are Long values, and accepts
an integer i instead of a pointer.

logic model [Rv : Long, Rt: Table [Rv ] ] (t: [Rt], i: int): option ([Rv])
The idea is that class Table [Rval] and logic function model represent a Java-like signature
of our tables. The implementation could be hidden: it is not needed to reason about the
table. The implementation of model is also kept hidden, but we write an axiom to specify
that model does not depend on the values of pointers in the Rv region argument:

axiom modelFootprint :8

region Rv1 : Long.8
region Rv2 : Long.8
region Rh1 : Table [Rv1 ].8
region Rh2 : Table [Rv2 ].8
h: [.]. 8i:int.
(get(Rh1 , h, contents) = get(Rh2 , h, contents)) )
model [Rv1 , Rh1 ] (h, i) = model [Rv2 , Rh2 ] (h, i)

Operation get(ae, h, contents) reads the o/eld contents of pointer h in region ae. Indeed, the
type of h is [.]: its region is unspecio/ed. In the logic a pointer can be read from any region

58 CHAPTER 3. INFORMAL PRESENTATION OF CAPUCINE
using get. If h is not actually in ae, the value of get(ae, h, contents) is unspecio/ed.
Table Creation Function createTable creates a table.
fun createTable [Rv : Long, Rt: Table [Rv ] ] (): [ae]

consumes ae;
produces ae*
post 8i: int. model[Rv , Rt](result, i) = none{

let t = new [Rt];
t.contents  emptyMap ();
return t}

The post-condition states that the table is empty: for each key, the associated model is none.
Table Insertion Function insert inserts a new key k and its value v into a table t.
fun insert [Rv : Long, Rt: Table [Rv ], Rk: Long] (t: [Rt], k: [Rk ], v : [Rv ]): unit

consumes Rt* Rk*
produces Rt*
post

model [Rv, Rt] (h, k .value) = some (v ) ^8

i: int.
i 6= k.value ) model [Rv, Rt] (t, i) = model [Rv, Rt] (t, i)@pre{

adopt Rk as t.Rkeys;
t.contents  store (t.contents, k , v);}

The adoption inserts the key into the Rkeys region owned by the table. As a consequence,
permission Rk * is consumed, and is no longer available. Hence the produces clause, which
mentions no permission on Rk . Ownership of the key has been transferred to the table struc-
ture.

The post-condition states that the only key whose associated value has changed is k .
It is expressed using model to ensure that tables can be used without knowledge of their
implementation.

Table Access Function find returns the associated value to a key k in a table t.
fun find [Rv: Long, Rt: Table [Rv], Rk : Long] (t: [Rt], k : [Rk]): option ([Rv ])

consumes Rt* Rk *
produces Rt* Rk *
post result = model [Rv , Rt] (t, k .value)

We do not provide an implementation, as it is not the interesting point of the example. It
o/nds a key of t.contents whose value is the same as k .value, and returns the associated data.

Fibonacci Data Structure We now deo/ne class Fibo which contains a table to store the
values of the Fibonacci function which have already been computed. The class is implemented

3.4. EXAMPLES 59

table (Rt):

keys (Rkeys): 8

contents:

values (Rv): 13
Fibo:

Figure 3.4: The Fibo data structure
entirely without ever accessing the contents o/eld of the table directly. In other words, class
Fibo is written without knowledge of the implementation of the Table class, thanks to logic
function model.

First we deo/ne the mathematical Fibonacci function as a logic function.

logic fibo (x : int): int

axiom fibo0 : fibo(0) = 0
axiom fibo1 : fibo(1) = 1
axiom fiboN : 8n: int. n > 1 ) fibo(n) = fibo(n-1) + fibo(n-2)

Now we can deo/ne class Fibo.
class Fibo{

group Rv : Long;
single Rt: Table [Rv ];
table: [Rt];
invariant8

x : int.8
y: [Rv ].
model [Rv, Rt] (table, x ) = some y ) y.value = fibo(x )}

The invariant states that for all bindings (x, y) in the table, y is the Fibonacci function applied
to x. Note that the invariant mentions the values stored in region Rv, which is owned by the
Fibo class, but there is no o/eld of type Rv : all locations of region Rv are actually stored in
the table. Figure 3.4 illustrates the data structure. Note how keys are owned by the table.
Also note how values are owned by the Fibo data structure, even though the contents of the
table may reference them.

We now introduce our main function. The fibonacci function takes a Fibo pointer as an
argument, an integer i and returns fibo(i). First it looks into the table to see if fibonacci (i)
has already been computed. If so, it returns the associated value in the table. Else, it

60 CHAPTER 3. INFORMAL PRESENTATION OF CAPUCINE
computes the value, inserts it in the table, and returns it.
fun fibonacci [ae: Fibo] (f : [ae], i: int): int

consumes ae*
produces ae*
pre i >= 0
post result = fibo(i){

use invariant f ;
let region Rr: Long;
let r = new [Rr ];

if i <= 1 then{

r .value  i;}

else {
let region Rk : Long;
let k = new Long [Rk];
k .value  i;

let ro = find [f .Rv , f .Rt, Rk] (f .table, k);
if ro = none then{

let f2 = fibonacci [ae] (f , i - 2);
let f1 = fibonacci [ae] (f , i - 1);
r .value  f1 + f2 ;

let region Rv : Long;
let v = new [Rv ];
use v /2 f .Rv ;
v .value  r.value;

use invariant f ;
use 8x : int. 8y: [.].

model [f .Rv , f .Rh] (f .hash, x ) = some (y) ) y 2 f .Rv ;

adopt Rv as f .Rv ;
let ignore = insert [f .Rv, f .Rt, Rk ] (f .table, k , v);}

else {
let i = getSome (ro);
r .value  i.value;}
;}
;

return r .value}

Variable r stores the result of the computation. It is required because in Capucine, the return

3.4. EXAMPLES 61
statement must syntactically be at the end of the function. To prove this function, we need
the invariant of f , which we obtain using the use invariant statement. We also need to know
that v is fresh in f .Rv, which we obtain from typing using another use statement. Later, v is
adopted in f .Rv thanks to the inference mechanism. We also need to know that all pointers
y in the table are in region f .Rv . We obtain this, again, from typing using a use statement.
We use this to prove that all pointers in the table are dioeerent than v.

We solved the two problems that we mentionned at the beginning. The region of the keys
is owned by the table. This forbids the client of the table from modifying them, and solves
our o/rst problem. We used parametric ownership to parameterize the table by the region of
values, to ensure the table could reference these values without owning them. This solves
our second issue.

3.4.5 Courses and Students
We now introduce the courses and students example. It consists in two classes: Student and
Course. A course maintains an array of students. Each student has a mark, and the course
maintains the sum of the marks of its students, as well as the student count, to be able to
compute the mean easily. Each course owns its students, as modifying the mark of a student
would break the course invariant, which is that the maintained sum is indeed the mark sum.

This program illustrates the use, in the specio/cation, of a logic function which is param-
eterized by a region. This region represents the footprint of the logic function as deo/ned in
literature [Reynolds02, Kassios06, Banerjee08].

Preliminaries Class Student is introduced as follows:
class Student{

mark : int;}

In a more practical instance of this example, one could add the name of the students and
other information as other o/elds.

We reuse the larray logic type of the sparse array example. We rename them array, and
we keep the store and select logic functions as well as the axioms which deo/ne them. We will
use this array theory to model the internal student array of courses.

Mark Sum We introduce logic function MarkSum:
logic MarkSum [ae: Student] (a: array ([ae]), i: int, j : int): int
Intuitively, MarkSum[ae](a, i, j ) is the sum of the marks of all students in array a from index i
(included) to index j (excluded). Region ae is the region in which information about students,
i.e. their mark, is read. Indeed, pointer a is only a pointer: it makes no sense to read its
value unless some heap in which to read the value is available. And in Capucine, heaps are
modeled as regions.

Logic function MarkSum is deo/ned using axioms. The o/rst one states that the sum from
i to j , when i = j , is 0 as j is excluded:

axiom MSempty:8

region ae: Student.

62 CHAPTER 3. INFORMAL PRESENTATION OF CAPUCINE

8a: array ([ae]).8

i: int.
MarkSum [ae] (a, i, i) = 0

Another axiom states that the sum from index i (included) to i+1 (excluded) is exactly
the mark at index i:

axiom MSsingleton:8

region ae: Student.8
a: array ([ae]).8
i: int.
MarkSum [ae] (a, i, i+1) = select(a, i).mark

The last axiom deo/ning how to compute MarkSum is the following:
axiom MSsplit:8

region ae: Student.8
a: array ([ae]).8
i: int.8
j : int.8
k: int.
i <= k ^ k <= j )
MarkSum [ae] (a, i, j ) = MarkSum [ae] (a, i, k) + MarkSum [ae] (a, k, j )

It states that the sum from i (included) to j (excluded) is the sum from i (included) to k
(excluded) plus the sum from k (included) to j (excluded), if i <= k <= j .

Mark Sum Footprint The above axioms fully deo/ned how to compute MarkSum. How-
ever, in the rest of the program we will need another axiom stating that the sum of marks
from i to j only depends on the marks from i to j . The set of locations on which a function
depends on is called its footprint.

axiom MSfootprint:8

region Rold : Student.8
region Rnew : Student.8
Aold: array ([Rold ]).8
Anew : array ([Rnew]).8
left: int.8
right: int.
(8i: int. left <= i ^ i < right )

select(Aold , i).mark =
select(Anew, i).mark ) )
MarkSum [Rold] (Aold , left, right) = MarkSum [Rnew ] (Anew, left, right)

This axiom could be deduced from the above axioms MSempty, MSsingleton and MSsplit.
But it requires reasoning which cannot be achieved by automatic theorem provers, namely
induction.

Courses Class Course is deo/ned as follows:
class Course{

3.4. EXAMPLES 63

group Rstudents: Student;
students: array ([Rstudents]);
sum: int;
count: int;
invariant

sum = MarkSum [Rstudents] (students, 0, count) ^
count >= 0 ^
(8i: int. 8j : int.

0 <= i ^ i < count )
0 <= j ^ j < count )
i 6= j )
select(students, i) 6= select(students, j )) ^
(8p: [Rstudents]. p in Rstudents )9

i: int. 0 <= i ^ i < count ^ p = select(students, i))}

The course owns its students. Indeed, the students o/eld is an array of pointers of region
Rstudents which is owned by class Course. This region is a group region: it may contain
several students.

The sum o/eld is the sum of the marks of all students in the students array. The count o/eld
is the number of students in the course, i.e. the students are stored from index 0 (included)
to index count (excluded) of array students. Those properties about sum and count are
specio/ed in the invariant of class Course, in the o/rst two parts.

The third part of the invariant states that all pointers of the students array are dioeerent.
This is the kind of property which is easy to forget, as it is so obviously assumed by the
programmer. It will be fundamental to the correctness of our functions.

The fourth and last part of the invariant states that all pointers of region Rstudents
actually appear in the students array. We introduce a new predicate: p in ae, which states
that pointer p is in region ae. We will later see that this predicate can be derived from the
p: [ae] typing information in programs. Note that in the logic, a pointer may have type [ae]
without the pointer actually being in ae. More discussion about this and the actual meaning
of type [ae] in the logic is made in Chapter 4.

Course Creation We introduce logic constant someArray of type array (ff):
logic someArray (): array (ff)
It has no deo/nition, it is only some array. If logic arrays were bounded, it could be the empty
array, for instance; but our logic arrays are unbounded. This is not important: someArray
will only be used as the initial value for the students o/eld of Course objects. We only read
students from index 0 (included) to count (excluded), and count is initially 0.

Here is the implementation of the Course constructor:

fun createCourse [ae: Course] (): [ae]

consumes ae;
produces ae*
post result.count = 0{

let c = new Course [ae];
c.students  someArray ();

64 CHAPTER 3. INFORMAL PRESENTATION OF CAPUCINE

c.sum  0;
c.count  0;
return c}

As usual with constructors, there are two proof obligations: the post-condition and the
invariant. They both are proved automatically by theorem provers.

Adding a Student to a Course Function addStudent allocates a new student, given its
initial mark m, and adds it to a course c. It returns the new student, which is in the owned
region Rstudents of course c.

fun addStudent [Rc: Course] (c: [Rc], m: int): [c.Rstudents]

consumes Rc*
produces Rc*
post

result.mark = m ^
c.count = c.count@pre + 1 ^
c.sum = c.sum@pre + m ^

8s: [c.Rstudents]. s in c.Rstudents@pre )
s.mark = s.mark @pre{

use invariant c;
let region Rstud: Student;
let s = new Student [Rstud];
s.mark  m;

use8

i: int. i >= 0 ^ i < c.count )
select(c.students, i) 6= s;

adopt s: Rstud as c.Rstudents;
c.students  store (c.students, c.count, s);
c.sum  c.sum + m;
c.count  c.count + 1;

return s}

The post-condition states that the mark of the new student is m and that the count and
sum o/elds of c have been updated accordingly. It also states that the marks of all students
which were in region c.Rstudents before are unchanged. It does not have to state that the
new student is in region c.Rstudents using the in predicate, as this is already known thanks
to typing.

We allocate the new student in a new region Rstud and update its mark. We then adopt
the student in region c.Rstudents, i.e. we move the student from its current region Rstud to
region c.Rstudents. After this statement, variable s has type [c.Rstudents]. We then update
the students array as well as the sum and count o/elds.

3.4. EXAMPLES 65

The invariant of c holds at the beginning thanks to permission Rc*, and it will be used to
prove proof obligations, so we introduce it in the hypotheses using statement use invariant c.
To prove the invariant is maintained, we will also need to know that pointer s is dioeerent than
all pointers which already were in array c.students. This can be deduced from typing, as s is
allocated in region Rstud, which is disjoint from region c.Rstudents before the adoption. We
know it is disjoint because at that point, permissions Rstudffi and Rc* are available. If Rc*
is available, then c.RstudentsG is also morally available. It is a property of the type system
that this implies disjointness of Rstud and c.Rstudents. So we introduce the hypothesis we
need using the use statement. The use statement takes a predicate, checks that it can be
deduced from typing, and introduces it in the hypotheses.

There are two proof obligations: the invariant must be maintained, and the post-condition
must hold. Both are proved automatically using theorem provers, thanks to the hypotheses
we introduced using the use invariant and use statements.

Changing the Mark of a Student Function changeMark takes a course c, a student s
of this course, a new mark m and changes the mark of s to m. Of course, it also updates the
sum o/eld of c.

fun changeMark [Rc: Course] (c: [Rc], s: [c.Rstudents], m: int): unit

consumes Rc*
produces Rc*
post

s.mark = m ^
c.sum = c.sum@pre + m - s.mark @pre ^
c.count = c.count@pre ^

8i: int.
0 <= i ^ i < c.count )
s 6= select(c.students, i) )
select(c.students, i).mark = select(c.students, i).mark @pre{

use invariant c;
use s 2 c.Rstudents;

label before;
let region F : Student;
focus s as F ;
c.sum  c.sum - s.mark + m;
s.mark  m;
unfocus s: F as c.Rstudents;

assert9

i: int.

0 <= i ^ i < c.count ^
select(c.students, i) = s ^
MarkSum [c.Rstudents] (c.students, 0, i) =

MarkSum [c.Rstudents] (c.students, 0, i)@before ^
MarkSum [c.Rstudents] (c.students, i+1, c.count) =

66 CHAPTER 3. INFORMAL PRESENTATION OF CAPUCINE

MarkSum [c.Rstudents] (c.students, i+1, c.count)@before;}
The post-condition states that the mark of student s is now m, the sum o/eld of course
c has been updated, and the count o/eld is unchanged. It also states that the marks of all
students except s are unchanged.

The code is mainly composed of the two update statements to c.sum and s.mark re-
spectively. All other statements deal with regions or the program specio/cation. Statements
dealing with regions are let region, focus and unfocus, as the student s being in a group
region, it must be moved temporarily into a singleton region so we can modify its mark. State-
ment use invariant c introduces the invariant of c in proof obligation hypotheses for free, as
permission Rc* is available. Statement use s in c.Rstudents introduces the s in c.Rstudents
hypothesis for free, as it is known by typing.

The assertion helps automatic provers to prove proof obligations. It essentially shows
them how to split the students array in three parts: the students before s, s, and the
students after s. Using this splitting, it states that all students but s are unchanged from the
before label, which was introduced before the assign statements. Thanks to this assertion,
both proof obligations, i.e. the invariant and the post-condition, are proved automatically.

Conclusion This example shows the limits of the Capucine approach: when pointers have
to belong to group regions, we have to resort to specifying separation in the logic. However,
Capucine still helps by separating the two courses in the main function, by providing a
methodology to handle the invariant of the Course class and by separating o/elds in proof
obligations. This example also illustrates the in predicate and how it can be introduced in
the proof obligation hypotheses if it can be shown through typing. It also shows the use
statement which can introduce hypotheses which can be derived from typing, in particular
pointer dioeerences when pointers belong two disjoint regions.

Chapter 4
Capucine Language Syntax and
Semantics

In this chapter we formalize the Capucine language. In Section 4.1 we give the grammar
of Capucine programs. In Section 4.2 we give typing rules for Capucine programs. In Sec-
tion 4.3 we give the operational semantics of Capucine. We call it the intuitive model, as it
is close to usual operational semantics of other imperative languages with pointers. In Sec-
tion 4.4 we introduce the notion of coherence of a heap. Our o/rst main result (Theorem 1)
is that coherence is preserved through execution. In Section 4.5 we give another operation
semantics for Capucine. We call it the separated model, as it emphasizes separating the heap
into regions. Our second main result (Theorem 5) is that under the coherence hypothesis,
execution in the separated model gives the same result as execution in the intuitive model.

4.1 Syntax
In this section we formally introduce the Capucine language. We deo/ne its syntax and remind
the informal meaning of each operation. Capucine programs are sequence of declarations:
logic declarations (logic types, logic functions, predicates and axioms) and program declara-
tions (classes and functions). These notions are mutually dependent. For instance, classes
appear in predicate declarations, but predicates appear in class declarations. Thus, this
section contains unavoidable forward references.

We denote by x the list x1, ..., xn for some n. In a similar fashion, x : y stands for
x1 : y1, ..., xn : yn for some n, and so on.

4.1.1 Classes
We introduce some namespaces for identio/ers: r and s are region names, where s will be
preferably used for owned regions; and f are o/eld names. A class declaration is of the form:

class C (ff) [r : C]{

size s: C;
f : o/ ;

67

68 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS

invariant P;}
where size may be either single or group, and C are class expressions:
C ::= C [ae] (o/ )
If class C expects no region ae, we may omit the brackets, and if class C expects no type o/ ,
we may omit the parentheses. For instance, C stands for C [] (). Regions ae, types o/ and
predicates P will be deo/ned later in this section.

Type variables ff are type parameters, and region variables r are region parameters. They
are bound in the remaining of the class deo/nition. In particular, they can be used as param-
eters of later class expressions. For instance, this is a valid class deo/nition:

class C (ff) [r1 : C1 (ff), r2 : C2 [r1 ] ] { * * * }
Type parameters are ML-like type parameters. Region parameters are similar, but they are
typed using class expressions.

Classes may also own regions. Regions s in the above declaration are owned regions.
Each region can be either group (group) or singleton (single). If a region is group, it may
contain any number of pointers, including zero or one; if a region is singleton, it may only
contain exactly one pointer. Owned regions, like region parameters, are typed using class
expressions. They are bound in the remainder of the class declaration, including in the class
expressions of following owned regions.

Classes contain o/elds. Each o/eld f is given a type o/ . This is similar to structures and
records of other languages.

Finally, each class is given an invariant. The invariant may mention each o/eld f , as well as
owned regions s. There is an important restriction though, which is the usual restriction for
invariants in ownership methodologies: the invariant may only dereference owned pointers,
i.e. if a term x .f1 . * * * .fi appears in the invariant, then x .f1 is a pointer of an owned region
of x , x .f1 .f2 is a pointer of an owned region of x .f1 , and so on.

4.1.2 Logic Types
A logic type deo/nition is of the form:
type t (ff1 , * * *, ffn )
It declares type t, with polymorphic type parameters ff1 , * * *, ffn where n may be zero. It is
only a declaration: there is no way to build a value of type t without deo/ning its constructors
as logic functions.

We assume all types to be inhabited: for each user-declared type t, there is at least one
value of type t. This implies that, for instance, logic formula:

8x : t. F
is equivalent to F, where F is the false predicate. If there was no value of type t, it would
instead be equivalent to T, the true predicate. In a sense, a type declaration is an axiom
stating the existence of a value. This approach is similar to Why [Fillia^tre07], in which
Capucine programs are interpreted. If the user wishes to, he may build a model of the type
in another, richer language such as the one of the Coq proof assistant [Coq].

4.1. SYNTAX 69
4.1.3 Regions
A region is of the form:
ae ::= r | x .s
It is either a region name r , or an owned region. Owned regions are of the form x .s, where
x is a variable of a class which contains owned region name s in its declaration. Region x .s
refers to the owned region s of the object which variable x points to.

4.1.4 Types
An object in Capucine is a value of a class. Objects do not appear in programs though.
The programmer may only manipulate pointers to objects. A variable of a pointer type is a
variable whose contents is an address in the heap, at which address an object can be found.
Capucine splits the heap into several smaller heaps: one for each region. Regions are not a
partition of the heap though, they may overlap. Each pointer belongs to at least one region.

The region of each program pointer is denoted by its type. The type of a pointer p of
region ae is written [ae]; pronounced iat aej. Each region binder comes with a class expressionC

, so the class of ae, i.e. the class of pointer p, is known from the typing environment.

In the logic though, pointers do not necessarily belong to a region. To read a pointer, i.e.
to select a o/eld of its object, it is necessary to know in which region the pointer is read. But in
the logic it sometimes makes sense to read the same pointer in dioeerent regions. For instance,
two dioeerent logic regions may denote dioeerent versions of the same region throughout the
execution of the program. It then makes sense that a pointer is in both regions at the same
time. The type given to pointers in the logic is [.], i.e. the type of pointers of any region.
Field selection is then annotated with the region in which the reading access is made, using
term get.

Additionnally, to avoid having to write get(ae, x , f ), we actually allow logic pointers such
as x to carry a region ae in their type. Their type is thus [ae] instead of [.], but this is only
used to desugar x .f as get(ae, x , f ).

A type is of the form:
o/ ::= t (o/ , * * *, o/) | int | bool | unit | [ae] | [.]
It is either a user-deo/ned type t with instanciated parameters o/1 , * * *, o/n , a base type, or a
pointer type. Base types are integers int, booleans bool and unit.

4.1.5 Logic Function and Predicate Declarations
A predicate deo/nition is of the form:
logic p param = P
where:
param ::= [r : C] | (x : o/ )
We deo/ne predicates P later in this section. This deo/nes predicate p, with arguments arg.
An argument is either a region argument [r: C] where r is a region name and C is its class, or
a regular argument (x : o/ ) where x is a variable name and o/ is its type. Note that regions r
may appear in types o/ of variables, and that variables x may appear in classes C of regions.
Here is an example of such an interleaving:

70 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS
logic p [r: C1 ] (x : [r ]) [r 0: C2 [x .r1 ] ] (y: [r 0])
assuming r1 is an owned region of class C1 , and class C2 expects one region parameter.

A logic function deo/nition is of the form:

logic f param: o/ = LT
We deo/ne terms LT later in this section. As usual, the only dioeerence between a predicate
and a logic function is their return type, which are of dioeerent kinds. Logic functions may
return values of any user-deo/ned type. The body of a logic function is not a predicate but a
term.

The body of predicates and logic functions, respectively P and LT above, is optional.
Often, the predicate and term language cannot express them. In this case, the user provides
axioms instead. If the user deo/ned a model for the logic types in a richer logic, he may
also deo/ne logic functions and predicates in this richer logic and prove the axioms to ensure
consistency.

4.1.6 Terms
A term is of the form:

LT ::= c|

x|
LT termop LT|
f larg|

get(RT , LT , f )

termop ::= + | - | * | && | ||
larg ::= [RT ] | (LT )

where c is a constant of a base type, i.e. either an integer literal or a boolean true or false.
A term may also be a variable x , the application of a base term operator termop or the
application of a logic function f to some logic arguments larg. A logic argument larg is either
[RT ] where RT is a region term (see below) or (LT ) where LT is a term.

We use a set of label names L. Labels denote the state of the heap at some program
point. A special label named here denotes the current program point.

Finally, a term can be the selection get(RT , LT , f ) of a o/eld f of a pointer term LT in
a region RT , where RT is a region term:

RT ::= r@L | get(RT , LT , s)
It is either a region variable r at some label L or the selection get(RT , LT , s) of an owned
region s of a pointer term LT in a region RT . Selection of owned regions and o/elds are quite
similar.

In practice, we may also write r with no label at all. This is desugared as r @L where
L is chosen depending on the context. We may write RT @L, LT @L or P@L for any region
term RT , term LT or predicate P. Region term r is then expanded as r @L, where L is the
innermost label. For instance, ((f [r ])@L)@L0 is desugared as f [r@L] and not f [r @L0]. If
no label is provided at all, r is replaced by r @here.

4.1. SYNTAX 71
Abbreviation In practice, get(ae, p, f ) can often be abbreviated as p.f . Indeed, if the type
of p is [r ], then we expand p.f to get(r , p, f ). If the type of p is [x .r ], then we expand p.f to
get(t, p, f ) where t is the expansion of x .r, computed in a similar fashion. If the type of p is
[.] however, p.f has no meaning and cannot be expanded. It is rejected by Capucine. It is
thus mandatory to use the get predicate for pointers of type [.]. In examples of Section 3.4
we used this abbreviation when possible. Function addStudent of the courses and students
example shows a use of type [.].

4.1.7 Predicates
A predicate is of the form:

P ::= p larg|

P ^ P | P . P | P ) P | P () P | ~P | T | F|
LT = LT | LT 6= LT | LT > LT | LT >= LT| 8

x : o/ . P | 9x : o/ . P| 8
region r : C. P | 9region r : C. P|
LT 2 RT

It can be the application of a user-deo/ned predicate p or the quantio/cation of a variable x .
Usual operators are also provided, including comparison, as well as constant predicates T
and F. A predicate can also be a quantio/cation over a region r of class C. Region r can then
be used in get(r, LT , f ) terms, and in types. Finally, predicate LT 2 RT states that the
location denoted by term LT is in the region denoted by region term RT .

4.1.8 Axioms and Lemmas
Axiom declarations are of the form:
axiom a: P
It is essentially a pair of a name a and a predicate P. The axiom does not take any parameters;
variables and regions must be quantio/ed in the body P. Types appearing in P may use free
type variables, which are implicitely universally quantio/ed at the beginning of the axiom,
i.e. the axiom is polymorphic in these variables. Axioms are typically used to axiomatize
predicate and logic functions which cannot be deo/ned otherwise in the o/rst-order logic of
Capucine.

Lemmas are similar to axioms, and are declared as:

lemma l: P
They are available in the context of proof obligations, but contrary to axioms, they must be
proved.

4.1.9 Permissions
Permissions are of the form:
\Sigma  ::= ae; | aeffi{f } | ae* | aeG | ae -ffi ae
Permission ae; states that region ae is empty, i.e. contains no pointer. Permission aeffi{f } states
that region ae is singleton, i.e. contains exactly one pointer p, and that ae is open, i.e. the
invariant p may be broken. It also states that o/elds f are not initialized. Permission ae*

72 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS
states that region ae is singleton and closed, i.e. the invariant of the pointer holds. It also
encapsulates permissions on owned regions. Permission aeG states that region ae is group, i.e.
it may contain any number of closed pointers. Permission oe -ffi ae states that region ae is being
focused, and is thus disabled as long as oe* is not given back.

Notation We may use aeffi to denote permission aeffi{}, i.e. ae is open and all its o/elds are
initialized.

4.1.10 Expressions
All expressions are pure, i.e. do not cause side-eoeects. They are of the form:

e ::= 0, 1, * * * Integers|

true, false Booleans|
() Unique value of the unit type|
e op e Operations (op 2 {+, -, *, =, 6=, >, <, >=, <=})|
f arg Logic function application|
x Variable|
x .f Field selection

where:
arg ::= [ae] | (e)

We restrict o/eld selection to variables. This is to ensure a type can be given to x .f when
f is a o/eld of pointer type of an owned region r . Indeed, the type of x .f is then [x .r ]: name
x is needed. More complex expressions such as x .f1 .f2 can be encoded by giving a name to
x .f1 such as y using a let-binding statement.

Logic functions may be used as expressions. They take a list of arguments arg where arg
is either a region argument [ae] or a regular expression argument (e).

4.1.11 Statements
Statements do cause side-eoeects and are of the form:

s ::= let x = e Variable declaration|

if e then S else S Test|
let x = f arg Call|
let region r : C New region|
let x = new C [ae] Allocation|
focus x : ae as ae Extract a pointer|
x .f  e Assign o/eld|
adopt x : ae as ae Move a pointer|
unfocus x : ae as ae Opposite of focus|
pack x : C Close pointer|
unpack x Open pointer|
weaken empty ae Weaken empty region|
weaken single ae Weaken singleton region|
assert P Assertion|
label L Label

where S are blocks, i.e. sequences of statements:

4.1. SYNTAX 73
S ::= {s; * * *; s}
The scope of all binders is restricted to the current block.

Function calls may be recursive. Loops are encoded using recursive calls. We chose not to
have loop statements in order to simplify the presentation of the language. It allows to avoid
duplicating the ideas behind typing rules of recursive calls. In particular, loops would require
loop invariant annotations, including invariant permissions: available permissions should be
the same at the beginning and at the end of the body of loops.

The let region r : C operation binds a new region r , of class expression C. The region is
initially empty. It can be used to allocate or focus pointers.

Allocation new takes a region ae as argument and allocates a new object of the class of ae
inside this region. A pointer to this object is stored in the let-bound variable x .

The focus x : ae as oe operation extracts pointer x from group region ae to empty region
oe, which becomes singleton. The type of x changes from [ae] to [oe]. The unfocus operation
does the opposite. While the pointer is focused, region ae is temporarily disabled: permission
aeG is replaced by oe -ffi ae. Adoption is similar to unfocus in that it moves a variable from a
singleton region to a group region, except that the variable was not being focused.

Packing and unpacking control the state of pointers (open or closed). Packing generates
a proof obligation: the invariant of the pointer being packed must hold.

Weakening is strictly a typing operation. It takes an empty or closed singleton region,
consumes the permission ae; or ae* and produces the group permission aeG.

Assertion assert P checks that predicate P holds at the current program point. It gener-
ates P as a proof obligation.

Label declaration label L binds label name L in the following statements of the current
block. The label L then denotes the state of the program at its declaration point.

4.1.12 Function Declarations
A function declaration is of the form:
fun f param: o/

consumes \Sigma 
produces \Sigma 
pre P
post P{

s;* * *
s;
return e}

The meaning of return type o/ , pre- and post-conditions P, body s and returned expression
e is straightforward.

Arguments param have been deo/ned in Section 4.1.5. Region arguments are region
binders. Regions bound this way are available in the remainder of the function declara-
tion. Typically, they are regions of pointer arguments, or of the return value if it is a pointer.
As usual with region binders, each region parameter is given a class expression C.

The consumes and produces clauses state which permissions \Sigma  are consumed and pro-
duced by the function. They give the state of region parameters before and after the function

74 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS
is called.

4.2 Typing
Now that we laid down the syntax of Capucine programs and logic, we introduce typing rules.
There are three main mechanisms involved: typing of expressions, typing of logic terms, and
permissions. Typing of expressions and logic terms use rules similar to type systems of the
ML family. In particular, they involve type variables. Capucine also uses region variables,
which are similar to type variables in their behavior. For instance, classes may have type
and region parameters. Typing of permissions reAEects how permissions are consumed and
produced by statements. Permissions are also used in typing rules of expressions to check
that reading access are allowed. They are not used in typing rules of terms, because our
model for logic is dioeerent than the one used for programs and allows reading even with no
permission.

We assume all identio/ers are ff-renamed when needed. For instance, we assume programs
such as:

let x = 1;
let x = true;

do not occur. The implementation of Capucine actually transforms this program into:
let x1 = 1;
let x2 = true;

4.2.1 Expressions
Owned Regions and Field First we introduce typing judgements for owned regions and
o/elds:

s: C0 2x C

f : o/ 2x C
The o/rst judgement states that owned region name s, deo/ned in class C, has class C0 when
owned by pointer variable x . The second judgement is the equivalent for o/elds: it states that
x .f has type o/ , where f is deo/ned in class C.

These judgements involve substitution of type and region variables. Consider for instance
the following class declaration:

class C (ff) [r : Long]{

single s: List (ff) [r ];
f : Array ([s]);}

Consider the following environment which gives the type of x :

oe: Long, ae: C (int) [oe], x : [ae]
The following judgement holds:

4.2. TYPING 75

\Gamma , r : C ` r : C RRoot

\Gamma , x : [ae] ` ae : C s : C0 2x C

\Gamma , x : [ae] ` x .s : C0 ROwn

Figure 4.1: Typing rules for regions

f : Array([x .s]) 2x C (int) (oe)
Note how Array ([s]) was substituted to Array ([x .s]). This illustrates the necessity of x in
the 2x judgement.

This substitution mechanism is the usual ML mechanism for type parameters, on top of
which we add substitution of owned regions. Substitution for type and region parameters
use the ML mechanism, which is well-known and we do not detail it. Substitution for owned
regions is quite simple: all region variables s which are owned regions of class C are substituted
to x .s, where x is the variable by which 2x is indexed.

Environments Typing rules for expressions involve an environment \Gamma . It is a list of:

* x : o/ pairs, where x is a variable and o/ is its type;

* r : C pairs, where r is a region variable and C is its class expression;

* L: R pairs, where L is a label and R is a set of region names.
The order of the list does not matter, and we will use \Gamma , a: b to denote an environment
containing pair a: b as well as some other pairs \Gamma . For clarity's sake, you may assume \Gamma  to be
a function, although it is not necessary. For instance, environment x : int, x : bool will never
occur naturally.

Regions Regions are typed using the following judgement:

\Gamma  ` ae: C
This judgement states that under environment \Gamma , region ae contains pointers of class expressionC

. Figure 4.1 shows typing rules for regions.

Rule RRoot states that if r : C is in the environment, then r contains pointers of class C.
Rule ROwn states how to type owned region x .s. First we look for the type of x in the
environment. It should be a pointer type [ae], where ae is the region of x . We then type ae in
the same environment, and obtain its class C. We o/nally look for the type of region s in class
expression C when it is owned by pointer x , and we obtain the class C0 of x .s.

Accessible Regions We introduce the following judgements aimed at deo/ning whether
there are enough permissions for a region ae to be accessible. Accessibility of a region denotes
whether we are able to translate an access to this region to compute proof obligations. To
this end we require permissions on the region and its owners. In other words we need to
know the state of the region, in particular whether it is being focused.

* \Gamma , \Sigma  `ffi ae

This judgement states that region ae is accessible and is in the open part of the region
ownership tree, i.e. that ae and all its transitive owners are open.

76 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS

r ffi{f1 , * * * , fk } 2 \Sigma  (k >= 0)

\Gamma , \Sigma  `ffi r Acc1

x .sffi{f1 , * * * , fk } 2 \Sigma  (k >= 0) x : [ae] 2 \Gamma  \Gamma , \Sigma  `ffi ae

\Gamma , \Sigma  `ffi x .s Acc2

\Sigma  " {r ;, r *, r G} 6= ;

\Gamma , \Sigma  `* r Acc3

oe -ffi r 2 \Sigma  \Gamma , \Sigma  ` oe

\Gamma , \Sigma  `* r Acc4

\Sigma  " {x .s;, x .s*, x .sG} 6= ; x : [ae] 2 \Gamma  \Gamma , \Sigma  `ffi ae

\Gamma , \Sigma  `* x .s Acc5

oe -ffi x .s 2 \Sigma  \Gamma , \Sigma  ` oe x : [ae] 2 \Gamma  \Gamma , \Sigma  `ffi ae

\Gamma , \Sigma  `* x .s Acc6

x : [ae] 2 \Gamma  \Gamma , \Sigma  `* ae

\Gamma , \Sigma  `* x .s Acc7

\Gamma , \Sigma  `* ae

\Gamma , \Sigma  ` ae Acc8

\Gamma , \Sigma  `ffi ae

\Gamma , \Sigma  ` ae Acc9

Figure 4.2: Typing rules for region accessibility

* \Gamma , \Sigma  `* ae

This judgement states that region ae is accessible and is in the closed part of the region
tree. It can be at the border between the closed part and the open part, i.e. permission
ae;, ae*, aeG or oe -ffi ae is available. If the permission is oe -ffi ae, then oe must be accessible.
Or ae can be below the border, i.e. transitively owned by a region of the border.

* \Gamma , \Sigma  ` ae

This judgement states that region ae is accessible, whether in the open part or the closed
part of the region tree.

Figure 4.2 deo/nes these judgements.

Rules Acc1 and Acc2 deo/ne judgement `ffi . A region is accessible in the open part of
the region ownership tree if the region is open and either the region is at the top of the tree,
i.e. is a variable r, or the region is owned by a region which is itself accessible in the open
part of the tree.

Rules Acc3 to Acc7 deo/ne judgement `* . A region ae on which we have a closed
permission (ae;, ae*, aeG or oe -ffi ae for some region oe) is at the border of the tree (rules Acc3
to Acc6). If the region is owned, its owner must be accessible in the open part of the tree
(rules Acc5 and Acc6). If the region is being focused, the target region oe must be accessible
(rules Acc4 and Acc6). Finally, a region which is transitively owned by a closed region is
also accessible in the closed part of the tree (rule Acc7).

We cannot read from or write into a region which is not accessible. Thus most typing
rules use the region accessibility judgement ` . More details on how we access regions and
why this typing judgements are required are given in Section 4.3, Section 4.5, and Section 5.2.

4.2. TYPING 77

x

y

* * * * * *

* * * z

z

* * *
s1

s3

s2 s4
rffi

x .s1 *
y.s3

r 0 -ffi x .s2

r0ffi

z .s4 G

focus

Figure 4.3: Illustration of a region ownership tree and its open/close border

\Sigma  " {ae;, ae*, aeG} 6= ;

\Gamma , \Sigma  `-ffi ae

aeffi 2 \Sigma  \Gamma  ` ae : C
owned regions of C are r1 , * * *, rn x : [ae] 2 \Gamma  for all i, \Gamma , \Sigma  `-ffi x .ri

\Gamma , \Sigma  `-ffi ae

Figure 4.4: Typing rules for focus-freeness
In fact, this typing requirement is only used when translating Capucine programs to Why
programs, in Section 5.2.

Figure 4.3 illustrates an example of a region ownership tree. The gray part of the o/gure
is the closed part of the tree. Regions r and r 0 form the open part of the tree. Region r is
open and singleton; it contains one location x . This location owns a closed singleton region
s1 . The location y of s1 owns, among others, a group region s3 . Location x also owns a
group region s2 , which contains a location z which is being focused in region r 0. Location z
owns a closed group region s4 . Thus the subtree rooted at z in x .s2 is inactive: it has been
moved into r 0.

Focus-Free Regions We introduce the following judgement aimed at checking whether a
region is focus-free:

\Gamma , \Sigma  `-ffi ae
This states that ae is not being focused, and that none of its (transitively) owned regions is
being focused either. Figure 4.4 deo/nes this judgement.

A simple way to prove that region ae is focus-free is if ae;, ae* or aeG is available. Else, then
aeffi is available and we have to o/nd a variable x of type [ae] in the environment such that all
owned permissions x .ri are focus-free.

78 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS

\Gamma , \Sigma  ` c : typeof (c) EConst (\Gamma , x : o/ ), \Sigma  ` x : o/ EVar

\Gamma , \Sigma  ` e1 : int \Gamma , \Sigma  ` e2 : int op 2 {+, -, *}

\Gamma , \Sigma  ` e1 op e2 : int EIntOp

\Gamma , \Sigma  ` e1 : bool \Gamma , \Sigma  ` e2 : bool op 2 {&&, ||}

\Gamma , \Sigma  ` e1 op e2 : bool EBoolOp

\Gamma , \Sigma  ` e1 : int \Gamma , \Sigma  ` e2 : int op 2 {=, 6=, >, <, >=, <=}

\Gamma , \Sigma  ` e1 op e2 : bool EIntComp

\Gamma , \Sigma  ` e1 : o/ \Gamma , \Sigma  ` e2 : o/ op 2 {=, 6=}

\Gamma , \Sigma  ` e1 op e2 : bool EComp

aeffi{f } 2 \Sigma 
f /2 f \Gamma , x : [ae] ` ae : C (\Gamma , x : [ae]), \Sigma  ` ae f : o/ 2x C

(\Gamma , x : [ae]), \Sigma  ` x .f : o/ ESelectOpen

\Sigma  " {ae*, aeG, oe -ffi ae} 6= ;
\Gamma , x : [ae] ` ae : C (\Gamma , x : [ae]), \Sigma  ` ae f : o/ 2x C

(\Gamma , x : [ae]), \Sigma  ` x .f : o/ ESelect

f : param1 * * * paramn ! o/ for all i : \Gamma , \Sigma , oe ` argi : parami

\Gamma , \Sigma  ` f arg1 * * * argn : oe(o/ ) EApp

Figure 4.5: Typing rules for expressions
This judgement is used when a region is passed from programs to logic. Indeed, we cannot
read focused regions in the logic, nor regions which transitively own a focused region.

Expressions Expressions are typed using the following judgement:

\Gamma , \Sigma  ` e: o/
This judgement states that under environment \Gamma  and if permissions \Sigma  are available, where
\Sigma  is a multiset, expression e has type o/. Note that although \Sigma  is a multiset, we show in
Section 4.4 that if we type a program which starts with no permission, it is not possible for
the same permission to appear twice later on. Figure 4.5 shows typing rules for expressions.

Rule EConst states that the type of a constant c is typeof (c). If c is an integer, typeof (c)
is int; if c is a boolean, typeof (c) is bool ; if c is the unit constant (), then typeof (c) is unit.

Rules EIntOp, EBoolOp EIntComp and EComp give the type of operators. Note
that only integers may be compared using >, <, >= or <=.

Rule EVar states that if x : o/ is in the environment, then variable x has type o/ .

4.2. TYPING 79

\Gamma  ` ae : oe(C) \Gamma , \Sigma  ` ae

\Gamma , \Sigma , oe ` [ae] : [r : C] ARegion

oe(x ) is undeo/ned \Gamma , \Sigma  ` e : oe(o/ )

\Gamma , \Sigma , oe ` (e) : (x : o/ ) ARegular

oe(x ) = y \Gamma , \Sigma  ` y : oe(o/)

\Gamma , \Sigma , oe ` (y) : (x : o/ ), oe AVariable

Figure 4.6: Typing rules for arguments
Rules ESelectOpen and ESelect states how to type o/eld selection x .f . First we look
for the type of x in the environment. It should be a pointer type [ae], where ae is the region
of x . We then check that there is a permission available for region ae, be it aeffi{f } where f
is initialized, i.e. is not in f (rule ESelectOpen) or ae*, aeG or oe -ffi ae (for any region oe _
rule ESelect). We then type ae in the same environment, and obtain its class C. We o/nally
look for the type of o/eld f in class expression C, and we obtain the type o/ of x .f . As you can
see, this rule is similar to rule ROwn, with an additional permission check.

Rule EApp states how to type logic function application. It uses the following new
judgement:

f : param1 * * * paramn ! o/
which states that f has been declared as a function taking n region or regular arguments
param1 * * * paramn and returning a value of type o/ . It also uses the following new judgement:

\Gamma , \Sigma , oe ` arg: param
which states that argument arg has the type of argument declaration param, under envi-
ronment \Gamma , permissions \Sigma , and substitution oe. This judgement is deo/ned in Figure 4.6. To
sum up how application is typed, o/rst we o/nd a substitution oe for type variables ff, region
variables r, and variables x which are deo/ned as parameters of function f . Region variables
are substituted to the regions given to the application. Variables are substituted to the vari-
ables given to the application (rule AVariable) if needed. Type variables are substituted to
ensure arguments ei are of the correct type. The type of the application is then substitution
oe applied to the return type o/ .

If a regular argument is a variable y, rule AVariable may be applied instead of
ARegular. Rule AVariable allows to substitute y in regions. For instance, say f is
deo/ned as:

logic f : [r : C ] (x : [r]) ! [x .s]
then f [r] (y) has type [y.s]. In fact, if the variable name x of a parameter parami = (x : o/ )
is used in the type of another formal parameter or in the return type o/ 0, then argi must be
a variable, as otherwise oe(o/ 0) would not be deo/ned. Indeed, if argi is not a variable then
rule ARegular must be applied instead of AVariable for parami , thus forcing oe(x ) to be
undeo/ned.

4.2.2 Terms and Predicates
Terms and Region Terms Terms are typed using the following judgement:

80 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS

\Gamma  ` c : typeof (c) TConst \Gamma , x : o/ ` x : o/ TVar
\Gamma  ` LT 1 : int \Gamma  ` LT 2 : int op 2 {+, -, *}

\Gamma  ` LT 1 op LT 2 : int TIntOp

\Gamma  ` LT 1 : bool \Gamma  ` LT 2 : bool op 2 {&&, ||}

\Gamma  ` LT 1 op LT 2 : bool TBoolOp

\Gamma  ` RT : C \Gamma  ` LT : [.] f : o/ 2 C

\Gamma  ` get(RT , LT , f ) : o/ TSelect

f : param1 * * * paramn ! o/ for all i : \Gamma , oe ` largi : parami

\Gamma  ` f larg1 * * * largn : oe(o/) TApp

L : R 2 \Gamma  r 2 R

\Gamma , r : C ` r @L : C RTVar

\Gamma  ` RT : C0 \Gamma  ` LT : [.] s : C 2 C0

\Gamma  ` get(RT , LT , s) : C RTSelect

Figure 4.7: Typing rules for terms
\Gamma  ` RT : oe(C)
\Gamma , oe ` [RT ] : [r : C] LARegion

oe(x ) is undeo/ned \Gamma  ` LT : oe(o/)

\Gamma , oe ` (LT ) : (x : o/) LARegular

oe(x ) = y \Gamma  ` y : oe(o/ )

\Gamma , oe ` (y) : (x : o/ ) LAVariable

Figure 4.8: Typing rules for logic arguments

\Gamma  ` LT : o/
This judgement states that under environment \Gamma , term LT has type o/ . Region terms are
typed using the following judgement:

\Gamma  ` RT : o/
This judgement states that under environment \Gamma , region term RT has class C. Figure 4.7
shows typing rules for terms and region terms.

Rule TApp involves typing logic arguments with the following judgement:

\Gamma , oe ` larg: param
It is similar to the judgement for typing arguments in expressions and is deo/ned in Figure 4.8.

Rules are similar to expression and region typing rules. The main dioeerences are for the
application rule TApp and for the selection rules TSelect and RTSelect, as region terms

4.2. TYPING 81

\Gamma  ` T PTrue \Gamma  ` F PFalse

\Gamma  ` P
\Gamma  ` ~P PNot

\Gamma  ` P1 \Gamma  ` P2 op 2 {^, ., ), () }

\Gamma  ` P1 op P2 POp

\Gamma  ` LT 1 : int \Gamma  ` LT 2 : int op 2 {>, >=}

\Gamma  ` LT 1 op LT 2 PIntComp

\Gamma  ` LT 1 : o/ \Gamma  ` LT 2 : o/ op 2 {=, 6=}

\Gamma  ` LT 1 op LT 2 PComp

\Gamma , x : o/ ` P quant 2 {8, 9}

\Gamma  ` quant x : o/. P PQuant

\Gamma , r : C, here : (R [ {r}) ` P quant 2 {8, 9}

\Gamma , here : R ` quant region r : C. P PRegionQuant

p : param1 * * * paramn for all i : \Gamma , oe ` largi : parami

\Gamma  ` p larg1 * * * largn PApp

\Gamma  ` LT : [.] \Gamma  ` RT : C

\Gamma  ` LT 2 RT PIn

Figure 4.9: Typing rules for predicates
RT are involved and get accept any pointer term LT , instead of just variables. We also check
in RTVar that label L is in the environment.

Rule TSelect involves the following new judgement:

f : o/ 2 C
This judgement is similar to f : o/ 2x C, except that all pointer types are substituted to [.].
Indeed, in the logic, pointer may belong to any region. Thus owner x is not needed. Similarly,
rule RTSelect involve the following new judgement:

r : C 2 C0
which also does not need any owner x as pointer types are replaced by [.].

Predicates Predicates are typed using the following judgement:

\Gamma  ` P
This judgement states that under environment \Gamma , predicate P is well-typed. Figure 4.9 shows
typing rules for predicates.

82 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS

Rules PTrue, PFalse, PNot and POp are straightforward. Typing rules PIntComp
and PComp deal with comparisons. Typing rules PQuant and PRegionQuant deal with
quantio/ers. They introduce new variables or region variables, respectively, in the environment
to type the body. Note that regions are also added to special label here. Rule PApp is similar
to TApp, except that there is no return type. It involves the following new judgement:

p: param1 * * * paramn
which is similar to the one used for terms. Rule PIn states how to type LT 2 RT : we simply
check that LT is a pointer (i.e. has type [.]) and that RT is well-typed.

Region Names Used by a Predicate Predicates appearing inside programs, i.e. in pre-
conditions, post-conditions, assertions and invariants, may only mention focus-free regions.
This is ensured by the typing rules for functions, classes and statements, which we introduce
later.

Here we deo/ne function freeregions, which takes a predicate, a term or a region term
as an argument and returns all free region names used by the argument. The deo/nition is
straightforward: it collects all region names r with label here appearing in the predicate
which are not bound by 8region r or 9region r . In particular:

* freeregions(r @here) = {r };

* freeregions(r @L) = ; if L 6= here;

* freeregions(get(RT , LT , s)) = freeregions(RT ) [ freeregions(LT );

* freeregions(8region r : C. P) = freeregions(P)-r ;

* freeregions(9region r : C. P) = freeregions(P)-r ;

* freeregions(p larg1 * * * largn ) = freeregions(larg1 ) [ * * * [ freeregions(largn );

* freeregions(f larg1 * * * largn ) = freeregions(larg1 ) [ * * * [ freeregions(largn );
Note that typing rules enforce regions bound using quantio/ers to only be used with label
here anyway. Function freeregions is used to compute the set of regions which should be
focus-free.

4.2.3 Statements
Sequences Statements are typed using the following judgement:

\Gamma  ` {\Sigma } s {\Sigma 0}, \Gamma 0
This judgement states that given environment \Gamma  and permissions \Sigma , statement s returns
permissions \Sigma 0 and environment \Gamma 0, where \Sigma  and \Sigma 0 are multisets. Indeed, statements may
change permissions: they consume some and produce others. They also may introduce new
variables or region variables in the environment.

Sequences of statements are typed using the following similar judgement:

\Gamma  ` {\Sigma } S {\Sigma 0}, \Gamma 0
This judgement states that given environment \Gamma  and permissions \Sigma , sequence S returns
permissions \Sigma 0 and environment \Gamma 0. Here is the typing rule for sequences:

4.2. TYPING 83

for all i, \Gamma i ` {\Sigma i } si {\Sigma i+1}, \Gamma i+1
\Gamma 1 ` {\Sigma 1 } s1 ; * * * ; sn {\Sigma n+1}, \Gamma n+1 SSeq

We simply chain the statement judgements.

To type blocks, i.e. sequences of statements which limit the scope of variables, we introduce
the following judgement:

\Gamma  ` {\Sigma } S {\Sigma 0}
The environment is unchanged: the scope of variables and regions which are bound in the
block is the block itself. This also implies that all permissions which mention such variable
or region must be removed. This is shown by the rule for blocks:

\Gamma  ` {\Sigma } S {\Sigma 0}, \Gamma 0
\Gamma  ` {\Sigma } S {scope(\Gamma , \Sigma 0)}

SBlock

where scope(\Gamma , \Sigma ) is \Sigma  without all permissions mentioning a variable x or a region r which
is not in the left-hand side of a pair in environment \Gamma .

A consequence of the fact that the environment is unchanged is that if the type of a
variable changes during execution because of an adoption, focus or unfocus, then its original
type is restored. Consider for instance the following program:

let region r : Long;
let x = new Long [r];
if true then{

let region s: Long;
weaken empty s;
adopt x : r as s;}

The type of x after the allocation is [r ]. After the adoption it is [s]. But after the if
statement, the type is restored to [r ]. It is safe for x to have type [r ], because typing rules
prevent accessing x with type [r] if no permission on r is available, and the adoption consumes
r *. Note that we could consider having both x : [r] and x : [s] in the environment after the
adoption.

Statements Figures 4.10 and 4.11 shows typing rules for statements. These typing rules
are the most important rules of Capucine, as they are the ones which deal with permissions.
Rule SCall is especially important, as it requires region arguments to be separated.

Rule SLet states how to type let-bindings. The expression is typed, and the variable
is given the type of the expression in the new environment. No permission is consumed or
produced.

Rule SIf states how to type if statements. The condition must have type bool . The
then body and the else body must consume and produce the same permissions. In other
words, from permissions \Sigma  available before the if, both bodies must return the same set

84 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS

\Gamma , \Sigma  ` e : o/
\Gamma  ` {\Sigma } let x = e {\Sigma }, (\Gamma , x : o/) SLet

\Gamma , \Sigma  ` e : bool \Gamma  ` {\Sigma } s1 ; * * * ; sn {\Sigma 0} \Gamma  ` {\Sigma } s01 ; * * * ; s0m {\Sigma 0}

\Gamma  ` {\Sigma } if e then {s1 ; * * * ; sn } else {s01 ; * * * ; s0m} {\Sigma 0}, \Gamma 

SIf

f consumes \Sigma 1 f produces \Sigma 2 f : param1 * * * paramn ! o/

for all i : \Gamma , \Sigma , oe ` argi : parami separated(arg1 , * * * , argn )

\Gamma  ` {\Sigma , oe(\Sigma 1 )} let x = f arg1 * * * argn {\Sigma , oe(\Sigma 2 )}, (\Gamma , x : oe(o/ )) SCall

\Gamma  ` C
\Gamma  ` {\Sigma } let region r : C {\Sigma , r;}, (\Gamma , r : C) SLetRegion

\Gamma  ` C \Gamma  ` ae : C \Gamma , {\Sigma , ae;} ` ae f are the o/elds declared in C

\Gamma  ` {\Sigma , ae;} let x = new C [ae] {\Sigma , aeffi{f }, own(x , C);}, (\Gamma , x : [ae]) SNew

\Gamma , {\Sigma , oe;, aeG} ` ae \Gamma , {\Sigma , oe;, aeG} ` oe
\Gamma , x : [ae] ` {\Sigma , oe;, aeG} focus x : ae as oe {\Sigma , oe*, oe -ffi ae}, (\Gamma , x : [oe]) SFocus

\Gamma  ` ae : C
\Gamma , {\Sigma , aeffi{f } } ` ae f : o/ 2x C (\Gamma , x : [ae]), {\Sigma , aeffi{f } } ` e : o/

\Gamma , x : [ae] ` {\Sigma , aeffi{f } } x .f  e {\Sigma , aeffi{f - f } }, \Gamma  SAssign

Figure 4.10: Typing rules for statements (1 of 2)

4.2. TYPING 85

\Gamma , {\Sigma , oe*, aeG} ` ae \Gamma , {\Sigma , oe*, aeG} ` oe
\Gamma , x : [oe] ` {\Sigma , oe*, aeG} adopt x : oe as ae {\Sigma , aeG}, (\Gamma , x : [ae]) SAdopt

\Gamma , {\Sigma , oe*, oe -ffi ae} ` ae \Gamma , {\Sigma , oe*, oe -ffi ae} ` oe
\Gamma , x : [oe] ` {\Sigma , oe*, oe -ffi ae} unfocus x : oe as ae {\Sigma , aeG}, (\Gamma , x : [ae]) SUnfocus

\Gamma  ` ae : C
\Gamma , x : [ae] ` {\Sigma , ae*} unpack x {\Sigma , aeffi, single(x , C)*, group(x , C)G}, \Gamma  SUnpack

\Gamma  ` ae : C \Gamma , {\Sigma , aeffi, single(x , C)*, group(x , C)G} ` ae

\Gamma , {\Sigma , aeffi, single(x , C)*, group(x , C)G} `-ffi root(ae)

\Gamma , x : [ae] ` {\Sigma , aeffi, single(x , C)*, group(x , C)G} pack x : C {\Sigma , ae*}, \Gamma  SPack

\Gamma , {\Sigma , ae;} ` ae
\Gamma  ` {\Sigma , ae;} weaken empty ae {\Sigma , aeG}, \Gamma  SWeakenEmpty

\Gamma , {\Sigma , ae*} ` ae
\Gamma  ` {\Sigma , ae*} weaken single ae {\Sigma , aeG}, \Gamma  SWeakenSingle

logicenv(\Gamma ), here ` P for all r 2 freeregions(P): \Gamma , \Sigma  `-ffi r

\Gamma  ` {\Sigma } assert P {\Sigma }, \Gamma  SAssert

L /2 \Gamma  for all r 2 R, there is C such that r: C 2 \Gamma 

\Gamma  ` {\Sigma } label L {\Sigma }, (\Gamma , L : R) SLabel

Figure 4.11: Typing rules for statements (2 of 2)

86 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS
of permissions \Sigma 0, which is also the set of permissions returned by the if statement. The
environment is unchanged, as the scope of variables and regions which are bound in the
bodies are their respective then or else block.

Rule SCall states how to type function calls. First we type region arguments and normal
arguments. We obtain a substitution oe. We use oe to compute consumed permissions and
produced permissions. Finally, we add the new bound variable x to the environment, with
the return type of the function, substituted using oe. This rule uses three new judgements,
used to retrieve typing information associated to a function:

f consumes \Sigma 
which states that the declaration of f states that f consumes permissions \Sigma ,

f produces \Sigma 
which states that the declaration of f states that f produces permissions \Sigma , and

f : param: o/
which gives the region names and their classes in the declaration of f , the argument names
and their types, and the return type.

The SCall rule also requires separated(arg1 , * * *, argn ), which we now deo/ne as follows:
for all i, j , if argi = [ae] and argj = [oe], then root(ae) 6= root(oe). Function root(oe) is deo/ned
as follows: root(r) = r , and root(x .s) = root(aex ) where x : [aex ] is in \Gamma . Informally, separated
states that region arguments are disjoint. We know that two regions are disjoint if their roots
are dioeerent. For instance, a function f expecting two region arguments cannot be called as
f [ae] [x .s] if x has type [ae]. The separated condition of SCall ensures that we know how to
translate the call in Why, and thus that we can compute proof obligations.

Rule SLetRegion states how to type region binding. First we check that the given classC
is well-formed using the following new judgement:

\Gamma  ` C
This judgement simply checks that all variables, all regions and all type variables are bound
in C. Then we enter the new region r in the environment, with class C. This operation
produces permission r ;: region r is initially empty.

Rule SNew states how to type allocation in region ae. We o/rst type ae and its class C.
Region ae must be empty before the allocation. We check this by consuming permission ae;.
Permission aeffi{f } where f are the o/elds of C is produced, stating that after the allocation the
region is no longer empty but singleton and that no o/eld is initialized. Permissions own(x , C);
are also produced. Notation own(x , C) denotes the set {x .r1 , * * *, x .rn } where ri are the
owned regions in the declaration of class C. Notation {ae1 , * * *, aen }; denotes ae1 ;, * * *, aen ;. In
other words, the owned regions of a newly-allocated pointer are initially empty.

Rule SFocus states how to type the focus x :ae as oe operation. Variable x must have type
[ae] before, and its type is changed to [oe]. The operation consumes permissions oe; and aeG:
source region ae must be group, and target region oe must be empty. Target region becomes
singleton: permission oe* is produced. Region ae is temporarily disabled: permission oe -ffi ae
is produced.

Rule SAssign states how to type assignment to a o/eld x .f . First we check that x is a
pointer and we look for its region ae in the environment. We then look for the class C of ae
and use this information to obtain the type o/ of x .f . We check the type of expression e is

4.2. TYPING 87
o/ . We then check that x is open, i.e. that permission aeffi{f } is available. This permission
is consumed and replaced by aeffi{f -f }, where f -f is f without o/eld f if it was in f , and f
otherwise. In other words, if f was not initialized, it is now.

Rule SAdopt states how to type the adopt x :oe as ae operation. It changes the type of x ,
which must be [oe], to [ae]. It also consumes permissions oe* (region oe must be singleton and
closed) and aeG (region ae must be group). No permission on oe is produced: the region is no
longer usable. Permission aeG is reproduced.

Rule SUnfocus states how to type the unfocus operation. It is essentially the same as
the adopt operation: a pointer is moved from a singleton region to a group region. However,
unfocus deals with the case where the pointer already was in the group region once. Hence the
only dioeerence is that instead of consuming permission aeG, the operation consumes oe -ffi ae.

Rules SUnpack and SPack state how to type unpacking and packing, respectively. Un-
packing a pointer x requires o/nding its region ae in the environment. We then look for its
class C. We can then compute owned permissions. Notations single(x , C) and group(x , C)
are similar to own(x , C) except that instead of denoting all owned regions, they are restricted
to regions which were declared as singleton and group, respectively. Unpacking consumes
ae* (region ae is closed) and produces aeffi (region ae is open), as well as permissions on owned
regions. Packing does the opposite. Note that packing x requires all o/elds of x to be initial-
ized. Also note that packing requires the permissions on ae to be complete and its root must
be focus-free, as the invariant is read. Unpacking does not.

Rules SWeakenEmpty and SWeakenSingle state how to type the weakening opera-
tions. They simply consume the expected permission ae; or ae*, respectively, and produce the
group permission aeG.

Rule SAssert states that to type the assert P operation, we type the P predicate under
environment logicenv(\Gamma ). The logicenv function substitutes all pointer types [ae], for any
region ae, into type [.] which is the type for pointers in the logic. For instance, environment:

\Gamma  = x : [r ], r : List ([y.s]), y: [r0], r 0: Long
becomes:

logicenv(\Gamma ) = x : [.], r: List ([.]), y: [.], r0: Long
Label here is available when typing P. Note that all regions used by the predicate should be
focus-free.

Finally, rule SLabel states how to type the label L statement. We check that L is not
already in the environment, and then we add it.

4.2.4 Declarations
A program is a sequence of declarations. The user may declare or deo/ne logic functions,
predicates, axioms, lemmas, classes and functions.

Logic Declarations A logic type declaration:
type t (ff1 , * * *, ffn )
is quite easy to type: we simply check that for all i 6= j , ffi 6= ffj . The scope of a type
declaration is the remainder of the program, i.e. type t may be used in all declarations which
follow its declaration.

A predicate declaration:

88 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS
logic p param1 * * * paramn = P
or a logic function declaration:
logic f param1 * * * paramn : o/ = LT
requires checking that each argument parami is well-formed. A region argument [r: C] or a
regular argument (x : o/ ) is well-formed if class expression C or type o/ only mentions region
variables r and variables x bound in previous parameters param1 * * * parami-1. We also
check that each parameter name is unique. We then check that pointer types, being logic
pointers and not program pointers, are of the form [.] (and not [ae]). The same restriction
applies for the return type o/ for logic functions. All class expressions C and types o/ may
mention any number of free type variable, which are then considered implicitely universally
quantio/ed, i.e. the predicate p or the function f is polymorphic.

The body of a predicate declaration such as the one above is typed as follows:

param1 * * * paramn , here: ; ` P
Similarly, the body of a logic function is typed as follows:

param1 * * * paramn , here: ; ` LT : o/
If the body is not given by the user, this type-checking of course does not happen. Label
here is available when typing P and LT . It is the only label available.

The scope of a logic function or predicate is the remainder of the program. It cannot be
used inside its own body. To deo/ne a recursive logic function or predicate, the user needs to
give an axiomatization.

Axioms and lemmas deo/ned as:

axiom a: P
lemma l: P

are type-checked as follows:

here: ; ` P
In other words, the body P is typed in the empty environment. Note that we have not
explicitely shown the environment for polymorphic type variables. In practice, free type
variables in the body P are added to this environment. Label here is available when typing P.
Axioms and lemmas are available in the context of all proof obligations which are generated
by declarations which follow the declaration of the axiom or lemma.

Class Declarations Class declarations:
class C (ff) [r : C]{

size s: C;
f : o/ ;
invariant P;}

are typed as follows. First, each class expression C is typed in an environment where
previously-declared region variables and regular variables are available. We allow recur-
sive types: class C is known when typing all class expressions in its deo/nition. Thus the

4.2. TYPING 89
scope of C is the remainder of the program, plus its own deo/nition. Field types o/ are also
type-checked: all regions and type variables must have been declared before in the class def-
inition. Moreover, all pointer types must be of the form [ae], i.e. not [.]. And of course all
class expressions must have the right number of arguments (regions and types).

The invariant P is type-checked as follows:

logicenv (r1 : C1 , * * *, rn : Cn , f1 : o/1 , * * *, fn : o/n ), here: ; ` P
where r1 , * * *, rn are all region parameters and owned regions of class C , of respective classesC

1 , * * *, Cn . Fields are available in P. Label here is available when typing P.

Restriction on Class Invariants We add another important restriction to the invariant
predicate of classes: it cannot read from a region which is not owned by class C . For each
subterm get(r , LT , f ), where r is a region variable, we require that r is an owned region of
C (i.e. not a region parameter). This is fundamental for the invariant methodology. It is
similar to the restriction of Spec# [Barnett04b].

Function Declarations Function declarations:
fun f param1 * * * paramn : o/

consumes \Sigma 
produces \Sigma 0
pre P
post Q{

S;
return e}

are typed as follows. First we check each argument param by requiring region variables and
regular variables to be bound, i.e. to be region parameters of the function appearing before.
Free type variables are polymorphic type variables. Let \Gamma  be the following environment:

\Gamma  = param1 * * * paramn
We type the pre- and post-conditions P and Q in this environment:

\Gamma , here: R ` P
\Gamma , here: R, pre: R ` Q
where R is the set of regions deo/ned in arguments param. Label here is available both in
the pre-condition and the post-condition. In the post-condition, label pre is also available; it
denotes the state of the program at the beginning of the function execution. We also require,
for all r in freeregions(P):

\Gamma , \Sigma  `-ffi r
and for all r in freeregions(Q):

\Gamma , \Sigma 0 `-ffi r
We then type the body:

90 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS

\Gamma  ` {\Sigma } S {\Sigma 0 }, \Gamma 0
We then check that \Sigma 0 = scope(\Gamma , \Sigma 0 ). Finally, we type the returned expression e in the
o/nal environment:

\Gamma 0, \Sigma 0 ` e: o/
Its type must be equal to the declared return type.

The scope of a function name f is the remainder of the program, plus its own body.
Indeed, all functions may be recursive.

Note that just as we do not prevent the user from writing F as a pre-condition, we do
not require consumed permissions to be consistent. For instance, the user may require twice
the same permission ae*. However, the function will not be callable, as typing rule SCall
requires all regions to be separated.

4.3 Intuitive Memory Model
Partial Functions We use partial functions to model Capucine heaps. A partial function
f has a domain, denoted by Dom(f ). It is deo/ned as follows: f (x ) is deo/ned if, and only if
x 2 Dom(f ).

We denote by f [x 7! v ] the partial function g such that:

* Dom(g) = Dom(f ) [ {x };

* g(x ) = v;

* for all y 2 Dom(f )-x , we have g(y) = f (y).
In other words, if x 2 Dom(f ), its value is replaced by v . If x /2 Dom(f ), then x is added to
the domain of the function and its value is now v .

Model: Values, Objects, Active Regions and Locations A value is either a location
p, an integer, a boolean or unit.

The active region of a location is the region ae in which its object should be read. Usually,
a pointer belongs to only one region, which is then its active region. But a focused pointer
belongs to several regions at the same time, and it must be read from the region in which
it has been temporarily extracted. Active regions are not important for the intuitive model,
they are only used to relate the intuitive model with the separated model.

An object is a function o from o/eld names f to values, and from region names r to sets
of locations. These are the regions which are owned by the object. Set o(r) contains all
locations which are in the region r owned by o. This set does not contain transitively owned
pointers, only owned pointers. Note that o(r) may contain locations whose active region is
not r .

We assume locations to be ino/nite, countable and ordered. Given a location l, we will
denote the location following l using l +1.

4.3. INTUITIVE MEMORY MODEL 91
Model: Logic Regions Functions A logic region is a function h from locations to objects,
and from a special symbol contents to a set of pointers. The contents h(contents) contains
locations which are part of the region. In practice, it is used to interpret predicate inRegion.

The domain Dom(h) of a logic region h contains not only the locations of the region, but
also all (transitively) owned locations. We thus have h(contents) ` Dom(h).

To illustrate the dioeerence between Dom(h) and h(contents), consider the following Ca-
pucine program:

class Long{

value: int;}

class Pair{

single Rleft: Long;
single Rright: Long;
left: [Rleft];
right: [Rright];}

logic PairSum [r : Pair ] (p: [r ]) =

p.left.value + p.right.value

Assume logic region h models the region r of logic function PairSum. Then the domain of h
is the following set of locations:

Dom(h) = {p, p.left, p.right}
whereas the contents of h is the following set of locations:

h(contents) = {p}
That is, assuming region r is singleton and contains only p.

Note that Dom(h) corresponds to the notion of footprint sometimes used in the literature.
In the above example, it is exactly the footprint of logic function PairSum. In general, the
footprint of a logic function is a subset of the union of the domain of all logic regions which
are passed as parameters to the logic function.

Model: Heap We model the heap using a function H:

* H(p) returns the object at location p;

* H(x ) returns the value of variable x ;

* H(r ) returns the set of pointers of region name r ;

* H(p?) returns the active region ae (of the form r or x .s) of pointer p;

* H(next) returns the next free location to be allocated;

* H(L) returns a function from region names r to the logic region function corresponding

to r at label L.

92 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS
Note that locations p, variables x , region variables r and labels L do not share the same
namespace and next is a unique symbol, so there is no ambiguity.

Logic Model Logic values are the same as program values, and we simply call them values.
Logic objects are also the same as objects: functions from o/eld names f to values v and from
owned region names s to sets of pointers P.

A logic environment L is a function:

* L(L) returns a function from region names r to the logic region function corresponding

to r at label L;

* L(x ) returns the value of variable x .
To give semantics to function applications, we assume a model of user-declared types,
functions and predicates. This model, given a function or a predicate f declared as:

logic f param1 * * * paramn * * *
deo/nes Jf K as a function taking n arguments. This function Jf K is assumed to model user
axioms. In the case of predicates p, JpK(x ) either holds or does not hold.

From Programs to Logic We deo/ne the AEattening of a set of locations P with respect to
a heap H as all locations in a region transitively owned by P. Formally, the AEattening of P
is the set P0 such that p is in P0 if, and only if there is q1 , * * *, qn such that q1 2 P, p = qn
and for all i > 1, there is an owned region name r such that qi 2 H(qi-1)(r).

We deo/ne function lor (logic of region): if H is a heap and P is a set of locations,
lor (H, P) is the logic region corresponding to P in H. Assume P0 is the AEattening of P with
respect to H. Domain Dom(lor (H, P)) is P0 [ {contents}. For all p in P0, we deo/ne:

lor (H, P)(p) = H(p)
We also deo/ne:

lor (H, P)(contents) = P
We deo/ne loh (logic environment of heap) as a function from heaps H to logic environ-
ments L. The domain of loh is the domain of H restricted to variables x and region names
r . For each region name r in Dom(H), we deo/ne the region function associated to r at label
here as follows:

loh(H)(here)(r ) = lor (H, H(r ))
For each label L in Dom(H), we deo/ne:

loh(H)(L) = H(L)
For each variable name x in Dom(H), we deo/ne:

loh(H)(x ) = H(x )
Note that the deo/nition of the AEattening of P was given for a heap H, but it also applies
for a logic region h, as h(q)(r ) makes sense as well. We thus deo/ne lor (h, P) as a logic region
of domain contents plus the AEattening of P with respect to h. For all p in this AEattening, we
deo/ne:

4.3. INTUITIVE MEMORY MODEL 93

lor (h, P)(p) = h(p)
We also deo/ne:

lor (h, P)(contents) = P

From Programs to Logic: Example We illustrate function loh on an example. Consider
class Pair which was introduced above. Consider the following Capucine program:

let region r : Pair ;
let pair = new Pair [r ];
let left = new Long [pair .Rleft];
left.value  42;
let right = new Long [pair .Rright];
right.value  69;

If we start with an empty heap and execute the program, we obtain heap H, where H is
deo/ned as the smallest partial function such that:

H(r ) = {0}H

(pair ) = 0H
(left) = 1H
(right) = 2H
(0)(Rleft) = {1}H
(0)(Rright) = {2}H
(0)(left) = 1H
(0)(right) = 2H
(1)(value) = 42H
(2)(value) = 69H
(0?) = rH
(1?) = pair .RleftH
(2?) = pair .RrightH
(next) = 3

Logic environment loh(H) is the smallest partial function such that:
loh(H)(pair ) = 0
loh(H)(left) = 1
loh(H)(right) = 2
loh(H)(here)(r )(contents) = {0}
loh(H)(here)(r )(0)(Rleft) = {1}
loh(H)(here)(r )(0)(Rright) = {2}
loh(H)(here)(r )(0)(left) = 1
loh(H)(here)(r )(0)(right) = 2
loh(H)(here)(r)(1)(value) = 42
loh(H)(here)(r)(2)(value) = 69

We have Dom(loh(H)(here)(r )) = {contents, 0, 1, 2}.

Term Evaluation We denote by: J

LT KL

94 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICSJ

cKL = cJ
LT 1 termop LT 2 KL = JLT 1 KL termop JLT 2 KLJ
x KL = L(x )J
get(RT , LT , f )KL = JRT KL(JLT KL)(f )J
f larg1 * * * largn KL = Jf K (Jlarg1 KL, * * *, Jlargn KL)

Semantics of logic arguments larg:J

[RT ] KL = JRT KLJ
(LT ) KL = JLT KL

Figure 4.12: Term Semantics (Intuitive Model)J
r @LKL = L(L)(r)J
get(RT , LT , s)KL = lor (JRT KL, JRT KL(JLT KL)(s))

Figure 4.13: Region Term Semantics (Intuitive Model)

the evaluation of term LT in logic environment L. It returns a value v. Figure 4.12 gives the
deo/nition of JLT KL.

We denote by: J

RT KL
the evaluation of region term RT in L. It returns a logic region. Figure 4.13 gives the
deo/nition of JRT KL.

Semantics for constants, operators and variables are standard. Application uses the as-
sumed user-deo/ned model Jf K. Field selection get(RT , LT , f ) reads location JLT KL in logic
region JRT KL, and then reads o/eld f in the obtained logic object. The semantics of a region
name r at label L is L(L)(r). The semantics of a region term get(RT , LT , s) uses roh to
restrict the logic region obtained from RT , to the AEattening of the set of locations in region
s owned by LT .

Predicate Evaluation We denote by: J

PKL
the evaluation of predicate P in logic environment L. It either holds or does not hold.
Figure 4.14 gives the deo/nition of JPKL.

Deo/nition of JPKL is standard for most operators. The o/rst novelty is Jp largKL where p
is a predicate name, which is similar to Jf largKL where f is a logic function name. The other
novelties are J8region r : C. PKL and J9region r: C. PKL, which quantify over logic regions.
Quantio/ed regions are available at label here, the default label.

Expression Evaluation We now give semantics to expression. We denote by:J

eKH
the evaluation of expression e in heap H. It returns a value v . Figure 4.15 gives the deo/nition
of JeKH.

4.3. INTUITIVE MEMORY MODEL 95
Jp larg1 * * * largn KL = JpK (Jarg1 KL, * * *, Jargn KL)J

P1 ^ P2 KL holds ioe JP1 KL holds and JP2 KL holdsJ
P1 . P2 KL holds ioe JP1 KL holds or JP2 KL holdsJ
P1 ) P2 KL holds ioe JP2 KL holds or JP1 KL does not holdJ
P1 () P2 KL holds ioe JP1 KL holds if and only if JP2 KL holdsJ~

PKL holds ioe JPKL does not holdJ
TKL holdsJ
FKL does not holdJ
LT 1 = LT 2 KL holds ioe JLT 1 KL = JLT 2 KLJ
LT 1 6= LT 2 KL holds ioe JLT 1 KL 6= JLT 2 KLJ
LT 1 > LT 2 KL holds ioe JLT 1 KL > JLT 2 KLJ
LT 1 >= LT 2 KL holds ioe JLT 1 KL >= JLT 2 KLJ8

x : o/. PKL holds ioe for all value v of type o/, JPKL[x 7! v] holdsJ9
x : o/. PKL holds ioe there is a value v of type o/ such that JPKL[x 7! v] holdsJ8
region r: C. PKL holds ioe for all logic region h, JPKL[here 7! L(here)[r 7! h] ] holdsJ9
region r: C. PKL holds ioe there is h such that JPKL[here 7! L(here)[r 7! h] ] holdsJ
LT 2 RT KL holds ioe JLT KL is in JRT KL(contents)

Figure 4.14: Predicate Semantics (Intuitive Model)

JcKH = cJ

e1 op e2 KH = Je1 KH op Je2 KHJ
x KH = H(x )J
x .f KH = H(H(x ))(f )J
f arg1 * * * argn KH = Jf K (Jarg1 KH, * * *, Jargn KH)

Semantics of arguments arg:J

[ae] KH = lor (H, H(ae))J
(e) KH = JeKH

Figure 4.15: Expression Semantics (Intuitive Model)

96 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS

Constants and operations are evaluated as themselves. The evaluation of logic functions in
expressions is the same as the one for terms, except that the model for regions is constructed
from program regions ae. To evaluate a variable is just to read its value in the heap. To
evaluate x .f , o/rst we read variable x to obtain a location p, then we read at location p to
obtain an object, and o/nally we read the f o/eld of the object.

Statement Execution We now give semantics to statements. We denote by:

H, s =) H0
the execution of statement s which transforms heap H into heap H0. We denote by:

H, s =) 1
the fact that the execution of statement s diverges.

We write:

H, s1 ; * * *; sn =) H0
if, and only if for all i:

Hi , si =) Hi+1
and H = H1 and H0 = Hn+1. We write:

H, s1 ; * * *; sn =) 1
if, and only if there is some i such that:

H, s1 ; * * *; si =) H0
and:

H0, si+1 =) 1
If f is a partial function (a heap H, for instance) we denote by f [ae 7! P] the function g
deo/ned as follows. If ae is a region variable r, then g(r ) = P and for all x 6= r , g(x ) = f (x ).
This corresponds to the already-deo/ned f [r 7! P]. Else ae is an owned region x .r, and then
g(x ) = g(x )[r 7! P] and for all y 6= x , g(y) = f (y).

We denote H(x .r ) = H(H(x ))(r ). In particular, this allows us to write H(ae) whether ae
is a region variable or an owned region.

Figures 4.16 and 4.17 give semantics for each statement of the Capucine language. Fig-
ure 4.16 deo/nes the semantics of statements which terminate. The deo/nition is inductive.
Figure 4.17 deo/nes the semantics of statements which diverge, which may happen due to
the presence of recursive functions. The deo/nition is coinductive. Programs which neither
terminate nor diverge are programs which block because of an error.

The let-binding statement inserts a new variable into the heap. It uses the semantics of
expressions deo/ned in Figure 4.15 to compute the value given to the variable.

The let-region statement simply adds the new region in the heap, initially empty.
The unpack and weakening statements do nothing and always reduce. They are only used
as typing annotations.

The focus statement o/rst computes the location p stored in variable x . Then it sets region
oe to a singleton region containing only p. The active region of p is changed to oe.

4.3. INTUITIVE MEMORY MODEL 97
H, let x = e =) H[x 7! JeKH]H

, let region r : C =) H[r 7! ;]H
, unpack x =) HH
, weaken empty ae =) HH
, weaken single ae =) HH
, focus x : ae as oe =) H[oe 7! {H(x )}][H(x )? 7! oe]H
, unfocus x : oe as ae =) H[H(x )? 7! ae]H
, x .f  e =) H[H(x ) 7! H(x )[f 7! JeKH] ]H
, adopt x : oe as ae =) H[ae 7! H(ae) [ {H(x )}][H(x )? 7! ae]

H, if e then S else S0 =) H0
with H, S =) H0 if JeKH = true and H, S0 =) H0 if JeKH = false.

H, let x = f arg1 * * * argl =) H4 [x 7! JeKH3 ]
where:
arg1 * * * argl restricted to region arguments is [ae1 ] * * * [aen ],
arg1 * * * argl restricted to regular arguments is (e1 ) * * * (em),
f was declared with region arguments r1 , * * *, rn in this order,
f was declared with regular arguments x1 , * * *, xm in this order,
f was declared with body s1 ; * * *; sn ; return e,
f was declared with pre-condition P and post-condition Q,H

1 = H[x1 7! Je1 KH]* * *[xm 7! JemKH],H
2 = H1 [r1 7! H(ae1 )]* * *[rn 7! H(aen )][ae1 ? 7! r1 ]* * *[aen ? 7! rn ],H
2 , s1 ; * * *; sl =) H3 ,H
4 = H3 [ae1 7! H3 (r1 )]* * *[aen 7! H3 (rn )][r1 ? 7! ae1 ]* * *[rn ? 7! aen ],and only if J

PKloh(H2 ) and JQKloh(H3 [result 7! JeKH3 ]) hold.

H, let x = new C [ae] =) H[p 7! o][x 7! p][ae 7! {p}][p? 7! ae][next 7! p+1]
where p = H(next) and o is an object associating ; to every region owned by C.

H, pack x : C =) H
if JInv C(H(x ))Kloh(H) holds.

H, assert P =) H
if JPKloh(H) holds.

H, label L =) H[L 7! cur ]
where cur is loh(H) restricted to labels.

Figure 4.16: Statement Semantics (Intuitive Model)

98 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS
H, if e then S else S0 =) 1
with H, S =) 1 if JeKH = true and H, S0 =) 1 if JeKH = false.

H, let x = f arg1 * * * argl =) 1
where:
arg1 * * * argl restricted to region arguments is [ae1 ] * * * [aen ],
arg1 * * * argl restricted to regular arguments is (e1 ) * * * (em),
f was declared with region arguments r1 , * * *, rn in this order,
f was declared with regular arguments x1 , * * *, xm in this order,
f was declared with body s1 ; * * *; sn ; return e,
f was declared with pre-condition P and post-condition Q,H

1 = H[x1 7! Je1 KH]* * *[xm 7! JemKH],H
2 = H1 [r1 7! H(ae1 )]* * *[rn 7! H(aen )][ae1 ? 7! r1 ]* * *[aen ? 7! rn ],H
2 , s1 ; * * *; sl =) 1

Figure 4.17: Statement Semantics: Divergence (Intuitive Model)

The unfocus statement restores the active region of x to ae.
The assignment statement o/rst reads the location stored in variable x . Then it modio/es
the object stored at this location to change the f o/eld.

The adoption statement adds location p stored in variable x to the set of pointers denoted
by region ae. The active region of p becomes ae.

The if statement is only deo/ned if the condition evaluates to true or false. The block
which is executed depends on this value.

The call statement semantics is a little tricky. Because the body of function f is de-
o/ned using formal parameters r1 , * * *, rn and x1 , * * *, xn , we build a heap H2 in which these
variables make sense. Their value is the value which was given as argument to the call.
This is simple for variables x1 , * * *, xn . For regions r1 , * * *, rn we also have to modify the
active regions of pointers. To this end we deo/ne H[ae? 7! r ] as f [p1 ? 7! r ]* * *[pn ? 7! r ], if{

p | H(p?) = ae} = {p1 , * * *, pn }. Note that we also require the pre-condition to hold in H2 .
After the call we obtain heap H3 , and we have to move pointers back to their original region.
We thus obtain H4 , which is almost the o/nal heap. We then return heap H4 with additional
variable x whose value is the evaluation of the return expression e in heap H3 . Note that we
also assume that no variable capture occurs.

The allocation statement takes the next free location p in the heap and puts it in newly-
bound variable x . Then H(next) becomes p+1. An object o is allocated in H(p), with empty
sets for all owned regions. The active region of p is ae, and ae is set to be the singleton set{

p}.

The pack statement does not change the heap, but it only reduces if the invariant of the
pointer being packed holds. To this end we deo/ne JInv C(p)KL, the invariant predicate of classC

applied to location p. It is equivalent to JPKL0 where P is the invariant predicate deo/ned
in the declaration of C, and L0 is a logic environment such that: for each o/eld f of C, we
have L0(f ) = L(p)(f ) (o/eld name f is viewed as a variable name) and for all region r of C,
we have L0(r ) = L(p)(r ).

The assert statement does not change the heap, but it only reduces if its predicate holds
in the current heap.

4.4. COHERENCE PRESERVATION 99
4.4 Coherence Preservation
Type of Values We say that type o/ is a pointer type of class C in environment \Gamma  and heapH

if o/ is [r ] and r : C is in \Gamma , or if o/ is [x .r ], x : o/ 0 is in \Gamma , o/ 0 is a pointer type of class C0, and
r is an owned region of class C in the class deo/nition of C0.

We say that p is a location of class C in heap H if H(p)(f ) is deo/ned for each o/eld f
deo/ned in C and is a value of the type of f (see below), and H(p)(r ) is deo/ned for each region
r deo/ned in C.

We say that v is a value of type o/ in environment \Gamma  and heap H if:

* o/ is int and v is an integer;

* or o/ is bool and v is true or false;

* or o/ is unit and v is the unit constant ();

* or o/ is a user type and v is a value of this type;

* or o/ is a pointer type of class C and v is a location of class C.
These deo/nitions coinductive. An inductive deo/nition would restrict ourself to programs
which do not manipulate data structures with cycles.

Coherence We say that location p is closed for class C in heap H if, and only if the
invariant of p holds in H, i.e.: J

Inv C(p)Kloh(H)
and all owned locations of p are closed, i.e. for all region r , for all q in H(p)(r ) (if deo/ned),
then q is closed in H. Moreover, we require that if r is deo/ned as a singleton region in C,
then H(p)(r) is a singleton set.

Heap H is coherent with respect to permissions \Sigma  and typing environment \Gamma  if, and only
if:

1. (unicity of permissions) for all region ae, there is at most one permission of the form

ae;, aeffi, ae*, aeG or oe -ffi ae in \Sigma ;

2. (empty permissions) if ae; is in \Sigma , then H(ae) = ;;
3. (singleton permissions) if aeffi{f } or ae* is in \Sigma , then there is p such that H(ae) = {p};
4. (closed permissions) if ae* or aeG is in \Sigma  and \Gamma  ` ae: C, then all p in H(ae) is closed

for C in H;

5. (focus permissions) if oe -ffi ae is in \Sigma  and \Gamma  ` ae: C, then all p in H(ae) - H(oe) is

closed for C in H;

6. (type of values) for all expression e such that \Gamma , \Sigma  ` e: o/ , then JeKH is deo/ned and

is a value of type o/ ;

7. (regions are deo/ned) for all region ae such that \Gamma  ` ae: C, then H(ae) is deo/ned;
8. (active regions) for all location p, for all region ae, if p 2 H(ae) and either aeffi, ae*, aeG

is in \Sigma  or oe -ffi ae is in \Sigma  and p /2 H(oe), then H(p?) = ae;

100 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS

9. (labels are deo/ned) for all L: R in \Gamma , for all r in R, H(L)(r) is deo/ned.
Item 1 is required for consistency; having both ae; and ae*, for instance, would result in ae
being both empty and not empty. Items 2, 3, 4 and 5 state the meaning of each permission.
Items 4 and 5 are especially important, as they ensure that invariants hold when they are
supposed to. In fact, they are the items which matter the most from an external point of
vue; other items strengthen the coherence predicate to be able to prove items 4 and 5. Item 6
mainly states that variables and locations of the heap are of the correct type. It also states
that all well-typed expressions can actually be evaluated. In the same fashion, item 7 states
that all well-typed regions make sense in the heap. Item 8 gives the meaning of active regions.
Item 9 ensures that labels in the environment are in the heap domain.

The following theorem states that executing a program in a coherent heap results in a
coherent heap.

Theorem 1 (Coherence Preservation) For all heap H coherent with respect to an
environment \Gamma  and some permissions \Sigma , for all statement s, if

\Gamma  ` {\Sigma } s {\Sigma 0}, \Gamma 0
and if

H, s =) H0
then H0 is coherent with respect to \Gamma 0 and \Sigma 0.

Proof. By induction on the derivation of H, s =) H0. We o/rst note that all statements
preserve item 1 of coherence. We will implicitely use this hypothesis each time a region or a
location is modio/ed in the heap in the following fashion: if we show item 2, 3, 4 or 5 for a
given region ae, we do not have to show any other of these items for region ae, except for ae*
which is shared by 3 and 4.

* let x = e

Item 6 of coherence is preserved because the only new variable in the environment is
x of the type o/ of expression e, and thus the only new well-typed expressions are x ,
and other expressions mentionning x . The value given to x in the heap is the value
obtained by evaluating e. Item 6 of coherence of H states that this value has type o/ .
From there we prove item 6 on all new well-typed expressions, i.e. those who mention
x , by induction on these expressions. Other items of coherence are trivial.

* if e then S1 else S2

We use the induction hypothesis on either S1 or S2 , depending on JeKH.

* let x = f arg

Recall typing rule SCall:

f consumes \Sigma 1 f produces \Sigma 2 f : param1 * * * paramn ! o/

for all i : \Gamma , \Sigma , oe ` argi : parami separated(arg1 , * * * , argn )

\Gamma  ` {\Sigma , oe(\Sigma 1 )} let x = f arg1 * * * argn {\Sigma , oe(\Sigma 2 )}, (\Gamma , x : oe(o/ )) SCall

4.4. COHERENCE PRESERVATION 101

First we show that H2 is coherent with respect to the internal environment \Gamma 2 and
permissions \Sigma 2 with which the body of function f was typed. Then we apply the
induction hypothesis and obtain that H3 is coherent. Then we show that H0 is coherent.

Heap H1 is obtained from H by adding variables x with respective values JeKH. Typing
ensures that the type of these values is the formal type of the regular arguments x of
f , and thus item 6 of coherence of H1 with respect to \Gamma 0 holds.

Heap H2 is obtained from H1 by adding regions r with respective sets H(ae). Typing
of permissions ensures that permissions \Sigma 1 are available. Thus items 2, 3, 4 and 5 of
coherence hold too, and H2 is coherent. Thus H3 is coherent.

We use a similar reasoning from produced permissions to show that H4 is coherent
after transferring regions back. Heap H0 is obtained from H4 by adding variable x of
the correct type, thus preserving coherence.

* let region r : C

The only items of coherence which are not straightforward are items 2, 6 and 7, as there
is new permission r ; and new region r in the environment. Item 2 holds by deo/nition
of =). The only new well-typed expressions are logic function applications using r ,
which are of the correct type. So item 6 of coherence is preserved. By deo/nition of the
reduction rule, H0(r ) is deo/ned, so item 7 is preserved.

* let x = new C [ae]

Item 6 holds as x is a pointer of the correct type. Expressions x .f is not well-typed
as permission on ae states that no o/eld is initialized. Permission ae; is consumed and
replaced by aeffi and empty permissions on owned regions of x . Region ae is indeed
singleton after the allocation, and owned regions are indeed empty. Moreover, H(x .r )
is deo/ned for each owned region r , so item 7 of coherence is preserved. Let p = H(next).
Item 8 holds as we have p 2 H0(ae) along with H0(p?) = ae and aeffi.

* focus x : ae as oe

Permissions aeG and oe; are consumed and replaced by oe -ffi ae and oe*. The location
put into oe was in ae; we use item 4 to show that it was thus closed, and is still closed
in oe. Region oe is singleton after the operation by deo/nition of =). Thus items 3 and
4 are preserved. The active region of the focused pointer is changed from oe to ae, to
preserve item 8.

Variable x has changed type from [ae] to [oe], but it indeed contains a location of oe, so
item 6 is preserved.

* x .f  e

This operation does not break items 4 and 5 of coherence. Indeed, assume that the
invariant of a pointer p is broken by this assignment. Then this invariant depends on
x .f . The restriction on invariants requires that x is (transitively) owned by p, which
contradicts item 4 of coherence.

Item 6 holds as typing ensures that JeKH has the type of f , and the only new well-typed
expression is x .f (permissions state that f is now initialized if it was not).

* adopt x : oe as ae

102 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS

Permission aeG is produced. We thus have to show that the new pointer of ae, i.e. x , is
closed. To this end we use the fact that oe* was available before the operation. Thus
item 4 is preserved. The active region of the focused pointer is changed from oe to ae,
to preserves item 8.

Variable x has changed type from [oe] to [ae], but it indeed contains a location which is
now in ae, so item 6 is preserved.

* unfocus x : oe as ae

Permission aeG is produced while oe -ffi ae was available before. We thus have to show
that the pointer of oe, i.e. x , is closed. To this end we use the fact that oe* was available
before the operation. Thus item 4 is preserved. The active region of the focused pointer
is changed from oe to ae, to preserves item 8.

Variable x has changed type from [oe] to [ae], but it indeed contains a location which is
now in ae, so item 6 is preserved.

Note how close this reasoning is to the one we used above for adoption. Indeed, adopt
and unfocus are very similar operations.

* pack x : C

Permission ae* is produced, where ae is the region of x . We thus have to show that
x is closed. By deo/nition of =), the invariant of x holds. Moreover, typing ensures
that closed permissions on all owned regions of x are consumed. So we use item 4 of
coherence to show that all (transitively) owned locations are closed, and thus that x is
closed itself.

* unpack x

Permission aeffi is produced, and ae* is consumed so ae is indeed singleton. Permissions on
owned regions are produced. We use item 4 to show that all owned locations of x are
closed and thus that item 4 is preserved. We also use item 4 to show that all singleton
owned locations are indeed singletons, and thus that item 3 is preserved.

* weaken empty ae

An empty region has no pointer, so item 4 trivially holds.

* weaken single ae

Permission ae* is consumed and replaced by aeG, which preserves item 4 of coherence.

* assert P

Heap, environment and permissions are not modio/ed by this operation.

* label L

We add L: R in \Gamma , so we have to check item 9 of coherence. The typing rule requires
all region names r in R to be in \Gamma , so from item 7 of coherence we obtain that H(r) is
deo/ned. So loh(H)(r) is deo/ned as well, and thus H0(L)(r ) is deo/ned.

2

4.5. SEPARATED MEMORY MODEL 103
4.5 Separated Memory Model
4.5.1 Separated Operational Semantics
We now give Capucine a model which is less standard, but which is closer to the Capucine-
to-Why translation which will be introduced in Chapter 5. The idea is that locations do not
belong to the heap but to regions. In other words, instead of writing H(p), we write Hs(r )(p)
where r is the region of location p. Moreover, if p owns a region s, we can obtain its object
by writing Hs(r )(p)(s). If location q belongs to s, we can write Hs(r )(p)(s)(q) to obtain the
object of q.

Model We deo/ne a region function g as a function from locations p to separated objects o.
A separated object is a function from o/eld names f to values, and from owned region names
r to region functions.

We deo/ne the separated heap Hs as a function:

* Hs(x ) returns the value of variable x ;

* Hs(r) returns the region function of region name r ;

* Hs(p?) returns the active region of pointer p;

* Hs(next) returns the next free location to be allocated;

* Hs(L)(r) returns a region function.
Hs(x ), Hs(p?) and Hs(next) are the same as H(x ), H(p?) and H(next), respectively. The
only change is thus that H(p) is moved into region functions Hs(r ).

We then deo/ne Hs(p) as follows. If Hs(p?) = r, where r is a region variable name, then we
deo/ne Hs(p) = Hs(r)(p). If Hs(p?) = x .r then we deo/ne Hs(p) = Hs(Hs(x ))(r )(p). This
is a recursive deo/nition, and thus Hs(p) is only deo/ned if the path described by Hs(p?) is
deo/ned and o/nite.

We deo/ne Hs[p 7! o] as follows. If Hs(p?) = r then:

Hs[p 7! o] = Hs[r 7! Hs(r)[p 7! o] ]
If Hs(p?) = x .r then:

Hs[p 7! o] = Hs[Hs(x ) 7! Hs(Hs(x ))[r 7! Hs(Hs(x ))(r)[p 7! o] ] ]
It is once again a recursive deo/nition.

We also deo/ne:

Hs(p.r ) = Hs(p)(r )

Hs(x .r ) = Hs(Hs(x ))(r)
as well as the corresponding replacements:

Hs[p.r 7! g] = Hs[p 7! Hs(p)[r 7! g] ]

Hs[x .r 7! g] = Hs[Hs(x ) 7! Hs(Hs(x ))[r 7! g] ]

104 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS
Logic Model The separated logic model is very close to the separated program model. A
separated logic environment Ls is a function:

* Ls(L)(r ) returns a region function;

* Ls(x ) returns the value of variable x .
Ls thus looks like a projection of Hs on regions and variables.

From Programs to Logic We deo/ne lor s(g), where g is a separated region function,
as the logic region corresponding to g. By logic region we mean intuitive logic region as
introduced in Section 4.3, not separated logic region. Formally, lor s(g) is deo/ned as the
smallest function such that:

lor s(g)(contents) = Dom(g)
and for all n >= 0, for all p1 , * * *, pn , for all r1 , * * *, rn , for all p, for all o/eld name f , for all
owned region name s, if g(p1 )(r1 )* * *(pn )(rn )(p)(f ) is deo/ned then:

lor s(p)(f ) = g(p1 )(r1 )* * *(pn )(rn )(p)(f )
and if g(p1 )(r1 )* * *(pn )(rn )(p)(r ) is deo/ned then:

lor s(p)(s) = Dom(g(p1 )(r1 )* * *(pn )(rn )(p)(s))
If a location appears twice in g, then lor s(g) is not deo/ned. For instance, if p 2 Dom(g) and
p 2 Dom(g(p)(s)), lor s(g) is not deo/ned.

We deo/ne lor s0(g, Hs) where g is a separated region function, as the logic region corre-
sponding to g in Hs. The dioeerence with lor s is that we take active regions of pointers inH

s into account. Thus:

Dom(lor s0(g, Hs)) = Dom(lor s(g))
and for all p in Dom(lor s(g)):

lor s0(g, Hs)(p) = Hs(p)
Remember that Hs(p) is actually a notation which uses active regions of pointers. Finally
we of course have:

lor s0(g, Hs)(contents) = lor s(g)(contents) = Dom(g)
We deo/ne lohs as a function from separated heaps Hs to separated logic environmentsL
s. The domain of lohs is the domain of Hs restricted to variables x and region names r .For each region name

r in Dom(Hs), we deo/ne:

lohs(Hs)(here)(r ) = lor s0(Hs(r ), Hs)
For each label L in Dom(Hs), we deo/ne:

lohs(Hs)(L) = Hs(L)
For each variable name x in Dom(Hs), we deo/ne:

lohs(Hs)(x ) = Hs(x )

4.5. SEPARATED MEMORY MODEL 105L

cMLs = cL
LT 1 termop LT 2 MLs = LLT 1 MLs termop LLT 2 MLsL
x MLs = Ls(x )L
get(RT , LT , f )MLs = LRT MLs(LLT MLs)(f )L
f larg1 * * * largn MLs = Jf K (Llarg1 MLs, * * *, Llargn MLs)

Semantics of logic arguments larg:L

[RT ] MLs = LRT MLsL
(LT ) MLs = LLT MLs

Figure 4.18: Term Semantics (Separated Model)L
r @LMLs = Ls(L)(r )L
get(RT , LT , s)MLs = lor s(LRT MLs (LLT MLs )(s))

Figure 4.19: Region Term Semantics (Separated Model)

Term Evaluation We denote by: L

LT MLs
the evaluation of term LT in separated logic environment Ls. It returns a value v. Figure 4.18
gives the deo/nition of LLT MLs.

We denote by: L

RT MLs
the evaluation of region term RT in Ls. It returns a logic region. Figure 4.19 gives the
deo/nition of LRT MLs.

Term evaluation in the separated model is very similar to term evaluation in the intuitive
model. In fact, the only dioeerence is evaluation of region term get(RT , LT , s). Note that
we do not assume another model Lf M for logic functions and predicates; instead we reuse the
existing one Jf K. This ensures that we obtain the same result when applying f in the intuitive
model and in the separated model.

Predicate Evaluation We denote by: L

PMLs
the evaluation of predicate P in separated logic environment Ls. It is similar to predicate
evaluation in an intuitive logic environment L, except that we use the separated term and
region evaluation deo/ned above. Thus the deo/nition of LPMLs is exactly the same as the
deo/nition of JPKL in Figure 4.14, except that most J.K are replaced by L.M and L by Ls. We
only keep JpK instead of LpM in predicate application, just as we did for terms.

Expression Evaluation We denote by: L

eMHs
the evaluation of expression e in separated heap Hs. Figure 4.20 gives the deo/nition of LeMHs .
It is similar to expression evaluation in an intuitive heap H as deo/ned in 4.15, except that
the deo/nition of Hs(p) is not the same as the deo/nition of H(p), and that the deo/nition ofL

[ae] MH is not the same as the deo/nition of J [ae] MH.

106 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICSL

cMHs = cL
e1 op e2 MHs = Le1 MHs op Le2 MHsL
x MHs = Hs(x )L
x .f MHs = Hs(Hs(x ))(f )L
f arg1 * * * argn MHs = Jf K (Larg1 MHs , * * *, Largn MHs)

Semantics of arguments arg:L

[ae] MHs = lor s0(Hs(ae), Hs)L
(e) MHs = LeMHs

Figure 4.20: Expression Semantics (Separated Model)

Statement Execution We denote by:H

s, s =) Hs0
the execution of statement s which transforms separated heap Hs into separated heap Hs0.
We denote by: H

s, s =) 1
the fact that the execution of statement s diverges. In a similar fashion as for the intuitive
semantics, we write: H

s, s1 ; * * *; sn =) Hs0
and: H

s, s1 ; * * *; sn =) 1
the semantics for sequences.

Figures 4.21 and 4.22 give semantics for each statement of the Capucine language in our
separated model. The deo/nitions are respectively inductive and coinductive.

We denote by ; the function of empty domain. It is used by the let region statement,
which adds an empty region, i.e. a function of empty domain, to the heap.

Most deo/nitions are unchanged from the intuitive model, or at least looks unchanged
thanks to notations such as Hs[p 7! * * *]. This is the case in particular for assignment and
function calls. Deo/nition for function calls uses notation f [ae? 7! * * *] which was deo/ned for
the intuitive model. The only deo/nitions which actually look dioeerent are deo/nitions for
focus, unfocus, adoption and allocation.

Adoption and allocation need to be rewritten because regions are no longer sets, but
functions from locations to objects. In the allocation rule, notation (p 7! o) denotes the
function of domain {p}, which associates o to p. More importantly, we need to rewrite rules
for focus, unfocus and adoption. Indeed, this time the object associated to the location must
be moved with the location. Note that the rule for adoption is the same as the rule for
unfocus. Also note that in those two rules, it happens that p = Hs(x ) and o = Hs(p).

Allocation Although pointers are separated, they are still allocated using a single counterH

s(next). There is not one such counter per region. This implies, in particular, that iftwo locations are in two distinct regions and if some permissions are available on those two

regions, then the locations are dioeerent. The permission condition is important as some
locations may actually be in several regions because of the focus and adopt operations. We
show in Section 5.7 how the programmer can use such kind of information.

4.5. SEPARATED MEMORY MODEL 107
Hs, let x = e =) Hs[x 7! LeMHs]H

s, let region r: C =) Hs[r 7! ;]H
s, unpack x =) HsH
s, weaken empty ae =) HsH
s, weaken single ae =) HsH
s, x .f  e =) Hs[Hs(x ) 7! Hs(x )[f 7! LeMHs ] ]

Hs, if e then S else S0 =) Hs0
with Hs, S =) Hs0 if LeMHs = true and Hs, S0 =) Hs0 if LeMHs = false.

Hs, let x = f arg1 * * * argl =) Hs4 [x 7! LeMHs3 ]
where:
arg1 * * * argl restricted to region arguments is [ae1 ] * * * [aen ],
arg1 * * * argl restricted to regular arguments is (e1 ) * * * (em),
f was declared with region arguments r1 , * * *, rn in this order,
f was declared with regular arguments x1 , * * *, xm in this order,
f was declared with body s1 ; * * *; sn ; return e,
f was declared with pre-condition P and post-condition Q,H

s1 = Hs[x1 7! Le1 MHs]* * *[xm 7! Lem MHs],H
s2 = Hs1 [r1 7! Hs(ae1 )]* * *[rn 7! Hs(aen )][ae1 ? 7! r1 ]* * *[aen ? 7! rn ],H
s2 , s1 ; * * *; sl =) Hs3 ,H
s4 = Hs3 [ae1 7! Hs3 (r1 )]* * *[aen 7! Hs3 (rn )][r1 ? 7! ae1 ]* * *[rn ? 7! aen ],and only if L

PMlohs(Hs2 ) and LQMlohs(Hs3 [result 7! LeMH

s3 ]) hold.

Hs, let x = new C [ae] =) Hs[ae 7! (p 7! o)][x 7! p][p? 7! ae][next 7! p+1]
where p = Hs(next) and o is an object associating ; to every region owned by C.

Hs, pack x : C =) Hs
if LInv C(Hs(x ))Mlohs(Hs) holds.

Hs, assert P =) Hs
if LPMlohs(Hs) holds.

Hs, focus x : ae as oe =) Hs[oe 7! (p 7! Hs(p))][p? 7! oe]
where p = Hs(x ).

Hs, unfocus x : oe as ae =) Hs[ae 7! Hs(ae)[p 7! o] ][p? 7! ae]
if Hs(oe) = p 7! o.

Hs, adopt x : oe as ae =) Hs[ae 7! Hs(ae)[p 7! o] ][p? 7! ae]
if Hs(oe) = p 7! o.

Hs, label L =) Hs[L 7! cur ]
where cur is lohs(H) restricted to labels.

Figure 4.21: Statement Semantics (Separated Model)

108 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS
Hs, if e then S else S0 =) 1
with Hs, S =) 1 if LeMHs = true and Hs, S0 =) 1 if LeMHs = false.

Hs, let x = f arg1 * * * argl =) 1
where:
arg1 * * * argl restricted to region arguments is [ae1 ] * * * [aen ],
arg1 * * * argl restricted to regular arguments is (e1 ) * * * (em),
f was declared with region arguments r1 , * * *, rn in this order,
f was declared with regular arguments x1 , * * *, xm in this order,
f was declared with body s1 ; * * *; sn ; return e,
f was declared with pre-condition P and post-condition Q,H

s1 = Hs[x1 7! Le1 MHs]* * *[xm 7! Lem MHs],H
s2 = Hs1 [r1 7! Hs(ae1 )]* * *[rn 7! Hs(aen )][ae1 ? 7! r1 ]* * *[aen ? 7! rn ],H
s2 , s1 ; * * *; sl =) 1

Figure 4.22: Statement Semantics: Divergence (Separated Model)

4.5.2 Intuitive and Separated Model Equivalence
We now compare the intuitive model and the separated model. We deo/ne a relation between
intuitive heaps and separated heaps, and we show that executing a statement preserves this
relation.

We deo/ne relation Ro(o, os) between an intuitive heap H, an intuitive object o and a
separated object os as the smallest relation verifying the following properties:

1. for all o/eld name f , o(f ) is deo/ned if, and only if os (f ) is deo/ned and if so, os(f ) = o(f );
2. for all region name r , o(r ) is deo/ned if, and only if os (r ) is deo/ned and if so,

Dom(os (r )) = o(r ).

We deo/ne relation R(H, Hs) between an intuitive heap H and a separated heap Hs as
the smallest relation verifying the following properties:

1. for all variable name x , H(x ) is deo/ned if, and only if Hs(x ) is deo/ned and if so,H

s(x ) = H(x );

2. for all location p, H(p?) is deo/ned if, and only if Hs(p?) is deo/ned and if so,H

s(p?) = H(p?);

3. for all location p, H(p) is deo/ned if, and only if Hs(p) is deo/ned and if so,R

o(H(p), Hs(p));

4. for all region name r, H(r ) is deo/ned if, and only if Hs(r ) is deo/ned and if so,

Dom(Hs(r)) = H(r);

5. H(next) = Hs(next);
6. for all label L, H(L) is deo/ned if, and only if Hs(L) is deo/ned and if so, H(L) = Hs(L).

Note that for two heaps to be in relation, it is necessary for paths described by active
regions of pointers to be o/nite. Indeed, Hs(p) is not deo/ned otherwise.

We o/rst show that terms and region terms evaluate to the same values in both models.

4.5. SEPARATED MEMORY MODEL 109
Theorem 2 (Soundness of Separated Term Evaluation) Let \Sigma  be a set of permissions,
\Gamma  an environment, RT a well-typed region term with respect to \Gamma , LT a well-typed term with
respect to \Gamma , H an coherent intuitive heap with respect to \Sigma  and \Gamma , and Hs a separated heap
such that R(H, Hs). Let L = loh(H) and Ls = lohs(Hs). Then:

1. JRT KL and LRT MLs are deo/ned, and are equal region functions;
2. JLT KL and LLT MLs are deo/ned, and are equal values.

Proof. By structural induction on RT and LT . More precisely, our induction hypothesis
is the following. Let x be either a a well-typed region term or a well-typed term. Then for
all sub-region-term RT of x , JRT KL and LRT MLs are deo/ned, and are equal region functions.
And for all sub-term LT of x , JLT KL and LLT MLs are deo/ned, and are equal values.

First, we consider the cases where x is a term.

* c

Constants are trivially evaluated as the same values.

* x

From item 6 of coherence we know that H(x ) is deo/ned. L(x ) and Ls(x ) are, by
construction, respectively equal to H(x ) and Hs(x ), which are equal by R if they are
deo/ned.

* LT 1 termop LT 2

We apply the induction hypothesis on LT 1 and LT 2 . Operations termop then evaluate
equally.

* f larg

For each argument larg, if larg is of the form [RT ] then we apply the induction hypoth-
esis on RT , else larg is of the form (LT ) and we apply the induction hypothesis on LT .
Function Jf K applied to these arguments is then the same in both models.

* get(RT , LT , f )

We apply the induction hypothesis on RT and LT .
Then we prove that lor and lor s construct the same logic region. On contents, these
logic regions are equal by R. On each location p, these logic regions are equal by R.
The domain of these logic regions are equal by construction of the AEattenings.

Finally we use R to obtain the fact that the f o/elds are equal in both models.

Then we consider the cases where x is a region term.

* r @L

This case amounts to showing that lor and lor s construct the same logic region, in
a similar fashion than for the get(RT , LT , f ) case above. We also use the fact thatH

(L) = Hs(L).

* get(RT , LT , s)

We apply the induction hypothesis on RT and LT , and then we show that lor and
lor s construct the same logic region in a similar fashion than we did for the above
get(RT , LT , f ) case.

110 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS
2

We can now show a similar theorem for predicates.
Theorem 3 (Soundness of Separated Predicate Evaluation) Let \Sigma  be a set of permis-
sions, \Gamma  an environment, P a well-typed predicate with respect to logicenv (\Gamma ), H an coherent
intuitive heap with respect to \Sigma  and \Gamma , and Hs a separated heap such that R(H, Hs). LetL

= loh(H) and Ls = lohs(Hs). Then JPKL and LPMLs are deo/ned and are equivalent.

Proof. By induction on P. We apply Theorem 2 on terms and region terms, in particular
for the case of the LT 2 RT predicate. 2

We now show a similar theorem for expressions.
Theorem 4 (Soundness of Separated Expression Evaluation) Let \Sigma  be a set of
permissions, \Gamma  an environment, e a well-typed expression with respect to \Sigma  and \Gamma , H an
coherent intuitive heap with respect to \Sigma  and \Gamma , and Hs a separated heap such that R(H, Hs).
Then JeKH and LeMHs are deo/ned and JeKH = LeMHs .

Proof. By induction on e. Item 6 of coherence ensures that JeKH is deo/ned. We consider
each case for e.

* c

Constants are trivially equally evaluated.

* x

As H(x ) is deo/ned, so is Hs(x ) by R and they are equal.

* e1 op e2

We apply the induction hypothesis on e1 and e2 . Operations op then evaluate equally.

* f arg

For each argument arg, if arg is of the form (e) we apply the induction hypothesis on
e. Else arg is of the form [ae], and we show that lor s0(Hs(ae), Hs) = lor (H, H(ae)) as we
did for the r case of Theorem 2. Function Jf K applied to these arguments is then the
same in both models.

* x .f

By deo/nition of R, Hs(p) is deo/ned and Ro(H(p), Hs(p)). By deo/nition of Ro, we
conclude that H(p)(f ) = Hs(p)(f ).

Note how similar the proof is to the proof of Theorem 2. 2

We o/nally show our main theorem for statements, relating intuitive and separated heaps.
Theorem 5 (Soundness of Separated Statement Execution) Let s be a statement
such that:

\Sigma , \Gamma  ` {\Sigma } s {\Sigma 0}, \Gamma 0
Let H an intuitive heap, coherent with respect to \Sigma  and \Gamma . Let Hs a separated heap, such
that R(H, Hs).

There is H0 such that:

4.5. SEPARATED MEMORY MODEL 111

H, s =) H0
if, and only if there is Hs0 such that:

Hs, s =) Hs0
and if so, then R(H0, Hs0).

Additionally:

H, s =) 1
if, and only if:

Hs, s =) 1

Proof. We begin by proving the case of programs which terminates. We prove the o/rst
implication by induction on the derivation of H, s =) H0, and the other by induction on the
derivation of Hs, s =) Hs0. Here we only tackle the o/rst implication; the other is similar.
We examine each possible case for s.

* let x = e

Theorem 4 gives JeKH = LeMHs = v. Instruction s reduces in H into H[x 7! v ] and inH

s into Hs[x 7! v]. So we do have R(H0, Hs0) as H0(x ) = Hs0(x ) = v.

* if e then oe1 else oe2

From Theorem 4, JeKH = JeKHs. If JeKH = true, we apply the induction hypothesis on
oe1 , else we apply it on oe2 .

* let x = f arg

We o/rst show R(H1 , Hs1 ) where H1 and Hs1 are deo/ned as in the reduction rule. To
this end we simply apply Theorem 4 on expressions e.

We now show R(H2 , Hs2 ). For all i, H1 (aei ) is deo/ned by item 7 of coher-
ence and Hs1 (aei) is deo/ned by deo/nition of R. From R(H1 , Hs1 ) we obtain
Dom(Hs1 (aei )) = H1 (aei ). So Dom(Hs2 (ri )) = H2 (ri ). Typing rule requires that for
all i and j such that i 6= j , region arguments aei and aej do not share the same root. In
particular, this implies that aei 6= aej . So if H1 (p?) = aei , then H2 (p?) = ri . As we also
copied the contents of ri , we have Ro(H2 (p), Hs2 (p)). Active region of other pointers
did not change.

We then show that H3 is deo/ned if, and only if Hs3 is deo/ned, and that R(H3 , Hs3 ).
To this end we apply the induction hypothesis on the body of f . We apply Theorem 3
on the pre-condition in H2 and Hs2 , and on the post-condition in H3 and Hs3 .

Typing rule requires that for all i and j , region arguments aei and aej do not share the
same root. This implies that modifying Hs(aei ) cannot also change Hs(aej ) as a side-
eoeect, and vice versa. Indeed, if root(aei) = ra and root(aej ) = rb then ra 6= rb. And
by deo/nition, modifying Hs(aei ) modio/es Hs(ra ) and only Hs(ra ), while reading Hs(aej )
implies reading Hs(rb) and only Hs(rb).

We o/nally show that H0 is deo/ned if, and only if Hs0 is deo/ned and that R(H0, Hs0).
As we noted, regions aei all have dioeerent roots, so we have Hs0(aei ) = Hs3 (ri ) for all
i. We apply Theorem 4 on returned expression e, as well as a similar reasoning to the
one we used for H2 and Hs2 on the copy from ri regions to aei regions.

112 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS

* let region r : C

Statement s always reduce in both model. New region r is empty in both cases.

* let x = new C [ae]

From R we have:

p = H(next) = Hs(next)
We have:

Dom(Hs0(ae)) = Dom(p 7! o) = {p} = H0(ae)

Hs0(p?) = ae = H0(p?)

Hs0(x ) = p = H0(x )
There is no initial value for o/elds in both semantics, so both H0(p)(f ) and Hs0(p)(f ) are
undeo/ned. For all region r deo/ned in H0(p), H0(p)(r ) is the empty set and Hs0(p)(r )
has empty domain, so Ro(H0(p), Hs0(p)). Finally, we have:

H0(next) = p+1 = Hs0(next)

* focus x : ae as oe

Let p = Jx KH, which is also equal to Lx MHs by Theorem 4. We also have by deo/nition
of the reduction rule:

Dom(Hs0(oe)) = Dom(p 7! o) = {p} = H0(oe)

Hs0(p?) = oe = H0(p?)
Finally, by R(H, Hs), for all f we have:

H0(p)(f ) = H(p)(f ) = Hs(p)(f ) = Hs0(p)(f )
and for all region name r :

H0(p)(r ) = H(p)(r ) = Dom(Hs(p)(r)) = Dom(Hs0(p)(r))

* x .f  e

We apply typing rules and coherence to show that H(H(x ))(f ) is deo/ned, and relationR

to show that Hs(Hs(x ))(f ) is deo/ned as well. Statement thus reduces in both models.
We apply Theorem 4 to show that e evaluates into the same value in both heaps which
thus stay in relation.

* adopt x : oe as ae

Region oe is singleton by typing and thus contains a unique location p by co-
herence. Its active region becomes ae. We have Hs0(p) = Hs(oe)(p). Item 8
of coherence gives Hs(p?) = oe as oe* was available before the adoption. ThusH

s(p) = Hs(oe)(p) = Hs0(p).

4.6. CONCLUSION 113

* unfocus x : oe as ae

The proof is similar to the one for adoption, as the execution rules are the same.

* pack x

The statement reduces if, and only if the invariant predicate on x holds. We apply
Theorem 3 to obtain that the statement reduces in the intuitive model if, and only if
it reduces in the separated model. The heaps are not modio/ed and thus are still in
relation.

* unpack x , weaken empty x , weaken single x

Statement always reduce and heap is not modio/ed.

* assert P

This is the same proof than for packing, except with predicate P instead of the invariant.

* label L

It is suOEcient to prove that for each label L, we have loh(H)(L) = lohs(Hs)(L). Let r
be a region name such that H(r ) is deo/ned. Thus loh(H)(L)(r ) is deo/ned. From R, so
is Hs(r ) and thus so is lohs(Hs)(L)(r ). We have already shown for terms how to prove
that lor and lor s construct the same logic region.

The proof for programs which diverge is done by coinduction on the derivation H, s =) 1
or Hs, s =) 1. Each case is dealt with similarly to the terminating case. 2

A corollary of this theorem is that paths described by active regions in H0 are o/nite.
Indeed, Hs0 would otherwise not exist.

Finally, let's deo/ne the starting intuitive heap H0 and the starting separated heap Hs0 ,
both only deo/ned on next, and with Hs0 (next) = H0 (next). We remark that H0 is co-
herent with respect to the empty environment and the empty list of permissions, and thatR

(H0 , Hs0 ) holds. We thus do have a starting point for our programs.

Note that we did not show that well-typed statements always reduce. This actually is false,
as we also requires proof obligations to be proven to ensure that pre- and post-conditions,
invariants and assertions hold. We will discuss this when introducing how proof obligations
are computed, in Chapter 5.

4.6 Conclusion
In this section we presented the core language of Capucine. We gave its syntax, typing
rules involving permissions, and semantics for two dioeerent models: the intuitive model and
the separated model. The former is close to models of existing languages, while the latter
separates regions more and is closer to the Why interpretation of Capucine, which is discussed
in Chapter 5. We have shown two main theorems: coherence of the heap is preserved in the
intuitive model, and a relation between an intuitive heap and a separated heap is preserved.
From this we conclude that coherence of the heap is preserved in the separated model.

This work will be used in Chapter 5 to prove properties about interpreted programs, as
well as a progress theorem stating that a well-typed Capucine program whose proof obli-
gations have been proved reduces. We cannot state this progress theorem yet, as we o/rst
require to know how proof obligations are produced.

114 CHAPTER 4. CAPUCINE LANGUAGE SYNTAX AND SEMANTICS

Finding the right deo/nition for coherence, and the right deo/nition for the R relation
between an intuitive heap and a separated heap, is crucial. Their knowledge is not needed to
use Capucine, but they play a central role in the proof that Capucine is a sound language.
Following this, the semantics must be deo/ned with great care.

It is important to note that a permission is needed to select o/elds in expressions, but that
no permission is needed to select o/elds in terms. The latter is a strong feature of Capucine:
no permission is needed to give semantics to the logic part of the language. In programs, a
permission on x is needed to read x .f to ensure that the active region of x is deo/ned; but
there is no active region in the logic model. It is possible thanks to the construction of logic
environments L and Ls, and more precisely to the construction of logic regions using lor and
lor s.

However, typing requires that program regions used in the logic are focus-free. This
restriction is not necessary to prove that the intuitive model and the separated model are
equivalent, but it greatly simplio/es the Why interpretation introduced in Chapter 5.

Chapter 5
Generation of Verio/cation
Conditions

In this chapter, we discuss how proof obligations of Capucine programs are produced. We also
discuss how proving these proof obligations relate to the soundness of Capucine programs.

5.1 The Why Intermediate Language
In order to produce proof obligations, we encode Capucine programs as Why programs [Fil-
lia^tre07]. We introduced the Why language informally in Section 2.3.1. In this section we
formally introduce the subpart of Why that we will be using1. To this end we present the
syntax of Why programs. We do not fully formalize the semantics of Why, which is straight-
forward. However we do state the main theorem we will be using, namely that if the proof
obligations generated by the Why tool on a Why program are proven, then the Why program
executes safely.

We index Why syntactic classes with letter w. For instance, Why types are o/w. Compare
this to Capucine types o/ .

5.1.1 Types
A Why logic type is of the form:
o/w ::= t (o/w, * * *, o/w) | int | bool | unit
It is the set of Capucine types without pointer types. User types t may have any number of
parameters, and base types are the usual integers, booleans and unit.

A Why program type is either a Why logic type, or a reference on a Why logic type:

o/w0 ::= o/w | ref (o/w)

5.1.2 Terms
A Why term is of the form:

1The syntax we use is slightly dioeerent than the actual syntax of Why.

115

116 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS

LT w ::= c|

x|
LT w termop LT w|
f (LT w)|
!x|
!x @L

termop ::= + | - | * | && | ||
where c is a constant of a base type, i.e. either an integer literal or a boolean true or false.
The set of Why terms contains most of Capucine terms, but there is no o/eld selection. Instead,
we may dereference a reference variable x using !x , or using !x @L where L is a label. Note
that reference variables can only be program variables, they cannot be logically quantio/ed
variables. Compared to Capucine, the application is simpler, as there is no region term.

5.1.3 Predicates
A Why predicate is of the form:

Pw ::= p (LT w)|

Pw ^ Pw | Pw . Pw | Pw ) Pw | Pw () Pw | ~Pw | T | F|
LT w relop LT w| 8

x : o/w. Pw | 9x : o/w. Pw

relop ::= = | 6= | > | >= | < | <=
Once again, this is a subset of Capucine predicates. There is no region, thus there is no
region quantio/cation nor any 2 predicate, and application is simpler.

5.1.4 Expressions
A Why expression is of the form:

ew ::= c Constant|

x Variable|
ew op ew Arithmetic or logic operation|
f (ew) Logic function application|
if ew then ew else ew Test|
let x = ew in ew Let-binding|
(ew, * * *, ew) Tuple|
proj i (ew) Tuple projection|
let x = ref ew in ew Reference creation|
!x Dereferenced variable|
x := ew Assignment|
ew; ew Sequence|
[{Pw} reads x writes x o/w {Pw}] Black box|
label L; ew Label

Expressions Without Side-Eoeects Constants are the same as Capucine constants: in-
tegers, booleans and unit. Operations op are the same as Capucine operations on integers

5.1. THE WHY INTERMEDIATE LANGUAGE 117
and booleans. Logic functions can be applied in expressions. The if test and let-binding are
also expressions. Tuples are available, and the i-th component of a tuple (x1 , * * *, xn ), i.e.
xi , can be obtained using projection proj i.

Expressions With Side-Eoeects Why expressions may contain side-eoeects. References
can be created with the ref keyword. Remember though that the type system ensures that
there is no alias. A variable x on a reference can be dereferenced with !x , and assigned to
with := . The sequence is also an expression.

Black Boxes Black boxes are special expressions with side-eoeects:

[{P} reads x writes y o/w {Q}]
is an expression of type o/w, with pre-condition P and post-condition Q, and which reads
references x and writes references y. The actual value returned by the black box is non-
deterministic; it only has to verify the post-condition, in which variable result is bound to
the returned value.

We may omit the reads clause, in which case x is implicitely equal to the set of references
read by P and Q. If y is the empty list, we may omit the writes clause. We denote by
assert Pw the black box [{Pw} unit {T}], by assume Pw the black box [{T} unit {Pw}], and
by any o/ the black box [{T} o/ {T}]. Finally, if ew1 and ew2 have type o/w, we denote by:

if Pw then ew1 else ew2
the following black box:

[o/w {Pw ) result = ew1 ^ ~Pw ) result = ew2 }]
Note that black boxes, such as assume F for instance, may introduce inconsistent hypotheses
in proof obligations. It is up to the user to guarantee that black boxes are realizable.

5.1.5 Logic Declarations
Types User types may be introduced using a declaration of the form:
type t (ff)
It is simply a name t and a list of type variables as parameters.

Logic Functions and Predicates Logic functions may be introduced using a declaration
of the form:

logic f (x : o/w): o/w = LT w
The body LT w may be omitted. If it is, variable names x may be omitted as well. If it is
not, the return type may be omitted: it will be inferred.

Predicates are deo/ned in a similar fashion:

logic p (x : o/w) = Pw
Once again, the body Pw may be omitted, and if so, variable names x may be omitted as
well.

118 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS
Axioms Axioms may be deo/ned using a declaration of the form:
axiom a: Pw
where a is the name of the axiom.

5.1.6 Program Declarations
Functions Functions may be declared as follows.
fun (x : o/w): o/w

pre Pw
post Pw{

ew}

They are similar to Capucine function declarations, except that there is no permissions, and
thus no consumes and produces clauses. Moreover, the body is not a list of statements but
an expression. Functions generate proof obligations.

Parameters Parameters are functions whose body { ew } was omitted:
fun (x : o/w): o/w

pre Pw
post Pw
reads x
writes x

Note that to replace the body, there is reads and writes clauses. In fact, parameters can
be seen as block boxes with a name and with arguments. They will not generate proof
obligations as there is nothing to prove. They can, however, be called from other functions.

5.1.7 Model
Values Values are either integers, booleans, unit, tuples, or values of user-deo/ned types.

Heap A Why heap Hw is a function:

* Hw(x ) is the value of variable x ;

* Hw(y, L) is the value of reference variable y at label L.
Note that !y is evaluated as Hw(y, here). In other words, label here is the default label.

Execution The semantics of expressions is deo/ned by the following relations:

ew, Hw

Why=) v, H

w0

which states that Why expression ew under heap Hw reduces to value v, with new heap Hw0.
The evaluation of a Why expression ew might also diverge. This is denoted by:

ew, Hw

Why=) 1

5.2. DIRECT ENCODING OF THE SEPARATED MODEL 119
It may happen because of loops and recursive calls. We will not be using loops though, so
we are only concerned with recursive calls. A program which diverges does not raise any
run-time error, so it is a correct program. Note that because some Why expressions are
non-deterministic, both judgements may hold for the same program.

The following theorem states that the Why language is sound [Fillia^tre03].

Theorem 6 (Why Soundness) Assume ew is a well-typed Why expression, whose pre-
condition has been proven to entail its weakest pre-condition. Assume that all functions
have been proven to verify their contract. Then for every heap Hw in which the pre-condition
holds, either:

ew, Hw

Why=) 1

or there is v and Hw0 such that:

ew, Hw

Why=) v, H

w0

5.2 Direct Encoding of the Separated Model
In this section, we show how to translate Capucine programs into Why programs. We base
our encoding on the separated model introduced in Section 4.5.

5.2.1 Pointers, Regions, Types and Objects
Understanding how separated heaps Hs are encoded in Why is key. Indeed, the remaining of
the translation follows directly from this encoding.

Pointers Regions are encoded as logic maps. Keys to these maps are locations:
type location
This type is abstract. The only way to build a location is by using a black box of type
location. Indeed, there is no logic function which returns a location.

Regions We declare the Why type of regions:
type region (ff)
It denotes maps from location values to ff values. Logic function set adds a location and its
ff value into a region:

logic set (ff region, location, ff): region (ff)
If the location already has an associated value in the map, it is replaced. Logic function get
reads the value of a location in a region:

logic get (ff region, location): ff
Functions get and set are axiomatized as follows:
axiom getSetEq:8

r : region (ff). 8p: location. 8x : ff.

120 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS

get(set(r , p, x ), p) = x
axiom getSetNeq:8

r : region (ff). 8p: location. 8q: location. 8x : ff.

p 6= q ) get(set(r, p, x ), q) = get(r , q)

This is the usual theory of ino/nite arrays.

We add the notion of domain for regions. Logic constant empty is a region of empty
domain:

logic empty: region (ff)
Predicate inRegion takes a location and a region as arguments, and holds if, and only if the
location is in the domain of the region:

logic inRegion (location, region (ff))
This predicate is deo/ned using four axioms. The o/rst one states that the empty region is
empty, i.e. has an empty domain:

axiom notInEmptyRegion:8

p: location.~

inRegion(p, empty)

Another one states that location p is in regions into which p was added:
axiom inSetRegionEq:8

p: location. 8r : region (ff). 8v : ff.

inRegion(p, set(r, p, v ))

The next one states that set only makes the domain bigger:
axiom inSetRegionNeq:8

p: location. 8q: location. 8r : region (ff). 8v : ff.

inRegion(p, r) ) inRegion(p, set(r, q, v))

The last one states that set only adds one location:
axiom notInSetRegion:8

p: location. 8q: location. 8r : region (ff). 8v : ff.

p 6= q ) ~inRegion(p, r ) ) ~inRegion(p, set(r , q, v ))

Note that regions are o/nite maps. However, all Why functions are total, including function
get. This means that one can write get(r , p) for any location p, including ones which are
not actually in region r . However, the above axioms do not specify the result, and we cannot
prove anything about get(r , p) except that it exists. The actual domain of r is given by
predicate inRegion.

Types We deo/ne the Why translation why(o/) of type o/ as follows:

* why(int) = int;

* why(bool ) = bool;

* why(unit) = unit;

5.2. DIRECT ENCODING OF THE SEPARATED MODEL 121

* why([ae]) = location;

* why([.]) = location;

* why(t (o/1 , * * *, o/n )) = t (why(o/1 ), * * *, why(o/n )).
This translation is recursive, and is well-founded.

Objects We deo/ne the Why translation why(C) of class expression C as follows. Assume
that r1 : C1 , * * *, rn : Cn is the list of owned regions of C, and that f1 : o/1 , * * *, fm: o/m is the
list of o/elds of C. Note that this assumes that type parameters and region parameters in
class expression C have been substituted in C1 , * * *, Cn and o/1 , * * *, o/m. Then why(C) is the
following Why tuple type:

(region (why(C1 )) * * * * * region (why(Cn )) * why(o/1 ) * * * * * why(o/m ))
Again, this translation is recursive. It is well-founded if classes are not recursive. We tackle
the recursive case in Section 5.3.

5.2.2 Expressions and Region Expressions
Logic Functions We already assumed a model Jf K for each user-deo/ned logic function.
We know there is a model for logic functions empty, get and set, and for predicate inRegion.
We assume that the application of a Why logic function f returns the value returned by the
model Jf K.

Region Expressions Region binders in programs, i.e. region parameters of functions
and the let region statement, introduce these variables as references. Their type is
region (why(C)) where C is the class of the region.

Assume ae is a well-typed region:

\Gamma  ` ae: C
and assume some permissions \Sigma . We deo/ne the Why translation why(ae) of ae with respect to
\Sigma  as follows.*

why(r ) = !r ;

* if x has type [oe], if oe;, oeffi, oe* or oeG is in \Sigma  or if oe is transitively owned by a closed

region (i.e. \Gamma , \Sigma  `* oe), then why(x .s) is:

proj s(get(why(oe), x ))
where proj s is the projection corresponding to owned region s in tuple why(C);

* if x has type [oe], if oe0 -ffi oe is in \Sigma  for some region oe0, then why(x .s) is:

proj r (get((if inRegion(x , why(oe0)) then why(oe0) else why(oe)), x ))
Note that the duplication of why(oe0) can be avoided using a let-binding;

This translation is not always deo/ned. In particular, why(x .s) is not deo/ned if there is no
available permission on the region of x .

It is important to note that if ae is being focused, then why(ae) denotes a region from which
the only pointers that should be read are the ones which have not been focused. In other
words, why(ae) denotes Hs(ae), but there may be a location p for which get(why(ae), p) does
not denote Hs(p). This happens if Hs(p?) is not ae.

122 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS
Expressions Assume e is a well-typed expression:

\Gamma , \Sigma  ` e: o/
We deo/ne the Why translation why(e) of e as follows:

* why(c) = c;

* why(x ) = x ;

* why(e1 op e2 ) = why(e1 ) op why(e2 );

* why(f arg1 * * * argn ) = f (why(arg1 ), * * *, why(argn )) where why(arg) = why(ae) if arg

is a region parameter [ae], and why(arg) = why(e) if arg is a regular parameter (e);

* why(x .f ) is deo/ned below.
The translation why(x .f ) depends on the type of x and on available permissions. Typing
rules ensures that x has type [ae] for some region ae of class C, of which f is a o/eld. Then
why(x .f ) is the projection proj f on the tuple component of why(C) corresponding to f , of
the object obj (x , ae) obtained by looking for x in region ae. We now deo/ne obj (x , ae):

* if aeffi, ae* or aeG is in \Sigma , then obj (x , ae) is get(why(ae), x );

* if oe -ffi ae is in \Sigma , then obj (x , ae) is:

if inRegion(x , why(oe)) then obj (x , oe) else get(why(ae), x ).

The main diOEculty is selection x .f , as the object of x must be read from its active region.
Usually the active region is the region given by the type of x . But this is not the case if x
is being focused, in which case the active region may be the focus region, or even another
one if another focus happened. Note that from a language design standpoint, it is possible
to consider preventing the user from reading a pointer which is in a region being focused.
Indeed, experiments tend to show that this kind of access is not useful very often.

Example In the following environment:

x : [y.s], y: [r ], r : C
and with permissions:

y.s*, r ffi
then the translation of x .f is:

why(x .f ) = proj f (obj (x , y.s))

= proj f (get(why(y.s), x ))
= proj f (get(proj s (get(!r , y)), x ))

where proj f is the projection on the f o/eld component of the class tuple of x , and proj s is
the projection on the s owned region component of the class tuple of C.

The expression we obtain corresponds to the following access in our separated model:

Hs(r )(y)(s)(x )(f )

5.2. DIRECT ENCODING OF THE SEPARATED MODEL 123
5.2.3 Logic
Assume an environment which, given a region variable r , states whether r is a program region
(i.e. a region bound as a function region parameter or a let region statement) or a logic region
(i.e. a region bound using a term or predicate parameter, or a 8region or 9region quantio/er).

Region Terms Assume RT is a well-typed region term. We deo/ne the Why translation
why(RT ) of RT as follows:

* why(r @here) = !r if r is a program region;

* why(r @L) = !r @L if r is a program region and L 6= here;

* why(r @here) = r if r is a logic region (typing ensures the label is here);

* why(get(RT , LT , s)) is the projection on the s component of:

get(why(RT ), why(LT )).

Terms Assume LT is a well-typed term. We deo/ne the Why translation why(LT ) of LT
as follows:

* why(c) = c;

* why(x ) = x ;

* why(LT 1 termop LT 2 ) = why(LT 1 ) termop why(LT 2 );

* why(f larg1 * * * largn ) = f (why(larg1 ), * * *, why(largn )) where why(larg) = why(RT )

if larg is a region parameter [RT ], and why(larg) = why(LT ) if larg is a regular param-
eter (LT );

* get(RT , LT , f ) is the projection on the f component of get(why(RT ), why(LT )).

Predicates Assume P is a well-typed predicate. We deo/ne the Why translation why(P) of
P as follows:

* why(P1 ^ P2 ) = why(P1 ) ^ why(P2 );

* why(P1 . P2 ) = why(P1 ) . why(P2 );

* why(P1 ) P2 ) = why(P1 ) ) why(P2 );

* why(P1 () P2 ) = why(P1 ) () why(P2 );

* why(~P) = ~why(P);

* why(T) = T;

* why(F) = F;

* why(LT 1 = LT 2 ) = (why(LT 1 ) = why(LT 2 ));

* why(LT 1 6= LT 2 ) = (why(LT 1 ) 6= why(LT 2 ));

* why(LT 1 > LT 2 ) = (why(LT 1 ) > why(LT 2 ));

124 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS

* why(LT 1 >= LT 2 ) = (why(LT 1 ) >= why(LT 2 ));

* why(8x : o/. P) = 8x : why(o/ ). why(P);

* why(9x : o/. P) = 9x : why(o/ ). why(P);

* why(8region r: C. P) = 8r : region (why(C)). why(P);

* why(9region r: C. P) = 9r : region (why(C)). why(P);

* why(p larg1 * * * largn ) = p(why(larg1 ), * * *, why(largn ));

* why(LT 2 RT ) = inRegion(why(LT ), why(RT )).
This is pretty straightforward.

5.2.4 Statements
Assigning Any Region Assume some typing environment \Gamma  and some permissions \Sigma . We
deo/ne operation assign(ae, w ) where ae is a Capucine region (i.e. r or x .s) and w is any why
expression. This operation ensures the value of ae is changed to w.

* assign(r , w ) =

r := w

* If x has type [oe] and oe;, oeffi, oe* or oeG is in \Sigma  or if oe is transitively owned by a closed

region (i.e. \Gamma , \Sigma  `* oe), then assign(x .s, w ) =

assign(oe, set(why(oe), x , sets(get(why(oe), x ), w )))
where sets (o, w) sets the s o/eld of an object tuple o to w .

* If x has type [oe] and oe0 -ffi oe is in \Sigma  then assign(x .s, w ) =

if inRegion(x , why(oe0)) then

assign(oe0, set(why(oe0), x , sets (get(why(oe0), x ), w )))
else

assign(oe, set(why(oe), x , sets (get(why(oe), x ), w )))

For instance, consider the following environment:

r : C, r0: C0, x : [r ], y: [r 0], y: [x .s]
and the following permissions:

r 0*, r 0 -ffi x .s, rffi
where s is an owned region of class C and t is an owned region of the class of s. This situation
is illustrated in Figure 5.1. Then assign(z .t, w ) is:

if inRegion(z , !r 0) then

r0 := set(!r 0, z , sett (get(!r 0, z ), w ))
else

r := set(!r , x , sets (get(!r , x ), set(proj s(get(!r, x )), z , sett (get(!r , z ), w))))

5.2. DIRECT ENCODING OF THE SEPARATED MODEL 125

x

* * * y* * *z * * *

yrffi r *
r 0 -ffi x .s

z .t

y.t
s

t

t
focus

Figure 5.1: Example situation to illustrate the assign operation (y and z may be equal)
Translation of Statements Assume s is a well-typed statement. We deo/ne the Why
translation why(s, cont) of s with continuation cont, where cont is a Why expression. First
we deo/ne why(S, cont) where S is a statement block recursively:

why((s; S), cont) = why(s, why(S, cont))
Then we consider each possible statement:

* why(let x = e, cont) =

let x = why(e) in
cont

* why(if e then S1 else S2 , cont) =

(if why(e) then why(S1 , ()) else why(S2 , ()));
cont

* why(let x = f arg1 * * * argm , cont) =

let r1 = ref (why(ae1 )) in* * *

let rn = ref (why(aen )) in
let x = f (whyarg(arg1 ), * * *, whyarg(argn )) in
assign(ae1 , !r1 );* * *

assign(aen , !rn );
cont

where arg1 , * * *, argm restricted to region arguments is [ae1 ], * * *, [aen ], where
whyarg((e)) is why(e), and where whyarg([aei ]) is ri .

* why(let region r : C, cont) =

let r = ref empty in
cont

* why(let x = new C [ae], cont) =

126 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS

let x = any location in
assign(ae, set(why(ae), x , any why(C)));
assign(x .r1 , empty);* * *

assign(x .rn , empty);
cont

The pointer is initialized to some unknown value of location type. We do not actually
require this value to be ithe next fresh locationj as in the model. Indeed, we only need
to now that the location is fresh in the region it is added to. Here it is added to an
empty region, so the location is necessarily fresh. Later it might be added into a group
region ae using adoption, and we would then be able to prove that the location is fresh
in ae as the location was not in ae before the adoption.

Note that the only reason we initialize the object in ae is to ensure the domain of ae is{

x }. Otherwise, from typing we could prove that Dom(ae) = {x } while Dom(ae) would
actually be empty. For the same reason we initialize owned regions r1 , * * *, rn .

* why(x .f  e, cont) =

assign(ae, set(why(ae), x , setf (get(why(ae), x ), why(e))));
cont

where x has type [ae] and setf (x , y) allows to change the f component of tuple x to y.

* why(adopt x : oe as ae, cont) =

assign(ae, set(why(ae), x , get(why(oe), x )));
cont

* why(focus x : ae as oe, cont) =

assign(oe, set(empty, x , get(why(ae), x )));
cont

Note that as why(oe) = empty before the focus operation, we could actually have used
the same translation than for adoption.

* why(unfocus x : oe as ae, cont) =

assign(ae, set(why(ae), x , get(why(oe), x )));
cont

Note that this is exactly the same as adoption.

* why(pack x , cont) =

assert why(Inv (x ));
cont

where Inv (x ) is the invariant predicate of the class C of x , applied to x .s1 , * * *, x .sn
and x .f1 , * * *, x .fm where s1 , * * *, sn are the owned regions of C and f1 , * * *, fm are the
o/elds of C.

* why(unpack x , cont) =

cont

5.2. DIRECT ENCODING OF THE SEPARATED MODEL 127

* why(weaken empty ae, cont) =

cont

* why(weaken single ae, cont) =

cont

* why(assert P, cont) =

assert why(P);
cont

* why(label L, cont) =

label L;
cont

Example: Function Call Translation of function calls is tricky, as regions which are
passed as arguments are copied to temporary references, and then put back to their original
location. Here is an example. Assume the following environment:

r: C, x : [r ], y: [x .s]
and the following permissions:

rffi, x .sG
Then the translation of the following statement:

let z = f [x .s] (y)
with continuation cont is the following Why expression:
let r1 = ref (proj s(get(!r, x ))) in
let z = f (r1 , y) in
r := set(!r , x , sets(get(!r, x ), !r1 ));
cont

5.2.5 Declarations
Logic Types Capucine logic types declarations are of the form:
type t (ff1 , * * *, ffn )
They are kept as it in the translated Why programs.

Logic Functions and Predicates Capucine logic functions are declared as follows:
logic f param: o/ = LT
They are translated into Why logic function declarations as follows:
logic f why(param): why(o/ ) = why(LT )
where why(param) is deo/ned as:

* why((x : o/ )) is x : why(o/ );

128 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS

* why([r : C]) is r: region (why(C));
Of course, if the body LT is omitted, it is omitted in the translated declaration as well.

Predicates are translated in exactly the same way. The only dioeerence is that the body,
if any, is a predicate and that there is no return type to translate.

Axioms Capucine axiom declarations are of the form:
axiom a: P
They are translated into Why axioms as follows:
axiom a: why(P)

Functions Capucine function declarations are of the form:
fun f param: o/

consumes \Sigma 
produces \Sigma 0
pre P
post Q{

S;
return e}

Assume r is the set of references read by Why expression why(S, why(e)), and w is the set of
references written by why(S, why(e)). Function f above is translated into a Why parameter
and a Why function:

fun f why0(param): why(o/ )

pre why(P)
post why(Q)
reads r
writes w

fun fgoal why0(param): why(o/ )

pre why(P)
post why(Q){

why(S, why(e))}

where why0(param) is deo/ned as:

* why0((x : o/ )) is x : why(o/ );

* why0([r : C]) is r: ref (region (why(C)));
Thus why0(param) is the same as why(param), except that region variables are references.

We translate the function into a parameter f which can be called from inside the body of
any function. Function fgoal will not be called, but generates the required proof obligations.
This is how we encode mutually recursive functions.

5.2. DIRECT ENCODING OF THE SEPARATED MODEL 129
class PosInt{

value: int;
invariant value > 0;}

class Triple{

single Ra: PosInt;
group Rbc: PosInt;
a: [Ra];
b: [Rbc];
c: [Rbc];}

Figure 5.2: Deo/nition of classes PosInt and Triple
5.2.6 Illustration
We illustrate our encoding on a simple example. We consider class PosInt, with one value
integer o/eld which must be positive, and class Triple with three pointer o/elds of class PosInt.
Two of those o/elds may be aliased. We program a function which increments all pointers
of the triple. Figure 5.2 contains the Capucine code deo/ning both classes, and Figure 5.3
contains the Capucine code of our incrementation function incrTriple, fully annotated and
with no syntactic sugar.

Translation We now construct, step by step, the Why code corresponding to the translation
of function incrTriple. Here is the header of the function, including the post-condition:

fun incrTriple

(r : ref (region (region (int) * region (int) * location * location * location)),

x : location): unit
post

proj value(get(proj Ra (get(!r, x )), proj a (get(!r , x )))) =

proj value(get(proj Ra (get(!r @pre, x )), proj a (get(!r@pre, x )))) + 1 ^
proj value(get(proj Rbc(get(!r , x )), proj b(get(!r , x )))) =

proj value(get(proj Rbc(get(!r @pre, x )), proj b(get(!r @pre, x )))) + 1 ^
proj value(get(proj Rbc(get(!r , x )), proj c(get(!r, x )))) =

proj value(get(proj Rbc(get(!r @pre, x )), proj c(get(!r @pre, x )))) + 1

Note that proj value is actually the identity function, as the tuple corresponding to class Long
has only one integer element. Similarly, setvalue(x , y) is y. We continue with the translation
of the incrementation of x .a.value and the pack statement:

{

let a = proj a (get(!r , x )) in
r :=

set(!r, x ,

setRa (get(!r , x ),

130 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS
fun incrTriple [r : Triple] (x : [r]): unit

consumes r *
produces r *
post

get(get(r , x , Ra), get(r , x , a), value) =

get(get(r , x , Ra), get(r, x , a), value)@pre + 1 ^
get(get(r , x , Rbc), get(r , x , b), value) =

get(get(r , x , Rbc), get(r , x , b), value)@pre + 1 ^
get(get(r , x , Rbc), get(r , x , c), value) =

get(get(r , x , Rbc), get(r , x , c), value)@pre + 1{

unpack x ;
let a = x .a;
unpack a;
a.value  a.value + 1;
pack a;

let b = x .b;
let region Fb: PosInt;
focus b: r.Rbc as Fb;
unpack b;
b.value  b.value + 1;
pack b;
unfocus b: Fb as r .Rbc;

let c = x .c;
if b 6= c then{

let region Fc: PosInt;
focus c: r .Rbc as Fc;
unpack c;
c.value  c.value + 1;
pack c;
unfocus c: Fc as r .Rbc;}

else {}
pack x ;}

Figure 5.3: Function incrTriple

5.2. DIRECT ENCODING OF THE SEPARATED MODEL 131

set(proj Ra (get(!r , x )), a,

setvalue(

get(proj Ra (get(!r , x )), a),
proj value(get(proj Ra (get(!r , x )), a)) + 1))));
assert proj value(get(proj Ra (get(!r , x )), a)) > 0;

The assignment to r comes from the assignment to a.value. The assert statement comes
from the pack statement. We continue with the focusing of x .b:

let b = proj b(get(!r, x )) in
let Fb = ref empty in
Fb := set(empty, b, get(proj Rbc(get(!r , x )), b));

Next is the assignment to x .b.value and the pack statement:

Fb := set(!Fb, b, setvalue(get(!Fb, b), proj value(get(!Fb, b)) + 1));
assert proj value(get(!Fb, b)) > 0;

The incrementation of x .b ends with the unfocus:

r := set(!r , x , setRbc(get(!r , x ), set(proj Rbc(get(!r , x )), b, get(!Fb, b))));
The remaining of the function is the conditional assignment to x .c.value, which is similar to
the one to x .b.value, so we do not show it here.

Proof Obligations There are several proof obligations:

* after the assignment to x .a.value, it is still positive (invariant of x .a);

* after the assignment to x .b.value, it is still positive (invariant of x .b);

* after the assignment to x .c.value, it is still positive (invariant of x .c);

* if x .b = x .c, then x .a.value, x .b.value and x .c.value all have been incremented by one;

* if x .b 6= x .c, then x .a.value, x .b.value and x .c.value all have been incremented by one.
Here is the proof obligations stating that the post-condition holds if x .b = x .c:

8r : (int region * int region * location * location * location) region.8

a: location.
a = proj a (get(r, x )) )8

r1 : (int region * int region * location * location * location) region.
r1 =

set(r , x ,

setRa (get(r, x ),

set(proj Ra (get(r , x )), a,

setvalue(

get(proj Ra (get(r , x )), a),
proj value(get(proj Ra (get(r, x )), a)) + 1)))) )8
b: location.
b = proj b(get(r1 , x )) )8

Fb: int region.
Fb = empty )

132 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS

8Fb1 : int region.
Fb1 = set(empty, b, get(proj Rbc(get(r1 , x )), b)) )8

Fb2 : int region.
Fb2 = set(Fb1 , b, setvalue(get(Fb1 , b), proj value(get(Fb1 , b)) + 1)) )8

r2 : (int region * int region * location * location * location) region.
r2 = set(r1 , x , setRbc(get(r1 , x ), set(proj Rbc(get(r1 , x )), b, get(Fb2 , b)))) )8

c: location.
c = proj c(get(r2 , x )) )
b = c )
proj value(get(proj Ra (get(r2 , x )), proj a (get(r2 , x )))) =

proj value(get(proj Ra (get(r , x )), proj a (get(r, x )))) + 1 ^
proj value(get(proj Rbc(get(r2 , x )), proj b(get(r2 , x )))) =

proj value(get(proj Rbc(get(r , x )), proj b(get(r , x )))) + 1 ^
proj value(get(proj Rbc(get(r2 , x )), proj c(get(r2 , x )))) =

proj value(get(proj Rbc(get(r , x )), proj c(get(r , x )))) + 1

Automatic provers can prove this logic formula easily. It is only a matter of substituting
all equalities, rewriting axioms regarding get and set and unfolding the deo/nitions of the
projections and tuple makers such as proj value and setvalue.

However, this logic formula, while stating a simple fact, is heavy and hard to read. While
the axiom instantiations are simple, they are quite numerous. This translation do not take
enough advantage of the separation information granted by typing. Indeed, when modifying
regions x .Ra and x .Rbc, it is the whole region of x which is modio/ed. So if we modify x .Ra
and then we modify x .Rbc, to access the value of x .Ra we have to use the fact that they are
two dioeerent o/elds of a tuple, and thus that modifying x .Rbc does not modify x .Ra. In the
next sections we explore ways to use type information to produce simpler proof obligations.

5.2.7 Soundness
In order to prove that our transformation from Capucine programs to Why programs is sound,
we apply a methodology similar to the one we used in Section 4.5.2. We deo/ne a relation
between Capucine separated heaps Hs and Why heaps Hw. Then we prove theorems stating
that expressions, terms, predicates and statements and their respective translation evaluate
and reduce equally in related heaps.

In this section, we will often say that a separated heap Hs is coherent. By that we mean
that Hs is in relation to a coherent intuitive heap H.

Relation Assume a bijection between Capucine locations p, and Why values of location
type. We will allow ourself to use Capucine locations as Why values, and vice versa.

Let C be a Capucine class. We deo/ne relation Ro(o, v ) between a separated object o and
a Why value v of type why(C), and relation Rr(g, v) between a separated region function g
and a Why value v of type region (why(C)), as the smallest relations such that:

* if Rr(g, v ) then for all location p, if g(p) is deo/ned then:R

o(g(p), get(v, p));

* if Ro(o, v ) then for all region name s, if o(s) is deo/ned then:R

r(o(s), proj s(v));

5.2. DIRECT ENCODING OF THE SEPARATED MODEL 133

* if Ro(o, v ) then for all o/eld name f , if o(f ) is deo/ned then:

o(f ) = proj f (v).

We deo/ne relation R(Hs, Hw) between separated Capucine heap Hs and Why heap Hw
as the smallest relation such that:

* for all variable name x , Hs(x ) is deo/ned if, and only if Hw(x ) is deo/ned and if so, thenH

s(x ) = Hw(x );

* for all region name r , Hs(r ) is deo/ned if, and only if Hw(r, here) is deo/ned and if so,

then Rr(Hs(r ), Hw(r , here)).

* for all region name r , for all label L, Hs(L)(r ) is deo/ned if, and only if Hw(r, L) is

deo/ned and if so, then Rl(Hs(L)(r ), Hw(r, L)) where Rl is deo/ned below.

We o/nally deo/ne relation Rl(g, v ) between AEattened region function g and Why region
value v . Indeed, in the logic, functions and predicates expect AEattened region functions
and not separated region functions. A AEattened region function is a function obtained using
lor or lor s (see paragraphs jFrom Programs to Logicj in Section 4.3 and Section 4.5.1,
respectively). Relation Rl(g, v) is the smallest relation such that for all location p, for all
o/eld f , if there are locations p1 , * * *, pn and region names r1 , * * *, rn such that if for all i > 1,
vi = proj ri (get(v i-1, pi )) with v1 = v and inRegion(pi , v i-1), and if inRegion(p, vn ), then
this path to p is unique and g(p)(f ) = proj f (get(vn , p)). In other words, Rl(g, v ) if v is the
smallest region value describing g.

Theorem 7 (Interpretation of Terms) Let LT be a Capucine term such that:

\Gamma  ` LT : o/
and RT be a Capucine region term such that:

\Gamma  ` RT : C
Let Hs be a separated Capucine heap coherent with respect to \Gamma  and some permissions \Sigma .
Let Hw be a Why heap such that R(Hs, Hw). If why term why(LT ) evaluates to value
v in Hw then LLT Mlohs(Hs) = v . If why term why(RT ) evaluates to value v in Hw thenR

l(LRT Mlohs(Hs), v).

Proof. By induction on RT and LT . More precisely, our induction hypothesis is the follow-
ing. Let x be either a well-typed region term or a well-typed term. Then for all sub-region-
term RT of x , and for all sub-term LT of x , RT and LT verify the theorem statement.

First, we consider the cases where x is a term.

* c

Constants are trivially evaluated as the same values.

* xL

s(Hs)(x ) is, by construction, equal to Hs(x ). Lx Mlohs(Hs) is thus equal to Hs(x ), which
is equal to Hw(x ) by R. And x evaluates to Hw(x ) in Hw.

* LT 1 termop LT 2

We apply the induction hypothesis on LT 1 and LT 2 . Operations termop then evaluate
equally.

134 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS

* f larg

For each argument larg, if larg is of the form [RT ] then we apply the induction hypoth-
esis on RT , else larg is of the form (LT ) and we apply the induction hypothesis on LT .
The application of Jf K thus yields the same result value in both models.

* get(RT , LT , f )

We apply the induction hypothesis on RT and LT . The term is evaluated toL

RT MLs(LLT MLs)(f ) where Ls = lohs(Hs) in the separated model, and is translated
to proj f (get(why(RT ), why(LT ))). The region variable r appearing in RT is either
bound using 8region or 9region, or is a focus-free program region. In both cases we
use the deo/nition of Rl to show that:L

RT MLs (LLT MLs )(f ) = proj f (get(why(RT ), why(LT )))
In the case that r is a program region, the fact that it is focus-free is fundamental to
obtain that active regions are the ones in which we actually read pointers.

Then we consider the cases where x is a region term.

* r @L

First, assume L is here. By deo/nition of R we have:

Rr(Hs(r ), Hw(r , here))
From this we show that:

Rl(lor s(Hs(r )), Hw(r ))
Indeed, let p be a location in the AEattening of Hs(r ). By construction of the AEattening,
there is a unique path to p in Hs, by following active regions. We use this unique path
to p to prove Rl for pointer p. For all o/eld f , by Rr we have:

Hs(r )(p)(f ) = proj f (get(Hw(r , here), p))
This proves Rl(lor s(Hs(r )), Hw(r )).
Then assume L is not here. We use a similar reasoning but using:

Rl(Hs(L)(r ), Hw(r, L))

* get(RT , LT , s)

This case is basically a combination of the get(RT , LT , f ) case and the s case. Re-
member that there is no pointer being focused in RT , as logic regions are reconstructed
entirely with lor s.

We apply the induction hypothesis on RT and LT . The region term is evaluated to
lor s(LRT MLs(LLT MLs )(s)) where Ls = lohs(Hs) in the separated model, and is trans-
lated to proj s(get(why(RT ), why(LT ))). We have:

Rr(LRT MLs(LLT MLs)(s), proj r (get(why(RT ), why(LT ))))

5.2. DIRECT ENCODING OF THE SEPARATED MODEL 135

and we show:

Rl(lor s(LRT MLs(LLT MLs)(s)), proj r (get(why(RT ), why(LT ))))
as we did for the r case.
2

Theorem 8 (Interpretation of Predicates) Let P be a Capucine predicate such that:

\Gamma  ` P
Let Hs be a separated Capucine heap coherent with respect to \Gamma  and some permissions \Sigma .
Let Hw be a Why heap such that R(Hs, Hw). Why predicate why(P) holds in Hw if, and
only if LPMlohs(Hs) holds.

Proof. By induction on P. We apply Theorem 7 on terms and region terms. In particular
for the LT 2 RT case we use the fact that deo/nition of Rl uses the inRegion predicate. 2

We now state an intermediary theorem which will be implicitely used in the proofs for
interpretation of expressions and statements. This theorem states that if all necessary per-
missions are available on region ae, then why(ae) is well-deo/ned.

Theorem 9 (Interpretation of Regions) Assume ae is a well-typed region: \Gamma  ` ae: C.
Assume some permissions \Sigma . Assume for all x : [oe] in \Gamma , oe; is not in \Sigma . If \Gamma , \Sigma  ` ae then
why(ae) is deo/ned.

Proof. By induction on \Gamma , \Sigma  ` ae.

If ae = r , then why(ae) is deo/ned and is !r . If ae = x .s, then by \Gamma , \Sigma  ` ae, variable x has
type [oe] for some region oe.

If x is in the open part of the region tree, i.e. \Gamma , \Sigma  `ffi oe, then why(oe) is deo/ned by
induction on the derivation of \Gamma , \Sigma  `ffi oe, and thus why(x .s) is deo/ned.

Assume x is not in the open part of the region tree. It is thus in the closed part, i.e.
\Gamma , \Sigma  `* oe. We prove that why(x .s) is deo/ned by induction on the derivation of \Gamma , \Sigma  `* oe.

* If x is below the border, i.e. oe = y.s0, y: [oe0] and \Gamma , \Sigma  `* oe0, then we apply the

induction hypothesis on oe0 to prove that why(oe0) is deo/ned, and thus that why(oe) is
deo/ned, and thus that why(x .s) is deo/ned.

* If x is at the border, then we have a permission oe;, oe*, oeG or oe0 -ffi oe for some oe0, and

we have \Gamma , \Sigma  `ffi oe, so why(oe) is deo/ned (by induction on the derivation of \Gamma , \Sigma  `ffi oe).
If the permission is oe;, oeffi, oe* or oeG, then why(ae) is deo/ned as:

proj r (get(why(oe), x ))
Else, the permission is oe0 -ffi oe and we have \Gamma , \Sigma  ` oe0. By induction, why(oe0) is deo/ned.
So why(ae) is deo/ned as:

proj r (get((if inRegion(x , why(oe0)) then why(oe0) else why(oe)), x ))

136 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS
2

Here is an example which shows the importance of this theorem and the \Gamma , \Sigma  ` ae typing
judgement:

class C{

single s: Long;}

fun f [r : C ] (x : [r ]) (y: [x .s])

consumes x .sffi{

y.value  3;}

We cannot translate the assignment to y.value as we do not have any permission on r, the
region of x . We do not know x is actually in r , or if r being focused. Typing judgement
\Gamma , \Sigma  ` x .s requires some permission on the region of x to solve this problem.

Theorem 10 (Interpretation of Expressions) Let e be a Capucine expression such that:

\Gamma , \Sigma  ` e: o/
Let Hs be a separated Capucine heap coherent with respect to \Gamma  and \Sigma . Let Hw be a Why
heap such that R(Hs, Hw). We have:

Hw, why(e)

Why=) LeMH

s, Hw

Proof. By induction on e. We consider each case for e.

* c

Constants are trivially equally evaluated.

* xH

s(x ) is equal to Hw(x ) by R.

* e1 op e2

We apply the induction hypothesis on e1 and e2 . Operations op then evaluate equally.

* f arg

For each argument arg, if arg is of the form (e) we apply the induction hypothesis on
e.

Else arg is of the form [ae], and is evaluated in the separated model as:

lor s0(Hs(ae), Hs)
and as why(ae) in the Why translation. We show that they are in relation Rl as we did
for region terms RT , as the deo/nition of lor s0 is similar to the deo/nition of lor s. We
use coherence to ensure that all locations accessible in why(ae) are actually deo/ned in
lor s0(Hs(ae), Hs).

Function Jf K is then exactly the Why function f .

5.2. DIRECT ENCODING OF THE SEPARATED MODEL 137

* x .f

This expression evaluates, in the separated model, to Hs(Hs(x ))(f ). How it evaluates
in the Why translation depends on the permission on the region ae of x , and we prove
the property by induction on the deo/nition of obj (x , ae).

If the region ae of Hs(x ) is not being focused, then the Why translation is
proj f (get(why(ae), x )). We use the deo/nition of R and we conclude.

If region ae is being focused, i.e. permission oe -ffi ae is available for some region oe, then
the Why translation is:

proj f (if inRegion(x , oe) then obj (x , oe) else get(why(ae), x ))
If x is in oe, we apply the induction hypothesis on obj (x , oe). It x is not in oe, by item 8
of coherence we obtain that the active region of x is ae. We use the deo/nition of R and
we conclude.

2

Theorem 11 (Progress) Let s be a Capucine statement such that:

\Gamma  ` {\Sigma } s {\Sigma 0}, \Gamma 0
Let Hs be a separated Capucine heap coherent with respect to \Gamma  and \Sigma . Let Hw be a Why
heap such that R(Hs, Hw). Assume all proof obligations have been proved. Either the
Capucine program diverges:

Hs, s =) 1
or there is a separated Capucine heap Hs0 and some Why heap Hw0 such that R(Hs0, Hw0)
and:

Hw, why(s, unit)

Why=) (), H

w0

Hs, s =) Hs0

Proof. All proof obligations have been proved, so by Theorem 6, either:

Hw, why(s, unit)

Why=) 1

or there is Hw00 such that:

Hw, why(s, unit)

Why=) (), H

w00

However, we do not necessarily have R(Hs0, Hw00). Indeed, the Why program is non-
deterministic. For instance, black boxes such as any o/ may return any value of type o/ .
This is the case for allocation. The idea is that when several non-deterministic choices are
possible, we show that there is one which corresponds to the reduction in the Capucine model.
Otherwise we choose Hw0 = Hw00 and we show R(Hs0, Hw0).

We o/rst prove the statement of the theorem for some sequence s1 ; s2 . Because proof obli-
gations have been proven, for all Why heap which verify the pre-condition of why(s1 , unit),
executing why(s1 , unit) either diverges or return a Why heap which verio/es the pre-condition

138 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS
of why(s2 , unit). By induction, s1 either diverges or terminates. If it diverges, s1 ; s2 di-
verges. Otherwise, the heap obtained after executing s1 is in relation with a Why heap
obtained by executing why(s1 , unit) and we can apply the induction hypothesis on s2 . We
generalize to any sequence s1 ; * * *; sn by induction.

First, we assume that why(s, unit) terminates. We prove Theorem 11 by induction on
the derivation of the reduction of why(s, unit). We examine each possible case for s.

* let x = e

We apply Theorem 10 on e to show that the value given to x is the same in the separated
model and the Why interpretation.

* if e then S1 else S2

We apply Theorem 10 on e. If it evaluates to true, we apply the induction hypothesis
on why(S1 , unit). Else we apply it on why(S2 , unit).

* let x = f arg

Function f is translated into Why parameter f as well as Why function fgoal . Why
parameter f modio/es the heap non-deterministically in several possible ways. One of
them is the one provided by Why function fgoal , as proof obligations ensure that fgoal
verio/es its contract, which is the contract of Why parameter f . We use this one.

Let Hw2 be the Why heap obtained after the bindings of Why variables r1 , * * *, rn . The
way these variables are initialized allows parameters given to f to be in relation with
the one given to their version in separated heap Hs2 of the separated execution rule.
We can thus execute the Why version of the body of f in Hw2 and obtain Hw3 , which
is in relation with Hs3 in the separated execution rule by induction. The fact that the
body reduces shows that the pre-condition holds in Hw2 and that the post-condition
holds in Hw3 , and we apply Theorem 8 to show that it also holds in the separated
model. Let Hw0 be the Why heap obtained after the assign(aei , !ri ) operations. The
way these assignments is done allows us to conclude that Hw0 is in relation with the
separated heap Hs0 obtained by reducing the call in the separated model.

Let's be more precise about Hs2 and Hw2 . In the Why translation, references ri are
given initial values why(aei). In the separated model, regions ri are assigned to Hs(aei ).
Their pointers' active region is now ri , because the typing rule implies that aei 6= aej
for all i 6= j . By R(Hs, Hw), they are the same region values and thus R(Hs2 , Hw2 )
holds. We use a similar reasoning to prove R(Hs0, Hw0), by also applying Theorem 10
for the return value and using the fact that root(aei ) 6= root(aej ) for all i 6= j as we did
in the proof for the R relation.

* let region r : C

Statement always reduce in both model. New region r is empty in both cases, and thusR

r(Hs0(r ), Hw0(r )) holds.

* let x = new C [ae]

We bind x to the next fresh location p and p to the empty object in the separated
version of ae. In the Why translation, p is deo/ned by a black box. One particular
reduction of this black box is thus p, and we choose this one. The same goes for the
initial value of the object in the Why translation, which is also initialized to a black

5.3. SUPPORT FOR RECURSIVE CLASSES 139

box, whose value we choose to be in relation Ro with the empty object of the separate
reduction rule. Such a value exists.

* x .f  e

By construction of assign, as the region ae of x has permission aeffi and is thus not being
focused. We apply Theorem 10 on e.

* focus x : ae as oe

Let p = Lx MHs, which is also equal to Hw(x ) by Theorem 10. Permission aeG is con-
sumed, so region ae is not being focused. Permission oe; is consumed, so oe is empty
before the operation. By deo/nition of assign, location p in oe is set to its value in ae. Its
active region is now oe, and thus the two obtained heaps are thus in relation.

* adopt x : oe as ae

This is the same reasoning than the one we used for the focus operation, except that
target region is group instead of empty, but the reduction rule only changes the value
of location x .

* unfocus x : oe as ae

This is the same reasoning than the one we used for the adopt operation, except that
target region is being focused, but the reduction rule only changes the value of location
x which was in the target region of the anyway, so its value was of no importance.

* pack x

The statement reduces if, and only if the invariant predicate on x holds. We apply
Theorem 8 to obtain that the statement reduces in the separated model if, and only
if it reduces in its Why translation. The heaps are not modio/ed and thus are still in
relation.

* unpack x , weaken empty x , weaken single x

Statement always reduce and heap is not modio/ed.

* assert P

This is the same proof than for packing, except with predicate P instead of the invariant.

* label L

In Hw0, all region references r are copied in Hw0(r , L), which is in relation Rl withH

s0(L)(r).

If the Why program never terminates, then it diverges and we prove by coinduction that
the Capucine program diverges. 2

5.3 Support for Recursive Classes
Our translation cannot encode recursive classes such as:
class List{

140 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS

group r : List;
next: [r];
value: int;}

Class List is recursive because its owned region r has class List. So why(List) is not deo/ned.

One could consider removing the argument of the region type:

type region
Then why(List) would simply be (region * location * int). However, this solution is not
sound when proving proof obligations using provers which do not assume that all types are
inhabited. Logic function get is deo/ned as:

logic get (region, location): ff
Given a value of type region and a value of type location, this function can create a value
of any type, including the false predicate. Here is an example of a Coq [Coq] script which
illustrates this problem:

Parameter region: Type.

Parameter get:

forall A: Type,
region -> location -> A.

Parameter r: region.
Parameter l: location.
Theorem bad: False.
apply get.
apply r.
apply l.
Qed.

Parameter region is the translation of Why type region. Parameter get is the translation
of Why logic function get. We assume a region r and a location l are available, which is
the case in proof obligations. Theorem bad illustrates how False can be proven: we simply
construct the Coq term get False r l.

We can, however, change our translation in a sound way, even when targetting provers
such as Coq. A o/rst solution is to introduce one Why type regionC per Capucine class C.
Logic function get is then duplicated for each class C, with type:

logic getC (regionC, location): why(C)
For instance, here is the get function for class List:
logic getList (regionList , location): (regionList * location * int)
The problem is that all other logic functions and predicates (set, empty and inRegion) must
be specialized for each class in the same way as get. Axioms must be duplicated as well.

Another solution is to introduce a Why type C for each class C . Type C encapsulates
the object tuple for class C . We introduce a function getC from C to why(C ) to read an

5.4. SIMPLIFY SINGLETON REGIONS 141
encapsulated tuple and a function makeC from why(C ) to C to make an encapsulated tuple.
For instance, here is the encoding of class List:

type EncapsulateList

logic getList (EncapsulateList): (region (EncapsulateList) * location * int)
logic makeList ((region (EncapsulateList) * location * int)): List

axiom getmakeList:8

x : (region (EncapsulateList) * location * int).
getList(makeList(x )) = x

In Coq, we could model type EncapsulateList with an inductive type. We can then keep the
polymorphic type ff region, but the ff is instanciated with type EncapsulateList instead of
why(List). This is obviously a better encoding of recursive classes.

Both solutions are compatible with the other extensions that we present in Section 5.4
and Section 5.5.

5.4 Simplify Singleton Regions
5.4.1 Singleton Maps Are Values
Proposal Our o/rst proposal to simplify proof obligations is to encode singleton regions
without a map. Ideally, we would represent singleton regions by one single value correspond-
ing to the object tuple stored in the region. The way singleton regions r were encoded in
the previous section is using a map from a single location p to its object tuple o. To read
o requires applying a logic function: get(r, p). To change o to o0 requires applying another
logic function: set(r, p, o0). But if region r is singleton, then typing ensures that the only
location we will read from r is its unique location p, which is thus irrelevant. However,
singleton regions were actually empty before being singleton, and sometimes become group
through the weakening operation.

What we actually propose is to represent each region ae using three components:

* the aeP component, containing the unique location p of region ae when ae is singleton;

* the aeO component, containing the unique object tuple o of region ae when ae is singleton;

* the aeG component, containing the map representing ae when ae is group.
If the region is a region name and is thus represented as a reference, it is now represented
as three references. If the region is owned and is thus one component of a tuple, it is now
represented as three components of the tuple.

We then use permissions to know which component to read:

* if ae is empty, we do not access it;

* if ae is singleton, we access it through aeP and aeO ;

* if ae is group, we access it through aeG .

142 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS
In particular, we need to be careful regarding statements which change the status of a region
from empty to singleton, from empty to group or from singleton to group.

In the logic though, we do not change anything: regions are still maps. This is because
there is no permission in the logic, and thus we would not know which component aeP , aeO or
aeG to use when translating accesses, especially in axioms or predicate bodies.

Region Expressions Instead of having one single function why(ae), we deo/ne three trans-
lation functions whyP (ae), whyO (ae) and whyG(ae) corresponding to the three components of
ae. They are deo/ned in a similar fashion than why(ae), except that they return the expected
component P, O or G.

Expressions We change how expression x .f is translated. Let ae be the region of x . If
aeffi{f1 , * * *, fk } (k >= 0) or ae* is available, the translation of x .f is proj f (whyO (ae)). For
instance, if ae is a region name r , then why(x .f ) is proj f (!rO ), which is simpler than what we
had before: proj f (get(!r , x )). If, however, aeG or oe -ffi ae is available, we translate as before
using whyG(ae).

Statements Instead of having one single function assign(ae, v ), we deo/ne three functions
assignP (ae, v), assignO(ae, v) and assignG(ae, v ) which respectively assign the aeP , aeO and aeG
components of ae. Now we can deo/ne the new translation for statements dealing with regions.

* why(let region r : C, cont) =

let rP = ref (any location) in
let rO = ref (any why(C)) in
let rG = ref empty in
cont

Black boxes construct unknown values, which will not be used as the region being
empty, none of the three components will be accessed anyway.

* why(let x = new C [ae], cont) =

let x = any location in
assignP (ae, x );
assignO (ae, any why(C));
cont

Interestingly enough, we could initialize x to whyP (ae), as this component of empty
regions is initialized to a black box as well. Same goes for the initial object tuple.

* why(x .f  e, cont) =

assignO (ae, setf (whyO(ae), why(e)));
cont

Region ae is the region of x . This is quite simpler than before as we know that ae is
singleton, as permission aeffi{f1 , * * *, fk } (k >= 0) is available.

* why(adopt x : oe as ae, cont) =

assignG(ae, set(whyG (ae), x , whyO (oe)));
cont

We simplify how we read the object of x , as its region oe is singleton.

5.4. SIMPLIFY SINGLETON REGIONS 143

* why(focus x : ae as oe, cont) =

assignP (oe, x );
assignO (oe, get(whyG(ae), x ));
cont

This is no longer an instance of adoption, as target region is singleton after the opera-
tion.

* why(unfocus x : oe as ae, cont) =

assignG(ae, set(whyG (ae), x , whyO (oe)));
cont

Once again, this is exactly the same as adoption.

* why(weaken empty ae, cont) =

assignG(ae, empty);
cont

We assign the aeG component to empty, but it is not necessary as it already was empty
(see the let region statement). It is simply a little easier for the user when ae is a region
parameter of the current function, as then the fact that aeG is empty would otherwise
have to be given as a pre-condition.

* why(weaken single ae, cont) =

assignG(ae, set(empty, whyP (ae), whyO (ae));
cont

Interestingly enough, while the weakening operation from singleton to group did not
do anything before, it now has to transfer the aeP , aeO components into aeG .

Further Simplio/cation If a region ae is never singleton, we may omit the aeP and aeO
components in the Why translation. Conversely, if ae is always singleton, we may omit the
aeG component.

Note that this can even be done if ae is a parameter of a function. Consider function incr :

fun incr [r: Long] (x : [r]): unit

consumes r *
produces r *{

r.value  r .value + 1;}

Region r is always singleton during the execution of incr . Instead of expecting three reference
arguments rP , rO and rG , function incr expects only the o/rst two. Why parameter incr
becomes:

parameter incr (rP : ref (pointer ), rO: ref (int), x : pointer ): unit* * *

Note that in practice, incr will always be called with x = !rP . We know this from the fact
that r is singleton. Another simplio/cation could thus be to automatically remove argument
rP or x .

144 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS
5.4.2 Illustration
We reuse the example of Figure 5.2 and Figure 5.3. We show how it is translated using
our simplio/cation of singleton regions, and then show the new proof obligation for the post-
condition.

Translation We construct the Why code corresponding to the new translation of function
incrTriple. Here is the header of the function, including the post-condition:

fun incrTriple

(r : ref (region (int * region (int) * location * location * location)),

x : location): unit
post

proj value(proj Ra (get(!r, x ))) =

proj value(proj Ra (get(!r @pre, x ))) + 1 ^
proj value(get(proj Rbc(get(!r , x )), proj b(get(!r , x )))) =

proj value(get(proj Rbc(get(!r @pre, x )), proj b(get(!r @pre, x )))) + 1 ^
proj value(get(proj Rbc(get(!r , x )), proj c(get(!r, x )))) =

proj value(get(proj Rbc(get(!r @pre, x )), proj c(get(!r @pre, x )))) + 1

Region x .Ra is singleton during the whole execution of the function, and we will not need
the P component as no adoption, focus or unfocus will be done. So we model x .Ra using a
simple integer. Region x .Rb is group during the whole execution, so we model it as before
using a region map. The other components are not needed. As you can see, the result is a
simplio/cation of the o/rst part of the post-condition. We continue with the translation of the
incrementation of x .a.value:

{

let a = proj a (get(!r , x )) in
r :=

set(!r, x ,

setRa (get(!r , x ),

setvalue(

proj Ra (get(!r, x )),
proj value(proj Ra (get(!r , x ))) + 1)));
assert proj value(proj Ra (get(!r , x ))) > 0;

Once again, the result is slightly simplio/ed thanks to the fact that Ra is singleton. We
continue with the focusing of x .b:

let b = proj b(get(!r, x )) in
let FbP = ref (any location) in
let FbO = ref (any int) in
FbP := b;
FbO := get(proj Rbc(get(!r , x )), b);

As the target region Fb of the focus is always either empty or singleton, we do not need the
G component of the region. We do need the P component for the unfocus which is to come.
Next is the assignment to x .b.value and the pack statement:

FbO := setvalue(!FbO, proj value(!FbO ) + 1);
assert proj value(!FbO ) > 0;

5.4. SIMPLIFY SINGLETON REGIONS 145
The incrementation of x .b ends with the unfocus:

r := set(!r , x , setRbc(get(!r , x ), set(proj Rbc(get(!r , x )), b, !FbO )));
The remaining of the function is the conditional assignment to x .c.value, which is similar to
the one to x .b.value, so we do not show it here.

Proof Obligations Here is the proof obligations stating that the post-condition holds if
x .b = x .c:

8r : (region * int region * location * location * location) region.8

a: location.
a = proj a (get(r, x )) )8

r1 : (region * int region * location * location * location) region.
r1 =

set(r , x ,

setRa (get(r, x ),

setvalue(

proj Ra (get(r , x )),
proj value(proj Ra (get(r , x ))) + 1))) )8
b: location.
b = proj b(get(r1 , x )) )8

FbP : location.8
FbO : int.
FbP = b )
FbO = get(proj Rbc(get(r1 , x )), b) )8

FbO,1 : int.
FbO,1 = setvalue(FbO , proj value(FbO ) + 1) )8

r2 : (region * int region * location * location * location) region.
r2 = set(r1 , x , setRbc(get(r1 , x ), set(proj Rbc(get(r1 , x )), b, FbO,1 ))) )8

c: location.
c = proj c(get(r2 , x )) )
b = c )
proj value(proj Ra (get(r2 , x ))) =

proj value(proj Ra (get(r , x ))) + 1 ^
proj value(get(proj Rbc(get(r2 , x )), proj b(get(r2 , x )))) =

proj value(get(proj Rbc(get(r , x )), proj b(get(r , x )))) + 1 ^
proj value(get(proj Rbc(get(r2 , x )), proj c(get(r2 , x )))) =

proj value(get(proj Rbc(get(r , x )), proj c(get(r , x )))) + 1

As you can see, the proof obligation is simpler regarding singleton regions x .Ra and Fb, as
there is no need to access the value with get and to change it using set. It is thus more
readable and we do not have to apply axioms deo/ning get and set as much. The complexity
regarding group regions is exactly the same.

5.4.3 Soundness
We shall not prove that our new translation is sound with as much details as we did for
our original translation. We do, however, sketch the modio/cations that must be done to the
proof. Relation Rr now takes three Why values vP , vO and vG instead of only one. Each of

146 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS
these value models one of the respective component of the region. Then we use permissions to
know which component should be used to model the separated region function g. If the region
is singleton, then g should be of singleton domain {vP }, and g(vP ) should be in relation Ro
with vO . If the region is group, then all location p in the domain of g should be in relationR

o with get(p, vG).

Knowing whether the considered region is singleton or group requires adding more argu-
ments to the relations Rr, Ro and R. We need to keep track of the region being considered
as well as permissions \Sigma .

5.5 Flattening Regions for More Separation
5.5.1 Generalizing The Component-as-Array Model
The simplio/cation we introduced for singleton regions is nice, but it does not introduce more
static separation. In this section, we use the idea of the Burstall-Bornat component-as-
array model [Bornat00], which we introduced in Section 2.4.3, and generalize it for Capucine.
We introduce the intuition behind this generalization using the example of Figure 5.2 and
Figure 5.3.

Reordering Heap Arguments In the separated heap Hs at the beginning of function
incrTriple, the following paths are deo/ned, where p is any location:

Hs(r)(p)(Ra)(p)(value): intH

s(r)(p)(Rbc)(p)(value): intH
s(r)(p)(a): locationH
s(r)(p)(b): location

We can reorder the arguments of function Hs. In particular, here is an interesting reordering:
Hs0(r)(Ra)(value)(p)(p): intH

s0(r)(Rbc)(value)(p)(p): intH
s0(r)(a)(p): locationH
s0(r)(b)(p): location

This reordering has several consequences. One of them is that it is harder to achieve partial
application Hs(r )(p)(Ra), for instance. However, it also has beneo/ts which we explore in the
next paragraphs.

Flattening Finite Arguments The o/rst argument of function Hs0 above is a region name.
There is a o/nite number of region names, which can be computed from the body of incrTriple.
Because this number is o/nite, we can split the function into one function per argument. Here,
there is only one possible argument: region r. So we transform Hs0 into one function Hsr
with one less argument. The following paths are deo/ned:

Hsr (Ra)(value)(p)(p)H

sr (Rbc)(value)(p)(p)H
sr (a)(p): locationH
sr (b)(p): location

5.5. FLATTENING REGIONS FOR MORE SEPARATION 147
The next argument can also only take a o/nite number of values: the names of owned regions
and o/elds of the class of pointers in r, namely Ra, Rbc, a and b. So we can split function Hsr
into four functions Hsr,Ra , Hsr,Rbc and Hsr,a and Hsr,b. The following paths are deo/ned:

Hsr,Ra (value)(p)(p)H

sr,Rbc(value)(p)(p)H
sr,a (p): locationH
sr,b(p): location

Similarly, class Long has only one o/eld value, and thus the o/rst argument of functions Hsr,Ra
and Hsr,Rbc is actually irrelevant. We delete this argument and rename these functionsH

sr,Ra,value and Hsr,Rbc,value, respectively. The following paths are deo/ned:H

sr,Ra,value(p)(p)H
sr,Rbc,value(p)(p)H
sr,a (p): locationH
sr,b(p): location

To sum up, what we did is simply:

* reorder the arguments of the heap function so that o/nite domains appear o/rst;

* split functions with a o/nite domain into several functions with one less argument.
This is a generalization of the Burstall-Bornat component-as-array model. Indeed, in a
naive model the heap is a function h of locations p and o/eld names f . We reorder h(p)(f )
into h(f )(p), and then AEatten the function into hf (p), and we obtain the component-as-array
model.

Singleton Regions This approach combines well with the simplio/cation of singleton re-
gions we introduced in Section 5.4. The three components P, O and G can be seen as an
additional argument of the heap function. This argument can only take a o/nite number of
values, namely P, O and G. Only the G component has a pointer argument, as it is a map.

In the above example, the following paths would be deo/ned:

Hs(r)(P): location

Hs(r)(O)(Ra)(P): locationH

s(r)(O)(Ra)(O)(value): intH
s(r)(O)(Ra)(G)(value)(p): intH
s(r)(O)(Rbc)(P): locationH
s(r)(O)(Rbc)(O)(value): intH
s(r)(O)(Rbc)(G)(value)(p): intH
s(r)(O)(a): locationH
s(r)(O)(b): locationH
s(r)(O)(c): location

Hs(r)(G)(p)(Ra)(P): locationH

s(r)(G)(p)(Ra)(O)(value): intH
s(r)(G)(p)(Ra)(G)(value)(p): intH
s(r)(G)(p)(Rbc)(P): locationH
s(r)(G)(p)(Rbc)(O)(value): int

148 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS
Hs(r)(G)(p)(Rbc)(G)(value)(p): intH

s(r)(G)(p)(a): locationH
s(r)(G)(p)(b): locationH
s(r)(G)(p)(c): location

When a region is always singleton, we can remove the G component. When a region is always
group, we can remove the P and O components. Region r is always singleton, region Ra is
also always singleton, and region Rbc is always group. We are left with the following paths:

Hs(r)(P)H

s(r)(O)(Ra)(P)H
s(r)(O)(Ra)(O)(value)H
s(r)(O)(Rbc)(G)(value)(p)H
s(r)(O)(a)H
s(r)(O)(b)H
s(r)(O)(c)

After applying our reorder-AEatten transformation, we obtain:
Hsr,PH

sr,O,Ra,PH
sr,O,Ra,O,valueH
sr,O,Rbc,G,value(p)H
sr,O,aH
sr,O,bH
sr,O,c

In other words, we can encode the initial heap of the incrTriple function using six Why values:

* Hsr,P , the unique pointer x of region r;

* Hsr,O,Ra,P , the unique pointer x .a of region x .Ra;

* Hsr,O,Ra,O,value, the integer value of x .a.value;

* Hsr,O,Rbc,G,value, the map from locations to integers for region x .Rbc;

* Hsr,O,a , the location value of x .a;

* Hsr,O,b, the location value of x .b.

* Hsr,O,c, the location value of x .c.

5.5.2 Computing Preo/x Trees
Compromises In Section 5.5.1, we gave the intuition for our new simplio/cation. However,
one important question is: how deep should we AEatten the heap ? Flattening more is great to
introduce more separation and using less arguments for functions, i.e. less maps in the Why
translation. However, AEattening introduces more reference variables. Assume for instance
that there are n regions of pointers of class C , and class C has m integer o/elds. If we AEatten
as much as possible, we obtain n * m variables. If instead class C has m regions of pointers
with o o/elds, we obtain n * m * o variables. The number of variables thus grows quickly
when the region tree becomes deeper. Another issue is if the tree is not statically o/nite, i.e.

5.5. FLATTENING REGIONS FOR MORE SEPARATION 149
if it involves recursive classes. Then there is an ino/nite number of ways we can AEatten the
tree.

Preo/x Trees We introduce the notion of preo/x tree. Preo/x trees describe how deep into
the heap tree we want to AEatten. We o/rst compute a preo/x tree, and only then we translate
the code according to this preo/x tree. Here are some possible preo/x trees:

* the empty tree, which says not to AEatten at all, and from which we obtain the regular

encoding of Section 5.2;

* the whole heap tree, which is only deo/ned if there is no recursive class involved;

* the paths that are actually used by the function;

* the paths that are actually used by the function, with a o/xed depth limit.
This fourth way of computing preo/x trees is the one we are interested in. If, say, pathH

s(r)(p)(value) is accessed by the function being translated, then it is a good idea to AEattenthis path as H

sr,value(p).
Formally, a preo/x tree is a tree whose root is labeled Hs. This root can be AEattened. If
so, we obtain n children, with n being the number of root regions involved in the translation.
Each child is then labeled with a region name. Each region node can also be AEattened, and
then children labeled with the name of each owned region and o/eld are added to the region
node. Each owned region node can be AEattened in the same fashion.

Computing Preo/x Trees To compute paths which are actually used by function bodies,
we add each used path in the code to the tree by AEattening all nodes involved in the path. A
path is a sequence of a region name, followed by some owned region names, possibly ended
by a o/eld name. Each expression x .f appearing in the body adds the path to x .f , computing
from the type of x and permissions, to the preo/x tree. For instance, if x has type [y.s] and
y has type [r ], the path r , s, f is added to the preo/x tree. The same goes if x .f is assigned
by a statement. Adoption, focus, unfocus allocation and region binders all add paths to the
preo/x tree as they involve creating, reading or writing regions.

Alternative Way of Flattening Instead of AEattening a node by adding all its children
into it, we can keep only the needed children. The remaining ones will be represented as
before using a function. This limits the number of reference variables involved. We will not
detail this approach in this thesis.

5.5.3 Using Preo/x Trees When Translating
Expressions and Statements When accessing a path Hs(x1 )* * *(xn ), we o/rst split the
path into two parts: Hs(x1 )* * *(xk )(y1 )* * *(yl ) where k + l = n, and where either:

* path Hs(x1 )* * *(xk ) leads to a leaf in the preo/x tree;

* or l = 0 and the whole path is in the preo/x tree.

150 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS
In other words, we look for the part of the path which is in the preo/x tree.

If l > 0, Hs(x1 )* * *(xk ) is represented using a reference variable and we read from this
variable. We access the remainder y1 , * * *, yl of the path using get and tuple projections. If
we are assigning the path, we use the usual set and tuple makers.

If l = 0 and Hs(x1 )* * *(xk ) does not lead to a leaf in the preo/x tree, then the preo/x tree is
bigger than what is being read. In other words, Hs(x1 )* * *(xk ) is not represented by a single
reference variable, but by several. The following cases are to be considered:

* the node is being read as a whole, for instance as a region given to a logic function;

* the node is being copied into another node, for instance when focusing, adopting or

unfocusing.

In the o/rst case, we reconstruct the node from its parts. Path Hs(x1 )* * *(xk ) leads to a node
with several children, represented as several reference variables. We take all these variables
and reconstruct one Why value representing Hs(x1 )* * *(xk ). In the second case, we do not
necessarily need to reconstruct the node if the target node into which we are copying is itself
AEattened. In this case, we copy each source child node into each target child node.

Function Calls Instead of using a Why parameter to encode function calls, we can inline
the function as a black box with the substituted pre-condition, post-condition, reads clause
and writes clause of the function. We can then compute the preo/x tree using the inlined
versions of these. This allows the preo/x tree to be deeper. If, for instance, function f takes x
as an argument and assigns x .f , and f (y.g) is called, then y.g can be AEattened so that y.g.f
appears as a separated reference variable.

It is also worth noting that the reads and writes clause can be computed in a o/ner fashion
using our AEattening methodology. Say, for instance, function f takes argument x of type [r ],
where r is a region containing Triple pointers. Say f only assigns x .a.value. With our direct
encoding, there is only one reference: r , which must appear in the writes clause. With our
AEattening methodology, r can be AEattened into several references, and we can put only the
one corresponding to x .a.value in the writes clause. Then from the outside world we know
that when calling f , x .b.value is not modio/ed. This is quite powerful as the user does not
have to put annotations in the post-condition to state that x .b.value is unchanged. Instead,
the reference corresponding to x .b.value is simply not assigned.

Region Arguments of Logic Functions and Predicates In axioms, logic functions
and predicates, there is no assignment, and thus the need for AEattening is lesser. Actually,
AEattening in the logic has bad properties. Consider function f :

logic f [r : Triple] (x : [r ]): int
Should region r be AEattened? If so, how deep should it be AEattened? It not only depends
on the deo/nition of f , which may not even be provided; but it also depends on the code
which applies f . Knowing whether r should be AEattened is thus not modular. To be modular
we need to choose one AEattening at the deo/nition of f , not after. Candidates for AEattening
include no AEattening or full AEattening. Full AEattening is only possible when involved classes
are not recursive. We could also choose to deo/ne several Why versions of f , for instance one
for each program function.

What we have chosen in our particular implementation of Capucine is not to AEatten
logic regions at all. Regions given as arguments to logic functions and predicates have to

5.5. FLATTENING REGIONS FOR MORE SEPARATION 151
be reconstructed. It is a bit heavy sometimes, and it can be argued that a global analysis,
although not modular, would lead to simpler proof obligations.

For instance, consider the following deo/nition for class List and logic function length,
which returns the length of a list:

class List{

group Rnext: List;
next: option ([Rnext]);}

logic length [r : List] (l : [r ]): int
We choose not to AEatten r at all, and the Why translation of the declaration of length is thus:
logic length (r : regionList , l : pointer ): int
However, if length is always applied on lists which are AEattened once, i.e. their region is
represented as two references, one for Rnext and one for next, then it would be a good idea
to change the Why declaration to:

logic length (Rnext: regionList , next: pointer , l: pointer ): int
Indeed, with this translation we do not have to reconstruct r from Rnext and next each time
we apply length.

5.5.4 Illustration
We once again construct the Why code corresponding to the translation of function incrTriple,
which was introduced in Figure 5.2 and Figure 5.3. We also use the simplio/cation of singleton
regions.

Choosing The Preo/x Tree Instead of using names such as Hsr,O,Ra,P , we choose to use
simpler, well-chosen names:

* Hsr,P , the unique pointer of r , is renamed into rP ;

* Hsr,O,Ra,P , the unique pointer of x .Ra, is renamed into RaP ;

* Hsr,O,Ra,O,value, the value of x .a.value, is renamed into Ravalue;

* Hsr,O,Rbc,G,value, the region map of Rbc, is renamed into Rbc;

* Hsr,O,a , the value of x .a, is renamed ra ;

* Hsr,O,b, the value of x .b, is renamed rb;

* Hsr,O,c, the value of x .c, is renamed rc;

* HsFb,P , the unique pointer of Fb, is renamed into FbP ;

* HsFb,O,value is renamed into Fbvalue.

152 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS
Translation Here is the header of the function:
fun incrTriple

(rP : ref location,

RaP : ref location,
Ravalue: ref int,
Rbc: ref (region (int)),
ra : ref location,
rb: ref location,
rc: ref location): unit
post

!Ravalue = !Ravalue@pre + 1 ^
get(!Rbc, !rb) = get(!Rbc@pre, !rb@pre) ^
get(!Rbc, !rc) = get(!Rbc@pre, !rc@pre)

The beneo/ts of our AEattening methodology is already quite visible. We continue with the
incrementation of x .a.value:

{

let a = !ra in
Ravalue := !Ravalue + 1;
assert !Ravalue > 0;

It cannot get simpler than this. Note that variable a is not actually useful here. We only
keep it because it comes from the Capucine program. We continue with the focusing of x .b:

let b = !rb in
let FbP = ref (any location) in
let Fbvalue = ref (any int) in
FbP := b;
Fbvalue := get(!Rbc, b);

Next is the assignment to x .b.value and the pack statement:

Fbvalue := !Fbvalue + 1;
assert !Fbvalue > 0;

Finally, here is the unfocus of x .b:

Rbc := set(!Rbc, b, !Fbvalue);
The remaining of the function is similar.

Proof Obligation Here is the proof obligation stating that the post-condition holds if
x .b = x .c:

8rP : location.8

RaP : location.8
Ravalue: int.8
Rbc: (region (int)).8
ra : location.8
rb: location.8
rc: location.8
a: location.

5.6. EXPERIMENTS 153

a = ra )8

Ravalue,1 : int.
Ravalue,1 = Ravalue + 1 )8

b: location.
b = rb )8

FbP : location.8
Fbvalue: int.
FbP = b )
Fbvalue = get(Rbc, b) )8

Fbvalue,1 : int.
Fbvalue,1 = Fbvalue + 1 )8

Rbc1 : (region (int)) )
Rbc1 = set(Rbc, b, Fbvalue,1 ) )8

c: location.
c = rc )
b = c )
Ravalue,1 = Ravalue + 1 ^
get(Rbc1 , rb) = get(Rbc, rb) + 1 ^
get(Rbc1 , rc) = get(Rbc, rc) + 1

This proof obligation is arguably much more readable than the ones we had with previous
encodings. It is also simpler to prove, as axioms getSetEq and getSetNeq have to be instanci-
ated less often. In particular this helps theorem provers. It takes advantage of the separation
information granted by typing. Indeed, when modifying x .a.value, for instance, the only ref-
erence which is modio/ed is the one representing x .a.value. The reference representing x .Rbc,
in particular, is left unchanged.

5.5.5 Soundness
Once again, we shall not prove that our new translation is sound with as much details as we
did for our original translation. We simply remark that there is a simple bijection between
the two representations, depending on the chosen preo/x tree.

5.6 Experiments
In this section we give the results of experiments aimed at comparing whether automatic
theorem provers are more eOEcient with the preo/x-tree encoding of Section 5.5 or with the
direct encoding of Section 5.2. We conduct our experiments using two theorem provers: Alt-
Ergo [AltErgo] and Z3 [Z3], and on three programs: the bounded arrays, the sparse arrays
and the course and students examples of Section 3.4.

We conduct our experiments on an Intel Core 2 Duo CPU E6850 at 3.00GHz with 3GB
of memory. To lower the impact of memory swapping, we run the experiments once before
running them again, and we only keep the second result. This way we ensure that the amount
of memory required by the prover is actually free when running the second run.

Sparse Arrays Assertions The o/rst result we observe is that some assertions that we put
in the code of the sparse arrays example to help automatic provers are needed to prove the
program entirely with the direct encoding, but are not needed with the preo/x-tree encoding.

154 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS

Bounded arrays: arrayCreate
invariant of the created array 0.120s 0.068s
post-condition 0.004s 0.000s

Bounded arrays: arrayGet
post-condition 0.000s 0.000s

Bounded arrays: arraySet
invariant of the modio/ed array 0.004s 0.000s
post-condition (contents) 0.004s 0.004s
post-condition (length) 0.004s trivial

Figure 5.4: Experiment results for bounded arrays

There are 3 of them. We thus have removed them when running the experiments on sparse
arrays with the preo/x-tree encoding.

Alt-Ergo We o/rst verify our programs with the Alt-Ergo theorem prover. The protocol
used is simple: we run Alt-Ergo on the o/le which contains all the goals. Alt-Ergo returns,
for each goal, whether it was capable of proving it or not. It also returns the time taken to
verify each verio/cation condition.

Results are given in Figures 5.4, 5.6, and 5.7. The left column is a description of the
verio/cation condition. The middle column is the time taken by Alt-Ergo to prove the verio/-
cation condition with the direct encoding. The right column is the time taken by Alt-Ergo to
prove the verio/cation condition with the preo/x-tree encoding. Some proof obligations are so
trivial with the preo/x-tree encoding that they are discharged automatically by Why. Those
are marked as itrivialj in the tables. Assertions which were removed from the sparse arrays
example with the preo/x-tree encoding are marked as inot usedj. Assertions which are not
proved automatically by Alt-Ergo are marked as inot provedj.

The total time taken to verify bounded arrays is 0.136s with the direct encoding, and
0.072s with the preo/x-tree encoding. These number are too small to be signio/cant. What
is signio/cant though is the fact that one proof obligation is so trivial with preo/x trees that
it is discharged by Why and is thus not even sent to the theorem prover. This is due to the
separation of the heap between several variables. On the other hand, the proof obligation is
proven almost instantly anyway even with the direct encoding.

The total time taken to verify the course and students example is not signio/cant: it takes
much less time (about 1.2s instead of about 14s) to prove obligations which are proved, but
one proof obligation is no longer proved with the preo/x-tree encoding. It is, however, proved
using Z3 in less than 1s. This does not take into account the main function, which is proved
automatically and in a quite fast fashion with both encoding. For this reason, we omitted the
results for this function. Some proof obligations are not proved by Alt-Ergo in both cases.
They are proved by another theorem prover. One proof obligation becomes trivial thanks to
separation.

The total time taken to verify sparse arrays is more than 120s with the direct encoding,
and is about 26s with the preo/x-tree encoding. This is a pretty signio/cant gain. The most
impressive case is the verio/cation condition for the invariant of the sparse array in function

5.6. EXPERIMENTS 155

Course and students: createCourse
invariant of the created course 0.168s 0.048s
post-condition 0.024s 0.012s

Course and students: addStudent
invariant of the created student 0.008s 0.004s
invariant of the modio/ed course not proved not proved
post-condition (mark) 12.917s 0.928s
post-condition (count) 0.068s 0.024s
post-condition (sum) 0.080s 0.020s
post-condition (other marks) 0.228s 0.040s

Course and students: changeMark
invariant of the student 0.008s 0.004s
assertion to help provers not proved not proved
invariant of the course 24.733s not proved
post-condition (mark) 0.080s 0.036s
post-condition (sum) 0.072s 0.032s
post-condition (count) 0.000s trivial
post-condition (other marks) 0.004s 0.004s

Figure 5.5: Experiment results for course and students

sset: it takes about 27s with the direct encoding, and a third of a second with the preo/x-tree
encoding. What is also quite interesting is that many proof obligations are trivial with the
preo/x-tree encoding, and that assertions to help provers are not needed.

Z3 In order to check that the preo/x-tree encoding does not only help Alt-Ergo but other
theorem provers as well, we also measured the time Z3 takes to prove the verio/cation condi-
tions. Note that while Alt-Ergo give the time taken to prove each verio/cation condition, Z3
does not. As a result, we choose to only measure the time taken for the whole program. It
also follows that the two methods are not comparable, and thus that one should not deduce
from these experiments that one prover is better than the other. However, it is suOEcient to
check whether the preo/x-tree encoding helps automatic provers or not.

The protocol used is as follows. We run Z3 on each verio/cation condition, one at a time,
with a timeout of 10 seconds for each verio/cation condition. If Z3 fails to prove a proof
obligation after 10 seconds it will abort and go on to the next one. We measure the time it
takes for Z3 to run on all proof obligations. We also count the number of timeouts. Note
that when Z3 cannot prove a verio/cation condition, it will continue to run until the timeout.
We also tried to run the experiment with no timeout, but we aborted it after memory started
swapping too much.

The results are the following:

* it takes about 72 seconds, including 7 timeouts, for the course and students example

using the direct encoding;

* it takes about 31 seconds, including 3 timeouts, for the course and students example

using the preo/x-tree encoding;

156 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS

Sparse arrays: create
pre-condition of arrayCreate 0.004s 0.004s
assertion to help provers 0.328s not used
invariant of the created sparse array 2.696s 0.032s
post-condition (size) 0.184s 0.016s
post-condition (model) 1.044s 0.184s

Sparse arrays: sget
pre-condition of arrayGet on a.idx 0.008s 0.008s
pre-condition of arrayGet on a.idx 0.008s 0.004s
pre-condition of arrayGet on a.back 0.008s 0.008s
pre-condition of arrayGet on a.value 0.012s 0.008s
post-condition 0.044s 0.192s
post-condition 0.024s 0.156s
assertion to help provers 0.024s not used
post-condition 0.040s 0.320s

Sparse arrays: sset
pre-condition of arraySet on a.value 0.008s 0.004s
pre-condition of arraySet on a.value 0.008s 0.008s
pre-condition of arrayGet on a.idx 0.040s 0.008s
pre-condition of arrayGet on a.back 0.040s 0.008s
assertion to help provers 0.020s not used
invariant of the sparse array 0.468s 0.036s
post-condition 0.068s trivial
post-condition 0.824s 1.420s
post-condition 0.084s 0.232s
assertion a.n < a.size not proved not proved
pre-condition of arraySet on a.back 0.636s 0.032s
pre-condition of arraySet on a.back 0.074s 0.012s
assertion to help provers 0.204s not used
invariant of the sparse array 6.004s 0.204s
post-condition 0.152s trivial
post-condition 3.480s 2.000s
post-condition 0.240s 0.216s
assertion a.n < a.size not proved not proved
pre-condition of arraySet on a.back 0.968s 0.036s
pre-condition of arraySet on a.back 0.120s 0.016s
assertion to help provers 1.028s not used
invariant of the sparse array 27.198s 0.364s
post-condition 0.272s trivial
post-condition 6.740s 3.900s
post-condition 0.448s 0.420s

Figure 5.6: Experiment results for sparse arrays (1/2)

5.6. EXPERIMENTS 157

Sparse arrays: test
pre-condition of create 0.004s 0.004s
pre-condition of sget on a 0.004s 0.004s
pre-condition of sget on b 0.008s 0.004s
assertion 0.008s 0.012s
assertion 0.012s 0.012s
pre-condition of sget on a 0.008s 0.004s
pre-condition of sget on b 0.004s 0.008s
assertion 0.008s 0.004s
assertion 0.008s 0.008s
pre-condition of sget on a 0.008s 0.004s
pre-condition of sget on b 0.008s 0.008s
assertion 8.144s 2.372s
assertion 7.905s 2.324s
pre-condition of sget on a 0.008s 0.008s
pre-condition of sget on b 0.008s 0.008s
assertion 25.842s 6.000s
assertion 24.793s 5.620s
pre-condition of sget on a 0.008s 0.008s
pre-condition of sget on b 0.012s 0.008s

Figure 5.7: Experiment results for sparse arrays (2/2)

* it takes about 156 seconds, including 10 timeouts, for the sparse arrays example using

the direct encoding;

* it takes about 53 seconds, including 3 timeouts, for the sparse arrays example using

the preo/x-tree encoding.

Once again the preo/x-tree encoding helps the automatic theorem prover, especially for the
sparse arrays example where it is about 3 times faster and is capable of proving more verio/-
cation conditions. Some of the other proof obligations cannot be proved automatically in a
reasonable time with the direct encoding.

Conclusion Experiments show that the preo/x-tree encoding greatly helps automatic the-
orem provers. Not only do they run faster, but they are also capable of proving more parts
of the program in a reasonable time. We believe that this is due to the fact that the prover
has to instanciate axioms for get and set much less often using the preo/x-tree encoding.

Before conducting these experiments, we thought that the need to reconstruct regions
when using them in the logic would have a negative impact on theorem provers. It does make
proof obligations a little less readable. However, in practice it seems that this disadvantage is
largely overcome by the advantage given by separation. It might be possible to build examples
where this is not the case, but on our two practical examples the preo/x-tree encoding is strictly
superior.

We did not run the same experiments to test the encoding of Section 5.4. The reason
is that there is no version of the implementation which features both simplio/ed singleton
regions and the preo/x-tree encoding. There is a version of Capucine which features simplio/ed
singleton regions, but it is old and is not comparable with the current version. We believe

158 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS
that, as the encoding of Section 5.4 further lowers the need to instanciate axioms, it can only
be beneo/cial. However, the impact would probably be much lower than the one provided by
the preo/x-tree encoding.

There are very few existing work comparing experimentally the relative power of memory
models. A notable recent exception is the work of Sascha Bo"hme and Michal/ Moskal in
the context of the VCC program verio/er and using Z3 [Bo"hme11]. They reach the same
conclusion that models which include separation perform better than others.

5.7 Using Typing Information in Proofs
The example of Figure 5.2 and Figure 5.3 generates a proof obligation stating that the
invariant of x .a still holds after it has been incremented. The proof obligation, using the preo/x
tree encoding of Section 5.5.4 and after removing unused variables and useless hypotheses, is
the following logic formula:

8Ravalue,1 : int.
Ravalue,1 = Ravalue + 1 )
Ravalue,1 > 0

This formula cannot be proven. We miss the hypothesis that the invariant of x .a held before
the assignment. The invariant is known by typing. Indeed, permission x .Ra* is available
before the unpack a operation.

There are several facts that are known by typing and that we want to use in proof
obligations. We review several of them in this section and we show how to introduce them
in proof obligations using assume clauses. Soundness is given by coherence. Indeed, the
Why heap is in relation with a separated heap, which is itself in relation with an intuitive
coherent heap. From this we show that each property we introduce in the hypotheses of proof
obligations using assume clauses actually hold.

5.7.1 Invariants
The o/rst fact we want to use from typing is that the invariant of closed pointers hold. We
introduce a new statement:

use invariant x
where x is a variable name. Typing requires that x is closed, i.e. that x : [ae] is in the current
environment and either:

* ae* or aeG is in \Sigma ;

* or ae is y.s, y: oe is in \Gamma , and oe is closed in \Sigma .
This operation is translated to the following Why statement:

assume why(Inv (x ))
where Inv (x ) is the invariant predicate of x applied to its owned regions and o/elds.

We can also allow use invariant x to be applied when x has type [ae] and permission
oe -ffi ae is available for some oe, but then the operation translates to:

assume ~inRegion(x , why(oe)) ) why(Inv (x ))

5.7. USING TYPING INFORMATION IN PROOFS 159
In other words, to use the invariant of x the user has to prove that x is not the pointer of ae
being focused.

Examples Section 3.4 contains several instances of the use invariant statement. In partic-
ular, functions arraySet, sget and sset of the sparse arrays example of Section 3.4.3 all use
the invariant of their parameter.

5.7.2 Region Disjointness
In this section, we do not introduce a new statement, but we remark that we can sometimes
deduce from available permissions that two regions ae and oe are disjoint. In the next sections,
we will use this to prove pointer disequalities, as well as to prove that some pointer is not in
some region. Our condition on permissions is not necessary, but it is suOEcient.

Theorem 12 (SuOEcient Condition for Disjointness) Let ae and oe be regions. Let \Gamma  be
an environment and \Sigma  be a set of permissions. If \Sigma  = \Sigma 0, \Sigma ae, \Sigma oe such that:

* \Sigma ae is either ae;, aeffi, ae* or aeG;

* \Sigma oe is either oe;, oeffi, oe* or oeG,
then for all separated heap Hs coherent with respect to \Gamma  and \Sigma , then Dom(Hs(ae)) and
Dom(Hs(oe)) are disjoint.

Proof. Assume there is p in Dom(Hs(ae)) and in Dom(Hs(oe)). Then by item 8 of coherence
and permissions \Sigma ae and \Sigma oe we have Hs(p?) = ae and Hs(p?) = oe, thus ae = oe. Item 1 of
coherence states that this is not possible, because we have the two permissions \Sigma ae and \Sigma oe
available. 2

5.7.3 Pointer Region
Positive Another fact we want to use from typing is that if a pointer has type [ae], then it
is actually in ae. We introduce a new statement:

use x 2 ae
Typing requires that x : [ae] is in the current environment. This operation is translated into
the following Why statement:

assume inRegion(x , why(ae))

Negative We can also use from typing that a pointer is not in a given region. We introduce
a new statement:

use x /2 ae
Typing rules are the following:

160 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS

x : [oe] 2 \Gamma  ae; 2 \Sigma 
\Gamma  ` {\Sigma } use x /2 ae {\Sigma }, \Gamma 

x : [oe] 2 \Gamma  \Sigma  = \Sigma 0, \Sigma oe, \Sigma ae \Sigma oe 2 {oeffi, oe*, oeG} \Sigma ae 2 {aeffi, ae*, aeG}

\Gamma  ` {\Sigma } use x /2 ae {\Sigma }, \Gamma 

The o/rst rule states that if ae is empty, then x is not in ae. The second rule uses the suOEcient
condition of Section 5.7.2 to conclude that the region of x is disjoint from ae, and thus that
x is not in ae.

This operation is translated to the following Why statement:

assume ~inRegion(x , why(ae))
For instance, we can prove that a pointer is fresh in a given region. Consider the following
program:

let x = new Long [oe];
use x /2 ae;
adopt x : oe as ae;

After the adoption, we know that x is in ae, but that it was not before. As it is the only
new pointer in ae, we can prove that x is dioeerent than all pointers that were in ae before the
adoption.

Example The Course example of Section 3.4.5 illustrates statement use x 2 ae, in function
changeMark .

5.7.4 Pointer Equalities
We can prove that two pointers are equal if they are in the same singleton region. We
introduce a new statement:

use x = y
Typing requires x and y to be in the same region ae. It requires a permission of the form
aeffi{f1 , * * *, fn } (n may be zero) or ae*.

This operation is translated to the following Why statement:

assume x = y

5.7.5 Pointer Disequalities
The use x /2 ae statement allows the user to prove pointer disequalities. For instance:
let region oe: Long;
let region ae: Long;
let x = new Long [oe];
let y = new Long [ae];
use x /2 ae;

5.7. USING TYPING INFORMATION IN PROOFS 161
use y 2 ae;
assert x 6= y;

The last assertion can be proven. But it generates a proof obligation.

To avoid the proof obligation, we introduce a new statement:

use x 6= y
The typing rule is the following:

x : [oe] 2 \Gamma 
y : [ae] 2 \Gamma  \Sigma  = \Sigma 0, \Sigma oe, \Sigma ae \Sigma oe 2 {oeffi, oe*, oeG} \Sigma ae 2 {aeffi, ae*, aeG}

\Gamma  ` {\Sigma } use x 6= y {\Sigma }, \Gamma 

One again, we use the suOEcient condition of Section 5.7.2 to prove that the regions of x and
y are disjoint. We use the fact that x has type [oe] to prove that x is in oe, and the fact that
y has type [ae] to prove that y is in ae. Because oe and ae are disjoint, we thus have x 6= y.

This operation is translated to the following Why statement:

assume x 6= y
Note that if a pointer comparison x = y or x 6= y appears inside a predicate or an ex-
pression, and if we can prove from typing that the locations are always equal or are always
dioeerent, then we can emit a warning to the user. For instance, in the following program:

let region r : Long;
let x = new Long [r];
let region s: Long;
let y = new Long [s];
if x = y then * * *

we can conclude from typing that x 6= y, and thus that the then branch of the if statement
will never be executed.

Example The Course example of Section 3.4.5 illustrates statement use x 6= y, in function
addStudent. The latter actually needs a small extension of the statement:

use8

i: int. i >= 0 ^ i < c.count )
select(c.students, i) 6= s

Indeed, x is no longer a variable but a term (here select(c.students, i)), which is itself deep
inside a predicate. The idea is that we replace select(c.students, i) 6= s by T, and then
simplify the predicate using (among others) the following laws: P ) T is equivalent to T,
and 8x : o/ . T is also equivalent to T. Moreover, the typing rules for predicates must be changed
slightly to be able to state that select(c.students, i) has the more precise type [c.Rstudents]
instead of [.]. All these extensions are straightforward, and we shall not detail them in this
thesis. They are available in the implementation of Capucine.

162 CHAPTER 5. GENERATION OF VERIFICATION CONDITIONS
5.8 Conclusion
In this chapter, we showed how the separated model of Capucine can be encoded in the
Why intermediate language. The Why tool then computes proof obligations. We showed
that if those verio/cation conditions are valid, then the Capucine program executes in the
separated model of Capucine (Theorem 11). It thus also executes in the intuitive model and
all assertions, all function contracts and all data invariants for closed objects are valid in this
model.

We showed several methods to use region information from typing to produce simpler
verio/cation conditions. The fact that a region is singleton can be used to further simplify
logic formulas. The separated model already beneo/ts from separation between regions, and
this reAEects in logic formulas that we have to prove. We can use AEattening techniques based
on the region ownership tree to statically separate regions. Finally, we showed how the
typing information that some invariant holds, or that a pointer belongs to a region, or that
two regions are disjoint can be added as an hypothesis in verio/cation conditions. Being able
to use information from typing in proof obligations is an important feature of Capucine.

Chapter 6
Inference of Region Annotations
The Capucine language features many region annotations and operations. These may become
tedious to write, especially for larger programs. In this chapter we explore how this burden
can by lightened using inference. In Section 6.1 we motivate the need for inference using
examples. In Section 6.2 we remark that there is no best way to infer region annotations,
and we discuss which of them should actually be inferred. In Section 6.3 we present the
core of the inference algorithm, and in Section 6.5 we propose extensions to further simplify
the work of the programmer. Finally, in Section 6.6 we illustrate how inference helps the
programmer using examples.

6.1 Need for Inference
Simple Example Simple C programs such as:
typedef struct {

int value;
} long;

void incr(long* i)
{

i->value = i->value + 1;
}

need region annotations in Capucine:
class long{

value: int;}

fun incr [r: long] (i: [r ]): unit

consumes r *
produces r *{

unpack i;

163

164 CHAPTER 6. INFERENCE OF REGION ANNOTATIONS

i.value  i.value + 1;
pack i;}

If the region r is group, focus and unfocus operations have to be inserted as well:

let region s: long;
focus i: r as s;
unpack i;
i.value  i.value + 1;
pack i;
unfocus i: s as r;

All these annotations are needed just for one single assignment. It quickly becomes tedious
to write them.

Most of these annotations are obvious. For instance, if i.value is assigned, then i must
be in an open region r. If r is closed, the unpack is obvious. If r is in a group region, the
fact that a focus operation is needed is obvious.

Moreover, common patterns emerge, such as let region * focus * unpack * pack * unfocus
illustrated above. Another one is allocation into a group region r :

let region s: long;
let i = new [s];
pack i;
adopt i in [r ];

The let region * pack * adopt sequence is a common pattern.

These observations motivate the need for inference of region annotations in Capucine.
The question is: what can we infer?

Candidates for Inference In an ideal world, we could infer every region annotation and
be as close as possible to languages such as C. These annotations are:

* region binders, be they function arguments or bound using let region;

* regions of pointers, be they function arguments or allocated using new;

* consumes and produces clauses of functions;

* adoption, focus, unfocus, packing and unpacking operations.
In the next sections, we try and see which of these are good candidates for inference, and
which should be better left for the user to write.

6.2 There Is No Principality
Principal Types An important property of type systems when considering them for in-
ference is the existence of principal types. ML expressions, for instance, have a most general
type for each expression. We call it the principal type of the expression. All other types can
be derived from the principal type. For instance, the following OCaml expression:

fun x ! x

6.2. THERE IS NO PRINCIPALITY 165
Has types int ! int and bool ! bool (among others), but both of these types can be
derived from instancing the more general type ff ! ff, which happens to be the principal
type of the expression. Good inference algorithms infer principal types, thus ensuring that
no expressivity is lost in the process.

Are Regions Separated In Capucine however, in general there is no principality. Con-
sider the following pseudo-Capucine program:

fun incrPair (x : long; y: long){

x .value  x .value + 1;
y.value  y.value + 1;}

We need to give regions to x and y. Shall we give the same region for both, or should they
be in dioeerent, separated regions? Regions are polymorphic, and we could think that if we
put x and y in two dioeerent regions, we could instantiate incrPair with the same region for
x and y. The code would become:

fun incrPair [r: long, s: long] (x : [r ], y: [s])

consumes r * s*
produces r * s** * *

But if a call to incrPair gives the same region ae twice:
incrPair [ae, ae] (x , y)
then permission ae* is consumed twice, which is prevented by the type system. So this version
of incrPair is not more general than the one where x and y share the same region.

Moreover, consider the same function incrPair , annotated with the following post-
condition:

x .value = x .value@pre + 1
This post-condition only holds if x 6= y. One could thus argue that with this post-condition,
pointers x and y must be separated in dioeerent regions. But, the problem of knowing whether
pre- and post-conditions require pointers to be separated is undecidable. And it is not
necessary for x and y to be in dioeerent regions to be dioeerent: they can be in the same group
region.

Is The Invariant Needed The next issue is the consumes and produces clauses. Consider
the following pseudo-Capucine program:

class posint{

value: int;
invariant value > 0;}

fun incr [r: posint] (x : [r ])

post x .value > 0

166 CHAPTER 6. INFERENCE OF REGION ANNOTATIONS
{

x .value  x .value + 1;}

Shall this function consume permission rffi, r * or r G? Permission rffi could be perceived as
more general as the permission is needed anyway for the assignment. The responsibility of
unpacking and packing would then fall to the caller. However, the invariant of x is needed
to prove the post-condition, so permission r * is actually required by incr . And of course,
knowing whether the invariant is needed is undecidable.

Conclusion We have shown that there is no best way to choose the regions of pointer
arguments, and the permissions on these regions. Notice that ibest wayj is another way
of saying iprincipalj. In Capucine, we thus choose not to try to infer regions of pointer
arguments and consumes and produces clauses. From a language design point of view, this
makes sense: these annotations are part of the contract of the function. They give information
on the intent of the programmer.

6.3 Inferring Most Region Annotations
We have chosen not to infer what is visible from outside of function deo/nitions: regions of
pointer arguments, and consumes and produces clauses. From these annotations, we are
capable of inferring some annotations which should be added inside the body of functions.

Forward Inference We state the problem as follows. Given available permissions \Sigma , an
environment \Gamma  and a statement s, can we compute a sequence of statements S; s0, a list of
produced permissions \Sigma 0 and a new environment \Gamma 0 such that:

\Gamma  ` {\Sigma } S; s0 {\Sigma 0}, \Gamma 0
Moreover, S should not change the operational semantics of the program. More precisely,
the program should return a heap in which well-typed expressions evaluate to unchanged
results. Sequence S may only be composed of local binders (let or let region), adoptions,
focus, unfocus, unpack, pack and weakening operations. Finally, if S contains let-bindings
such as let x = e, then replacing all such variables x by their corresponding expression e in
s0 should result in s. Remember that there is no side-eoeect in expressions. We say that S; s0
and s are equivalent.

We call this forward inference because we compute S given available permissions \Sigma ,
instead of produced permissions \Sigma 0. Other forms of inference might also be interesting, such
as:

* given \Sigma 0, compute S and \Sigma  such that s; S is well-typed;

* given S, compute both \Sigma  and \Sigma 0 while inserting new statements in S such that S is

well-typed.

The former kind of inference would be backward inference. We think it is less predictable
for the user and thus harder to work with in practice. The latter kind of inference would be
the strongest. However, not only would it be even less predictable, it also implies being able
to infer permissions which are consumed and produced by functions. We already explained
why this was not what we wanted for Capucine.

6.3. INFERRING MOST REGION ANNOTATIONS 167
Unio/cation Our inference mechanism uses the usual ML inference algorithm based on
unio/cation. In particular, this solves the issue of o/nding substitutions oe when applying
polymorphic functions. The unio/cation mechanism is applied not only on type variables
but also on region variables. If unsolvable constraints result from unio/cation, the inference
mechanism fails, with the exception on region variables described in the next paragraph.

Main Loop Our inference algorithm takes as input:

* a list of available permissions \Sigma 0 ;

* an initial environment \Gamma 0 ;

* a sequence of statements S0 .
It may either fail or return a sequence S0 equivalent to S0 such that there is \Sigma 0 and \Gamma 0 such
that:

\Gamma 0 ` {\Sigma 0 } S0 {\Sigma 0}, \Gamma 0
It uses the following variables:

* a sequence (represented as a list) of statements S;

* the list of currently available permissions \Sigma ;

* the current environment \Gamma ;

* the result being built S0.
Here is the algorithm. The deo/nition of region constraints and how to apply them is given in
a later paragraph. The way Sprod is computed, and how branches are joined, are also given
in later paragraphs.

1. Initialize S to S0 , \Sigma  to \Sigma 0 , \Gamma  to \Gamma 0 and S0 to the empty list.
2. While S is not empty, do the following.

(a) Let s be the o/rst statement of S.
(b) If s is if e then S1 else S2 :

i. call the algorithm recursively on S1 and S2 , thus obtaining well-typed state-

ments S1 0 and S2 0 respectively equivalent to S1 and S2 ;

ii. using typing rule SBlock, compute permissions \Sigma 1 and \Sigma 2 produced by S1

and S2 ;

iii. join \Sigma 1 and \Sigma 2 in S1 0 and S2 0, obtaining S1 00 and S2 00;

iv. add if e then S1 00 else S2 00 at the end of S0;

v. remove s from S;
vi. do not execute the rest of the current loop iteration.

(c) Let rc be the region constraints of s with respect to \Gamma  and \Sigma .
(d) If rc is not empty, apply region constraints rc.

Else:

i. compute the set of permissions \Sigma s consumed by s;

168 CHAPTER 6. INFERENCE OF REGION ANNOTATIONS

ii. compute a sequence Sprod such that:

\Gamma  ` {\Sigma } Sprod {\Sigma s, \Sigma rem}, \Gamma 0
iii. change the value of \Gamma  to \Gamma 0, and the value of \Sigma  to (\Sigma s, \Sigma rem );

iv. add Sprod ; s at the end of S0;

v. remove s from S.

3. Return S0.

Compute Region Constraints The o/rst step of our inference mechanism is to collect
region constraints from statement s. A region constraint is a triple (e, oe, ae), whose informal
meaning is that expression e, of type [oe], should actually be of type [ae].

Region constraints come from unio/cation failures between regions. In Capucine, region
constraint (e, oe, ae) may be generated in any of the following circumstances:

* s is x .f  e and x .f has type [ae];

* s is a function call and e is one of the parameters, whose expected type is [ae];

* s contains a sub-expression e0 which is a logic function application, of which e is a

parameter whose expected type is [ae].

Unio/cation failure on regions may also happen in other circumstances. For instance, unio/-
cation of Array ([ae]) and Array ([oe]) leads to unio/cation of ae and oe. However, in general we
do not have any expression e whose type [oe] should be [ae]. So instead of generating a region
constraint, the inference mechanism just fails. Only in the three cases above do we have such
an expression e.

For instance, consider the following Capucine program.

class Long{

value: int;}

class Pair{

group Rleft: Long;
group Rright: Long;
left: [Rleft];
right: [Rright];}

fun f [r : Pair ] (p: [r ], i: [p.Rright]): unit* * *
fun initPair [r: Pair ] (p: [r ]): unit

consumes r ffi{left, right}, p.Rleft;, p.Rright;* * *

{

let region s: Long;
let x = new Long [s];

6.3. INFERRING MOST REGION ANNOTATIONS 169

p.left  x ; (1)
f [r ] (p, p.left); (2)}

Line (1) generates region constraint (x , s, p.Rleft), i.e. pointer x is in s but it really
should now be in p.Rleft. Assuming it now is, line (2) generates region constraint
(p.left, p.Rleft, p.Rright).

Additionally we want to be able to infer a focus operation for x when s = x .f  e and
the region of x is group. If x : [ae] is in \Gamma , and if aeG or oe -ffi ae is available or if ae = y.s is
transitively owned by a closed region and s is deo/ned as group, then ae is group and a focus
is needed. In this case, we bind a fresh region r using let region and we generate region
constraint (x , ae, r ).

Apply Region Constraints The next step of our inference mechanism is to apply region
constraints. First, we apply a transformation which ensures that for all region constraint
(e, oe, ae), expression e is already a variable. The transformation is the following. If e is
already a variable, do nothing. Else:

* choose a fresh variable name x and add statement let x = e to the S0, the result

sequence being built by the main loop;

* syntactically replace e by x in the current statement s, both in variable s of the main

loop and in the o/rst statement of variable S of the main loop (which is equal to s).

Ensuring that all expressions e are actually variables is necessary, as adoption, focus and
unfocus operations only change the type of variables in the environment. For instance,
consider the constraint generated by line (2) in the initPair example. The type of expression
p.left does not change from [p.Rleft] to [p.Rright] even if we adopt the pointer. However,
if we insert let x = p.left before and adopt x , then the type of x changes. Note that this
transformation does not change the meaning of the program because expressions do not have
side-eoeects.

We are left with region constraints of the form (x , oe, ae), with oe 6= ae. Our goal is to insert
an adoption, focus or unfocus operation ensuring that x is moved from oe to ae. We choose
the operation depending on available permissions on oe and ae. Or, rather, on permissions we
could obtain on oe and ae.

To unfocus x from oe to ae, we need permission oe -ffi ae. The only operation (beside function
calls) which produces oe -ffi ae is the focus operation. It is a property of our inference algorithm
that the only way focus operations are inferred is by applying region constraints. So if oe -ffi ae
is not available, we know that applying region constraint (x , oe, ae) should not be done using
an unfocus operation. However, is oe -ffi ae is available, then we know that unfocusing is the
way to go. To sum up, the operation we try to infer is unfocus x : oe as ae if, and only if
oe -ffi ae is in \Sigma .

To focus x from oe to ae, we need permission ae;. The only operations which produce ae; are
region binding and allocation, which we do not infer during the region constraint application
phase. So if ae; is not available, we shall not infer a focus operation to apply the region
constraint. Instead we shall try to infer an adoption.

If ae; is available, we have two choices: either focus into ae, or weaken ae to obtain aeG and
then adopt into ae. This choice depends on whether oe is group or not. Region oe is group
if oeG or oe0 -ffi oe is available for some region oe0 dioeerent than oe, or if oe is a group region

170 CHAPTER 6. INFERENCE OF REGION ANNOTATIONS
transitively owned by a closed region. In all other cases, oe is singleton, and we do not wish
to weaken it as a group region just to focus from it. So we choose to try to infer an adoption.

Once we have chosen which operation s0 we want to try to infer (either adoption
adopt x : oe as ae, focus focus x : oe as ae or unfocus unfocus x : oe as ae), we add s0 at the be-
ginning of variable S of the main loop. In other words, we leave the work of producing the
correct permissions needed by s0 to the other parts of the inference mechanism.

If statement s generates several constraint, we insert their respective operation in an
unspecio/ed order. The reasoning behind this is that if applying the constraints in some order
fails, then applying them in any order will fail, because it basically means that a pointer
should be in two regions at the same time.

Let's illustrate region constraint application on function initPair . The o/rst constraint
(x , s, p.Rleft) is solved by inserting an adoption, as s is singleton and p.Rleft is not being
focused. Here is the intermediate body of function initPair up to line (1) after inference:

let region s: Long;
let x = new Long [s];
weaken empty p.Rleft;
pack x ;
adopt x : s as p.Rleft;
p.left  x ;

The weakening and packing are added by another part of the inference mechanism. Now we
have permissions p.RleftG and p.Rright;. So the second constraint (p.left, p.Rleft, p.Rright)
is solved by a focus operation, after replacing p.left by a variable:

let y = p.left;
focus y: p.Rleft as p.Rright;
f [r ] (p, y);

The function is now well-typed, assuming the consumes clause of f and the produces clause
of initPair is:

pffi{right}, p.Rright -ffi p.Rleft, p.Rright*
Note that if the consumes clause of initPair is the more normal p*, the inference mechanism
will fail as there is no way to put the pointer of p.Rright back into p.Rleft without losing the
permission on p.Rright, which is required to pack p.

Compute Permission Constraints The next step of our inference algorithm requires
being able to compute the set of permissions \Sigma s consumed by any statement s, given current
permissions \Sigma  and environment \Gamma , and given that s is not an if statement. The set \Sigma s is
given by typing rules of Figures 4.10 and 4.11 for statements. Here is a summary.

* Statements let x = e, let region r : C, assert P and label L consume no permissions.

* Test if e then S1 else S2 is a special case which is handled separately.

* Function call let x = f arg consumes the permissions consumed by f , after having

applied the substitution oe obtained by unio/cation.

* Allocation let x = new C [ae] consumes {ae;}.

* Focus focus x : ae as oe consumes {aeG, oe;}.

6.3. INFERRING MOST REGION ANNOTATIONS 171

* Assignment x .f  e consumes an open permission on a region ae such that x : [ae] is

in \Gamma . If aeffi{f1 , * * *, fn } is available in \Sigma , we deo/ne \Sigma s = {aeffi{f1 , * * *, fn } }. Else, we
can only obtain aeffi by unpacking ae, so all o/elds are initialized, and we can thus deo/ne
\Sigma s = {aeffi}.

* Adoption adopt x : oe as ae consumes {oe*, aeG}.

* Unfocus unfocus x : oe as ae consumes {oe*, oe -ffi ae}.

* Packing pack x , if x : [ae], ae: C is in \Gamma , consumes {single(x , C)*, group(x , C)G, aeffi}.

* Unpacking unpack x , if x : [ae] is in \Gamma , consumes {ae*}.

* Weakening weaken empty ae consumes {ae;}.

* Weakening weaken single ae consumes {ae*}.

Solve Permission Constraints Now that we know which permissions \Sigma s we have to
produce, we look for S such that there is \Sigma 0 and \Gamma 0 such that:

\Gamma  ` {\Sigma } S {\Sigma s , \Sigma 0}, \Gamma 0
Our methodology is the following.

* First we deo/ne function operations(\Gamma , \Sigma ) which returns the list of statements which

produce \Sigma  under the environment \Gamma . The list only contains statements which we are
willing to insert as inferred operations.

* Then we deo/ne function produce(\Gamma , \Sigma , \Sigma ) which returns a sequence which produces,

among others, permission \Sigma  from \Sigma .

* Then we deo/ne function producelist(\Gamma , \Sigma , \Sigma 0) which returns a sequence which produces,

among others, the set of permissions \Sigma 0 from \Sigma . Functions produce and producelist are
mutually recursive.

* We are then capable of producing \Sigma s using produce(\Gamma , \Sigma , \Sigma s).

Function operations We deo/ne function operations(\Gamma , \Sigma ) by pattern-matching on \Sigma .

* operations(\Gamma , ae;) = ;

The only operation which can produce ae; are let region, only if ae is a region variable,
and new. Region binders are only needed by focus and new operations. Section 6.5 dis-
cusses how region binders are inferred in these two cases. This is why operation(\Gamma , ae;)
returns the empty set of operations.

* operations(\Gamma , aeffi{f1 , * * *, fk }) = ;

This assumes k >= 1. Only new can produce such kind of permission, and we do not
wish to infer new operations.

* operations(\Gamma , aeffi) = {unpack x }

This assumes x : [ae] is in \Gamma . If several variables of type [ae] are in \Gamma , we pick one at
random, as their value is the same (the unique location of ae).

172 CHAPTER 6. INFERENCE OF REGION ANNOTATIONS

* operations(\Gamma , ae*) = {pack x } [ A

This assumes x : [ae] is in \Gamma . Operation set A is deo/ned as:

* A = ; if ae is a region variable;
* A = {unpack y} if ae is an owned region y.s.

* operations(\Gamma , aeG) = {weaken empty ae, weaken single ae} [ A [ B

Operation set A is deo/ned as:

* A = ; if ae is a region variable;
* A = {unpack y} if ae is an owned region y.s.

Operation set B is deo/ned as the set of all unfocus x : oe as ae where x : [oe] is well-typed
with respect to \Gamma . In practice, we may restrict this set to regions oe such that oe -ffi ae is
available.

Function produce We deo/ne function produce(\Gamma , \Sigma , \Sigma , \Sigma no) using the following algorithm.
Argument \Sigma no stores the set of permissions which we are already trying to produce, to ensure
the algorithm terminates. This argument is also added to producelist.

1. If \Sigma  is in \Sigma , return the empty sequence.
2. If \Sigma  is in \Sigma no, fail.
3. Let ops be operations(\Gamma , \Sigma ).
4. For each s in ops, let \Sigma 0 be the permissions consumed by s and try to compute:

S = producelist(\Gamma , \Sigma , \Sigma 0 , (\Sigma no, \Sigma )).

(a) If it fails, continue with the next operation; if there is no more operation, fail.
(b) Else return S; s.

We then deo/ne:

produce(\Gamma , \Sigma , \Sigma ) = produce(\Gamma , \Sigma , \Sigma , ;)

Function producelist We deo/ne function producelist(\Gamma , \Sigma , \Sigma 0, \Sigma no) using the following al-
gorithm.

1. If \Sigma 0 is empty, return the empty sequence.
2. Select any \Sigma  from \Sigma 0 = \Sigma , \Sigma rem .
3. Try to compute S = produce(\Gamma , \Sigma , \Sigma , \Sigma no).
4. If it fails, fail.
5. Let \Sigma 1 and \Gamma 1 such that:

\Gamma  ` {\Sigma } S {\Sigma 1 }, \Gamma 1
6. Try to compute S0 = producelist(\Gamma 1 , \Sigma 1 , \Sigma rem, \Sigma no).

6.3. INFERRING MOST REGION ANNOTATIONS 173

7. If it fails, fail.
8. Let \Sigma 2 and \Gamma 2 such that:

\Gamma  ` {\Sigma } S; S0 {\Sigma 2 }, \Gamma 2
9. If \Sigma  is in \Sigma 2 , return S; S0.
10. Else, fail.
We then deo/ne:

producelist(\Gamma , \Sigma , \Sigma 0) = producelist(\Gamma , \Sigma , \Sigma 0, ;)
This function can also be used to produce the permissions of consumes clauses of functions.

Joining Branches We detail the case when s is an if e then S1 else S2 statement. We
apply the inference algorithm recursively on S1 and S2 , obtaining S1 0 which produces
permissions \Sigma 1 and S2 0 which produces permissions \Sigma 2 , and such that s is equivalent to
s0 = if e then S1 0 else S2 0. However, s0 is not well-typed if \Sigma 1 6= \Sigma 2 . We now show how we
try to compute operations Sa and Sb such that there is \Sigma 0 such that:

\Gamma  ` {\Sigma 1 } Sa {\Sigma 0}

\Gamma  ` {\Sigma 2 } Sb {\Sigma 0}
This ensures that:

s00 = if e then S1 0; Sa else S2 0; Sb
is equivalent to s and is well-typed.

We consider each region ae appearing in \Sigma 1 or \Sigma 2 and in \Gamma . Assume it appears in \Sigma 1 ; the
other case is symmetric. We consider each possible case (\Sigma 1 , \Sigma 2 ) where \Sigma 1 is the permission
on ae in \Sigma 1 and \Sigma 2 is the permission on ae in \Sigma 2 if there is any, or ? if there is no such
permission.

* If \Sigma 1 = \Sigma 2 , do nothing.

* \Sigma 1 = ae;

* \Sigma 2 = aeffi{f1 , * * *, fk } (k >= 0) or \Sigma 2 = ae*

Fail. We do not infer allocations.

* \Sigma 2 = aeG

Add weaken empty ae at the end of Sa .

* \Sigma 2 = oe -ffi ae

Add weaken empty ae at the end of Sa , and add unfocus x : oe as ae at the end of
Sb, where x : [oe] is in \Gamma . If there is no such x , fail.

* \Sigma 2 = ?

Fail.

174 CHAPTER 6. INFERENCE OF REGION ANNOTATIONS

* \Sigma 1 = aeffi{f1 , * * *, fk } (k >= 1)

Fail.

* \Sigma 1 = aeffi

* \Sigma 2 = ae*

Add unpack x at the end of Sb, where x : [ae] is in \Gamma . If there is no such x , fail.

* \Sigma 2 = aeG

Add pack x ; weaken single ae at the end of Sa , where x : [ae] is in \Gamma . If there is
no such x , fail. Ensure all owned permissions needed by the pack statement are
available, by recursively applying the inference algorithm.

* \Sigma 2 = oe -ffi ae

Do the same than for the \Sigma 2 = aeG case, except also add unfocus x : oe as ae at
the end of Sb where x : [oe] is in \Gamma . If there is no such x , fail. Ensure permission
oe* needed by the unfocus statement are available, by recursively applying the
inference algorithm.

* \Sigma 2 = ?

If ae = x .s and s is declared as single, try unpacking the owners of ae, ending with
x , from the o/rst available permission on a transitive owner of ae in \Sigma 2 . If there
is no such permission, fail. Else, add all these unpacking statements in Sb. Then
unpack y of type [ae]. If there is no such y, fail.

* \Sigma 1 = ae*

* \Sigma 2 = aeG

Add weaken single ae at the end of Sa .

* \Sigma 2 = oe -ffi ae

Add weaken single ae at the end of Sa . Add unfocus x : oe as ae at the end of Sb
where x : [oe] is in \Gamma . If there is no such x , fail. Ensure permission oe* needed by the
unfocus statement are available, by recursively applying the inference algorithm.

* \Sigma 2 = ?

If ae = x .s and s is declared as single, try unpacking the owners of ae, ending with
x , from the o/rst available permission on a transitive owner of ae in \Sigma 2 . If there is
no such permission, fail. Else, add all these unpacking statements in Sb.

* \Sigma 1 = aeG

* \Sigma 2 = oe -ffi ae

Add unfocus x : oe as ae at the end of Sb where x : [oe] is in \Gamma . If there is no such
x , fail. Ensure permission oe* needed by the unfocus statement are available, by
recursively applying the inference algorithm.

* \Sigma 2 = ?

If ae = x .s and s is declared as group, try unpacking the owners of ae, ending with
x , from the o/rst available permission on a transitive owner of ae in \Sigma 2 . If there is
no such permission, fail. Else, add all these unpacking statements in Sb.

6.4. TERMINATION, SOUNDNESS AND COMPLETENESS 175

* \Sigma 1 = oe -ffi ae

* \Sigma 2 = oe0 -ffi ae (with oe 6= oe0)

Add unfocus x : oe as ae at the end of Sa where x : [oe] is in \Gamma . If there is no such
x , fail. Add unfocus y: oe0 as ae at the end of Sb where y: [oe0] is in \Gamma . If there is
no such y, fail. Ensure permission oe* and oe0* needed by the respective unfocus
statement are available, by recursively applying the inference algorithm.

* \Sigma 2 = ?

Fail.

The remaining cases are symmetric. We start with Sa and Sb being empty. Each rule ensures
that \Sigma 1 and \Sigma 2 are consumed and replaced by identical permissions. Each time a rule is
applied, we remove these identical permissions from \Sigma 1 and \Sigma 2 . All these rules are applied
in any order until either one of them fails, or \Sigma 1 = \Sigma 2 = ;.

Notice that when a region is opened in a branch and closed in the other, we made the
choice of unpacking the region in the latter instead of packing it in the former. The reason
is that packing generates a proof obligation. If the region is required to be closed after
the if statement, the inference mechanism will unpack it after the if statement. The proof
obligation will then be slightly more complicated, with the two branches to take into account,
one of them being trivial as the region was closed so the invariant held.

6.4 Termination, Soundness and Completeness
Termination We now prove some properties of our inference algorithm. First, we prove
that it terminates.

Theorem 13 (Termination) The inference algorithm terminates on all inputs.

Proof. Proving that the computation of region constraints and their application terminate
is straightforward. Proving that functions produce and producelist terminate is also easy: the
main argument is that argument \Sigma no strictly grows each time produce is called recursively,
and cannot grow more than the set of all permissions on well-typed regions, which is o/nite.

We now prove that joining branches terminates. Recursive calls to the inference algorithm
are only done to produce permissions of the form ae*, so the recursive call will not try to
join other branches. We remove permissions from \Sigma 1 and \Sigma 2 each time a rule is applied
successfully, but we also sometimes obtain new permissions when unpacking. However, these
new permissions are only on owned regions, on which there already was a permission in the
other branch. The intuition behind the termination argument is thus that we cannot grow a
permission set more than some boundary given by the permission set of the other branch at
the beginning of the algorithm. 2

Soundness We then prove that the algorithm is sound.
Theorem 14 (Soundness) Given inputs \Gamma , \Sigma  and S, if the inference algorithm does not
fail, it returns statement S0 which is equivalent to S. Moreover, there are \Sigma 0 and \Gamma 0 such
that:

\Gamma  ` {\Sigma } S0 {\Sigma 0}, \Gamma 0

176 CHAPTER 6. INFERENCE OF REGION ANNOTATIONS
Proof. First we prove that S0 is equivalent to S. The main loop always adds s to S0 before
removing s from S. This s may have been modio/ed from the input, but only by replacing
some sub-expressions e with variables x whose value is bound to e just before s.

Then we prove that S0 is well-typed. The unio/cation mechanism (along with region
constraints) ensures that the types are correct. We now prove that permissions are correct.
In the main loop, the set of permissions consumed by s, denoted \Sigma s , is computed from typing
rules. Assuming Sprod is computed such that:

\Gamma  ` {\Sigma } Sprod {\Sigma s , \Sigma rem }, \Gamma 0
then \Sigma s are available and thus Sprod ; s is well-typed. We now prove that Sprod is computed
in such a fashion. First we prove from typing rules that operations(\Gamma , \Sigma ) returns a set of
well-typed statements which all happen to produce \Sigma . Then we prove by induction that
produce and producelist return well-typed sequences returning the required permission or set
of permissions. For produce it is straightforward. For producelist, we note that variable \Sigma 2
contains \Sigma rem by induction, and \Sigma  thanks to the test. Finally, we prove that branches are
joined correctly by noting that all inferred statements are well-typed. 2

Completeness? Ideally, we would like to prove a theorem stating that if a Capucine pro-
gram can be annotated without changing its result such that the program becomes well-typed,
then the inference algorithm o/nds such annotations. We could not o/nd any counter-example,
and we believe that such a theorem could be proven. However, we are more interested in
using the algorithm to help us write more concise examples than we are in proving that it is
actually complete. So far, we are pleased with the results.

We nevertheless give some intuitions about completeness. The inference algorithm is de-
o/ned in such a way that more backtracking could be done to o/nd valid annotations. However,
our intuition is that this is not necessary thanks to properties about region trees.

We already stated that when applying multiple region constraints, we can apply them in
any order because if any order fails, then it means that a pointer should be in two regions at
the same time and thus all other orders will fail as well.

The order in which we apply the rules to join branches does not matter either. The
intuition is that we can o/rst unpack everything that needs to be unpacked. Indeed, assume
we apply a rule A which does not imply unpacking before a rule B which implies unpacking.
If we cannot apply A after B, then A implies some weakening or unfocusing which would
consume some permission which would prevent B from being applied after A. So we can
assume that all unpacking have been done and that each permission has a corresponding
permission in the other branch. We then show for each pair of rules that do not imply any
unpacking that we can switch the order of the two rules, as they deal with dioeerent regions.
There is one exception, which is if an unfocus operation is generated. But once again, it
would imply that the permission on the source region is needed afterwards.

It remains to be understood whether produce and producelist could use more backtracking
or not. We believe that they do not, but it remains to be proved.

6.5 Simplify Allocation and Focus
We now introduce alternative versions of allocation and focus in order to ease the work of
the programmer. This implies adding a new step of inference before the steps we already
presented. Indeed, this new step is done at the binding stage of typing.

6.5. SIMPLIFY ALLOCATION AND FOCUS 177
Allocation The new version of the allocation statement is the following:

let x = new C
Compared to the old one, the region annotation has been removed. The idea is that this
operation is automatically replaced by:

let x = new C [r ]
where r is a fresh region name. A region binder:

let region r : C
is added at the beginning of the current innermost block. A block is either a branch of an
if statement, or the body of the function. It is not necessary for the scope of r to be longer
than the scope of x , and the scope of x is the current innermost block.

Focus The new version of the focus statement is the following:

focus x : ae
Compared to the old one, the target region annotation has been removed. This operation is
automatically replaced by:

focus x : ae as r
where r is a fresh region name, bound in the same fashion than the fresh region is bound for
allocation. It is not necessary for the scope of r to be longer than the scope during which
the type of x changes from ae to r , i.e. the current innermost block.

Synergy With Adoption Inference The question which comes to mind immediately is:
but what if the user did not want to put the pointer in a fresh region, but in an existing
region instead? First, the old operation is still available if needed. Second, the adoption
inference mechanism we introduce in Section 6.3 can sometimes automatically insert an adopt
operation to move the pointer from the fresh region to its intended region.

However, adoption can only be done from a singleton region to a group region. If the
target region ae is empty (permission ae;), adopting a pointer into it results in permission aeG
while ae* would actually be possible. Permission ae* is stronger and is thus preferable. It
is particularly important in the example of the next paragraph. This is one motivation for
adding more adoption operations to Capucine. See Section 7.2.4 for more discussion.

Example Consider the following constructor:
fun newLong [r: Long] (): [r ]

consumes r ;
produces r *{

let x = new Long;
return x}

The body is automatically expanded into:

178 CHAPTER 6. INFERENCE OF REGION ANNOTATIONS
{

let region s: Long;
let x = new Long [s];
return x}

The unio/cation of the type [s] of the returned expression x , with expected return type [r ],
triggers the insertion of an adoption:

{

let region s: Long;
let x = new Long [s];
adopt x as r ;
return x}

Assuming adoption produces r* instead of r G (see Section 7.2.4), this body is now well-typed.

6.6 Experiments
Examples of Chapter 3 illustrate the inference mechanism. Indeed, there are almost no region
operations: they are all inferred. The only operations that are left and that we would want
to infer are:

* the adopt statement, the let region and the region of the new in function addStudent;

* the focus operation, its associated let region and the unfocus operation in function

changeMark ;

* the regions in which new statements allocate their pointers, in other functions.
All those statements are actually not necessary as they can be inferred as well. We only left
them to illustrate their use. To sum up, the only annotations related to regions which are
needed in the examples of Chapter 3 are function contracts (regions of pointer arguments,
consumed and produced permissions) and use statements. This shows that the inference
algorithm is quite handy in practice.

For instance, consider the fully-annotated version of addStudent:

fun addStudent [Rc: Course] (c: [Rc], m: int): [c.Rstudents]

consumes Rc*
produces Rc*
post * * *{

use invariant c;
let region Rstud: Student;
let s = new [Rstud];
s.mark  m;
use * * *;
pack s;
adopt s: Rstud as c.Rstudents;
unpack c;

6.7. CONCLUSION 179

c.students  store (c.students, c.count, s);
c.sum  c.sum + m;
c.count  c.count + 1;
pack c;
return s}

Compare this with the lightweight version which uses the inference mechanism:
fun addStudent [Rc: Course] (c: [Rc], m: int): [c.Rstudents]

consumes Rc*
produces Rc*
post * * *{

use invariant c;
let s = new Student;
s.mark  m;
use * * *;
c.students  store (c.students, c.count, s);
c.sum  c.sum + m;
c.count  c.count + 1;
return s}

We removed 5 lines of code out of less than 20.

The time taken to infer and type a Capucine program is negligible in practice. It takes
less than 16ms on an Intel Core 2 Duo CPU E6850 at 3.00GHz for the Sparse Array example,
and less than 14ms for the Course example. Note that most of this time is actually spent
logging various debugging information (163 lines of text for the Sparse Array example and
194 lines for the Course example) using printf commands. Also note that we did not try to
optimize the algorithm at all.

6.7 Conclusion
We have shown how to infer tedious annotations to lighten the work of the user. In particular:

* most of the time, the user do not have to annotate the region in which pointers are

allocated;

* focus and unfocus operations are automatically inserted if necessary when a pointer is

modio/ed;

* focus and unfocus are also inserted when a function call expects a singleton region, if

a variable of the region is available;

* packing and unpacking are automatically inserted if necessary as well;

* adoption operations are automatically inserted when the pointer to be adopted is avail-

able as a variable.

Practice shows that this makes the Capucine language much easier to program with. However,
some annotations are not inferred, notably:

180 CHAPTER 6. INFERENCE OF REGION ANNOTATIONS

* region arguments, consumes and produces clauses of functions;

* adoption of complex expressions.
We have explained why those were not good candidates for inference.

While Loops The Capucine language does not feature loops. We encode them using
recursive function calls. If while loops were to be added to the core language, they should be
annotated using a permission invariant, i.e. a list of permissions which should be available
at the beginning and at the end of each iteration of the loop. The inference algorithm would
then use this permission invariant as the set of permissions consumed and produced back by
the loop body.

Chapter 7
Conclusion
Before concluding this thesis, we compare our work with related work. Then we give some
ideas for extensions that could be considered for Capucine.

7.1 Related Work and Contributions
7.1.1 Other Memory Models
In Section 2.4.1 we introduced a simple memory model where the heap is represented as a
single array from locations to values. This model is, in particular, used in the Spec# [Bar-
nett04a] platform when producing Boogie [Barnett05] intermediate programs. We argued
in Section 2.4.2 that this model lacked static separation between pointers. In Section 2.4.3
we showed how to obtain some static separation thanks to the Burstall-Bornat component-
as-array model [Bornat00]. This model splits the array representing the heap into several
arrays, one for each structure o/eld.

In Section 2.4.4 we showed how Thierry Hubert and Claude Marche' [Hubert07, Hubert08]
proposed a separation analysis for the Why platform [Fillia^tre07]. This separation analysis
gives each pointer a region variable, unio/es these region variables using the ML unio/cation
mechanism and then splits the heap into several arrays, one for each region. This mechanism
has also been implemented [Moy09] in the Jessie intermediate language [Marche'07] of the
Why platform.

Comparison With Capucine In Capucine, pointers may own regions and the heap is
thus a tree. Depending on how we represent this tree, we achieve more or less separation. In
Section 5.2 we present a simple encoding of the heap where only root regions, i.e. regions at
the top of the tree, are separated as statically dioeerent variables.

In Section 5.5 we show that using preo/x trees we can split the heap not only by root
regions, but also by owned regions and class o/elds. This allows Capucine to achieve separation
similar to the one used in Jessie, except the region language is richer with the possibility for
pointers to move from their region into another, the possibility to implement functions which
allocate, initialize and return new pointers, and last but not least, the possibility for pointers
to own regions. The caveat is that preo/x trees are harder to use for region arguments of logic
functions. However, the separation granted by having dioeerent variables for parts of the heap
is most useful when these parts are assigned new values, which does not happen in the logic.

181

182 CHAPTER 7. CONCLUSION

In Section 5.4 we show that we can represent pointers of singleton regions simply us-
ing their value. In other words, those pointers are statically separated from every other
pointer, thus simplifying reasoning on the program. This simplio/cation is inspired by work
by Chargue'raud and Pottier on translation of imperative programs into pure programs using
capabilities [Chargue'raud08]. Capabilities are similar to permissions.

7.1.2 Data Groups
K. Rustan M. Leino proposed datagroups to reason about side-eoeects in a modular fash-
ion [Leino98, Leino02]. One may declare datagroups inside classes. One then declare that
some o/elds belong to some datagroup. One may also declare that some datagroups are in-
cluded in some others. Static restrictions prevent pivot o/elds from being aliased. A pivot
o/eld is a o/eld whose type is a class which contains a datagroup H and which is declared in a
class which contains a datagroup G. Note that in such a case we may want to specify that
G includes H .

Datagroups can be used to hide parts of the implementation of classes. The o/elds of a
datagroup may be hidden. Eoeects on the o/elds are then modeled by eoeects on the datagroup.

Comparison With Capucine Datagroups are comparable to regions of Capucine. The
inclusion relation between datagroups is comparable to ownership. Intuitively, if a pointer x
owns some region x .r, then x .r is included in the region of x . Owned regions are encapsulated
in their owners, and the permissions on owned regions are hidden when the owner is closed.
This is comparable to the data abstraction mechanism provided by datagroups.

7.1.3 Spec# Ownership Methodology for Data Invariants
In Section 2.5 we presented the ownership methodology used in the Spec# platform [Bar-
nett04b]. The ownership methodology of Capucine is largely based on the Spec# method-
ology. The main dioeerence is that in Capucine, ownership is handled by the type system.
Another key dioeerence is that objects own regions instead of other objects. In other words,
in Capucine objects own groups of potentially aliased other objects. Regions happen to be
the main feature of Capucine which allows to control aliasing using the type system. This
explains why objects own regions instead of single objects. Note that if a region is always
singleton (i.e. is marked as single in the owner class), then it plays the same role as an owned
object in Spec# (i.e. a o/eld marked as rep).

The use of a type system to control ownership allows Capucine to generate less proof obli-
gations. In Spec#, the user writes pre- and post-conditions such as x.inv == ClassName
to state that the invariants of class ClassName hold for object x . This equality then ap-
pears in proof obligations. In particular, we have to prove it when calling functions which
assume the invariants of their arguments. In Capucine however, this equality is replaced by
permission ae*, aeG or oe -ffi ae, which is handled by the type system.

To some extent, the use of a type system also allows Capucine to infer the pack and unpack
statements. Indeed, the inference mechanism of Capucine automatically unpacks objects
being modio/ed. The object is then automatically packed when the invariant is required.

On the other hand, the use of a type system implies some restrictions. Ownership transfer
is possible in Capucine using adoption and/or focusing, but this consumes the permission on
the source region, disabling the region completely. In general, it is not possible to remove a
location x from a region ae safely without disabling the region. We should ensure that the

7.1. RELATED WORK AND CONTRIBUTIONS 183
type of all expressions denoting the same location as x changes so that the location cannot
be accessed from ae, but knowing which locations are equal to x is an undecidable property.

Also, as the state of invariants is encoded as a o/eld in Spec#, the user can use complex,
undecidable conditions such as: ithe invariant of my argument should hold if x + y > 0j.
This is not possible with permissions, although the extension we sketch in Section 7.2.2 might
allow such kind of conditions.

The ownership methodology of Spec# is compatible with object inheritance. In Capucine,
there is no inheritance. As the ownership methodology is very similar, we believe that if
inheritance were to be added to Capucine, we could use the ideas of Spec# to extend the
ownership methodology of Capucine to handle it.

7.1.4 Ownership Types
David G. Clarke, John M. Potter and James Noble propose ownership types [Clarke98]. As
the name suggests, it is a type system aimed at controlling aliasing using ownership. It is
based on an object-oriented language. Types are annotated by their context. A context is
a set of locations. There is a root context, denoted norep, owned by nobody. Each object
owns a context. The context owned by the current object this is denoted rep. Classes can
be parameterized by context variables m.

Comparison With Capucine The type system of Capucine generalizes ownership types.
Regions are obviously similar to contexts. Capucine pointer types are also annotated by their
region. In Capucine there are several root regions instead of only one root context norep.
Those root regions are the set of region variables bound by the programmer. Similarly, an
object may own zero, one or several regions in Capucine. Capucine is not object-oriented,
and thus there is no special object this; relative context rep has no meaning. We can encode
methods using functions with an argument called this. Context rep of ownership types then
corresponds, in Capucine, to the union of owned regions of this. Capucine features region
parameters, which are similar to context parameters.

Moreover, the Capucine language provides greater AEexibility. In Capucine, we may write
region x .s for any variable x . We are thus not limited to contexts rep or norep, as x may
be any argument of the function, or any local variable. In Capucine we also have region
parameters for functions, not just for classes. Those region parameters may be used in
particular to specify whether two arguments of the function may be aliased or not.

Capucine adds the ability to track the state of invariants to the type system. It also
allows to move locations from their current context to another, using adoption, focus and
unfocus operations.

7.1.5 Universe Types
Werner Dietl and Peter Mu"ller propose Universe types [Dietl05]. The Universe type system
provides ownership control for JML [Burdy04]. Universe types can be seen as a lightweight
version of ownership types [Clarke98].

A key dioeerence between ownership types and Universe types is that while ownership types
enforce the owner-as-dominator property, the Universe type system enforces the owner-as-
modio/er property. The owner-as-dominator property ensures that the owner of an object x
controls how x is read and modio/ed. In other words, to access x, one must go through the

184 CHAPTER 7. CONCLUSION
owner of x. By contrast, the owner-as-modio/er property only restricts modio/cations: one
can read any object. This property is suOEcient to ensure that invariants are maintained.

Universe types have been implemented in the context of JML. The type system can thus
be used in conjunction with either runtime checking or static verio/cation using verio/cation
conditions. This is one of the strength of Universe types, as the combination of typing
and a modelling language provides great expressiveness. In particular, JML features object
invariants. The Universe type system is orthogonal to the invariant methodology, but as it
provides ownership, it can be used to ensure the chosen invariant methodology is sound.

Universe types are annotated by either rep, peer or readonly. Context rep of Universe
types is similar to context rep of ownership types: if an object is annotated with rep, then the
object is owned by this. If an object x is annotated with peer, then the object has the same
owner that this. In other words, x and this are brothers in the ownership tree. Finally, if an
object is annotated with readonly then the object owner, and thus its context, is unknown.
Subtyping allows a rep or a peer object to be seen as a readonly object.

Downcasting can be used to view a readonly object as a rep or a peer object. A pre-
condition is required for downcasts, namely that the owner of the object is this (when down-
casting to rep) or is the same as the owner of this (when downcasting to peer). This implies
having, along with the type system, a way to express object owners in the modelling lan-
guage. In JML, this is done using a ghost o/eld called owner . Type annotations rep, peer
and readonly of method arguments, return values and allocated objects can be translated as
conditions on owner o/elds.

Only the o/elds of rep and peer objects can be modio/ed. Fields of readonly objects
cannot: they can only be read. This ensures the owner-as-modio/er property.

The Universe type system does not feature context parameters for classes. Instead of
using a context parameters, one uses the readonly annotation. To modify readonly variables
x, one has to use a downcast. In other words, one has to prove that x is rep or peer before
modifying it. This trade-ooe makes programs more readable and the type system is lighter,
at the cost of additional conditions for the runtime checker or static verio/ers.

By default, all references are peer, except for pure methods and exceptions which are
readonly. In other words, by default everyone is in the same context. This allows to be
backward compatible and type most already-existing programs.

Comparison With Capucine All remarks that we made when comparing Capucine and
ownership types still hold when comparing Capucine with the Universe type system. In
particular, contexts and regions are similar, although in Capucine there are several root
regions and an object may own several regions.

In Capucine there is no equivalent to the readonly context annotation. Precise region
annotation is thus required, which can sometimes be heavy and most importantly, does
not provide the same level of expressiveness. On the other hand, region parameters and
polymorphism proved to be enough for the examples we were interested in, and they do
not generate verio/cation conditions whereas downcasts from readonly to rep or peer do. In
Capucine there is no need for an owner ghost o/eld: ownership properties are verio/ed by the
type system, not by a runtime checker or a static verio/er. Moreover, with Universe types
there is sometimes the need for an invariant stating who is the owner of readonly references.
There is no such need in Capucine: this information is contained in the type.

Ownership transfer in Capucine can be made using adoption and focus, at the cost of
disabling the source region. With Universe types, it is not clear how such transfers could be
done. If a location x is rep and if x.owner is changed, then x still has type rep even though its

7.1. RELATED WORK AND CONTRIBUTIONS 185
owner might not be this anymore. If one could ensure that all expressions denoting location
x had type readonly, then one could allow changing the owner ghost o/eld. But ensuring
such a typing property does not seem reasonable. We found a similar problem with Capucine
when we tried to extract a pointer from a region without disabling the region.

It is clear that Capucine enforces the owner-as-modio/er property, in the sense that one
must unpack all transitive owners of an object before modifying the object. However, it is not
clear whether Capucine enforces the owner-as-dominator property. Indeed, on the one hand
one does not have to unpack an object x and its owners to be able to read it, but on the other
hand a permission on the region of x is required. Moreover, accessibility rules (Figure 4.2)
require not only a permission on x but also permissions on the owners of x. However, this
permission requirement is only here to ensure the separated translation of Chapter 5 is sound.
If we had chosen a more classic translation with only one heap array, i.e. a translation closer
to the intuitive model of Capucine (Section 4.3) and to the Spec#-to-Boogie translation,
then we would not need to require any permission on x; but we would not beneo/t from the
separation properties of our translation.

It is interesting to note that the default peer type in the Universe implementation cor-
responds to the use of a unique group region in Capucine. This would lead to the naive
translation with only one non-separated heap, with no alias control, and thus to the same
result.

7.1.6 Regions, Capabilities and Alias Types
Regions Regions are originally introduced by Mads Tofte and Jean-Pierre Talpin [Tofte94,
Tofte97]. They structure the store as a stack of regions to control allocation and deallocation.
Regions are allocated and deallocated as a whole. All points of allocation and deallocation
are inferred automatically. The presence of a garbage collector is not required.

Capabilities Karl Crary, David Walker and Greg Morrisett propose a calculus of capabil-
ities to type memory management [Crary99], using regions similar to those of Mads Tofte
and Jean-Pierre Talpin. Capabilities are similar to permissions: they cannot be duplicated
and give information about regions. Their work is presented as an alternative to garbage
collectors. Capabilities are used in particular to know which regions can be deallocated.

John Tang Boyland, James Noble and William S Retert propose a type-system for capa-
bilities [Boyland01] for object-oriented programs. It is a generalization of many usual Java
annotations such as unique or readonly. The language is quite general and can be used to
encode many such policies. The language of permissions separates read and write accesses.
They also propose a permission which does not allow to access a pointer but which still allows
the location of the pointer to be compared with others. Some permissions denote the fact
that nobody else has the permission. These allow to control duplication of permission, and
thus to encode linear or aOEne constraints. The authors extend their type-system with adop-
tion [Boyland05]. They call this operation nesting, to emphasize the fact that the operation
is more o/ne-grained than adoption as it can be applied to single o/elds instead of a whole
object.

Alias Types Frederick Smith, David Walker and Greg Morrisett propose alias
types [Smith00, Walker00], which are inspired by the calculus of capabilities. The idea is
to control aliasing using regions and permissions. It allows the distinction between singleton

186 CHAPTER 7. CONCLUSION
and group regions. This distinction allows strong update: as the type associated to a region
is contained in its capability, which is linear, it can be changed safely.

Manuel Fa"hndrich and Robert DeLine introduce the adoption, focus and unfocus opera-
tions [Fa"hndrich02]. It extends the calculus of capabilities and alias types. These operations
are similar to the ones used by Capucine.

Imperative Program Encoding Arthur Chargue'raud and Franc,ois Pottier propose a
type system based on capabilities and use it to encode imperative programs into pure lan-
guages [Chargue'raud08]. Their original plan was to use this as a basis for program verio/ca-
tion. Capucine is largely based on this idea. Their translation into pure languages provides
a solid basis to understand the semantics of capabilities. The idea is that capabilities are
encoded as values in the pure language, each capability denoting the values of locations of
its regions. In other words, if the region is singleton, the encoding of the capability denotes
the value of the unique location of the region, and if the region is group, the capability
is encoded as a map from locations to values. Allocation produces a permission on a new
region, which translates to the creation of a new value in the pure program. Deallocation
consumes a permission on the region being freed, which translates to the corresponding value
in the pure program no longer being used. Modio/cation consumes a permission and produces
it back, which translates to the corresponding value being modio/ed in the pure program.
The type system of Arthur Chargue'raud and Franc,ois Pottier also features strong update.
Contrary to previous versions of the calculus of capabilities [Crary99, Fa"hndrich02], their
type system also allows regions to contain not only locations but also any value. This allows
more expressive types and data structures such as sum types and thus linked lists. They also
feature polymorphism a` la System F [Girard71, Reynolds74]. In particular, the type system
features existential types.

Concurrency Another application of permissions is to control which process may access
some part of the memory in a concurrent setting. Let's show a simple example:

*x = 2;
*y = 49 / *x;

If the memory cell denoted by pointer x is assigned to zero between the two lines of this
program, a division by zero occurs. The usual way to prevent this from happening is by using
locks or mutexes to make these two lines atomic, i.e. to ensure that nothing will be executed
between these two operations. Permissions are a way to prevent x from being modio/ed. The
process running the above two lines requires permissions x and y, and because permissions
cannot be duplicated, no other process can modify x. Those two lines are no longer atomic,
yet nothing that can break the behavior of the program can be inserted between them.

Protocol API Specio/cation Kevin Bierhooe uses permissions in his PhD thesis to specify
protocol APIs [Bierhooe09]. For instance, a channel may be opened, accessed and then closed,
in this order. Access to a closed channel usually leads to a run-time error, but a type
system using permissions can be used to catch this error when compiling. Indeed, one may
specify channel creation to produce a permission which is consumed when the channel is
closed, and which is required to access the channel. Kevin Bierhooe applies this approach to
object-oriented languages and propose to split the state space of objects using hierarchical
reo/nements. Each reo/nement describes one interface for an object. Permissions state in
which exact reo/nement the object is, and thus which methods may be called.

7.1. RELATED WORK AND CONTRIBUTIONS 187

The work of Kevin Bierhooe has been implemented as an Eclipse plugin called Plural [Bier-
hooe11]. The language of permissions describes the state of an object: exclusive access
(unique), exclusive with right to modify (full ), read-only (pure), immutable, and shared
access (shared). Permissions may only coexist if they do not violate each other. They can
be decomposed and recomposed. For instance, unique is equivalent to pure plus full. The
language also features fractional permissions, although the authors claim not to need this
particular feature that often. For instance, full is equivalent to one half of shared plus one
other half of shared. The authors of Plural found permissions to be quite a powerful tool for
specio/cation.

Plaid Jonathan Aldrich et al. propose to design a permission-based programming lan-
guage [Aldrich11]. Their work is inspired by Plural : the state of objects may change and
permissions track the current interface of an object. They sketch their own proposal, called
Plaid. The aim of the language is to provide permissions as a specio/cation tool to, in particu-
lar, specify ownership in parallel programs, check protocol APIs and ensure that some values
are not leaked outside the scope of a module. That last property can be useful to ensure
security properties and encapsulation. It is also worth noting that the authors do not wish
to restrict themselves to a type system: they consider dynamic permissions, which would be
checked at run-time. This would provide more expressiveness when required.

Permissions and Ownership Yang Zhao and John Tang Boyland propose to use permis-
sions to encode ownership [Zhao08]. Permissions may be nested inside others. As a result,
the nested permission is iprotectedj: one has to iun-nestj the nester permission to obtain the
nested one. More precisely, permissions can be nested inside object o/elds. This is encoded
using linear implication. The authors show, in particular, how the owner-as-dominator policy
can be enforced. They discuss how fractional permissions could be used to provide multiple
ownership. They also argue that this provides encapsulation.

Conditional Permissions Some of the above related work feature conditional permis-
sions [Boyland05, Retert09, Zhao08]. They are permissions which are only available if some
boolean predicate evaluates to true. They can in particular be used to specify the cases where
a pointer is null.

Inference of Permissions Both William S Retert and Kevin Bierhooe discuss, in their PhD
thesis, how to implement their permission type-system [Retert09, Bierhooe09]. The problem
is: given a program which is partially annotated with permissions, can we statically prove
that those permissions will indeed be available at run-time? The main issue seems to decide
when permissions should be decomposed and recomposed. In particular, both systems feature
fractional permissions. William S Retert introduces a lattice of permissions. A control-AEow
analysis generates constraints, and a o/xpoint is found in this lattice. Kevin Bierhooe views
permission-based assertions as a decidable fragment of linear logic.

Comparison With Capucine While the type system of Capucine is largely based on the
ideas of regions and capabilities, it features some important dioeerences. The o/rst change
is that Capucine does not feature polymorphism a` la System F. It is closer to ML, and
may thus be considered simpler, albeit less expressive. In particular, there is no need for

188 CHAPTER 7. CONCLUSION
existential types, although owned permissions can be seen as existential regions. Allocation,
in particular, takes an empty region as an argument.

Permissions of Capucine are capable of tracking the state of invariants. Permissions ae*
and aeG imply that the invariants of all objects of ae hold, and permission oe -ffi ae imply that
the invariants of all objects of ae, except possibly the objects which are also in oe, hold.

Another important change is that Capucine features a region ownership tree. A closed
permission encapsulates other permissions on owned regions, as if these permissions were
part of the invariant of the data structure. Moreover, the region ownership tree is used to
ensure the invariant methodology is sound.

Compared to the type system of Arthur Chargue'raud and Franc,ois Pottier, the regions
of Capucine may only contain locations. They cannot contain any value. Capucine is thus
closer to the original calculus of capabilities and alias types.

Capucine does not feature deallocation. We assume the presence of a garbage collector.
Adding deallocation would not be hard though: the operation would simply consume the
permission of the region it deallocates, just as it is done in the calculus of capabilities.

The inference algorithm of Capucine is more specialized than the ones of William S
Retert and Kevin Bierhooe. In particular, Capucine does not feature fractional permissions,
conditional permissions, or permissions disjunctions. On the other hand, it does feature
adoption, focus and unfocus, as well as region ownership (i.e. permission nesting). Moreover,
Capucine infers region operations which have an eoeect in the resulting Why program. As a
result, some care has to be taken to ensure that the program semantic is unchanged.

7.1.7 Separation Logic
John Reynolds propose separation logic to reason about potentially-aliased data struc-
tures [Reynolds02]. The main idea is that predicates describe the heap using the separative
conjunction P * Q, which states that P holds in a part of the heap which is separated from
Q. For instance, i ,! v * j ,! w states that the heap contains exactly two distinct locations
i and j of respective values v and w.

To reason about recursive data structures such as lists using separation logic, we use
packing and unpacking operations. For instance, say Plist (i) is a predicate stating that i is
a location for a linked list. This predicate can be unpacked to obtain i ,! (v, j) * Plist (j) if
the list is not empty. Value v is the value of the node stored at location i, and location j is
the location of the next node.

Separative conjunction * has a dual operation P -* Q. This predicate describes a heap
in which Q would hold if a separated heap in which P held were provided. Thus P denotes
a iholej in Q.

VeriFast [Jacobs08] is a program verio/cation tool for programs annotated with pre-
conditions and post-conditions written in separation logic. The programmer may use open
and close operations to respectively unpack and pack predicates such as Plist .

Comparison With Capucine Separation logic focuses, as its name suggests, on the logic,
whereas Capucine focuses on its type system. Separation logic encodes separation informa-
tion in logic connectives whereas Capucine relies on its type system. As a consequence,
proof obligations need special theorem provers to be proven, automatically or not. However,
separation logic is also more expressive as a result.

Note that permissions are similar to separation logic predicates. Indeed, a permission
denotes some property about some region, i.e. some part of the heap. If a pair of permissions

7.1. RELATED WORK AND CONTRIBUTIONS 189
\Sigma 1 , \Sigma 2 is available in Capucine, then the region of \Sigma 1 is disjoint than the region of \Sigma 2 . Thus
this pair of permission is similar to a separative conjunction. Moreover, permission oe -ffi ae is
comparable to the magic wand -* of separation logic. Indeed, permission oe -ffi ae denotes
permission aeG on the condition that oe* is given back.

The open and close operations of VeriFast are similar to the unpack and pack statements
of Capucine. By unpacking a Capucine pointer x we obtain permissions on owned regions
of x . With VeriFast, by opening a predicate we obtain iownedj predicates. For instance, by
opening Plist (i) we obtain Plist (j ) where j is the next node of list i.

7.1.8 Dynamic Frames
Ioannis T. Kassios proposed dynamic frames [Kassios06] to reason about pointer aliasing
in a modular fashion. A frame is a set of locations. A specio/cation variable is a variable
which may only be used in the specio/cation. In particular, specio/cation variables may be
frames. The programmer can thus use frames to state aliasing properties in the program
specio/cation, which is then proved as usual using deductive verio/cation techniques. This
implies that dynamic frames appear in proof obligations, hence the idynamicj name.

Predicate \Xi (f) states that frame f is preserved, i.e. no location of f is modio/ed. This
predicate implicitely takes two states s, s0 as arguments, where s is the pre-state and s0 is
the post-state. It states that for every location l in f , s(l) = s0(l).

Predicate \Delta (f) states that frame f is modio/ed, i.e. no location other than those in f are
modio/ed. If all is the set of all locations, \Delta (f ) can be deo/ned as \Xi (all - f).

Predicate \Lambda (f) states that frame f has grown using fresh locations only. It is sometimes
called the swinging pivot requirement. It is useful to deal with allocations.

Predicate disjoint(f, g) states that frames f and g are disjoint. In other words, no location
of f is in g and vice-versa.

Predicate f frames e states that if frame f is preserved (i.e. \Xi (f)), then e is not modio/ed,
where e is a side-eoeect-free expression, a term or a predicate. In other words, f includes the
locations appearing in e.

For instance, the following specio/cation states that variables x and y are not aliased:

f frames x ^ g frames y ^ disjoint(f, g)
Indeed, x and y are in disjoint frames and so they must denote dioeerent locations.

Usually, frame variables f are self-framed, i.e. we write f frames f in the specio/cation.
In other words, if no location is added to or removed from the set of location which f is
intended to denote, then variable f is unchanged.

A data structure is typically specio/ed using a self-framed frame specio/cation variable
named rep, which describes all locations used by the data structure. For instance, a linked
list will have all its nodes and its values in rep. Adding a new node to the list will grow rep
using the new node location.

Comparison With Capucine Dynamic frames can be easily added to existing deductive
verio/cation systems, as frames are variables as any other. However, Capucine requires the
implementation of a type system.

Capucine puts the emphasis on static properties: it uses a type system capable of rea-
soning with location sets, which are called regions. Dynamic frames also aim at specifying
location sets, called frames. Thus regions are similar to frames. However, the regions of

190 CHAPTER 7. CONCLUSION
Capucine appear in types, whereas dynamic frames appear in the logic. Capucine regions do
appear in the logic as well, but with less available operations. Thus dynamic frames put the
emphasis on dynamic properties, i.e. properties which are verio/ed using proof obligations.
Naturally, this makes the expressive power of dynamic frames stronger than the one of Ca-
pucine, as a type system cannot handle undecidable properties without resorting to proof
obligations. However, many proof obligations using dynamic frames could be automatically
discharged using a type system such as Capucine.

The static means Capucine uses to specify region properties allow regions to be statically
separated in proof obligations using dioeerent variables. This simplio/es proof obligations and
helps automatic provers greatly. Not only separation does not have to be proved, it is also
easier to use to prove other proof obligations. Dynamic frames, being dynamic, do not provide
such static separation.

7.1.9 Implicit Dynamic Frames
Jan Smans, Bart Jacobs and Frank Piessens recently introduced implicit dynamic
frames [Smans08, Smans09] to unify dynamic frames [Kassios06] and separation
logic [Reynolds02]. The idea is that instead of being explicitly specio/ed, frames are computed
from function pre- and post-conditions, which may contain instances of the accessibility pred-
icate acc(e). This predicate states that locations mentioned by term t are accessible. If func-
tion reads or writes some location, it must be required to be accessible in the pre-condition.
Dynamic frames are computed from the accessibility predicates contained in pre-conditions.
The separating conjunction * is available in predicates.

The accessibility predicate is encoded as a boolean ghost o/eld acc in each object, stating
whether the object is accessible. The verio/er then checks before each o/eld access that the
corresponding location is accessible, i.e. the value of its acc o/eld is true.

Pure methods can be used in the program specio/cation, and are used to encode abstrac-
tion. For instance, instead of directly using some f o/eld in a pre-condition, one can apply a
method getf which returns the value of f. Field f can then be hidden.

Allocation implicitely returns a fresh location. This location is thus separated from
previously-allocated ones.

Comparison With Capucine The accessibility predicate plays a role similar to permis-
sions: they are both required to access some location. The dioeerence is, once again, that
permissions are part of the type system, while accessibility predicates are part of the logic
and, as such, generate proof obligations. Implicit dynamic frames do not require eoeect an-
notations, as they are inferred. Capucine also infers eoeects. By ieoeectsj we mean: which
regions are read and which region are modio/ed.

Implicit dynamic frames tackle the issue of modularity using pure methods. Capucine
provides a framework for abstraction through encapsulation of owned regions: a closed per-
mission encapsulates all its owned permissions, thus hiding the corresponding regions.

7.1.10 Regional Logic
Anindya Banerjee propose regional logic [Banerjee08] to reason about global invariants in a
local fashion. His approach follows the ideas of dynamic frames [Kassios06]. More precisely,
he again deo/nes regions as sets of locations. These regions are ghosts variables, usable in
specio/cations and eoeects. They can be assigned by specio/cation annotations in the program,

7.1. RELATED WORK AND CONTRIBUTIONS 191
but they cannot be used to change the result of the program. Regions terms include the empty
region, a singleton region deo/ned by an expression denoting the unique location of the region,
and the region composed of all locations. Region operations include union, intersection and
dioeerence. Region predicates include inclusion and disjointness. An important predicate is
the frame predicate P ` e frm P 0, which states that, if predicate P is valid, then predicate
P 0 only depends on locations read by eoeects e. Another important predicate is er ? ew, which
states that eoeects ew cannot modify what is read by eoeects er. This predicate is close to the
separative conjunction of separation logic.

Comparison With Capucine As with dynamic frames [Kassios06] and separation
logic [Reynolds02], the main dioeerence between regional logic and Capucine is that Capucine
is based on a type system to control alias properties, while regional logic checks separation
at verio/cation time. This results in regional logic being more expressive, at the cost of a need
for more annotations from the programmer and more verio/cation conditions.

7.1.11 Considerate Reasoning
Limits of Ownership Methodologies Matthew Parkinson argues [Parkinson07] that
class invariants may not be the correct foundation for verifying object-oriented programs.
Indeed, invariants often relate several objects together. This means that modifying one
object may break the invariants of other objects. Ownership methodologies allow control of
which objects may be modio/ed, and they also structure the heap as a tree.

However, in some design patterns such as Subject-Observer there is not a clear ownership
relation between objects. In other words, the heap is not necessarily a tree. The Subject-
Observer pattern involves one subject which is observed by several observers. When the
subject is modio/ed, it notio/es its observers so that they can act accordingly. There is an
invariant relating the subject and the observers, and thus there must be an ownership relation
between them. The observers cannot own the subject, because an object can only be owned
by one other object. So the subject must own its observers. This prevent other objects from
owning the observers.

The Composite Pattern Even in tree data structures, ownership may limit expressivity.
A typical example is the Composite Pattern [Robby08]. It consists of a tree data structure
where each node maintains some invariant about its subtree, such as the total number of
children. Moreover, each node contains a back-pointer to its parent in the tree. This allows
to add new nodes anywhere in the tree: given a node, one can add children to the node
without starting from the root of the tree. The invariant is then re-established by following
the back-pointers up to the root of the tree, instead of starting from the root and then going
down. However, ownership is a methodology which requires unpacking from the root owner
to modify a deeper node. It is thus not AEexible enough to handle the Composite Pattern.

The following code is an example of an implementation following the Composite Pattern,
using Java-like syntax.

class Node
{

Node parent;
List<Node> children;
int count = 1;

192 CHAPTER 7. CONCLUSION

void Add(Node n)
{

n.parent = this;
children.Add(n);
IncrCount();
}

void IncrCount()
{

count = count + 1;
if (parent != null)

parent.IncrCount();
}
}

The implicit invariant is that o/eld count contains the sum of all count o/elds of all
children nodes, plus 1. The Add method adds a new child to a Node, and restores
the invariant of all Nodes by calling IncrCount.

Considerate Reasoning As an anwser to the position paper of Matthew Parkin-
son [Parkinson07], Alexander J. Summers, Sophia Drossopoulou and Peter Mu"ller argue that
class invariants are a useful specio/cation tool (Section 1.3 covers some of their arguments),
but they agree that they need to be more AEexible [Summers09]. Alexander J. Summers and
Sophia Drossopoulou propose Considerate Reasoning to provide such AEexibility [Summers10].
In the Composite Pattern, the method which adds a child to a node must be considerate and
re-establish the invariant of all broken objects, i.e. all transitive parents of the added node.

Considerate Reasoning requires being able to state which invariants of which objects
may be broken when a given o/eld is modio/ed. In the above Composite Pattern imple-
mentation, adding a child to this.children o/eld will break the invariant of this. An
over-approximation of the set of objects whose invariants may break can usually be computed
automatically.

Considerate Reasoning also requires being able to state that a method does not expect
some invariant to hold. In the above Composite Pattern implementation, IncrCount does
not require the invariant of this to hold. The method can thus be marked using the broken
keyword, which states exactly this: the method will restore the broken invariant.

Capucine and the Composite Pattern Because Capucine implements an ownership
methodology which requires unpacking from the root owner down to the object being mod-
io/ed, the Composite Pattern does not beneo/t from the Capucine ownership approach. The
Add method would require a permission on this, and such permission would not be avail-
able if this had a packed parent. The caller would thus require to unpack the parent of
this, and maybe the parent of the parent as well, and so on. This does not mean that the
Composite Pattern cannot be encoded in Capucine, but this means that parents cannot own
their children, which is not the intuitive way to implement trees in Capucine. To encode the
Composite Pattern in Capucine without changing the code to unpack from the top of the
tree to the target node, we need to put all nodes in a single group region and use a complex
invariant predicate [Hubert05]. This also means that the invariant could not be encoded us-

7.2. FUTURE WORK 193
ing Capucine built-in invariants. However, regions could encode some separation properties.
In particular, the Add method could require n to be in a region separated from the region of
this, and then adopt it.

7.1.12 Liquid Types for Invariant Inference
Patrick M. Rondon, Ming W. Kawaguchi and Ranjit Jhala propose Logically Qualio/ed Data
Types, abbreviated to Liquid Types, a type system where invariant predicates are associated
to types [Rondon08]. The system is then capable of inferring such types, including invariants.
Examples of inferred invariants include intervals: type {x : int | 1 <= x <= 99} denotes the
type of integers which are between 1 and 99.

Comparison With Capucine Capucine is not capable of invariant inference: invariants
must be given by the user. In the body of functions, Capucine is capable to infer when
invariants hold. It would be interesting to try and combine the two approaches. However,
the inference mechanism for liquid types is not modular: the whole program must be analized
to be able to infer invariants for function arguments.

7.2 Future Work
7.2.1 Encoding Mainstream Languages Into Capucine
Capucine is an intermediate language. It is not designed to program with directly. Its purpose
is similar to the purpose of Jessie [Marche'07]: serve as an intermediate language for the Why
platform [Fillia^tre07], to provide a memory model and the tools to reason on this model. The
next step is thus to build a front end which would take programs written in more mainstream
languages such as C, Pascal, Java or OCaml, and translate them into Capucine. This raises
several questions.

A o/rst question is: what should the annotation language look like? The Java Model-
ing Language (JML) [Burdy04] is well-known and the ANSI/ISO C Specio/cation Language
(ACSL) [Baudin09] is already used in the Why platform and by Frama-C [FramaC], but
both languages lack the necessary region annotations that would be needed by Capucine. A
possibility would be to work on inference of these annotations so that they are completely
transparent, but as we argued in Chapter 6, this would probably not be fully satisfying, in
particular because it would probably not be modular. Another possibility would be to design
a new annotation language which would basically be JML or ACSL plus region annotations.

Another question is: how can we encode complex data structures provided by the source
language into Capucine? In particular, how can we encode objects and inheritance? We
already know how to encode objects into Jessie, and we already know that the invariant
methodology of Spec# handles inheritance [Barnett04b]. In fact, we already applied the
Spec# methodology, including inheritance, in Jessie [Bardou07]. We thus believe that we
have all the tools we need for such an extension. It is however not clear how functional
programming languages such as OCaml should be encoded because of higher-order func-
tions. Work by Johannes Kanig show one possible way to handle eoeects in such kind of
languages [Kanig10].

194 CHAPTER 7. CONCLUSION
7.2.2 Conditional Permissions
An idea we would like to investigate is the concept of conditional permissions, i.e. permissions
of the form P ) \Sigma  where P is a predicate and \Sigma  is a regular permission such as ae;, aeffi, ae*,
aeG or oe -ffi ae. Informally, the meaning of this permission is: iif P holds, then \Sigma  is availablej.
This idea has already been proposed in other permission-based type systems [Boyland05,
Retert09, Zhao08]. We would add a new statement use \Sigma . This statement would consume
P ) \Sigma , produce \Sigma , and would require P as a pre-condition. At any time \Sigma  could be weakened
to P ) \Sigma .

Our original motivation for conditional permissions is linked lists:

class List{

group Rnext;
next: option ([Rnext]);}

The fact that Rnext is a group region is not very satisfying, as Rnext contains at most one
location. We cannot mark the region as single instead of group either, because then no
closed list could be built as a closed list would necessarily be ino/nite. Instead, we propose to
explicitly store the state of the region (i.e. its permission) in the invariant as follows:

class List{

region Rnext;
next: option ([Rnext]);
invariant (next = none ) Rnext;) ^ (next 6= none ) Rnext*);}

The invariant contains two conditional permissions. The o/rst one states that if next is
none then Rnext is empty, while the second one states that if next is not none then Rnext
is singleton and closed. To use the permissions of the invariants, one would o/rst write a
use invariant statement, followed by use Rnext; or use Rnext*.

Interesting questions arise. Can we simplify the encoding of Rnext as we did in Sec-
tion 5.4? How much expressiveness would this extension add to Capucine? Are there other
interesting examples that would beneo/t from conditional permissions?

7.2.3 Combine With Other Approaches for Group Regions
Even though Capucine provides many tools to separate pointers, sometimes we have no
choice but to group many of them in a single group region. Also, as we already noticed in
Section 7.1.11, some data structures do not beneo/t from the ownership approach. When we
encounter these limitations we have to put all pointers of the data structure in a single group
region.

Group regions correspond to the limit of what the Capucine type system can provide as a
means for separation. Beyond this limit, we need tools which are not based on types. Right
now, inside a group region we only have access to the basic tools provided by deductive
verio/cation, although the invariant methodology of Capucine does help. For instance, a
typical invariant we want to state is that all locations stored in an array are dioeerent. The
Course example of Section 3.4.5 provides an example of such invariant.

7.2. FUTURE WORK 195

This leads us to question the possibility of bringing deductive tools tailored for separation
analysis to Capucine. For instance, separation logic, dynamic frames and regional logic all
are interesting candidates. It would be interesting to see whether such kind of logic can
replace the logic of Capucine. We would still have static separation through typing, but we
would have more expressive power when typing is not enough.

7.2.4 More Adoption Operations
In our presentation of Capucine we chose to stay simple and we have only one kind of
adoption:

adopt x : oe as ae
which takes a singleton region oe and a group region ae, and puts the pointer of oe into ae. This
is suOEcient most of the time when we write region annotations by hand. In practice however,
our inference mechanism motivates us to add other kinds of adoptions. Here are potential
candidates.

From Singleton To Empty Moving a pointer from a singleton region oe to an empty
region ae is already possible by weakening the empty region o/rst, but the result is that ae
becomes group. We know, however, that after this kind of adoption, ae is actually singleton,
which is strictly stronger information. Permission ae* could thus be produced instead of aeG.
It would not be diOEcult to prove that this operation is sound. It also combines well with the
extension of Section 5.4, and is almost necessary to make good use of Section 6.5.

From Group Another interesting extension would be adoption from a group region instead
of a singleton region. All pointers would be adopted at the same time. The result would be
a union of the two regions, which are known to be disjoint before the operation.

From or Into Focus Say we want to adopt region oe into region ae. Assume one of the two
regions is being focused by a third, distinct region oe0, i.e. either we have oe* (or oeG) and
oe0 -ffi ae or we have oe0 -ffi ae and aeG. Right now we have to unfocus the focused region o/rst.
But in practice we could allow the adoption and produce permission oe0 -ffi ae.

Unfocus A Group Region This suggestion is not a new adoption operation but a new
unfocus operation. Right now, if we focus from ae into oe and then weaken oe to a group region,
we cannot unfocus oe back into ae. However, this would not necessarily pose any problem as
long as oeG is consumed. Indeed, the pointer which was focused would be back in ae, and the
fact that more pointers came with it is not an issue.

7.2.5 Multiple Focus
Another extension which might prove useful is being able to focus several pointers from the
same region at the same time. The idea would be to improve the language of permissions,
to be able to write permissions such as (oe, oe0) -ffi ae. Such a permission would state that two
pointers of ae are being focused in oe and oe0 respectively, and that ae is disabled until oe* and
oe0* are given back.

196 CHAPTER 7. CONCLUSION

A proof obligation should be produced when focusing from ae into oe0 if oe -ffi ae is available.
Indeed, we need to make sure that the pointer being focused is dioeerent than the pointer
which was focused in oe.

We can then generalize with any list of permissions:

(oe1 , * * *, oen ) -ffi ae
When focusing from ae into oe, we would have a proof obligation stating that the pointer being
focused is dioeerent than all pointers of regions oe1 , * * *, oen . The produced permission on ae
would be:

(oe1 , * * *, oen , oe) -ffi ae
Thus growing the list of regions at the left of the lollipop. Another possibility would be to
have group regions at the left of the lollipop, to focus several pointers into the same region
oe. It remains to be explored whether this extension would actually be useful or if it would
just complicate the type system.

7.3. CONCLUSION 197
7.3 Conclusion
Capucine combines several ingredients from various existing work. A o/rst ingredient is deduc-
tive verio/cation: Capucine features function contracts using o/rst-order logic to describe the
behavior of programs. A second ingredient is regions: Capucine features a type system where
each pointer belongs to a region. A third ingredient is ML polymorphism. A fourth ingredient
is permissions. A o/fth ingredient is ownership: the heap is structured as an ownership tree.
A sixth ingredient is data invariants.

Several synergies appear between each ingredient. Invariants are expressed in the logic
used by the deductive verio/cation ingredient. They also beneo/t from ownership which allows
invariants to depend on more pointers. Permissions give information about regions, tracking
the state of invariants and of the region ownership tree. They allow operations to move
pointers from regions into others. Regions beneo/t from ML polymorphism, which is applied
on region variables. The deductive verio/cation ingredient beneo/ts from regions as information
about aliasing can be used when producing proof obligations. It also beneo/ts from permissions
as information about the state of invariants can be extracted from typing. Finally, deductive
verio/cation beneo/ts from ownership as ownership structures the heap so that reasoning can
be done in a modular fashion.

Thanks to all these ingredients, Capucine achieves what we have stated in the introduction
to be the main contribution of this thesis: a type system using regions and permissions to
structure the heap in a modular fashion, control pointer aliasing and data invariants and
produce proof obligations where pointers are separated.

On an imaginary scale between typing and deductive verio/cation, Capucine stands some-
where in the middle and beneo/ts from both worlds. It features the power of o/rst-order
deductive verio/cation while still putting a lot of emphasis on the type system. The type
system discharges some proof obligations that can be considered uninteresting, and those
that remain beneo/t from the information gained through typing.

Yet, there is still work to be done before the contributions of this thesis can be used more
eoeectively. The language can be enhanced with more features to control pointer aliasing.
Capucine is an intermediate language, and many features of mainstream languages such as
inheritance still need to be encoded. Some of these features, such as higher-order functions,
will prove to be quite challenging.

Until a highly-hypothetical day when programmers leave the imperative and object-
oriented paradigms behind and focus on pure fonctional programming, I hope that this work
will help to understand how to write safer programs with pointers.

198 CHAPTER 7. CONCLUSION
List of Figures

3.1 Pseudo-Java code for the Sparse Arrays challenge . . . . . . . . . . . . . . . . 49
3.2 Example of State of a Sparse Array Structure . . . . . . . . . . . . . . . . . . 50
3.3 Java code for the memoized Fibonacci function . . . . . . . . . . . . . . . . . 56
3.4 The Fibo data structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

4.1 Typing rules for regions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
4.2 Typing rules for region accessibility . . . . . . . . . . . . . . . . . . . . . . . . 76
4.3 Illustration of a region ownership tree and its open/close border . . . . . . . . 77
4.4 Typing rules for focus-freeness . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
4.5 Typing rules for expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
4.6 Typing rules for arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
4.7 Typing rules for terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
4.8 Typing rules for logic arguments . . . . . . . . . . . . . . . . . . . . . . . . . 80
4.9 Typing rules for predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
4.10 Typing rules for statements (1 of 2) . . . . . . . . . . . . . . . . . . . . . . . 84
4.11 Typing rules for statements (2 of 2) . . . . . . . . . . . . . . . . . . . . . . . 85
4.12 Term Semantics (Intuitive Model) . . . . . . . . . . . . . . . . . . . . . . . . 94
4.13 Region Term Semantics (Intuitive Model) . . . . . . . . . . . . . . . . . . . . 94
4.14 Predicate Semantics (Intuitive Model) . . . . . . . . . . . . . . . . . . . . . . 95
4.15 Expression Semantics (Intuitive Model) . . . . . . . . . . . . . . . . . . . . . 95
4.16 Statement Semantics (Intuitive Model) . . . . . . . . . . . . . . . . . . . . . . 97
4.17 Statement Semantics: Divergence (Intuitive Model) . . . . . . . . . . . . . . . 98
4.18 Term Semantics (Separated Model) . . . . . . . . . . . . . . . . . . . . . . . . 105
4.19 Region Term Semantics (Separated Model) . . . . . . . . . . . . . . . . . . . 105
4.20 Expression Semantics (Separated Model) . . . . . . . . . . . . . . . . . . . . . 106
4.21 Statement Semantics (Separated Model) . . . . . . . . . . . . . . . . . . . . . 107
4.22 Statement Semantics: Divergence (Separated Model) . . . . . . . . . . . . . . 108

5.1 Example situation to illustrate the assign operation (y and z may be equal) . 125
5.2 Deo/nition of classes PosInt and Triple . . . . . . . . . . . . . . . . . . . . . . 129
5.3 Function incrTriple . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
5.4 Experiment results for bounded arrays . . . . . . . . . . . . . . . . . . . . . . 154
5.5 Experiment results for course and students . . . . . . . . . . . . . . . . . . . 155
5.6 Experiment results for sparse arrays (1/2) . . . . . . . . . . . . . . . . . . . . 156
5.7 Experiment results for sparse arrays (2/2) . . . . . . . . . . . . . . . . . . . . 157

199

200 LIST OF FIGURES
Bibliography

[Aldrich11] Jonathan Aldrich, Ronald Garcia, Mark Hahnenberg, Manuel Mohr,

Karl Naden, Darpan Saini, Sven Stork, Joshua Sunshine, E'ric Tan-
ter, Roger Woloe. Permission-Based Programming Languages (NIER
Track). (ICSE 2011)

[AltErgo] Franc,ois Bobot, Sylvain Conchon, E'velyne Contejean, Mohamed

Iguernelala, Ste'phane Lescuyer, Alain Mebsout. The Alt-Ergo Au-
tomated Theorem Prover. 2008.
http://alt-ergo.lri.fr/

[Banerjee08] Anindya Banerjee, David A. Naumann, Stan Rosenberg. Regional

logic for local reasoning about global invariants. (ECOOP 2008)

[Bardou07] Romain Bardou. Invariants de classe et syste`mes d'ownership. Mas-

ter Thesis, Master Parisien de Recherche en Informatique (MPRI),
2007.

[Barnett04a] Mike Barnett, K. Rustan M. Leino, Wolfram Schulte. The Spec#

Programming System: An Overview. (CASSIS 2004)

[Barnett04b] Mike Barnett, Robert DeLine, Manuel Fa"hndrich, K. Rustan M.

Leino, Wolfram Schulte. Verio/cation of object-oriented programs with
invariants. Journal of Object Technology, vol. 3, no. 6, June 2004,
Special issue: ECOOP 2003 workshop on FTfJP, pp. 22*56.
http://www.jot.fm/issues/issue_2004_06/article2

[Barnett05] Mike Barnett, Robert DeLine, Bart Jacobs, Bor-Yuh Evan Chang, K.

Rustan M. Leino. Boogie: A Modular Reusable Verio/er for Object-
Oriented Programs. (FMCO 2005)

[Barrett07] Clark Barrett, Cesare Tinelli. CVC3. (CAV 2007)
[Baudin09] Patrick Baudin, Jean-Christophe Fillia^tre, Claude Marche', Benjamin

Monate, Yannick Moy, Virgile Prevosto. ACSL: ANSI/ISO C Speci-
o/cation Language, version 1.4. 2009.
http://frama-c.cea.fr/acsl.html

[Bierhooe09] Kevin Bierhooe. API Protocol Compliance in Object-Oriented Soft-

ware. PhD thesis, April 2009.

201

202 LIST OF FIGURES

[Bierhooe11] Kevin Bierhooe, Nels E. Beckman, Jonathan Aldrich. Checking Con-

current Typestate with Access Permissions in Plural: A Retrospective.
Peri L. Tarr and Alexander L. Wolf, editors, Engineering of Software:
The Continuing Contributions of Leon J. Osterweil, 2011, pp. 35*48.

[Bornat00] Richard Bornat. Proving Pointer Programs in Hoare Logic. (MPC

2000)

[Boyland01] John Tang Boyland, James Noble, William S Retert. Capabilities for

Sharing: A Generalisation of Uniqueness and Read-Only. (ECOOP
2001)

[Boyland05] John Tang Boyland, William S Retert. Connecting Eoeects and

Uniqueness with Adoption. (POPL 2005)

[Burdy04] Lilian Burdy, Yoonsik Cheon, David Cok, Michael Ernst, Joe Kiniry,

Gary T. Leavens, K. Rustan M. Leino, Erik Poll. An overview of
JML tools and applications. International Journal on Software Tools
for Technology Transfer, 2004.

[Bo"hme11] Sascha Bo"hme, Michal/ Moskal. Heaps and Data Structures: A Chal-

lenge for Automated Provers. (CADE 2011)

[Chargue'raud08] Arthur Chargue'raud, Franc,ois Pottier. Functional Translation of a

Calculus of Capabilities. (ICFP 2008)

[Clarke98] David G. Clarke, John M. Potter, James Noble. Ownership Types for

Flexible Alias Protection. (OOPSLA 1998)

[Coq] The Coq Proof Assistant.

http://coq.inria.fr/

[Cousot77] Patrick Cousot, Radhia Cousot. Abstract interpretation: a unio/ed

lattice model for static analysis of programs by construction or ap-
proximation of o/xpoints. (POPL 1977)

[Crary99] Karl Crary, David Walker, Greg Morrisett. Typed memory manage-

ment in a calculus of capabilities. (POPL 1999)

[Damas82] Luis Damas, Robin Milner. Principal type-schemes for functional pro-

grams. (POPL 1982)

[Detlefs05] David Detlefs, Greg Nelson, James B. Saxe. Simplify: a theorem

prover for program checking. J. ACM, 2005, pp. 365*473.

[Dietl05] Werner Dietl, Peter Mu"ller. Universes: Lightweight Ownership for

JML. Journal of Object Technology, vol. 4, no. 8, 2005, pp. 5*32.
http://www.jot.fm/issues/issue_2005_10/article1

[Dijkstra76] Edsger W. Dijkstra. A discipline of programming. Series in Automatic

Computation, 1976.

LIST OF FIGURES 203

[Drossopoulou08] Sophia Drossopoulou, Adrian Francalanza, Peter Mu"ller, Alexander

J. Summers. A Unio/ed Framework for Verio/cation Techniques for
Object Invariants. (ECOOP 2008)

[Fillia^tre03] Jean-Christophe Fillia^tre. Verio/cation of Non-Functional Programs

using Interpretations in Type Theory. Journal of Functional Program-
ming, vol. 13, no. 4, July 2003, pp. 709*745.

[Fillia^tre07] Jean-Christophe Fillia^tre, Claude Marche'. The

Why/Krakatoa/Caduceus platform for deductive program verio/-
cation. (CAV 2007)

[Floyd67] Robert Floyd. Assigning meanings to programs. Proceedings of Sym-

posia in Applied Mathematics, vol. 19, 1967, Mathematical Aspects
of Computer Science, pp. 19*32.

[FramaC] The Frama-C platform for static analysis of C programs.

http://www.frama-c.cea.fr/

[Fa"hndrich02] Manuel Fa"hndrich, Robert DeLine. Adoption and focus: practical

linear types for imperative programming. (PLDI 2002)

[Gappa] Guillaume Melquiond. Gappa: Ge'ne'ration Automatique de Preuves

de Proprie'te's Arithme'tiques.
http://gappa.gforge.inria.fr/

[Girard71] Jean-Yves Girard. Une Extension de l'Interpretation de Go"del a`

l'Analyse, et son Application a` l'E'limination des Coupures dans
l'Analyse et la The'orie des Types. (Second Scandinavian Logic Sym-
posium 1971)

[Hoare69] C. A. R. Hoare. An axiomatic basis for computer programming. Com-

munications of the ACM, vol. 12, no. 10, October 1969, pp. 576*580
and 583.

[Hubert05] Thierry Hubert, Claude Marche'. A case study of C source code veri-

o/cation: the Schorr-Waite algorithm. (SEFM 2005)

[Hubert07] Thierry Hubert, Claude Marche'. Separation Analysis for Deductive

Verio/cation. (HAV 2007)
http://www.lri.fr/~marche/hubert07hav.pdf

[Hubert08] Thierry Hubert. Analyse Statique et preuve de Programmes Indus-

triels Critiques. The`se de doctorat, Universite' Paris-Sud, June 2008.
http://www.lri.fr/~marche/hubert08these.pdf

[Hughes89] John Hughes. Why Functional Programming Matters. Computer

Journal, vol. 32, no. 2, 1989, pp. 98*107.

[Jacobs08] Bart Jacobs, Frank Piessens. The VeriFast program verio/er. Tech-

nical Report CW-520, Department of Computer Sciences, Katholieke
Universiteit Leuven, Belgium, August 2008.

204 LIST OF FIGURES

[Kanig10] Johannes Kanig. Spe'cio/cation et preuve de programmes d'ordre

supe'rieur. The`se de doctorat, Universite' Paris-Sud, June 2010.

[Kassios06] Ioannis T. Kassios. Dynamic frames: Support for framing, dependen-

cies and sharing without restrictions. (FM 2006)

[Leino98] K. Rustan M. Leino. Data Groups: Specifying the Modio/cation of

Extended State. (OOPSLA 1998)

[Leino02] K. Rustan M. Leino, Arnd Poetzsch-Heoeter, Yunhong Zhou. Using

data groups to specify and check side eoeects. (PLDI 2002)

[Leino05] K. Rustan M. Leino. EOEcient weakest preconditions. Information

Processing Letters, vol. 93, no. 6, March 2005, pp. 281*288.

[Leino10] K. Rustan M. Leino, Michal/ Moskal. Verio/cation of ample correctness

of invariants of data-structures, edition 0. Proceedings of Tools and
Experiments Workshop at VSTTE, 2010.
http://vacid.codeplex.com

[Marche'07] Claude Marche'. Jessie: an Intermediate Language for Java and C

Verio/cation. (PLPV 2007)

[Moy09] Yannick Moy. Automatic Modular Static Safety Checking for C Pro-

grams. PhD Thesis, Universite' Paris-Sud, January 2009.
http://www.lri.fr/~marche/moy09phd.pdf

[OCaml] The Objective Caml Language.

http://caml.inria.fr/

[Parkinson07] Matthew Parkinson. Class Invariants: The end of the road?.

(IWACO 2007)

[Pottier05] Franc,ois Pottier, Didier Re'my. The Essence of ML Type Inference.

Advanced Topics in Types and Programming Languages, MIT Press,
2005.

[Retert09] William S Retert. Implementing Permission Analysis. PhD thesis,

May 2009.

[Reynolds74] John Reynolds. Towards a Theory of Type Structure. (Colloque sur

la Programmation 1974)

[Reynolds02] John Reynolds. Separation logic: a logic for shared mutable data

structures. (LICS 2002)

[Robby08] Robby (editor). Proceedings of the Seventh International Workshop

on Specio/cation and Verio/cation of Component-Based Systems. Tech-
nical Report CS-TR-08-07, University of Central Florida. (SAVCBS
2008)

[Rondon08] Patrick M. Rondon, Ming W. Kawaguchi, Ranjit Jhala. Liquid Types.

(PLDI 2008)

LIST OF FIGURES 205

[Smans08] Jan Smans, Bart Jacobs, Frank Piessens. Implicit Dynamic Frames.

(FTfJP 2008)

[Smans09] Jan Smans, Bart Jacobs, Frank Piessens. Implicit Dynamic Frames:

Combining Dynamic Frames and Separation Logic. (ECOOP 2009)

[Smith00] Frederick Smith, David Walker, Greg Morrisett. Alias types. (ESOP

2000)

[Summers09] Alexander J. Summers, Sophia Drossopoulou, Peter Mu"ller. The Need

for Flexible Object Invariants. (IWACO 2009)

[Summers10] Alexander J. Summers, Sophia Drossopoulou. Considerate Reason-

ing and the Composite Design Pattern. Lecture Notes in Computer
Science, vol. 5944, 2010, pp. 328*344. (VMCAI 2010)

[Tofte94] Mads Tofte, Jean-Pierre Talpin. Implementation of the typed call-by-

value *-calculus using a stack of regions. (POPL 1994)

[Tofte97] Mads Tofte, Jean-Pierre Talpin. Region-based memory management.

Information and Computation, vol. 132, no. 2, 1997, pp. 107*176.

[Walker00] David Walker, Greg Morrisett. Alias types for recursive data struc-

tures. (TIC 2000)

[Z3] Leonardo de Moura, Nikolaj Bjo/rner. Z3, An EOEcient SMT Solver.

http://research.microsoft.com/projects/z3/

[Zhao08] Yang Zhao, John Tang Boyland. A Fundamental Permission Inter-

pretation for Ownership Types. (2nd IEEE International Symposium
on Theoretical Aspects of Software Engineering 2008)