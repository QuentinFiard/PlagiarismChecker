

Directly Reflective Meta-Programming *

Aaron Stump
Computer Science and Engineering
Washington University in St. Louis

St. Louis, Missouri, USA

stump@cse.wustl.edu

Abstract
Existing meta-programming languages operate on encodings of programs as data. This paper presents a new meta-programming language,
based on an untyped lambda calculus, in which structurally reflective programming is supported directly, without any encoding. The language features call-by-value and call-by-name lambda abstractions, as well as novel
reflective features enabling the intensional manipulation of arbitrary program terms. The language is scope safe, in the sense that variables can
neither be captured nor escape their scopes. The expressiveness of the
language is demonstrated by showing how to implement quotation and
evaluation operations, as proposed by Wand. The language's utility for
meta-programming is further demonstrated through additional representative examples. A prototype implementation is described and evaluated.

Keywords: lambda calculus, reflection, meta-programming, Church encoding, Mogensen-Scott encoding, Wand-style fexprs, alpha equivalence,
language implementation.

1 Introduction
This paper presents a new meta-programming language called Archon, inwhich programs can operate directly on other programs as data. Existing metaprogramming languages suffer from defects such as encoding programs at toolow a level of abstraction, or in a way that bloats the encoded program terms.
Other issues include the possibility for variables either to be captured or escapetheir static scopes.

Archon rectifies these defects by trading the complexityof the reflective encoding for additional programming constructs. We adopt

*This work is supported by funding from the U.S. National Science Foundation under
award CCF-0448275. Any opinions, findings, and conclusions or recommendations expressed
in this material are those of the author and do not necessarily reflect the views of the National
Science Foundation.

1

the identity function as our encoding, and add new reflective constructs to tra-verse (unencoded) program terms. These results are achieved in a scope-safe
way: variables may neither be captured by substitution nor escape their scopes.This work is the crucial first part of the

Archon project, which aims to unitereflective programming and reflective theorem proving.

In order to situate the present work with respect to the existing literature,we first survey work on several kinds of reflection in Computer Science (Section 2). We then further motivate the work by briefly discussing the role of meta-programming in the

Archon project (Section 3). In Sections 4 through 6, weconsider in detail related work by Wand [50]. We will see how Wand's language

achieves desirable properties which other reflective programming languages lack,but at the same time fails to be suitable for general meta-programming. This
requires a brief review of the Mogensen-Scott encoding used in Wand's language(Section 5). The Archon language itself is presented starting in Section 7. An
outline for the sections of the paper presenting Archon may be found in Sec-tion 3.3.

2 On Reflection
Abstractly speaking, reflection is concerned with enabling entities at one lin-guistic level (called the object level) to interact with entities at a higher level
(the meta-level). This is typically done via some kind of encoding of the meta-level entities in the object language. This abstract description is specialized by
stating what the languages are, what kind of entities are involved, and whatsort of interaction is allowed. A crucial point is how the meta-level entities are
encoded in the object language. The rest of this section categorizes related workon reflection in Computer Science according to these criteria.

Note that in related work on logical frameworks, object languages (such aslogics) are seen as being embedded in meta-languages (logical frameworks) [33].
This determination of what is object-level and what is meta-level differs fromthat of our abstract description of reflection. The difference in viewpoint arises
from a difference in emphasis. Logical frameworks are typically concerned withrepresenting other deductive systems. In reflection, the emphasis is on the
ability of an object-level language to encode entities from its own meta-level.

2.1 Reflective Programming Languages
In programming languages, the object-level language is a programming lan-guage, and the entities there are programs. Following Ferber, we may then

informally distinguish structural reflection and computational reflection [9]. Instructural reflection, the meta-level entities are determined in some way by program source code, and have a more static character. In computational reflec-tion, the meta-level entities are constituents of the running program's execution
environment, and thus are more dynamic. This paper is concerned with meta-programming, which is a form of structural reflection. We first briefly survey

2

other forms of reflective programming.Much early interest in reflective programming languages centered around
language extension via computational reflection [18, 41]. Control operators suchas

Scheme's call/cc are also computationally reflective, since they expose anaspect of the program's execution environment, namely its continuation, to the

program itself. Object-oriented programming languages like Smalltalk and
Java include computationally reflective features, for example the ability, in
Java, of a running program to replace its class loader [1, 13].Object-oriented programming languages typically also provide certain structurally reflective features, mediated by abstracted representations of classes.For example,

Java's reflection mechanism makes essentially just the names andtypes of object and class components available to running object-level programs.

Interaction is restricted mostly to inspection, although certain simple updatingoperations like setting the values of object fields are allowed. Object-oriented
languages like Smalltalk allow much more liberal forms of interaction. Run-time type information in

C++ may be considered another example [43]. Similarfunctionality is provided in functional languages by intensional polymorphism,

where code can dispatch at runtime on a term's type [6].
2.1.1 Meta-Programming
Meta-programming languages are based on a shallow encoding of program texts.In general, the kind of interaction allowed in meta-programming is to perform

arbitrary computation of output values, including program texts, from inputprogram texts. Note that this excludes meta-programs from modifying running
code. Self-modifying code can arguably be viewed as both structurally andcomputationally reflective, since the running code can be viewed as forming
part of the program's execution environment.With meta-programming, object-level programs manipulate encoded program texts as data. Languages in the LISP family, such as modern dialects
Common LISP, Emacs LISP, and Scheme, exemplify this kind of reflectiveprogramming [42, 27, 21, 28]. In these languages, it is possible to view any

program as a piece of data, and any piece of data as a program (albeit pos-sibly one which cannot execute without error, as in trying to call something,
such as a numeric literal, which is not a function). Quotation (quote) encodesprogram expressions as data, specifically nested lists of symbols. As lists, program expressions such as fi-redexes, which would otherwise evaluate, are frozen.They may be inspected and decomposed using

LISP's list constructs. For ex-ample, one may obtain the applicand
(lambda (x) x) from the quoted ap-plication
'((lambda (x) x) 3) by applying car. Similarly, evaluation (eval)transforms data into programs. Frozen terms are, so to speak, thawed, and

reduction of their redexes takes place again. Note that since LISP languagestypically include functions for obtaining the name of a symbol as a string (e.g.,
symbol->string in Scheme), detailed lexical information about variables isavailable to programs in these languages. So the reflective encoding provided
by these languages is at a rather low level of abstraction.

3

Among the research problems related to meta-programming that have beenconsidered in the literature are static typing of meta-programs, and how metaprograms deal with the scoping of variables. It is no accident that the LISPlanguages, which best exemplify meta-programming, are not statically typed.
The soft type system of Wright and Cartwright for Scheme covers the featuresof

Scheme version R4RS, which does not include the meta-programming fea-ture eval [52]. Static typing of general meta-programs appears difficult, and

the existing literature mostly considers static typing for a weaker form of meta-programming called staged computation, used also for macro systems [22, 3, 32,
10, 44]. In staged computation, programs may generate programs as data, butnot inspect or decompose them. Some work on static typing of more general
meta-programs has been done, but a full account is currently lacking [31]. Ex-tensible languages support the addition of new syntax to a host language, as well
as accompanying semantic analyses for more informative error reporting [11].
2.1.2 Variables in Meta-Programming
A meta-programming language is scope safe (or hygienic) iff variables may notbe captured or escape their scopes during computation. Dynamic variables

in Emacs LISP and Common LISP are a good example of a violation ofscope safety [30, 24].

Scheme R5RS's macro language is designed to be scopesafe [21]. Other constructs in

Scheme R5RS, however, enable violation ofscope safety, even though the language does not have dynamic variables. For a

violation of scope safety in spirit, though not technically, we have that (caddr
'(lambda (x) x)) evaluates to x. According to the R5RS language definition,
'(lambda (x) x) is a literal expression, and hence the occurrences of x in itare not variables at all, but just (unscoped) literal data. So in this example, a

variable has been created (namely, the resulting unquoted x), but not by meansof removing it from its scope. Using quasiquotation, however, the example may
be modified to give a true violation of scope safety. The following expressionextracts the variable

x from its scope, by transforming the binding lambdaexpression into a piece of literal data, and then extracting and evaluating the

quoted variable.

((lambda (y) (eval `(car (cdr (cdr ',y))))) (lambda (x) x))
Representation of variables is another issue considered in the literature onmeta-programming. Higher-order abstract syntax (HOAS), where variables in

reflected programs are represented directly using variables in meta-programs (asopposed to, for instance, de Bruijn indices or other numbering schemes) greatly
eases the burden of operating on reflected program texts, but poses challengesfor static typing [51, 38, 34]. A great variety of other representation techniques
has been considered, for example in the solutions to the POPLmark challenge [2].The details of these are not relevant to the current work, other than to note:
while HOAS can introduce technical complications, particularly for typed lan-guages, it is widely acknowledged to be the most concise and convenient variable
representation technique.

4

2.2 Reflective Theorem Proving
Another kind of reflection is studied in Mathematical Logic and AutomatedTheorem Proving [17, 14, 5, 8]. There, the object language is a logical theory.

The meta-level language is the language in which this theory is defined. Ob-ject language entities such as formulas and proofs may refer to similar entities
at the meta-level, via an encoding of meta-level syntax and semantics in thetheory. The most famous example of this is G"odel's use of reflection in the
development of his incompleteness theorems. He encodes formulas and proofsas natural numbers, with the provability predicate then expressed via a logical formula. In this way, one can prove in the theory various formulas of theform Provable p

OEq, where OE is a formula provable in the theory, and pOEq is itsencoding as a number. G"odel's results establish fundamental limits on logical

reflection: consistent theories of suitable strength cannot reflect meta-theoreticproofs of their own consistency. Hence, they can express only proper fragments
of their meta-theories.The principle use of reflection in automated theorem proving is to enable
safe extension of a trusted core prover by more efficient, untrusted reasoningprinciples. An early example is the work by Davis and Schwartz on using reflection to allow safe extension of an arithmetic theory [8]. This requires encodingformulas and proofs as numbers, as in G"odel's work. Modern theorem provers
like Coq, HOL Light, and others support richer notions of data type than justnatural numbers [15, 45]. Such provers can support reflective activities with a
lower encoding penalty than that incurred by encoding formulas and proofs asnatural numbers, since their datatypes enable much more natural encodings.
Nevertheless, there is still an encoding penalty to pay. Users wishing to doreflective proofs must work with some class of encoded objects, although some
systems allow shallower encodings than others. In Coq, for example, reflec-tive tactics typically must encode the syntactic entities such as formulas upon
which they will operate (cf. [37]). They typically do not need to encode thecode for the tactic itself, however. The mapping from Coq formulas to encoded
formulas is implemented in Coq's tactic language (Ltac), and is not susceptibleto formal reasoning, or even type checking. In provers like HOL Light, tactics
written in ML are type checked, but are otherwise outside the direct scope of theprover's proof system (although see [16]). In ACL2, meta-functions operating
on non-trivially encoded terms may be added to the trusted core once provedcorrect [17]. Non-trivially encoded terms are also used heavily in the Maude
term rewriting system [4].

3 The Archon Project
As stated above, the work reported in this paper is the first part of a projectcalled

Archon, which aims to unite reflective programming and reflective the-orem proving. The two main goals of

Archon are formal verification of struc-turally reflective programs and directly reflective theorem proving. Achieving

5

these goals is both work in progress and beyond the scope of the current pa-per. Nevertheless, we consider them briefly, to help motivate the design of the
Archon programming language.

3.1 Verification of Meta-Programs
Formal verification of structurally reflective programs written in existing lan-guages is a daunting prospect. Consider the

LISP family of languages. Theimperative nature of these languages already greatly increases the difficulty of

formal reasoning, since program state (the environment, in LISP terminology)must be handled explicitly. One could work in just a pure subset, as done
in ACL2, but then one does not support the full language, which may be adrawback for reasoning about existing programs [20]. Furthermore, the level of
abstraction of program texts is quite low. As noted above, the encoding of pro-gram texts as data in languages like

Scheme leaves some low-level details (e.g.,the string representations of variables) of program texts unabstracted. The lack

of scope safety poses another challenge, since in general, formal reasoning thenrequires reasoning about the scope of variables.

Verification of meta-programs is motivated by the observation that there aremeta-programs such as compilers which are important targets for verification
(see, e.g., [25, 26]). There is also a deeper motivation. Static type systems andother analyses can greatly aid formal verification. If a program is typable in
some non-trivial type system, there is a non-trivial theorem that holds about it,which can be used as a lemma during verification of more general properties (see,
e.g., [48]). To obtain such lemmas in a machine-checked setting, it is necessaryto reason formally about the behavior of such analyses. Since these analyses are
meta-programs (computing a type, for example, from a program text encoded asa piece of data in the language), formal verification of meta-programs is needed.

3.2 Directly Reflective Theorem Proving
The second goal of Archon is directly reflective theorem proving. Recall thatexisting reflective provers require an encoding of at least some meta-level objects

like formulas and proofs. Directly reflective theorem proving is reflective provingwithout any encoding. Instead of operating on encodings of theorem prover
structures like formulas or terms, programs like tautology checkers may operateon such structures directly. Safe extension of the prover's trusted core then
becomes more feasible, since there is no non-trivial encoding, as implementedby the Ltac code used in Coq, which falls outside the realm of the prover's
reasoning system. Reasoning about reflective operations is also easier, since itis not necessary to account for a non-trivial encoding.

3.3 The Problem and Further Outline
The crucial first step to meeting the above goals is to devise a programminglanguage with direct structural reflection, in which programs can operate di6

rectly on other programs, at an appropriate level of abstraction. The level ofabstraction of the reflective encoding in

LISP is too low, because it results ina contextual equivalence that is too fine. Recall that two program terms are

contextually equivalent iff no context can distinguish them by behaving in obser-vationally different ways (e.g., returning true for the one term and false for the
other). Programs in LISP languages can distinguish between terms which are
ff-equivalent (equivalent up to capture-avoiding renaming of bound variables).For example, building on the code given in Section 2.1.2 for extracting the

bound variable from a lambda abstraction, we can easily write a program whichreturns

#t if it is applied to (lambda (x) x), and #f if it applied to (lambda
(y) y). With a good higher-level encoding scheme, ff-equivalence of programtexts should certainly imply contextual equivalence of their encodings, and the

language should be scope safe. Going further, we can observe that for a generalmeta-programming language,

ff-equivalence of programs should coincide withcontextual equivalence of their encodings. For this implies that meta-programs

have an intensional enough view of encoded programs to be able to make all thedistinctions we consider relevant at the meta-level. For ease of formal reasoning,
the language should be pure, with no imperative features. Finally, it is desir-able for the encoding of programs to use higher-order abstract syntax (HOAS)
where applicable, since this is by far the most convenient variable representationtechnique (as discussed in Section 2.1.2).

An important step towards these goals has been taken by Wand, who achievesa minimalistic pure programming language with a reflective encoding meeting
the above criteria [50]. Unfortunately, Wand's language is not suitable for gen-eral meta-programming (though it does not need to be, for the theoretical results
of his paper). This matter is discussed in detail in the next three sections. Thesyntax and operational semantics of

Archon are presented next (Section 7), aswell as examples demonstrating
Archon's utility for meta-programming (Sec-tion 8). Section 8.4 shows how to implement the reflective primitives of Wand's

language in Archon, thus further establishing the new language's expressive-ness. A prototype implementation of

Archon is discussed and evaluated inSection 9.

4 Wand's System
Wand defines operations fexpr (for quotation) and eval which map programterms to their HOAS-based Mogensen-Scott encodings (reviewed below) and
back [50]. He proves that ff-equivalence of programs coincides with contextualequivalence of their encodings. This achieves the goal mentioned above for a
higher-level encoding of terms. The motivation for Wand's work is, in a sense, anegative one: he wishes to point out the difficulties which reflective capabilities
raise for traditional approaches to applications like compilation. These rely oncoarser notions of contextual equivalence than just

ff-equivalence, for example todo source-to-source optimizations. Such optimizations are intended, of course,

to result in terms which are not ff-equivalent to the unoptimized terms. It is

7

not Wand's aim to give an account of general meta-programming in his pro-posed system, since for his purposes, it is enough to establish the triviality of
contextual equivalence (namely, that it coincides with ff-equivalence). Indeed,Wand's system cannot be used for general meta-programming, at least not in
any obvious way. We explain why (in Section 6 below), after first reviewing hissystem.

The syntax for Wand's system is the following (cf. [50, pages 90-91]):

T ::= x | *x.T | T T | fexpr T | eval T
Here and below we use standard abbreviations from lambda calculus includingleft associativity of application, abbreviated notation for consecutively nested

lambda abstractions, and lambda abstraction with scope extending as far assyntactically possible to the right. To define the operational semantics of this
language, we first designate reduction contexts R and values V , as follows:

R ::= [] | (R M ) | ((*x.M ) R) | (fexpr R) | (eval R)
V ::= *x.M | (fexpr V )

We use a standard notion of reduction contexts R. Recall that these containexactly one occurrence of the hole [], which may be filled with a term

M with thenotation
R[M] . Reduction contexts indicate, in a compact way, the evaluationorder of the language. The operational semantics is now defined by the following

reduction rules:

R[((*x.M ) V )] ! R[[V /x]M ]
R[((fexpr V ) M)] ! R[(V pMq)]
R[(eval pM q)] ! R[M]

The second and third reduction rules rely on an encoding function p*q, definedjust below. We first observe that intuitively, ((

fexpr V ) M) calls V on theencoding of
M , where M need not be a value. Indeed, the whole point is thatarbitrary program terms

M, including ones which would otherwise reduce, arefrozen by
fexpr and presented to V . Frozen terms may then be thawed usingeval. As Wand explains in an endnote, it is necessary to include eval as a

primitive in the language, due to the way the encoding works. We will returnto this point below. The encoding is defined as follows:

pxq = *a b c d e.a xp

M N q = *a b c d e.b pM q pN qp
*x.M q = *a b c d e.c *x.pM qp(fexpr

M )q = *a b c d e.d pM qp(
eval M )q = *a b c d e.e pMq

Wand calls this encoding a Mogensen-Scott encoding, since Mogensen definesan encoding with the essential features of the above. Mogensen's encoding extends an encoding attributed to Dana Scott with the use of HOAS (higher-orderabstract syntax) in the clause for encoding lambda abstractions [29]. Since these

8

encodings appear to be less well known than, say, the Church encoding, andsince they play a crucial role both in understanding the limitations of Wand's
system and the contribution of the present work, we pause now to consider them(readers familiar with these encodings may, of course, wish to skip the following
Section).

5 The Mogensen-Scott Encoding
There are a variety of ways to encode inductive datatypes using lambda calculusterms (see, e.g., [49] or [7, Chapter 13]). Informally, the basic problem is to
define the fundamental operations of an inductive datatype as pure lambdaterms. So constructors (e.g., in

Scheme, '() and cons), testers (e.g., null?)and selectors (e.g.,
car and cdr) are to be defined in pure lambda calculus,instead of taken as primitive, as they are in

LISP languages.

5.1 The Church Encoding
Before considering the Scott encoding and its extension by Mogensen, let usrecall the Church encoding, which may be more familiar to some readers. We

encode the operations of an inductive datatype in the following way. Supposethe datatype has

n constructors, where the i'th constructor Ci has arity a(i).We encode
Ci by the following lambda term, where we write _c for c1 . . . cn:

*x1 . . . xa(i).*c1 . . . cn.ci (x1 _c) . . . (xa(i) _c)
This term takes in the a(i) arguments to constructor Ci as x1, . . . , xa(i). Itthen returns a lambda abstraction (let us call it

M) which accepts n arguments
c1, . . . , cn, one for each constructor of the datatype. These arguments are it-erators, which will be applied according to the structure of the data. This

Mthen applies the
i'th iterator to, not literally the input arguments x1, . . . , xa(i),but rather to what we might think of as the transposition of those inputs to

the iterators c1, . . . , cn. That is, each Church-encoded piece of data, such as thearguments

x1, . . . , xa(i), begins by accepting n iterators to apply according tothe structure of the data. Our term

M transposes the arguments to the con-structor, so that they apply the given iterators

c1, . . . , cn, rather than whateverother iterators they would have taken in.

A simple example helps demonstrate this encoding. Consider the inductivedatatype of the natural numbers in unary notation. There are two constructors,
S (successor) and Z (zero), where the former has arity 1 and the latter has arity0. They are Church encoded like this:

S := *x1.*s z.s (x1 s z)
Z := *s z.z

With this encoding, the first few numerals are defined as follows, and satisfy

9

the stated fi-equivalences:

0 := Z =fi *s z.z1 :=

S Z =fi *s z.s z2 :=
S (S Z) =fi *s z.s (s z)3 :=
S (S (S Z)) =fi *s z.s (s (s z))

5.2 The Scott Encoding
As the source for the Scott encoding, the Computer Science literature dependson the following citation from Curry et al.: "Dana Scott, A system of functional abstraction. Lectures delivered at University of California, Berkeley, Cal.,1962/63. Photocopy of a preliminary version, issued by Stanford University,
September 1963, furnished by author in 1968" [7, page 504]. This work appearsnot to have been subsequently published. Disregarding this bibliographic issue,
we consider the Scott encoding as follows. Given an inductive datatype pre-sented as at the start of the previous section, we encode constructor

Ci by thefollowing lambda term:

*x1 . . . xa(i).*c1 . . . cn.ci x1 . . . xa(i)
The crucial difference between this term and the corresponding term from theChurch encoding is that here, the inputs

x1, . . . , xa(i) are not "transposed"to use the iterators
c1, . . . , cn. This means that lambda abstractions occur allthroughout the encoding of a compound piece of data, unlike in Church-encoded

data, where such lambda abstractions occur only at the very top of the term.For the natural number datatype, the definition specializes as follows:

S := *x1.*s z.s x1
Z := *s z.z

With this encoding, we may obtain the first few numerals by call-by-value re-duction (denoted here by +

cbv) using S and Z:

0 := Z +cbv *s z.z1 :=

S Z +cbv *s z.s 02 :=
S (S Z) +cbv *s z.s 13 :=
S (S (S Z)) +cbv *s z.s 2

So for example, the Scott encoding of 2 may be written fully as

*s z.s (*s z.s (*s z.z))
In contrast, the Church encoding of 2 is fi-equivalent to

*s z.s (s z)
Where Church-encoded data accept iterators to apply according to the struc-ture of the term, Scott-encoded data may be viewed as accepting continuations.

10

The appropriate continuation will be called with the immediate subdata of agiven piece of data. Thus, the Scott encoding encodes data as case statements,
instead of as iterations. For example, we can define the predecessor function forScott-encoded numerals as follows (where zero is taken to be its own predecessor):

*x.x (*p.p) 0

A Scott-encoded numeral x is accepted as input by this lambda term. This x isthen immediately applied to two continuations. The first continuation will be

used when x is a successor number. The second will be used when x is zero.Whichever continuation is called, it will be called with the immediate subdata
of x. If x is zero, it has no subdata, so the continuation 0 is called with noarguments (i.e., simply returned). If

x is a successor number, its immediatesubdata is its predecessor
p. This will be given as the input to the continuation
*p.p, which simply returns it, thus producing the predecessor.

5.3 Comparison of the Church and Scott Encodings
The Church encoding seems to be more familiar to computer scientists thanthe Scott encoding. For example, the Church encoding is presented in detail

in standard programming languages textbooks like Pierce's, while the Scott en-coding is not mentioned [35]. The Church encoding does have some advantages
over the Scott encoding. As shown just above, Church-encoded data are gen-erally more concise than Scott-encoded data (though not asymptotically so).
The main advantage and perhaps the reason they are better known is thatChurch-encoded data and many common operations on them are typable in
System F [12]. Thanks to strong normalization of System F, the large class ofprograms expressible as well-typed operations on Church-encoded data (including non-trivial examples like list-sorting functions) are statically guaranteed toterminate.

Scott-encoded data, in contrast, is not in any obvious way typable in pureSystem F. They appear to require both universal and recursive types for typability. Since strong normalization fails in the presence of recursive types,we cannot establish termination of programs manipulating Scott-encoded data
just by static typing in a traditional type system. Nevertheless, the Scott en-coding enjoys two critical advantages over the Church encoding, which should
make them preferable for general programming. First, constructor terms (like
S (S Z)) evaluate to their intended encodings in call-by-value lambda calculus.This is not the case with the Church encoding, where a constructor term like

(S Z) evaluates to a value in one step as follows in the call-by-value strategy:

(S Z) ! *s z.s (Z s z)
In order to obtain the intended encoding *s z.s z, two fi-reductions would needto be performed beneath a lambda abstraction, which is not allowed with the
call-by-value or call-by-name strategy.

11

The second advantage of the Scott encoding is that constant-time selectorfunctions are easily definable, as discussed above. With the Church encoding,
in contrast, known implementations of predecessor are rather complicated, andrun in time linear in the size of the input numeral.

5.4 Mogensen's Addition to the Scott Encoding
Mogensen extends the idea of the Scott encoding using HOAS to encode untypedlambda terms [29]:

pxq = *a b c.a xp

M N q = *a b c.b pM q pN qp
*x.M q = *a b c.c *x.pM q

The crucial difference from a Scott encoding as defined in the previous sectionis in the third clause of this definition. Lambda abstractions are encoded by

using a lambda abstraction for the bound variable (in *x.pM q). So variablesare represented using variables. We will not review here the general advantages
of this representation (see the works cited in Section 2.1.2 above), but considernext the specific effect of this representation in Wand's system.

6 Meta-Programming in Wand's System
The use of the Mogensen-Scott encoding of lambda terms in Wand's systemresults in a HOAS-based encoding of lambda terms which satisfies the goals
stated in Section 3.3 above [50]. He thus accomplishes his stated objective ofshowing the triviality of contextual equivalence, and to highlight the challenges
this poses for applications like source-to-source optimization.Certain kinds of meta-programs can be written in Wand's system, as demonstrated below (Section 8.1). But Wand's language is inadequate for meta-programs which generate code, or even encodings of code, as indeed hinted
by Endnote 2 of his paper. Wand there explains that he was led to include evalas a primitive operation in the language because it is not in any obvious way
definable, given the Mogensen-Scott encoding. This limitation is not unique to
eval. There is no obvious way to define any non-trivial code-generating meta-programs (like eval) in Wand's system. The problem is that there is no way to

compute beneath a lambda abstraction. For example, as mentioned in Wand'sendnote, suppose we try to implement

eval. Mogensen gives code for eval thatworks, but only if arbitrary
fi-reduction is used. In the call-by-value setting ofWand's language, we could try something like the following:

eval := fix *eval m. m (*x.x)(

*m n.(eval m) (eval n))(
*m.*x.eval (m x))

where fix is a standard call-by-value fixpoint operator, which may be definedas:

fix := *f.(*x.f (*y.x x y)) (*x.f (*y.x x y))

12

The problem, noted by Wand, is in the third line of the term for eval above,where we try to evaluate a lambda abstraction

m by evaluating, essentially,its body, beneath a new lambda abstraction ("
*x.eval (m x)"). With call-by-value or call-by-name evaluation, the redex eval (

m x) cannot be evaluated here,since it is buried beneath a lambda abstraction. This same problem afflicts any

non-trivial meta-program generating code or encodings of code. Meta-programswhich need to recursively compute the body of a lambda abstraction cannot be
implemented (in any obvious way). For to do so as in existing approaches,they would either compute the body using a free variable which would then be
captured, or else they would compute beneath the lambda abstraction. Theformer option is disallowed by scope safety, and the latter by the evaluation
strategy. Hence, this language, despite the desirable properties of its reflectiveencoding, is not suitable for general meta-programming. We can conclude additionally that it is not sufficient, for the purposes of general meta-programming,to have

ff-equivalence of programs coincide with contextual equivalence of theirencodings.

7 The Archon Programming Language
We turn now to the definition of the Archon programming language, whichsolves the problems discussed above with existing structurally reflective languages. Archon is pure and scope safe. We have ff-equivalence of programscoinciding with contextual equivalence of their encodings, which use HOAS.
These qualities are shared with Wand's language. Like Wand's system, we arestriving in

Archon for something like minimality or independence: no lan-guage construct is directly definable using the others, in the sense that any use

of one operator can be replaced by some constant-time computable term withthe same extensional behavior. If scope safety is a form of soundness, we are
also interested in completeness. We might take completeness in this contextto mean that every scope-safe function implementable in an untyped lambda
calculus with more general, non-scope-safe meta-programming constructs (e.g.,
LISP) can be implemented in the scope-safe language. While independence andcompleteness are both desired properties of the language, proving or disproving

these must remain to future work.

Archon is suitable for general meta-programming, as demonstrated by sev-eral examples in Section 8 below. The shortcoming of Wand's language, namely

the inability to compute beneath lambda binders, is repaired in Archon. Or-thogonally,

Archon opts to place the burden of reflection on the programminglanguage, rather than the reflective encoding.

Archon adopts the identity func-tion for the encoding, at the cost of introducing new reflective programming

constructs for operating on program terms. Hence, Archon meta-programsoperate directly on raw program terms, without any encoding. This shift of the
burden of reflection from the encoding to the language is justified as follows.First, the language must already be extended in some way to allow computation
beneath lambda abstractions. Once we have begun extending the language to

13

allow for reflection, we can achieve a simpler language by shifting all reflectiveburden from the encoding to the language. This simplification has practical
benefits. In reasoning (either formally or informally) about the behavior ofmeta-programs, we can consider the manipulated programs directly, in their
natural form as programs of the language, and not via a non-trivial encoding.In contrast, with Wand's language, we must contend not only with additional
reflective language constructs, but with the overhead of the Mogensen-Scottencoding.

One quantitative measure of the simplicity of the language design is its lo-cality, in the following sense. Wand's reduction rules for

fexpr and eval requirerecursive meta-level computation to apply or undo the Mogensen-Scott encoding, for a single reduction step. In contrast, Archon's reflective constructsrequire only constant-time meta-level computation for a single reduction step.
A single step of evaluation, without any recursive meta-level evaluation, sufficesto eliminate any use of

Archon's reflective constructs, in favor of constructs ofuntyped lambda calculus.

7.1 Syntax
The syntax of Archon terms T (we also write M , N , R) appears in Figure 1.We write

x (as well as y and z) only for variables, drawn from some countablyinfinite set. We then have call-by-value

*-abstractions and call-by-name _*-abstractions, and applications (written using juxtaposition as usual). When a

call-by-value lambda abstraction appears in an application, its argument mustbe evaluated before the application can be

fi-reduced. In contrast, arguments arepassed to call-by-name lambda abstractions unevaluated. This is useful in metaprogramming for passing around raw program terms, which would otherwiseevaluate.

For meta-programming purposes, it seems required in practice to allow com-putation with open terms (i.e., terms which contain free variables). So in

Archon, (free) variables evaluate to themselves. In LISP languages, in contrast,evaluation of a free variable is not allowed (and typically causes evaluation to

abort with an error). Applications like a b, where a and b are free variables,also evaluate to themselves. Indeed, the set of values

V in Archon is somewhatmore complex than usual in call-by-value or call-by-name lambda calculus:

V ::= *x.T | _*x.T | A

A ::= x | A V

The remaining four constructs of the language are the reflective constructs,informally explained next (the formal operational semantics is given in the next
Section). We rely on no parsing conventions for Archon below, except the(standard) ones mentioned above from lambda calculus.

14

T ::= x | *x.T | _*x.T | T T | open T T | vcomp T T|

swap T | T : T T T T T T T

Figure 1: The Syntax of Archo Terms
7.1.1 Opening a Lambda Abstraction
The open construct "opens" a lambda abstraction to allow computation on itsbound variable and its body. An open expression has two subexpressions. The

first is the term to attempt to open. The bound variable and the body of thisterm, if it is a lambda abstraction, are both passed to the second argument of
open. For an artificial but representative example, the following term opens
*x.x and applies its body (x, passed as the argument for variable b) to itself:

open (*x.x) (*v b.(b b))
Since Archon is intended to be scope safe, open cannot simply return x x inthis case, for then the bound variable

x would escape its scope. The solutionadopted in
Archon is simply to rebind the variable around the result of thecomputation, using the same kind of abstraction (call-by-name or call-by-value)

as the opened lambda abstraction. So the above example term evaluates to
*x.x x. The behavior of open when its first subexpression is not a lambdaabstraction is not important. Below, we choose to have the open expression

evaluate to a rather arbitrary term. It would also be reasonable to have it abortthe computation. This construct has some features in common with a recently
proposed reflective construct called map-closure [40]. The difference is thatmap-closure operates on environments in closures, not lambda abstractions.
Hence, it is a computationally rather than structurally reflective construct, andnot suitable in any obvious way for general meta-programming.

7.1.2 Comparing Variables
For some meta-programs it is necessary to test whether two free variables arethe same or different. This is done in

Archon using the vcomp construct. Theterm vcomp
T1 T2 evaluates to true if T1 and T2 are identical free variables.Otherwise it evaluates to false. Here and below, the expressions true and false

are abbreviations for Scott-encoded call-by-name booleans _*x._*y.x and _*x._*y.y.Note that the Scott and Church encodings coincide on enumerated datatypes
like the boolean datatype. Note also that using call-by-name abstractions here(and in other Scott-encoded data) means that unused cases are not executed
when a piece of data is used as a case construct.

15

7.1.3 Swapping Lambda Abstractions
The operation swap is used to swap the order of consecutive lambda bindings.For example, our operational semantics will give us the following evaluation

(where +, defined below, is the evaluation relation):

swap (*x y.x) + *y x.x
It may not be obvious to the reader why this operation is practically useful, butit turns out to be necessary for a class of practical meta-programs, in particular
those which must recursively traverse Archon terms to compute some resultingterm, using the decomposition operator discussed next. An example of such a
meta-program is given later, in Figure 9.It is not clear if

swap can be defined using other language features. Onemight consider defining it by opening the lambda abstraction twice, and then

using a recursive function to traverse the body and swap the variables (aided,for example, by variable comparison) wherever they occur. But such traversals,
as just mentioned, appear to need swap already. So it may not be possible todefine

swap in terms of other operations. This question must be left open. Justas for open, the behavior of swap when its subexpression does not evaluate to

a consecutively nested lambda abstraction is not important, and is chosen to bea rather arbitrary term.

7.1.4 Decomposition
The final construct of Figure 1 is called decomposition. This is an inten-sional case-analysis construct, which takes apart raw (i.e., unevaluated) program

terms, and passes their immediate subterms as arguments to the appropriatebranch of the case. In the decomposition

T : T T T T T T T
the first term is the one being decomposed, and the remaining seven termsare the terms to use for each of the seven kinds of constructs, in the order
in which they appear in Figure 1. Observe that Archon does have exactlyseven constructs, if we lump call-by-value and call-by-name lambda abstractions
together, as we do. They are distinguished in decompositions by passing aScott-encoded boolean to the case for lambda abstractions, which is true for
call-by-value, and false for call-by-name. For a simple example of the use ofdecomposition, the following term evaluates to

b a (here writing in the unusedcases for an arbitrary lambda term):

(a b) : (*x y.y x)
A final note on decomposition is that decomposing a lambda abstraction doesnot access its subexpressions, since this functionality is already provided by
open.

16

7.2 Operational Semantics
A big-step operational semantics for Archon is given in Figures 2, 3, and 4.The judgment

T + R means that the term T evaluates to R. In the rules
E-Lam and E-OpenLam, ** is either lambda abstraction operator (* or _*), asare

*1 and *2 in the rule E-Swap. Variable renaming is accounted for explicitlyin
E-OpenLam and by capture-avoiding substitution, denoted [T2/x]T1. It isnecessary, in general, to rename the bound variable in

E-OpenLam, to avoidclashes with existing free variables.

The choice of *x.false for the result of attempting to open or swap a termwhich is not a lambda abstraction or a consecutively nested lambda abstraction
in rules E-Open and E-Swap, respectively, is not essential. There is also some ar-bitrariness in whether or not to evaluate the first subexpressions of open, swap,
and vcomp expressions. The language is not greatly changed by the choice, foreach of those three constructs, of whether to evaluate this subexpression before
reduction or not.Note that evaluation of terms without open, vcomp, swap, and decomposition (Figure 2) is contained in the fi-equivalence relation (on open terms) ofthe standard untyped

*-calculus, if we collapse both lambda abstractions to thestandard one. The meta-level function FV used in

E-OpenLam is defined in astandard way to give the set of free variables of a term.

7.3 Meta-Theory
The side condition in E-OpenLam prevents confusion of the newly introducedfree variable with other free variables. The only other potential opportunity for

variable capture is in applying substitutions, but these are capture-avoiding bydefinition. This fact and the following theorem, easily proved by induction on
the structure of computations, establish scope safety of the language:
Theorem 1 For all terms T and R, if T + R, then FV(R) ` FV(T ).
The following theorem can also be established. Together with the implementabil-ity of a test for

ff-equivalence in the language (Section 8.2), it suffices to provethat
ff-equivalence of programs coincides with contextual equivalence.

Theorem 2 For all ff-equivalent terms T and T 0, if T + R, then T 0 + R0where

R0 is ff-equivalent to R.

Proof. The proof is by induction on the structure of T + R. We consider justthe case for

E-OpenLam. We have

T2 y [y/x]T1 + R1 y 62 FV(**x.T1) [ FV(T2)

open (**x.T1) T2 + **y.R1

and also \Gamma  ` (open (

**x.T1) T2) =ff (open (**x0.T 01) T 02)

17

x + x E-Var
**x.T + **x.T E-Lam
T1 + *x.R1 T2 + R2 [R2/x]R1 + R

T1 T2 + R E-AppCbv

T1 + _*x.R1 [T2/x]R1 + R

T1 T2 + R E-AppCbn

T1 + R1 T2 + R2 R1 not a lambda abstraction

T1 T2 + R1 R2 E-App

Figure 2: Evaluation of Standard Constructs

T2 y [y/x]T1 + R y 62 FV(**x.T1) [ FV(T2)

open (**x.T1) T2 + **y.R E-OpenLam

T1 not a lambda abstraction

open T1 T2 + *x.false E-Open

vcomp x x + true E-VcompEqVars
T1 6j T2 or T1 or T2 not a variable

vcomp T1 T2 + false E-Vcomp

T + *1x.*2y.R
swap T + *2y.*1x.R E-SwapLam

T + R1 R1 not a consecutively nested lambda abstraction

swap T + *x.false E-Swap

Figure 3: Evaluation of Swap, Open, and Vcomp

18

T1 z + R
z : T1 T2 T3 T4 T5 T6 T7 + R E-DecompVar

T2 true *z.M + R
(*z.M ) : T1 T2 T3 T4 T5 T6 T7 + R E-DecompCbv

T2 false _*z.M + R
(_*z.M ) : T1 T2 T3 T4 T5 T6 T7 + R E-DecompCbn

T3 M N + R
(M N ) : T1 T2 T3 T4 T5 T6 T7 + R E-DecompApp

T4 M N + R
(open M N ) : T1 T2 T3 T4 T5 T6 T7 + R E-DecompOpen

T5 M N + R
(vcomp M N ) : T1 T2 T3 T4 T5 T6 T7 + R E-DecompVcomp

T6 M + R
(swap M) : T1 T2 T3 T4 T5 T6 T7 + R E-DecompSwap

T7 M M1 M2 M3 M4 M5 M6 M7 + R

(M : M1 M2 M3 M4 M5 M6 M7):

T1 T2 T3 T4 T5 T6 T7 + R

E-DecompDecomp

Figure 4: Evaluation of Decomposition

19

From these facts, we get y 62 FV(**x0.T 01) [ FV(T 02). Hence, we have

T2 y [y/x]T1 =ff T 02 y [y/x0]T 01
The induction hypothesis may now be applied to obtain R0 =ff R with

T 02 y [y/x0]T 01 + R01
We can then obtain the desired evaluation judgment by applying E-OpenLam,with

**y.R1, which is easily seen to be ff-equivalent to **y.R01.

8 Meta-Programming Examples
We now consider meta-programming examples in Archon. We may distin-guish meta-programs which recursively inspect code from meta-programs which
also recursively produce it. The former class can be implemented in Wand'slanguage, since inspection of Mogensen-Scott encoded lambda terms is supported. As discussed in Section 6, the latter class is not in any obvious wayimplementable, except in trivial cases (e.g., constant functions).

Archon canimplement both kinds of meta-programs, and has some advantages for implementing code-inspecting meta-programs. So we begin by comparing Archonand Wand's language on a meta-program which is canonical for Wand's purposes, namely testing arbitrary terms for ff-equivalence. Note that this is prov-ably not implementable in untyped lambda calculus, so both Wand's language
and Archon are more expressive (see, e.g., [23, Section 3.3.4]). Section 8.3gives another representative meta-program, namely to compute from

n and fthe function
*x.f n x, where f n denotes n-fold application of f.

8.1 Alpha Equivalence Test in Wand's System
In Wand's system, we can define a test eq for ff-equivalence of encoded termsas a term of the language. This eq cannot take in arbitrary terms and then

encode them itself using fexpr, since evaluation of an application of eq to twoarguments will cause those arguments to be evaluated. So it must operate
on Mogensen-Scott encoded terms (cf. the family Eq of terms defined in [50,Figure 1]). It must furthermore operate only on closed lambda terms, since it
has no means to inspect free variables. Indeed, as eq traverses terms, it mustsubstitute some entities which it can inspect for all the bound variables retained
in the Mogensen-Scott encoding. It may use Scott- or Church-encoded naturalnumbers for this purpose. The number to introduce for the next bound variable
it encounters must be taken as an additional input to eq.
8.1.1 Helper Functions
The code for eq makes use of several defined helper functions. We use a standardcall-by-value fixed point operator fix, such as given in Section 6. We assume

20

S is the successor function in whichever encoding of natural numbers we areusing, and eqnat is the equality test for natural numbers (straightforwardly implementable in both the Scott and Church encodings). We also use and as anabbreviation for a standard implementation of conjunction on Scott-encoded
booleans. It is helpful also to define several operations on Mogensen-Scott en-coded programs ("

x") which use one continuation ("t") when encoded data hasa certain form (e.g., is an encoded application), and another ("

f") when itdoes not have that form. Writing F1 as an abbreviation for
*y.f and F2 as anabbreviation for
*y1 y2.f , we have

on app := *x t f.(x F1 t F1 F1 F1)on lam :=

*x t f.(x F1 F2 t F1 F1)on fexpr :=
*x t f.(x F1 F2 F1 t F1)on eval :=
*x t f.(x F1 F2 F1 F1 t)

So we have on app p(

a b)q (*x y.x) false

evaluating to a, and

on app p(*x.x)q (*x y.x) false
evaluating to false. We also take "let x = T1 in T2" to abbreviate (*x.T2) T1,as usual.

8.1.2 The Code for eq
The code for eq in Wand's system is given in Figure 5. The function eq takesinput

n for the next number to introduce for a bound variable, and inputs s and
t for the closed Mogensen-Scott encoded terms to compare for ff-equivalence.The basic idea of this code is first to do a case analysis on

s, and then, in eachcase, a subsequent case analysis on
t. Recall from Section 5.2 that Scott-encodeddata are effectively their own case analyses. So to perform a case analysis on

s, we apply it to five continuations, one for each of the five syntactic forms scould have. In each case, we perform the subsequent case analysis on

t using thehelper functions from the previous Section. When
s is a lambda abstraction (inthe third case), we apply that lambda abstraction to the next natural number to

use for its bound variable. This, of course, causes the number to be substitutedfor the bound variable. It can then be inspected in the case for variables (the
first case).

8.2 Alpha Equivalence Test in Archon
The Archon implementation of a test eq for ff-equivalence is similar to the im-plementation above in Wand's system. Here, we factor out recursively checking

equality of constructs with two subterms as eq2, to keep the code more concise.One advantage of implementing eq in

Archon is that we can test ff-equivalenceof program terms containing free variables. Furthermore, it is convenient not to

21

have to introduce numbers for bound variables. Also, we do not need to assumethat those terms are in an encoded form, since

Archon meta-programs operatedirectly on raw program terms.

8.2.1 Helper Functions
We use standard helper functions and and beq for conjunction and equality teston Scott-encoded booleans. We make use of functions similar in spirit to the

functions like on app in the implementation in Wand's system above. Below wewrite F1 as an abbreviation for _

*m.f , and similarly F2 for _*m n.f , and F8 for_
*m m1 m2 m3 m4 m5 m6 m7.f . The functions are then:

on lam := _*u t f.u : F1 t F2 F2 F2 F1 F8

on app := _*u t f.u : F1 F2 t F2 F2 F1 F8
on open := _*u t f.u : F1 F2 F2 t F2 F1 F8
on vcomp := _*u t f.u : F1 F2 F2 F2 t F1 F8

on swap := _*u t f.u : F1 F2 F2 F2 F2 t F8
on decomp := _*u t f.u : F1 F2 F2 F2 F2 F1 t

We also define nfix as follows, for a standard call-by-name fixpoint operator:

nfix := *f.(*x.f (_*y.x x y)) (*x.f (_*y.x x y))
This operator must be used instead of fix, since the Archon implementationof eq uses call-by-name lambda abstraction to receive the two terms to test for

ff-equivalence.The

Archon code for eq also needs a helper function beta reducek for per-forming a single

fi-reduction. The basic idea of this function is that given twoterms, where the first term

M is either of the form *x.B or of the form _*x.B, andthe second is
N ; it should return [N/x]B. We cannot return this term directly,without risk that it might reduce. So we return it instead via a continuation,

provided as a third argument. Here and below, let I abbreviate *z.z. The codefor this helper function is the following, which requires some explanation (note
that is used here just as another variable, with the name chosen to indicateinformally that it is not subsequently used):

beta reducek := _*M N k.let M1 = open

M _*x B.*z.B inlet M2 =
open (_*y.y) (_* y.M1 y) inlet
R = M2 N in((open

R _* b.k b) I)

The action of this code is rather subtle, but it well illustrates the power ofthe open construct. Our idea in computing [

N/x]B from *x.B and N is illus-trated informally by the following transformation sequence (the case for _

*x.Bis similar):

(*x.B) N ; (*x.*z.B) N ; (_*x.*z.B) N ; *z.[N/x]B

22

eq := fix *eq n s t.(

s (*x.eqnat x t)(

*s1 s2.on app t (*t1 t2.and (eq n s1 t1) (eq n s2 t2)) false)(
*s1.on lam t (*t1.eq (S n) (s1 n) (t1 n)) false)(
*s1.on fexpr t (*t1.eq n s1 t1) false)(
*s1.on eval t (*t1.eq n s1 t1) false))

Figure 5: Test for ff-Equivalence in Wand's System

eq := nfix *eq._*s t.let eq2 =

*on op._*m n.(on op

t (_*m2 n2.and (eq m m2) (eq n n2))false) in

(s : (vcomp s t)(_

*cbv1 s.on lam

t (_*cbv2 t.and (beq cbv

1 cbv2)((open

s _*x tb.(beta reducek t x (eq tb)))

I))false)

(eq2 on app)(eq2

on open)(eq2
on vcomp)(_
*m.on swap t (eq m) false)(_
*m0 m1 m2 m3 m4 m5 m6 m7.on decomp

t(_
*n0 n1 n2 n3 n4 n5 n6 n7.(and (eq

m0 n0) (and (eq m1 n1)(and (eq
m2 n2) (and (eq m3 n3)(and (eq
m4 n4) (and (eq m5 n5)(and (eq
m6 n6) (eq m7 n7)))))))))false))

Figure 6: Test for ff-Equivalence in Archon

23

In more detail, we first wish to insert a dummy binder beneath the *x, so thatapplying the lambda abstraction to

N will not trigger reductions in B. So wefirst want to compute a term M1 defined to be

*x.*z.B. Then we want toconvert the call-by-value
*x to a call-by-name _*x, so that applying the lambdaabstraction to
N will not cause N to evaluate. So we next want to computea term M2 defined to be _

*x.*z.B. Finally, we can achieve our fi-reduction byapplying this M2 directly to

N , and allowing reduction in Archon to performthe substitution. This results in a term R of the form

*z.[N/x]B. It sufficesnow just to open this lambda abstraction and apply the continuation

k to itsbody (which is [
N/x]B). Whatever result the continuation produces will thenbe closed beneath a binding

*z, since uses of open (such as this one opening R)always rebind the variable of the opened lambda abstraction. To eliminate this

dummy binding, we apply the result to an arbitrary value (here, I).We leave it to the reader to confirm that the code above computes M1 as
specified, and just consider in detail the computation of M2. The code forbeta reducek computes M2 ("_

*x.*z.B") from M1 as follows. It opens a newlambda abstraction _
*y.y, using _* y.M1 y. The latter term accepts the boundvariable (
y, received via variable ) and the body (also y, received by variable
y) of this _*y.y. It then applies M1 to y. This results in *z.[y/x]B. The resultof this computation is then closed beneath a rebinding _

*y, since this is alwayshow evaluation of an
open expression finishes. So the result is _*y.*z.[y/x]B,which is
ff-equivalent to the desired term _*x.*z.B. The use of variable y here ispurely for readability of the example. Thanks to the scope safety of

Archon,the code works just as well if we use
x instead of y.This example provides some small evidence for completeness. It shows that

an operation, namely changing a lambda abstraction from call-by-value to call-by-name, which one might otherwise doubt possible in

Archon, is in fact im-plementable. Similar code can convert a call-by-name to a call-by-value abstraction.
8.2.2 The Code for eq
Figure 6 gives the Archon code for the test eq for ff-equivalence. Its basic struc-ture resembles that of the code in Wand's language (Figure 5). Some differences

have already been noted. The top-level case analysis is performed using Archon's decomposition operator, instead of by application of a Mogensen-Scottencoded term. The first case, for variables, is implemented using vcomp, as expected. The case for lambda abstractions (the second case) is the most complex.Naturally, for two lambda abstractions to be

ff-equivalent, they must either bothbe call-by-value or both call-by-name. This is checked by beq cbv

1 cbv2. To con-tinue the comparison, we wish to compare the bodies. But we must make sure

the bodies are expressed using the same variable. So we open one lambda ab-straction ("

s"), obtain its bound variable ("x") and do a single fi-reduction of
t on x (using beta reducek, defined in the previous Section). This causes uses of
t's bound variable to be replaced in its body ("tb") by x. We may then comparethe two bodies. The lambda binder placed around the (boolean) result is then

24

iter h := fix *iter h x n f.(

n (*p.let r = iter h x p f in((

open r _*x rb.*d.f rb) I))
*d.x)

iter := *n f.(swap (open (*x.x) *x .iter h x n f )) I
mult := *n.(swap (open (*m.m) *m .iter h zero n (plus m))) I

Figure 7: Statically Iterated Function Application in Archon

removed by applying to I (defined, as stated above, to be *z.z).
8.3 Statically Iterated Function Application
We implement a familiar meta-programming example in Archon, namely stat-ically iterated function application. The problem is to compute from

n and fthe function
*x.f n x, where fn denotes n-fold application of f. We rely here onthe helper function fix, defined exactly as above for Wand's language; as well as

zero, succ, and plus for Scott-encoded unary numbers. A rather simple functioncan build

fn x from f , n, and x. If the function f is a lambda abstraction (as ingeneral we would expect it to be), then some care must be taken to return

f n xin such a way that it does not prematurely reduce. The code iter h in Figure 7

achieves this using the following idea. We return code from iter h underneatha dummy lambda abstraction. To access the result of a recursive call, we must
then open this dummy lambda abstraction, access the body ("rb"), and thenplace the result beneath a new dummy lambda abstraction ("

*d.f rb"). Sinceopening the first dummy lambda abstraction rebinds the dummy variable, we

end up with two dummy lambda abstractions at the start of the term. We caneliminate the first one simply by applying the result of the open to some arbitrary value (here, I). Then to build the function *x.f n x, the Archon termiter in the figure just needs to open a new lambda abstraction ("

*x.x") anduse iter h to build
*d.f n x. When the open returns, we have *x.*d.f n x. Toeliminate the dummy binding of

d, iter just swaps the two lambda abstractionsand applies the result to an arbitrary value ("

I"). A similar idea is used in thethird piece of code in the figure, for multiplication by statically iterated addition

(cf. [32, Section 2]).

8.4 Encoding and Decoding in Archon
We can implement Mogensen-Scott encoding and decoding functions (corre-sponding to

fexpr and eval in Wand's language) in Archon as follows. Fig-ure 8 first defines the Mogensen-Scott encoding for

Archon terms, and thengives an
Archon term which when applied to a term t, evaluates to ptq (seeFigure 8). The crucial ideas are the use of call-by-name lambda abstractions

25

to input raw program terms, and the use of open to recurse on the bodies oflambda abstractions. Correctness of the code can be expressed like this:
Theorem 3 For all terms T , encode T + pT q.

Figure 9 defines the decoding function for the Mogensen-Scott encoding of
Archon terms, and then gives an implementation in Archon. Notice thatwhere the encoding function uses

Archon's decomposition construct, the de-coding function may just apply the Scott-encoded data as a case statement. As

for the example of iterated function application above, the crucial idea is toreturn expressions beneath a dummy lambda abstraction (binding variable

d),in order to prevent decoded expressions from reducing. The bodies of lambda

abstractions are accessed using open*, defined as follows:

open* := *x._*y.open x y
This term works just like open except that it evaluates its first argument. Itis used in the code for decode to cause the recursive calls to execute instead
of intensionally analyzing them. (Recall from Section 7.2 that for inessentialreasons, we have designed the operational semantics of

open so that it does notevaluate its first argument.) Also, recall that, as stated above,

I is defined tobe
*z.z.The only complication that arises is for the case of lambda abstractions

(the second case in the Archon code of Figure 9). After the body has beendecoded and evaluation of the open expression completes, we have a dummy
lambda abstraction trapped beneath the binding that has been replaced by theevaluation of open. This is similar to the situation with iter in Section 8.3.
We just swap the two bindings using swap. For example, the Mogensen-Scottencoding of _

*x.x is

*V L A O C S D.L false _*x.*V L A O C S D.V x
If decode is called on this term, the code in the second case of Figure 9 tells usfirst to open the

*x and recursively decode the body (decode F 0). This gives usjust
x, frozen beneath a dummy lambda abstraction. When the open expressionfinishes, we thus have _

*x.*d.x. To finish decoding the lambda abstraction, weneed to pull the
*d out from beneath the _*x. This is done (by the code in thesecond case) using

swap, which yields *d._*x.x, as desired.In all the other cases, a combination of open and call-by-name abstraction is

used to move live code from under dummy abstractions and reassemble that codeunder a new dummy abstraction. Since open always replaces the bound variable
(in this case, a now unused dummy), it is necessary to apply the resulting term toseveral arbitrary terms (here,

I) to eliminate the unused dummies. Correctnessof the implementation can be expressed as follows:

Theorem 4 For all terms T , decode pT q + *d.T .

26

pxq = *V L A O C S D.V x
p*z.T q = *V L A O C S D.L true *z.pT q
p_*z.T q = *V L A O C S D.L false _*z.pT q
pT1 T2q = *V L A O C S D.A pT1q pT2q
popen T1 T2q = *V L A O C S D.O pT1q pT2q
pvcomp T1 T2q = *V L A O C S D.C pT1q pT2q

pswap T q = *V L A O C S D.S pT q
pT : T1 T2 T3 T4 T5 T6 T7q = *V L A O C S D.

D pT q pT1q pT2q pT3q

pT4q pT5q pT6q pT7q

encode := nfix *encode._*t.t :(

*x.*V L A O C S D.V x)(
*b F. let r = open F (*x._*F 0.encode F 0) in

*V L A O C S D.L b r)(_
*M N. let r = encode M inlet

s = encode N in *V L A O C S D.A r s)(_
*M N. let r = encode M inlet

s = encode N in *V L A O C S D.O r s)(_
*M N. let r = encode M inlet

s = encode N in *V L A O C S D.C r s)(_
*M.let r = encode M in *V L A O C S D.S r)(_
*M M1 M2 M3 M4 M5 M6 M7.let

r = encode M inlet
r1 = encode M1 inlet
r2 = encode M2 inlet
r3 = encode M3 inlet
r4 = encode M4 inlet
r5 = encode M5 inlet
r6 = encode M6 inlet
r7 = encode M7 in
*V L A O C S D.D r r1 r2 r3 r4 r5 r6 r7)

Figure 8: Mogensen-Scott Encoding and Its Implementation in Archon

27

x*V L A O C S D.V xy = x
x*V L A O C S D.L true *x.T y = *x.xT y
x*V L A O C S D.L false _*x.T y = _*x.xT y

x*V L A O C S D.A T1 T2y = xT1y xT2y
x*V L A O C S D.O T1 T2y = open xT1y xT2y

x*V L A O C S D.C T1 T2y = vcomp xT1y xT2y

x*V L A O C S D.S T y = swap xT y
x*V L A O C S D.D T T1 T2 T3

T4 T5 T6 T7y = xT y : xT1y xT2y xT3y

xT4y xT5y xT6y xT7y

decode := fix *decode.*t.t(

*x d.x)(
*b F.swap (open* F (* .*F 0.decode F 0)))(
*M N. (open* (decode M) (* ._*M0.

open* (decode N ) (* ._*N 0. *d.M 0 N0))) I I)(
*M N. (open* (decode M) (* ._*M0.open* (decode

N ) (* ._*N 0. *d.open M 0 N 0))) I I)(
*M N. (open* (decode M) (* ._*M0.open* (decode

N ) (* ._*N 0. *d.vcomp M0 N 0))) I I)(
*M.(open* (decode M) (* ._*M0. *d.swap M0)) I)(
*M M1 M2 M3 M4 M5 M6 M7.(

open* (decode M ) * ._*M 0.open* (decode

M1) * ._*M 01.
open* (decode M2) * ._*M 02.
open* (decode M3) * ._*M 03.open* (decode

M4) * ._*M 04.
open* (decode M5) * ._*M 05.open* (decode

M6) * ._*M 06.
open* (decode M7) * ._*M 07.

*d.(M : M 01 M02 M 03 M04 M 05 M 06 M07)))
I I I I I I I I)

Figure 9: Mogensen-Scott Decoding and Its Implementation in Archon

28

9 Implementation
As pointed out by Wand, in any language where ff-equivalence of program termscoincides with contextual equivalence of their encodings, compilation steps like
source-to-source optimization are rendered unsound. Sound, efficient imple-mentation of structurally reflective languages like

Archon is thus a non-trivialissue. It is not an insuperable one, however. For example, source-to-source

optimization could be allowed for programs which are not analyzed reflectively,as determined by a static analysis. Furthermore, while source-to-source optimization is unsound in general, it may still be possible to design more efficientabstract machines for

Archon, incorporating optimizations to the entire oper-ational semantics. Exploring these ideas must remain to future work.

This section discusses initial efforts at an graph-reducing interpreter. Ap-proaches based on compilation to an abstract machine result in large performance gains over interpretation, and are considered necessary for serious im-plementation. Nevertheless, interpretation is the appropriate starting point for
a language with novel constructs like Archon's (cf. [19]). The prototype Archon interpreter is written in just under 1000 lines of Java, version 1.4.2. Itmay be downloaded from

http://cl.cse.wustl.edu/archon/, together withall the examples considered in this paper. Since

Java source code may be com-piled to native code using the
gcj compiler, we obtain a reasonably efficientexecutable. The use of a garbage-collected language eliminates the burden of

implementing garbage collection in the interpreter. For this reason, functionallanguages are also a good choice for implementation of

Archon.To reduce a
fi-redex, a pointer (which we will call the assigned variablepointer) is set from the in-memory representation of the bound variable to the

argument value. Most of the computation time in graph reduction is consumedcopying lambda abstractions. Lambda abstractions must be copied, in order
to avoid setting the same assigned variable pointer in two different ways fortwo different applications. We will call the operation of duplicating lambda
expressions cloning. The Archon interpreter uses three optimizations to reducethe amount and cost of cloning:

1. Do not clone lambda abstractions the first time they are applied in a

fi-reduction. Only clone them for reductions after the first one.

2. Clone lambda abstractions only when following an assigned variable pointer.This is justified because the only point in which sharing is introduced to

the term graph is when the assigned variable pointer is set from a variablewhich is used more than once.

3. Avoid following assigned variable pointers during cloning.

Optimization 1 is easy to implement: one just sets a flag on the in-memory(possibly shared) representation of a lambda abstraction, after the first

fi-reduction in which it is applied. If another application of that lambda abstraction is fi-reduced later, the abstraction must be cloned. Optimization 3 requires

29

Benchmark -1 - 3 -1 + 3 +1 - 3 +1 + 3
eq.a 53.1 (118,586) 6.8 (202,888) 9.1 (32,690) 3.4 (90,113)
fact.a 7.2 (6,563) 0.3 (13,118) 0.2 (1,639) 0.2 (4,102)

Figure 10: Effect of Optimizations on Running Time (Times in Seconds)
more care to implement soundly. When a lambda abstraction binding variable
x is cloned, we set the assigned variable pointer to point to the new variable(call it

x0) which the cloned abstraction will contain. When we encounter a useof any variable

y during cloning, we thus should replace it with the expression
e that its assigned variable pointer points to, if that expression e is a variable.If

e is not a variable, we need not replace y with e. We can dereference thepointer later, if we ever need to. The only issue is that we must be sure that

no occurrence of the bound variable x we are currently cloning occurs in e (forthen, failing to dereference

y will leave behind occurrences of x which shouldhave been replaced with
x0). An occurrence of a bound variable in e pointed toby
y can arise only during evaluation of an open expression, when a fi-reductionoperating on an open term may cause

e to get assigned to y. Hence, for sound-ness of optimization 3, it is sufficient to dereference all assigned variables in the

results of computation of open expressions. This is implemented in Archonsimply by running through such a result after evaluation of an open expression
finishes, and dereferencing all assigned variable pointers.

9.1 Effect of the Optimizations
Figure 10 shows the effect of two of the three cloning optimizations discussedabove, on two benchmarks. The

eq.a benchmark evaluates "eq eq eq", whereeq is the term defined in Section 8.2 testing

ff-equivalence of two input terms.In this case, the benchmark is testing whether eq is

ff-equivalent to itself (itis, of course). The second benchmark is computing factorial of the number

6, expressed as a Scott-encoded unary number. All times are the averages oftimes for three runs of the same benchmark. The machine used has an 800
MHz Intel Pentium III processor with 512 MB main memory and 512 KBcache. The version of

gcj used is 3.4.4. A "+1" or "-1" in the headingindicates whether optimization 1 of the previous Section is enabled or disabled,

respectively (similarly for "+3" and "-3"). Optimization 2 is not easy to disablein the implementation, and so its effect is not measured here.

The eq.a benchmark takes 295,146 fi-reductions for Archon to evaluate,and

fact.a take 12,381. The number of times an expression is cloned is givenin Figure 10 in parentheses. Note that with optimization 3 turned off, there are

fewer clonings, because each cloning does more work (by following all assignedvariable pointers).

30

9.2 Comparison with Other Interpreters
We compare Archon with the ghci interpreter that ships as part of the Glasgow Haskell Compiler (GHC), and also with the MzScheme interpreter,that ships with the

DrScheme programming environment [47, 46]. Not sur-prisingly for tools that have been under development for many years, these

interpreters are much faster than the Archon interpreter. Nevertheless, thegap is not as huge as one might expect.

The simple benchmark used is squaring the factorial of 5 (as a Scott-encodedunary number). Thanks to its support for higher-rank polymorphism and recursive types, GHC can type check code operating on Scott-encoded numbers.
Scheme is untyped, and hence easily supports Scott-encoded data. The Archon, Haskell, and Scheme programs for this benchmark are given in theAppendix. Note that the implementation of multiplication and factorial used

in all three languages is deliberately inefficient: the usual, more efficient im-plementations of both functions pass their arguments to their recursive calls
in the opposite order to the one used here. (The version of factorial used forthe benchmarks in Section 9.1 is the more efficient one.) The deliberate inefficiency is introduced to get a benchmark that takes long enough for ghci and
MzScheme to evaluate, without causing the Archon implementation to taketoo long to complete. The machine used for this experiment has a 1.2 GHz Intel

Core Duo processor with 1.5 GB main memory and a 2 MB cache. Even thoughboth

MzScheme and GHC ship with compilation capabilities, we deliberatelycompare only with their interpreters. The benchmark takes 28.9 seconds to evaluate with Archon, 2.5 seconds with ghci version 6.6.1, and 3.6 seconds with
MzScheme version v371, with just-in-time compilation off. So we see Archonis around an order of magnitude slower than the other interpreters.

10 Conclusion
This paper has defined the Archon directly reflective meta-programming lan-guage. This language satisfies a number of desirable properties, including purity and scope safety. Programs are encoded using higher-order abstract syntax(since they are trivially encoded as themselves).

Archon is also suitable forcode-generating meta-programs. The language extends untyped lambda calculus with call-by-value and call-by-name abstractions, as well as novel reflectivefeatures for swapping consecutive nested lambda binders, opening lambda abstractions to compute on their bodies, comparing free variables, and decompos-ing arbitrary program terms. An optimized interpreter has also been presented.
As we have seen, Archon is substantially closer to completeness than Wand'ssystem, in which code-generating meta-programs are not (in any direct way)
generally implementable. Whether or not the proposed language is actuallycomplete is left open.

Acknowledgments. Many thanks to the anonymous reviewers of previ-ous versions of this paper for their thorough reading and insightful criticisms.

31

Their comments on earlier versions helped greatly improve this paper. Thanksto Walid Taha for helpful conversations on meta-programming and the ideas
of the current paper. Thanks also to Matthew Bensley for contributions tothe

Archon project including help implementing several of the examples fromSections 8 and 9.

References

[1] K. Arnold, J. Gosling, and D. Holmes. The Java Programming Language.Prentice Hall, 2000.

[2] B. Aydemir, A. Bohannon, M. Fairbairn, J. Foster, B. Pierce, P. Sewell,D. Vytiniotis, G. Washburn, S. Weirich, and S. Zdancewic. Mechanized

metatheory for the masses: The POPLmark Challenge. In Proceedingsof the Eighteenth International Conference on Theorem Proving in Higher
Order Logics (TPHOLs 2005), 2005.
[3] C. Chen and H. Xi. Meta-Programming through Typeful Code Represen-tation. Journal of Functional Programming, 15(6):797-835, 2005.

[4] M. Clavel, F. Dur'an, S. Eker, P. Lincoln, N. Mart'i-Oliet, and J. Meseguer.Metalevel Computation in Maude. In Proc. 2nd Intl. Workshop on Rewriting Logic and its Applications, Electronic Notes in Theoretical ComputerScience. Elsevier, 1998.

[5] R. Constable. Using reflection to explain and enhance type theory. In Proofand Computation, NATO ASI Series. Springer-Verlag, 1994.
[6] K. Crary, S. Weirich, and G. Morrisett. Intensional polymorphism in type-erasure semantics. Journal of Functional Programming, 12(06):567-600,

2002.
[7] H. Curry, J. Hindley, and J. Seldin. Combinatory Logic, volume 2. North-Holland Publishing Company, 1972.

[8] M. Davis and J. Schwartz. Metamathematical Extensibility for TheoremVerifiers and Proof-Checkers. Computers and Mathematics with Applications, 5:217-230, 1979.
[9] J. Ferber. Computational reflection in class based object-oriented lan-guages. In OOPSLA '89: Conference Proceedings on Object-Oriented Programming Systems, Languages and Applications, pages 317-326, New York,NY, USA, 1989. ACM Press.

[10] S. Ganz, A. Sabry, and W. Taha. Macros as Multi-Stage Computations:Type-Safe, Generative, Binding Macros in MacroML. In International Conference on Functional Programming, pages 74-85, 2001.

32

[11] J. Gao, M. Heimdahl, and E. Van Wyk. Flexible and Extensible Notationsfor Modeling Languages. In Fundamental Approaches to Software Engineering, FASE 2007, volume 4422 of Lecture Notes in Computer Science,pages 102-116. Springer Verlag, March 2007.

[12] J.-Y. Girard, Y. Lafont, and P. Taylor. Proofs and Types. CambridgeUniversity Press, 1990.
[13] A. Goldberg and D. Robson. Smalltalk-80: The Language and Its Imple-mentation. Addison-Wesley, 1983.
[14] J. Harrison. Metatheory and Reflection in Theorem Proving: A Surveyand Critique. Technical Report CRC-053, SRI Cambridge, Millers Yard,

Cambridge, UK, 1995.
[15] J. Harrison. The HOL Light System Reference, 2006.
[16] J. Harrison. Towards Self-verification of HOL Light. In International JointConference on Automated Reasoning, 2006.

[17] W. Hunt, M. Kaufmann, R. Krug, J Moore, and E. Smith. Meta Rea-soning in ACL2. In J. Hurd and T. Melham, editors, 18th International

Conference on Theorem Proving in Higher Order Logics, pages 163-178.Springer-Verlag, 2005.

[18] S. Jefferson and D. Friedman. A Simple Reflective Interpreter. In IMSA'92International Workshop on Reflection and Meta-level architecture, 1992.
[19] S. Peyton Jones. The Implementation of Functional Programming Lan-guages. Prentice Hall, 1987.
[20] M. Kaufmann, P. Manolios, and J Moore. Computer-Aided Reasoning: AnApproach. Kluwer Academic, 2000.
[21] R. Kelsey, W. Clinger, J. Rees, et al. Revised5 Report on the AlgorithmicLanguage Scheme. SIGPLAN Notices, 33(9):26-76, 1998.
[22] I.-S. Kim, K. Yi, and C. Calcagno. A Polymorphic Modal Type System forLisp-Like Multi-Staged Languages. In The 33rd ACM SIGPLAN-SIGACT

Symposium on Principles of Programming Languages, pages 257-268, 2006.
[23] J. Klop and R. de Vrijer. Examples of TRSs and Special Rewriting For-mats. In TERESE, editor, Term Rewriting Systems, chapter 3. Cambridge

University Press, 2003.
[24] E. Kohlbecker, D. Friedman, M. Felleisen, and B. Duba. Hygienic macroexpansion. In LFP '86: Proceedings of the 1986 ACM conference on LISP

and functional programming, pages 151-161. ACM Press, 1986.

33

[25] X. Leroy. Formal certification of a compiler back-end, or: programming acompiler with a proof assistant. In S. Peyton Jones, editor, Proceedings of

the 32nd ACM Symposium on Principles of Programming Languages, 2006.
[26] X. Leroy, S. Blazy, and Z. Dargaye. Formal verification of a C compilerfront-end. In J. Misra and T. Nipkow, editors, Proceedings of Formal Methods, 2006.
[27] B. Lewis, D. LaLiberte, R. Stallman, and the GNU Manual Group. GNUEmacs Lisp Reference Manual. GNU Press, 2000.

[28] J. McCarthy. Recursive Functions of Symbolic Expressions and Their Com-putation by Machine, Part I. Communications of the ACM, 3(4):184-195,

1960.
[29] T. Mogensen. Efficient Self-Interpretations in lambda Calculus. Journal ofFunctional Programming, 2(3):345-363, 1992.

[30] L. Moreau. A Syntactic Theory of Dynamic Binding. In InternationalJoint Conference on Theory and Practice of Software Development (TAPSOFT/FASE'97), volume 1214, pages 727-741. Springer-Verlag, apr 1997.
[31] A. Nanevski. Meta-programming with names and necessity. TechnicalReport CMU-CS-02-123R, Carnegie Mellon University, November 2002.

[32] A. Nanevski and F. Pfenning. Meta-programming with names and neces-sity. Journal of Functional Programming, 2005. To appear.
[33] F. Pfenning. Logical Frameworks, chapter 21. Volume 2 of Robinson andVoronkov [36], 2001.
[34] F. Pfenning and C. Elliott. Higher-order abstract syntax. In ACM SIG-PLAN Symposium on Language Design and Implementation, 1988.
[35] B. Pierce. Types and Programming Languages. The MIT Press, 2002.
[36] A. Robinson and A. Voronkov, editors. Handbook of Automated Reasoning.Elsevier and MIT Press, 2001.

[37] H. Ruess. Computational Reflection in the Calculus of Constructions andits Application to Theorem Proving. In Proceedings of the Third International Conference on Typed Lambda Calculi and Applications, pages 319-335. Springer-Verlag, 1997.

[38] C. Sch"urmann, A. Poswolsky, and J. Sarnat. The r-Calculus. FunctionalProgramming with Higher-Order Encodings. In Proceedings of the 7th International Conference on Typed Lambda Calculi and Applications, pages339-353. Springer-Verlag, 2005.

[39] J. Seldin and J. Hindley, editors. To H.B. Curry: Essays on CombinatoryLogic, Lambda Calculus, and Formalism. Academic Press, 1980.

34

[40] J. Siskind and B. Pearlmutter. First-Class Nonstandard Interpretationsby Opening Closures. In Proceedings of the Symposium on Principles of

Programming Languages (POPL), 2007.
[41] B. Smith. Reflection and Semantics in LISP. In Proceedings of the 11thACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, pages 23-35, 1984.
[42] G. Steele. Common LISP: the Language (2nd ed.). Digital Press, 1990.
[43] B. Stroustrup. The C++ Programming Language (3rd Edition). Addison-Wesley, 1997.

[44] W. Taha. Multi-Stage Programming: Its Theory and Applications. PhDthesis, Oregon Graduate Institute, November 1999.
[45] The Coq Development Team. The Coq Proof Assistant Reference Manual,Version V8.0, 2004. http://coq.inria.fr.
[46] The GHC Team. The Glorious Glasgow Haskell Compilation SystemUser's Guide, Version 6.6.1, 2007.

http://www.haskell.org/ghc/docs/
latest/html/users guide/.

[47] The PLT Group. PLT DrScheme: Programming Environment Manual,2007.

http://download.plt-scheme.org/doc/drscheme/.

[48] P. Wadler. Theorems for free! In 4th International Conference on Func-tional Programming and Computer Architecture, 1989.

[49] C. Wadsworth. Some Unusual *-Calculus Numeral Systems, pages 215-230.In Seldin and Hindley [39], 1980.
[50] M. Wand. The Theory of Fexprs is Trivial. Lisp and Symbolic Computation,10(3):189-199, 1998.
[51] E. Westbrook. Free variable types. In Seventh Symposium on Trends inFunctional Programming (TFP 06), April 2006.
[52] A. Wright and R. Cartwright. A Practical Soft Type System for Scheme.ACM Trans. Program. Lang. Syst., 19(1):87-152, 1997.

35

A Haskell Code for the Factorial Benchmark
The type of Scott-encoded unary numbers may be considered to be

uN. (8b. (N ! b) ! b ! b) ! N
That is, it is a recursive type created from a functional accepting a continuationfor successor (of type

N ! b) and a continuation for zero (of type b), and com-puting a value. We can define this recursive type in

Haskell with higher-rankpolymorphism. Zero and successor numbers are then created from particular

functionals. Case analysis is implemented ("use" below) simply by extractingthe functional and applying it to the branches of the case.

module Ns where
data N = Mk (forall b . (N -> b) -> b -> b)
nz = Mk (\ s z -> z)
ns = \ n -> Mk (\ s z -> s n)
use = \ n s z -> case n of { Mk f -> f s z }

plus = \ n m -> use n (\p -> plus p (ns m)) m
mult = \ n m -> use n (\p -> plus (mult p m) m) nz
fact = \ n -> use n (\p -> mult n (fact p)) (ns nz)

showN :: N -> String
showN = \ n -> use n (\ p -> ("S "++(showN p))) "Z"
instance Show N where

show = showN

test0 = fact (ns (ns (ns (ns (ns nz)))))
test = mult test0 test0

36

B Archon Code for the Factorial Benchmark
Note that the prototype Archon implementation uses "^ " for _* and "\" for *.Also, to allow simple recursive descent parsing, application is written explicitly,
in prefix notation, with "@". Finally "$ x T1 T2" means that we define x to bethe value of

T1 in T2. Arguments in applications are sometimes printed directlybelow the corresponding "@" symbol.

$ zero ^ s ^ z z
$ succ \ n ^ s ^ z @ s n
$ one @ succ zero
$ fix \f @ \x @ f \y @ @ x x y

\x @ f \y @ @ x x y
$ plus @ fix \ plus \ n \ m @ @ n ^ p @ @ plus p

@ succ m
m
$ mult @ fix \ mult \ n \ m @ @ n ^ p @ @ plus @ @ mult p m m

zero
$ fact @ fix \ fact \ n @ @ n ^ p @ @ mult n @ fact p

one
$ show @ fix \ show \ n @ @ n ^ p @ S @ show p

Z
$ test0 @ fact @ succ @ succ @ succ @ succ @ succ zero

@ show @ @ mult test0 test0

37

C Scheme Code for the Factorial Benchmark
(define (nz)

(lambda (s z) z))

(define (ns n)

(lambda (s z) (s n)))

(define (nat-to-string n)

(n (lambda (n) (string-append "S " (nat-to-string n))) "Z"))

(define (plus n m)

(n (lambda (p) (plus p (ns m))) m))

(define (mult n m)

(n (lambda (p) (plus (mult p m) m)) (nz)))

(define (fact n)

(n (lambda (p) (mult (fact p) n)) (ns (nz))))

(define (test0)

(fact (ns (ns (ns (ns (ns (nz))))))))

(define (test)

(let ((x (test0))) (mult x x)))

(define (main argv)

(print (nat-to-string (test))))

38