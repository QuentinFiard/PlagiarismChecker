

ELSEVIER  Theoretical  Computer  Science  187 (1997)  147-165 

Theoretical Computer  Science 

Indexed  types 

Christoph  Zenger 
Universitiit Karlsruhe,  Institut  fir  Algorithmen  und Kognitive  Systeme,  D-76128  Karlsruhe,  Germany 

Abstract 

A new  extension  of  the  Hindley/Milner  type  system  is  proposed.  The  type  system  has  algebraic 
types,  that  have  not  only  type  parameters  but  also  value  parameters  (indices).  This  allows  for 
example  to  parameterize  matrices  and  vectors  by  their  size  and  to  check  size  compatibility 

statically.  This  is  especially  of  interest  in  computer  algebra. 

Keywords:  Type  system;  Functional  languages;  Type  inference;  Dependent  types;  Constraints 

1.  Introduction 

In  a  functional  language  with  a  Hindley/Milner  type  system,  as  described  in  [20] 
and  [lo],  we  declare  matrix  multiplication  and  determinant  for  integer  matrices  with 
the  following  types: 

matmult  ::  Matrix  Int  ->  Matrix  Int  ->  Matrix  Int 

determinant  ::  Matrix  Int  ->  Int 

With  these  declarations  the  compiler/type-checker  cannot  see,  whether  we  try  to  mul- 
tiply  two  matrices  of  incompatible  sizes.  For  taking  the  determinant  of  a  non-square 
matrix  it  is  just  the  same.  Errors  of  this  kind  will  result  in  run-time  errors  or,  even 
worse,  simply  return  an  inadequate  result.  The  solution  we  present,  solves  this  problem 
by  introducing  algebraic  types  that  take  complex  numbers,  called  indices,  as  parame- 
ters.  Furthermore,  one  can  constrain  these  indices  by  requiring  that  certain  polynomial 

equations  in  these  indices  hold.  As  an  example  the  definition  of  a  vector  might  look 
as  follows: 

data  Vector  a  #n  = 

Vnil,  n  =  0  I 
Vcons  a  (Vector  a  m>,  n  =  m+l 

* E-mail:  zenger@ira.uka.de. 
0304-3975/97/$17.00 @  1997 -  Elsevier  Science  B.V.  All  rights  reserved 
PZISO304-3975(97)00062-5 

148  C.  Zengerl  Theoretical  Computer  Science  187  (1997)  147-165 
n  is  such  an  index  (In  type  definitions  we  will  prefix  indices  by  a  #  to  distinguish  them 

from  type  parameters).  The  constraints  are  that  empty  vectors  that  have  zero  length, 
and  that  vectors  constructed  from  first  element  and  rest  have  length  one  greater  than 
the  rest.  (Vcons  3  Vnil)  has  type  (Vector  Int  1).  Variables  that  do  not  occur  on 
the  left  hand  side  (m  in  the  example)  are  existentially  quantified  indices. 

The  above  functions  can  now  be  declared  as  follows: 

matmult  ::  Matrix  Int  n  m  ->  Matrix  Int  m  k  ->  Matrix  Int  n  k 

determinant  ::  Matrix  Int  n  n  ->  Int 

Here  we  specified  the  constraint  that  only  matrices  with  compatible  sizes  can  be  multi- 
plied  and  that  for  calculating  the  determinant  the  two  size  parameters  of  a  matrix  must 
be  equal. 

Given  such  declarations  of  types  and  function  signatures  the  compiler/type  checker 
finds  out  about  problems  like  multiplication  of  matrices  with  incompatible  sizes  and 
determinant  of  a  non-square  matrix  at  compile-time  and  reports  a  type  error. 

Indexed  types  do  not  allow  to  type  more  expressions  than  the  Hindley/Milner  system 
but  they  do  allow  to  type  more  fine-grained,  such  that  we  can  detect  more  errors  by 

type  checking.  This  static  error  detection  will  be  even  more  important  for  specification 

languages  than  for  functional  languages,  because  there  are  no  run-time  tests. 

Constraints  have  to  be  enforced  by  the  type  system  during  construction  of  objects 
of  the  algebraic  types  and  they  can  be  used  as  known  facts  when  decomposing  in 
the  case  construct  respectively  pattern  matching.  There  may  be  a  different  set  of  con- 

straints  for  each  constructor.  A  difficult  question  is,  what  kind  of  constraints  on  the 
indices  should  be  allowed.  It  turns  out,  that  polynomial  equations  (equations  of  the  form 

p(.  . .) =  0  where  p  is  a  polynomial)  are  a  suitable  choice.  They  are  expressive  enough 
to  describe  many  constraints  that  arise  in  practice,  yet  we  can  still  have  type  infer- 

ence  using  Grijbner  basis  techniques  (See  Buchberger  [l]  for  an  overview  on  Griibner 
bases).  Still  other  kinds  of  constraints  have  to  be  considered.  We  will  discuss  that  in 

Section  5. 

In  the  second  section  we  will  now  introduce  the  system  of  indexed  types.  In  the 
third  section  we  will  give  some  examples  that  can  be  expressed  in  the  type  sys- 
tem,  before  we  discuss  some  of  its  limitations  in  section  four.  We  shortly  discuss 

the  constraint  system  before  we  describe  the  type  inference.  We  conclude  by  re- 

lating  our  approach  to  work  done  by  others  and  discussing  some  topics  for  future 
research. 

2.  System  of  indexed  types 

We  propose  an  extension  of  the  Hindley/Milner  system  by  indexed  types.  The 
type  language  is  constructed  along  the  lines  of  qualified  types  [ 141, where  the  predicates 
are  polynomial  equations.  But  here  types  may  also  have  polynomials  as  parameters. 

C.  Zengerl  Theoretical  Computer  Science  187  (1997)  147-165  149 
Definition  1  (Types).  Types  can  be  constructed  as  follows: 

(i)  polynomials 

P  E a=[4 
where  ii  are  polynomial  variables,  and  @ denotes  the  complex  numbers. 

(ii)  types 

r=r-+rlr?pla, 
where  T  is  a  type  constructor  for  an  algebraic  type  and  a  is  a  type  variable. 

(iii)  qualified  types  ' 

P=P*Pb 
(iv)  type  schemes 

Cr =  Va.crlV'n.olp 

The  intuition  behind  a  qualified  type  p  +  z  is  that  an  expression  of  the  qualified 
type  is  of  type  r  if  the  constraints  p  are  satisfied. 

tv(a)  denotes  the  free  type  variables,  pv(a)  the  free  polynomial  variables.  Similarly 
tv  and  pv  will  be  used  on  contexts  r  and  constraints  G. 

The  following  are  the  rules  for  variable  introduction,  arrow  introduction  and  elimi- 
nation,  quantifier  introduction  and  elimination,  and  the  let-rule: 

(uar)  (x:a)Er 

GITtx:o 

(+E)  Glr  t  E:z'--+z  GIrtF:z' GIrkEF:z 

G/r  t- E:  Va.c 
`vE)G\I-  k  E:  [T/E]* 

cfo GIrEE:o Glr  t  E  : Vu.0  a $  w-) 

(let>  Gil-  t  E:  CJ  G'IT,,x:a  k  F:z G'+GITt(letx=EinF):z 
All  of  them  are  straightforward  generalizations  of  the  rules  of  the  Hindley/Milner 

system.  The  G  on  the  left  side  denotes  a  set  of  constraints  on  the  polynomial  variables 
in  the  judgement,  that  are  not  bound  by  quantifiers. 

' We  do  not  distinguish  between  p  +  q +  p  and  p, q G- p. 

150  C.  Zengerl  Theoretical  Computer  Science  187  (1997)  147-165 

We  need  a  special  rule  for  building  fixpoints,  because  in  contrast  to  e.g.  ML  types 
of  recursive  functions  need  to  be  declared. 

(fix)  GII-,,x  : 

CJ t-  E : CJ 

GITk(fixn::oinE):cr 

If  we  did  not  allow  type-schemes  here,  we  would  not  be  allowed  to  use  special  instances 
of  the  function  f on  the  right-hand  side  of  the  definition  of  f.  For  example  in  Gofer 
the  following  definition  for  the  length  of  a  list 

len  Nil  =  0, 
len  (Cons  x  Nil)  =  I, 
len  (Cons  x  xs>  =  (len  xs>  +  (len  [II> 

has  type  List  Int  ->  Int  and  not  the  more  general  type  List  a->  Int.  Otherwise 
type  inference  would  not  be  computable  [21,  171. This  is  obviously  an  artificial  example, 

and  indeed  it  is  not  much  of  a  restriction  in  languages  like  Gofer,  Haskell  or  ML,  but  as 
we  shall  see  in  the  case  of  indexed  types  we  need  true  polymorphic  recursion.  Besides 

Odersky  and  Lhfer  [23]  showed  already  how  to  get  true  polymorphic  recursion  by 
declarations. 

Because  we  also  have  quantification  over  index  variables,  we  need  introduction  and 
elimination  rules  for  these.  They  are  rather  similar  to  introduction  and  elimination  rules 

for  ordinary  quantification. 

@`n'nE) Glr  k  E:`dn.o Glr  t- E:  [p/n]0 

ofn'nl) GITFE:o Glr  t- E : Vn.o  n $ pv(G)  u  pv(U 
Besides,  the  constraints  on  the  left-hand  side  tell  us,  that  some  types  are  equivalent 
((Vector  a  n)  and  (Vector  a  m>  will  be  equivalent  types,  if  there  is  a  constraint 
m =n).  The  rule  (equiv)  allows  to  change  the  type  according  to  this  equivalence.  To 

formulate  it  we  first  need  a  definition: 

Definition  2  (Structural  equivalent).  Two  types  z  and  r'  are  structural  equivalent  (z  S 

r'),  iff  they  differ  only  in  their  polynomial  parts.  By  r-z'  we  denote  the  weakest  con- 
straint  set,  that  implies  equality  of  z  and  7'. 

So,  (Vector  Int  n>  zs  (Vector  Int  m)  and  (Vector  Int  n)-(Vector  Int 
m> =n-m  =  0.  fi  denotes  the  radical  ideal,  that  is  the  ideal  containing  all  poly- 

nomials  p  such  that  there  is  some  m  with  pm  E  G. 

(equiu) 

C.  Zengerl  Theoretical  Computer  Science  187  (1997)  147-165  151 
Before  we  introduce  rules  which  allow  to  shift  constraints  from  left  to  right  and  vice 
versa,  we  need  another  definition: 

Definition  3  (Elimination  Ideal).  Elim(G,  V)  :=  G  n  k[pv(G)  \  V]. 
eliminable(  G,  V)  :  @  (3 V.G)  c  Elim(  G,  V). 

The  elimination  ideal  Elim(G,  V)  is  the  set  of  polynomial  constraints  that  are  in  G, 
but  do  not  contain  variables  from  V.  eliminable(G,  V)  checks,  whether  a  solution  of 

Elim(G,  I')  can  always  be  extended  to  a  solution  of  G. 

We  can  calculate  elimination  ideals  using  Griibner  bases  and  we  can  also  check  the 
condition  for  elimination.  Furthermore  we  can  calculate  whether  a  set  P  of  polynomial 
constraints  implies  another  set  Q  of  constraints  (each  polynomial  in  Q  vanishes  at 
points  where  every  polynomial  from  P  vanishes),  because  this  is  equivalent  to  one 
ideal  being  a  subideal  of  the  radical  ideal  of  the  other  ideal.  See  standard  textbooks 

on  Grijbner  bases  computations  such  as  [6]  or  [3]  for  that.  We  are  going  to  use  these 
computations  for  inferring  types. 

(+-E)  GIZ-FE:P+p GITkE:p  PC& 

(*Z)  G+PlZ-kE:p Gil-tE:P+p 

G[TkE:z  n @ PV(T),  n  #  pv(r) (Elim) 
Ellm(G~ n ) 1 r  t- E  : 7  eliminable(  G, n ) 

Basically  we  can  eliminate  a  constraint  on  the  right  side,  if  it  is  implied  by  G,  and  we 
can  shift  constraints  from  the  left  to  the  right.  Constraints  that  do  not  really  constrain  the 
right-hand  side  may  be  eliminated.  This  applies  for  example  if  we  have  the  judgement 
m = nix  : (Vector  n>  tx  : (Vector  n>  .  Here  m does  not  occur  anywhere  else,  so  m = n 

can  be  safely  eliminated. 

We  need  to  test  membership  in  the  radical  ideal  because  n2 =  0  implies  n =  0,  though 
(n)  is  not  a  subideal  of  (n2)  but  only  of  m  =  (n).  To  make  sure  that  we  can  really 
eliminate  we  have  to  test,  whether  an  n  always  exists.  We  can  do  that  using  Grobner 
basis  techniques. 

Finally,  we  want  to  have  algebraic  types  in  our  type  system,  otherwise  we  could 
not  build  any  types  with  indices  in  the  first  place.  Algebraic  types  can  be  declared  as 

follows: 

We  assume  here  that  the  polynomial  variables  occur  at  most 

is  no  effective  constraint,  because  a  data  declaration  data  T 
be  rewritten  as  data  T  n = D  n  m,  n  = m.  In  practice  the  first 

syntactic  sugar  for  the  second. 

once  in  each  fi.  This 
n=  D  n  n  can  always 

would  be  regarded  as 

1.52  C. ZengerI  Theoretical  Computer  Science  187  (1997)  147-165 

When  elements  of  algebraic  types  are  constructed,  the  type  system  has  to  ensure  that 
the  constraints  Qi  are  satisfied.  On  the  other  hand,  when  destructing,  we  may  assume 

Qi  in  the  Ci  alternative  of  the  case  construct. 

(abE) Girt-z:T/%j  G+e@lT~,Z:tEikEi:z'  tl=[ii/rii,~/ii,ji/ii] Glr  k  case  z  of  {CiXi +  Ei}i=l,.,k : T'  K 9  pv(r') 
Here,  4  are  polynomials,  Z types,  E are  variables  that  play  the  role  of  Skolem  constants, 
and  ti  are  the  polynomial  variables  occurring  in  ?i  but  not  in  n.  Note,  that  existential 

quantification  is  always  encapsulated  in  a  constructor  and  is  immediately  cancelled  with 
an  universal  quantification.  Logically  this  relates  to  a  rule 

C  t  3c.A  C t- k(A  ---t B) 

CI-B  x #  MB) 

The  encapsulation  of  the  existential  quantification  in  the  type  constructor  is  necessary 
to  make  type  inference  possible. 

3.  Using  indexed  types 

To  make  the  examples  in  this  section  more  readable,  we  are  going  to  use  pattern 
matching  syntax  instead  of  explicit  case  expressions  and  recursive  definitions  with 
type  declarations  as  they  are  common  in  Haskell  or  Gofer  instead  of  building  explicit 
fixpoints.  There  are  standard  techniques  to  reduce  this  to  the  above  constructs  [25]. 

3.1.  Scalar  product 

We  start  with  recalling  the  type  declaration  of  vectors: 

data  Vector  a  #n  = 

Vnil,  n=O  I 
Vcons a  (Vector  a  m>,  n  =  m+l 

The  definition  of  a  scalar  product  is  straightforward: 

sprod  ::  Vector  Int n -> Vector  Int n -> Int 
sprod Vnil Vnil = 0 
sprod (Vcons x xs) (Vcons y ys> = x*y +  (sprod xs ys> 

We  have  to  declare  the  type  of  the  recursive  function,  otherwise  the  definition  is  quite 

similar  to  a  definition  for  lists.  The  difference,  however,  is  that  the  expression  (sprod 
Vnil  (Vcons  1  Vnil)  >  will  be  rejected  by  the  compiler  and  a  type  error  will  be 
reported. 

C.  Zengerl  Theoretical  Computer  Science  187  (1997)  147-165  153 
Note  that  the  type  of  sprod  at  the  recursive  invocation  has  different  indices  (n  -  1) 
than  the  type  of  the  sprod  function  on  the  left  hand  side  (n),  that  is  we  have  true 
polymorphic  recursion  in  the  index.  Due  to  this  fact  we  need  to  declare  types. 

3.2.  Vector  comprehensions 

List  comprehensions,  first  used  by  Turner  [27],  are  very  elegant  and  frequently  used 
in  functional  programming.  For  example  the  map  function  for  lists  can  be  expressed 
nicely  as  follows: 

map  f  1=  [  f  x  I  x  <-  11 
This gives  as  a  result  the  list  of  all  f  x,  where  x  is  from  1,  very  similar  to  the 
mathematical  set  comprehension  {f(x)lx  E ,C}.  An  analog  for  vector  comprehensions 
can  also  be  established: 

vmap f v = << f x  I  x  <-  v  >> 
This  is  a  very  intuitive  formulation  and  there  is  no  possibility  of  errors  at  the  vector 
boundaries.  One  may  even  allow  vectors  in  list  comprehensions,  as  for  example  in  a 

function  that  converts  vectors  to  lists. 

v21  ::  Vector a n ->  [a] 
v21  v  =  [  x  I  x  <-  v  I 

However,  the  converse  is  not  true.  Lists  cannot  be  used  in  vector  comprehensions,  for 

it  is  impossible  to  check  the  length  statically.  Also  filters,  a  very  effective  feature  of 
list  comprehensions,  cannot  possibly  be  used  in  vector  comprehensions,  but  we  shall 

see  shortly  how  to  get  around  this. 

3.3.  Sorting 

Due  to  the  lack  of  filters  in  vector  comprehensions  we  cannot  rewrite  the  following 
quicksort  easily  for  vectors. 

quicksort  [I  =  [I 
quicksort  (x:xs)  =  (quicksort  [  y  I  y  <-  xs,  y  <=  x  ] >  ++  [x] 

++  (quicksort  [  y  I  y  <-  xs,  y  >  x  ] > 

We  have  to  split  a  vector  into  two  vectors,  although  the  actual  sizes  of  the  subvectors 

are  only  known  at  run-time.  But  we  know  that  the  sum  of  the  two  lengths  of  the 
subvectors  is  exactly  the  same  as  the  size  of  the  original.  By  introducing  a  new  data 
type  SplitVector,  we  can  make  use  of  that  fact. 

data  SplitVector a #n = 

Spv  (Vector a m>  (Vector a k), m + k = n 

Now  we  may  write  a  function  vfilter  similar  to  the  common  filter  function 

in  Hindley/Milner  languages.  vf  ilter  splits  a  vector  into  two,  where  the  first  one 

154  C.  Zengerl  Theoretical  Computer  Science  187  (1997)  147-165 
contains  all  the  elements  for  which  the  function  f  yields  true,  the  second  one  all  the 

others. 

vfilter  : :  (a  ->  Bool)  ->  Vector  a  n  ->  SplitVector  a  n 
vfilter  f  Vnil  =  (Spv  Vnil  Vnil) 
vfilter  f  (Vcons  x  xs)  = 

if  (f  x>  (Spv  (Vcons  x  1)  r>  (Spv  1  (Vcons  x  r>>  where 

(Spv  1  r>  =  (vfilter  f  xs) 

We  cannot  just  use  the  pair  constructor  Pair  instead  of  SplitVector,  because  then 
the  information  that  the  sum  of  the  lengths  is  just  the  length  of  the  argument  would 
be  lost  and  a  type  could  not  be  found. 

The  quicksort  function  itself  is  almost  as  short  as  the  original  for  lists  and  has  the 
advantage  that  it  checks  that  the  resulting  vector  has  exactly  the  same  length  as  the 
original.  If  we  forget  to  add  the  partition  element  x,  the  compiler  reports  a  type  error. 

quicksort  : :  Vector  Int  n  ->  Vector  Int  n 
quicksort  Vnil  =  Vnil 

quicksort  (Vcons  x  xs)  =  vappend  (quicksort  1) 

(Vcons  x  (quicksort  r>>  where 
(Spv  1  r>  =  vfilter  (\y  ->  y  <  x>  xs 

Here  vappend  is  the  vector  analog  to  append.  We  can  formulate  vappend  also  with 
an  accumulating  parameter  [2]. 

3.4.  Vectors  and  lists 

We  saw  ~21,  a  function  that  converts  vectors  to  lists.  The  converse  is  not  possible, 
because  we  cannot  know  the  length  in  advance.  However  we  know  that  a  length  will 
exist  and  encapsulate  this  in  the  constructor  AnyVec: 

data  AnyVector  a  =  AnyVec  (Vector  a  n> 
Now  we  can  write  a  function  12av  that  converts  a  list  to  such  a  vector. 

12av  ::  (List  a>  ->  (AnyVector  a> 
12av  Nil  =  (AnyVec  Vnil> 

12av  (Cons  x  xs)  =  (AnyVec  (Vcons  x  xs'  ) > 

where  (AnyVec  xs')  =  (12av  xs) 

Now  we  can  again  use  this  to  implement  quicklist,  a  quicksort  on  lists  using  our 

routine  quicksort. 

quicklist  ::  (List  a>  ->  (List  a) 
quicklist  xs  =  (~21  (quicksort  xs  ' > > 

where  (AnyVec  xs  ' )  =  (12av  x.s> 

The  advantage  is  that  quicksort  is  internally  checked.  v2I  and  12av  seem  to  in- 
troduce  a  large  run-time  overhead,  but  we  hope  to  reduce  it  by  using  deforestation 
techniques  [28]. 

C.  Zengerl  Theoretical  Computer  Science I87  (1997)  147-16s  155 
3.5.  Matrix  lists 

When  we  supply  a  data  type  with  additional  parameters,  here  indices,  to  reflect  more 
of  the  structure  in  the  type,  a  typical  problem  that  arises  is  that  some  lists  become 
inhomogeneous  in  the  type.  As  an  example  consider  a  list  of  matrices  of  different  sizes. 
This  was  a  homogeneous  list,  when  the  data  type  matrix  did  not  have  size  parameters, 
but  is  not  so  now. 

But  there  is  a  way  out:  depending  on  what  we  want  to  do  afterwards,  we  can  build 
special  lists  with  size  constraints.  For  example  a  list  which  contains  square  matrices. 

data  SqMatrList  a  = 

Snil  1 
Scans  (Matrix  a  n  m>  (SqMatrList  a>,  n  =  m 

We  can  then  e.g.  calculate  the  sum  of  all  the  determinants: 

detsum  ::  SqMatrList  Int  ->  Int 
detsum  Snil  =  0 
detsum  Scans  m  1  =  (determinant  m)  +  (detsum  1) 

We  can  also  declare  lists  of  matrices,  which  have  compatible  sizes  for  multiplication: 

data  MatrixList  a  #m  #n  = 

Mnil,  m  =  n  I 
Mcons  (Matrix  a  m  kl)  (MatrixList  a  k2  n),  kl  =  k2 

Now  we  can  multiply  all  the  matrices  in  a  non-empty  list 

mult  ::  MatrixList  Int  n  k  ->  Matrix  Int  n  k 
mult  (Mcons  m  Mnil)  =  m 
mult  (Mcons  m  1)  =  (matmult  m  (mult  1)) 

Note,  however,  what  we  cannot  do  is  to  return  a  unit  matrix  for  the  empty  list.  We 

will  discuss  this  problem  in  the  next  section. 

4.  Limitations 

We  have  seen  some  nice  examples  with  indexed  types.  This  section  now  shows  some 
of  the  deficiencies  of  indexed  types  as  they  were  presented  above. 

4.1.  Usage  of  the  Index 

We  can  determine  the  size  of  a  vector  with 

vlen  ::  Vector  a  n  ->  Int 
vlen  Vnil  =  0 
vlen  (Vcons  x  xs>  =  1  +  (vlen  xs) 

156  C.  Zengerl  Theoretical  Computer  Science  187  (1997)  147-165 
just  as  we  can  compute  the  length  of  a  list,  but  we  cannot  use  the  index  as  in 

vsize  ::  Vector  a  n  ->  Int 

vsize  _  =  n 

though  this  would  be  an  elegant  notation.  Another  example  is  the  construction  of  a 

zero  vector  or  a  unit  matrix  as  above: 

zero_vector  ::  Vector  Int  n 
zero_vector  =  Vnil 
zero_vector  =  (Vcons  0  (zero_vector)> 

Here  we  would  hope  that  after  type-inference  we  could  supply  an  n  and  from  that 
choose  the  right  branch  at  run-time. 

One  reason  for  the  failure  is  that  the  type  inference  only  checks  whether  the  con- 
straints  are  satisfied  and  does  not  actually  construct  n,  not  even  a  way  to  compute  it  at 
run-time.  If  the  compiler  did  this,  it  would  require  the  implementation  to  carry  around 

all  the  indices  at  run-time  and  it  is  not  clear  whether  the  ability  to  use  the  index  would 
outweigh  this  performance  overhead. 

In  the  second  example  we  see  an  additional  problem:  The  semantics  is  influenced 
by  the  type  inference.  Consider  the  expression  (sprod  zero-vector  zero-vector)! 

The  term  looks  well-typed  but  what  should  its  semantics  be?  The  type  inference  cannot 
infer  the  lengths  of  the  zero-vectors. 

Note  here  that  multiple  solutions  to  the  type-problem  do  not  hurt  us,  because  the 
solution  doesn't  influence  the  semantics  of  execution. 

4.2.  Dependent  types 

Suppose  we  want  to  read  two  vectors  from  a  file,  calculate  a  scalar  product  and 
print  the  result.  There  is  no  way  to  check  statically  whether  they  are  of  equal  size  and 

a  program  doing  this  by  using  the  data  type  Vector  would  be  necessarily  ill-typed. 
A  way  out  of  this  problem  would  be  to  allow  explicit  dependent  types:  dependent 

sums  (n:  Int,  Vector  Int  n)  and  dependent  products  (n:  Int  ->  Vector  Int  n). 
Dependent  sums  could  be  used  to  read  a  pair  of  a  vector  and  its  length.  We  would 
then  need  a  special  if  clause,  such  that  in  the  true  alternative  of  an  if  (n  =m>  we 

would  know  (statically!)  that  Vector  Int  n  and  Vector  Int  m have  matching  sizes. 

Similarly  dependent  products  could  be  used.  We  would  first  read  the  size  of  the 
vectors  and  then  the  vectors  themselves.  A  function  reading  a  vector  with  a  size  given 

as  argument  would  then  have  a  dependent  product  type. 

Another  problem  from  computer  algebra,  where  we  would  want  to  have  dependent 
types,  is  a  data  type  IntMod  n  which  represents  integers  modulo  n. 

data  IntMod  #n  =  Mod  Int  n:Int 
We  could  then  write  functions  for  the  multiplication  and  Chinese  remaindering  with 

detailed  type  information. 

C.  Zengeri  Theoretical  Computer  Science  187  (1997)  147-165  157 
imul  : :  IntMod  n  ->  IntMod  n  ->  IntMod  n 
Chinese  : :  IntMod  n  ->  IntMod  m  ->  IntMod  (m*n) 

Mixing  of  different  moduli  would  be  detected  as  type  error.  The  difficulty  in  introducing 

dependent  types  lies  in  the  integration  of  explicit  dependent  types  and  indices.  Besides 
dependent  types  can  only  be  checked  if  we  use  term-equality  on  the  values. 

To  see  how  far  we  can  get  without  dependent  types  we  look  again  at  the 
zero-vector  example.  First  a  typing  with  dependent  types: 

zero_vector  : :  n:Int  ->  Vector  Int  n 
But  using  a  definition 

data  Int'  #n  = 

Zero,  n  =0  I 
Succ  (Int'  m>,  n  =  m  +  I  I 
Pred  (Int'  m>,  n  =  m  -  I 

we  can  write  something  quite  similar: 
zero_vector  ::  (Int'  n>  ->  (Vector  Int  n> 

and  use  this  to  multiply  two  zero-vectors  of  length  one. 

(sprod  (zerovector  (Succ  (Zero)>>  (zerovector  (Succ  (Zero>)>> 
Of  course  we  would  have  to  invent  syntactic  sugar  for  that.  How  far  we  can  get  using 
this  approach  seems  a  promising  research  topic. 

4.3.  Vector  access 

Of  course  we  can  write  a  function,  accessing  the  n-th  element  of  a  vector 

access  : :  (Vector  a  n)  ->  Int  ->  a 
access  (Vcons  x  xs>  0  =  x 
access  (Vcons  x  xs)  m  =  (access  xs  (m-l>> 

but  we  have  no  way  of  checking  statically,  that  the  access  doesn't  fail.  This  would  need 

dependent  types  as  well  as  a  comparison  operator  in  the  constraints.  But  in  functional 
programming  these  accesses  are  rarely  used.  Instead  we  use  vmap  and  this  gives  us 

security. 

4.4.  Higher  order  functions 

Some  constructions  which  work  in  the  Hindley/Milner  system  cease  to  work  when 
introducing  indexed  types.  To  illustrate  this  we  look  at  the  following  definition  for  the 
transposition  of  a  list  of  lists,  adapted  from  [13]. 

transpose  : :  [[all  ->  [Call 
transpose  =  foldr  (\xs  xss  ->  zipWith  (Cons)  xs  xss>  Nil 

158  C.  Zengerl  Theoretical  Computer  Science  187  (1997)  147-165 
where  foldr  and  zipWith  are  standard  functions 

foldr  : :  (a  ->  b  ->  b)  ->  b  ->  [a]  ->  b 
foldr  f  z  [I  =  z 
foldr  f  z  (x:xs)  =  f  x  (foldr  f  z  xs) 
zipWith  : :  (a  ->  b  ->  c>  ->  Cal  ->  [bl  ->  Ccl 
zipWith  z  (a:as>  (b:bs)  =  z  a  b  :  zipWith  z  as  bs 
zipWith  _  _  _  =  [I 

Now,  what  happens  if  we  try  the  same  with  vectors?  The  corresponding  vf  oldr  and 

vzipwith  are  easy  to  rewrite: 

vfoldr  : :  (a  ->  b  ->  b)  ->  b  ->  (Vector  a  n>  ->  b 
vfoldr  f  z  Vnil  =  z 

vfoldr  f  z  (Vcons  x  xs)  =  f  x  (vfoldr  f  z  xs) 

vzipwith  ::  (a  ->  b  ->  c>  ->  (Vector  a  n>  -> 

(Vector  b  n>  ->  (Vector  c  n> 
vzipwith  z  (Vcons  a  as>  (Vcons  b  bs)  = 

Vcons  (z  a  b)  CvzipWith  z  as  bs) 
vzipwith  z  Vnil  Vnil  =  Vnil 

but  when  we  rewrite  transpose  as 

transpose  ::  Vector  (Vector  a  m)  n  ->  Vector  (Vector  a  n>  m 
transpose  =  vfoldr  (\xs  xss  ->  vzipwith  (Vcons)  xs  xss)  Vnil 

we  end  up  with  a  type  error,  because  (\xs  xss  ->  vzipwith  (Vcons)  xs  xss> 
has  type  (Vector  a  n>  ->  (Vector  (Vector  a  m>  n)  ->  (VectorCVector  a 

k)  n>  ,  k  =  m  +  1,  and  this  does  not  match  the  argument  type  of  vf  oldr. 

The  reason  behind  this  is,  that  we  have  to  fix  the  size  of  the  vectors  on  which  Vcons 
works,  when  we  pass  it  to  vf  oldr.  But  then  vf  oldr  cannot  see  that  it  indeed  works 

on  all  sizes.  Allowing  type  schemes  instead  of  just  types  as  arguments  to  functions 
as  in  [23]  may  solve  this  problem,  but  it  is  not  yet  clear  whether  this  can  be  easily 
combined  with  indexed  types. 

5.  Constraints 
5.1.  Indexing  with  IntegersjComplex 

All  the  way  we  used  types  which  we  thought  of  as  indexed  by  integers  or  even  non- 
negative  integers,  though  actually  the  indices  are  complex  numbers.  Does  this  pose  a 

serious  problem?  No!  Many  formulas,  e.g.  formulas  of  the  form  p(X)  =  0  +  q(f)  =  0, 
that  are  valid  for  complex  numbers  are  also  valid  for  the  integers. 

The  problem  that  arises  is  twofold.  Firstly,  a  program  might  type-check,  though  the 
user  would  not  expect  it  to.  For  example  there  is  no  difference  between  the  types 

C.  Zengerl  Theoretical  Computer  Science  187  (1997)  147-165  159 
(Vector  a  n>  ->  (Vector  a  n>  and  (Vector  a  (2*n))  ->  (Vector  a  (2*n)) 
and  f  (Vcons  3  Vnil)  would  type-check  if  f  has  either  of  the  above  types.  Hence, 
there  is  no  way  to  specify  that  an  index  has  to  be  a  multiple  of  another,  that  it  has  to 
be  a  square  of  an  integer  and  so  on. 

The  other  problem  is  that  a  program  may  not  type-check,  because  type  correctness 
relies  on  the  fact  that  only  integers  are  substituted  for  constraint  variables. 

5.2.  Other  systems 

In  this  paper  we  presented  the  constraint  system  of  polynomial  equations.  2  An  ex- 
tension  of  this  system  to  include  also  comparisons  using  cylindrical  algebraic  decom- 
position  [7]  is  worth  considering.  However,  it  is  unclear,  whether  the  second  problem 

above  might  be  an  obstacle.  We  cannot  prove  n  >  0 +  n 2  1,  though  the  type-checker 
might  need  this  in  typical  situations. 

Another  choice  which  has  to  be  investigated  is  Presburger  arithmetic  [16]  (thanks 
to  the  referee  for  pointing  that  out).  Besides  comparison  operators  this  constraint  sys- 
tem  has  the  advantage  of  being  over  the  integers,  but  on  the  other  hand  we  lose  the 
possibility  of  general  polynomial  constraints. 

6.  Type  inference 

We  present  the  type  inference  along  the  lines  of  Jones  [14].  After  giving  some 
auxiliary  definitions,  we  start  with  presenting  a  syntax-directed  deduction  system  t-s, 
in  which  for  every  term  of  the  language  there  exists  exactly  one  rule  to  derive  its  type. 
The  second  step  will  be  a  deduction  system  tW,  which  can  be  read  as  an  attribute 
grammar  and  thus  gives  an  algorithm  W  for  computing  the  type  of  an  expression. 

We  want  to  define  a  relation  "more  general"  denoted  <  on  constrained  type-schemes 
(Plo),  which  has  the  property 

(PIa)  >  r  (P'la')  iff  (P'IP  F  E  : (T' implies  PIP  t- E  : a). 
We  start  with  the  special  case  P' = 0  and  O' =  R  +  p  and  call  <  "generic  instance" 
in  this  context. 

Definition  4  (Generic  instance).  R  +  p  is  a  generic  instance  of  (PlV'a.Vr7.Q +  v) under 

r  iff  there  exist  Z  such  that 

(i)  Elim(P  A Q  A [T/qv  -  pL, I')  C R 
(ii)  eliminable(R  A P  A Q A [?/L?]v -  p, V) 
where  V =  pv(Q,  P, v)\  pv(T),  a,<  $  pv(P)  and  pv(R,  p)  npv(P,  Q, v)  C pv(P).  We  are 
allowed  to  achieve  these  conditions  by  renaming  variables  that  do  not  occur  free  in  P. 

2 Since  the  writing  of  the  paper  we  generalized  this  to  quantified  boolean  formulas  over  polynomial 
equations. 

160  C.  Zenger  I Theoretical  Computer  Science  187  (1997)  147-165 

We  will  denote  the  genetic  instance  relation  by  R=sp<r(PlV'a.Vii.Q+  v).  We  take 
cr as  a  shorthand  for  (010). 

Definition  5  (More  general).  (PI  ) ts  IS  more  general  than  (P'lo')  under  r  iff  every 
generic  instance  of  (P'la')  is  also  a  generic  instance  of  (Pla).  We  denote  this  by 
(PIa)  2r(P'la'). 

We  still  need  a  definition  of  a  generalization  function,  then  we  will  be  able  to  present 
the  syntax-directed  system. 

Definition  6  (Generalization).  Genr(p)  = V(tv(p)\  tv(T)).V(pv(p)\  pv(r)).p. 
Definition  7  (Syntactic  type  system). 

(-  E>' GIl?E:z'+z  Glr  ks F  : T' Glr  ks  EF  : z 
(-OS  GIr',x  : z'  Es  E  : z GIrkSkE:z'--tz 
( Zet)s Gil-  ks E  : z'  G'Ir,,x  : CJ I-'  F  : z  CJ =  Genr(G  -+  6) G'jr  Es  (let  x=E  in  F)  : z 

(f  ws G+PII",x:at-SE:z  a=V'cr.Vfi.P+~  a @h(r) G +  Plr  l-s  (fix  x  :: 0  in  E)  : z  pv(a)  =  0 

(aWS GjTk'z:Tiicj  G+eQiIr,,x:ezi~SE,:z' Glr  ks  case  z  of  {Ci.fi  S-  Ei}i=  I..,k : Z' 
We  claim  a  soundness  property  of  t-'  with  respect  to  the  original  system.  We  believe, 
that  I-'  is  also  complete  as  stated  below.  However  this  seems  less  important,  when  we 
note,  that  at  the  next  step  to  ts'  we  lose  completeness.  3 

3 Furthermore  for  a  more  sophisticated  system  developed  in  the  meantime,  completeness  seems  easier  to 
prove. 

C.  Zenger  I Theoretical  Computer  Science  187  (1997)  147-165  161 
Proposition  8  (Soundness).  Zf  G/r  ks  E  : z,  then  Glr  k  E:  z. 

Conjecture  9  (Completeness).  Zf  G(Z  k  E  : o,  then  exists  G', z  with  G'IT  Fs  E  : z  and 
(Glo)<rGenr(G'  +  7). 

All  derivations  trees  in  Ps  for  the  type  of  an  expression  have  the  same  form.  Now 
we  want  to  find  a  most  general  derivation.  To  this  end  we  define  a  new  deduction  t-w, 
which  is  computational  in  that  it  can  be  read  as  an  attribute  grammar  that  computes 

an  ideal  G,  a  substitution  S  on  type  variables,  and  a  type  r,  such  that  GlSZ  kw  E  : z 
from  Z  and  E.  Moreover,  each  derivation  in  kw  will  be  a  derivation  in  tS.  kw  uses 
some  auxiliary  functions: 
_  univar(z)  computes  a  type  r',  which  is  structural  equivalent  to  r,  but  each  polynomial 

in  r'  consists  of  a  single  new  polynomial  variable,  each  polynomial  variable  occurring 
exactly  once  in  r'. 
-  (Z, S)  =  mgu(7)  iff S  is  the  most  general  substitution,  such  that  Sri  2  Srj  and  Z =  Cij 

Sri  -  SZj. 
-  (z',  S)  =  umgu(f)  iff  (_, S)  =  mgu(?),  r' =  univar(Sri  ). 
-  (Z, S)  =  mgs(  F,  ci)  iff  S  is  the  most  general  substitution,  such  that  ST&  =`S@k  and 

Z =  -&  Sz&  -  S+k  . 
-  (T',  s)  =  W#g.S( F, ii)  iff  (_, S)  =  ??U.JY( 7,  cc), T'  =  [uniuar(suk)/ak]. 
-  Finally  there  is  a  function  mgc(Q,fi,  V,, I+)  that  computes  an  ideal  G  such  that 

&  C  G +  Qi  (I$,  VK are  used  for  heuristic  purposes  only).  The  algorithm  should  find 

a  large  ideal  G  (few  constraints).  However,  in  general  an  optimal  solution  does  not 
exist  ((m  =  0)  and  (m =  n)  are  both  solutions  to  mgc(n  =  0, m =  0)  but  none  is  better 
than  the  other).  The  following  algorithm  for  mgc(Q,Z?,  I$$, VK) seems  to  work  well 

in  practice: 

lCompute  a  Griibner  basis  in  lex  order,  such  that  reduction  with  this  Griibner  basis 

tends  to  eliminate  V,  and  to  keep  I&. 

Q,' =  griibnerlex(  Qi ) 
where  u>w>u  if  VE  V$,w$&  U  VK,U E  VK 
lTry  to  eliminate  V  as  far  as  possible  from  ZZi 

ZZ; =  nolnlalizee;  (Hi ) 
lEliminate  heuristically  variables  from  the  Q[ 

Q(' =  Elim  (Qc, pv(Q,`)\  pv(ZZ,`)) 
if  eliminable(Qi,pv(Qi)\  pv(ZZ,`)). 
lIf  Yi.Qr  #  8  then  return  C  H,!. 

162  C. Zengerl  Theoretical  Computer  Science  187  (1997)  147-165 

a  Choose  j  such  that  Qy  =  8  and  return 

Now  we  can  specify  kw: 
Definition  10  (Type  inference). 

(uar) ,+, (x  : V'BVii.G +  z)  E  I- [rE/ii]GIT  kw x  .  [j,a][ `;; new  .  -  mnT 

GlSl- kw E:  z  HIS/ST  t-w  F  : T' 
(+  E)w  (I,  U)  =  mgu(S'z,  z' -+ a)  GI new I+G+HIUS'STt-wEF:  Uor 

(_  r)~  GMT, x:a)kwE:z  tl  new 

GlSJ-  l-w  ALE  : Sa  +  z 

(let)  w GlSr  t-w  E  : T'  G'IS'(ST,,x  : a)  t-w  F  : z  o =  Genr(G  +  z') G'IS'ST  kw  (let  x = E  in  F)  : z 

GIS(T,,x  : r~) Fw E  : z'  o = Vii.Qi.2  +  z 
(Z,S')=mgu(z,z')  S'z'  ss  z  G'=mgc(P,Z  +  G,ii,O) 

(fixlw  tv(cr) = 0  pv(o)  =  0  E $Z pv(G')  /%l?i new [ti/ii]P  +  GII[j?/~,rii/ii]SISr  kw  (fix  x  :: (I  in  E)  : [j/i?,ii/Z]z 

GlSr  kw z  : z  __  -  _ (I,  U)  =  mgu(TBZ,  z)  j?, I, rCj new 

GilSiU(ST,2  : [tZi/Si, i/ii,  P/E]fi)  Fw  Ei  : pi 
(z', S')  =  umgu(p,  pv(  UST))  ( W, W')  =  umgs(S'S,  pv(  UST)) 

Hi  =  Gi +  (z'  -  S'pi)  +  ( W -pv((/sr)  W'S'Si)) 

(algE)W  K  = mgc@,  [i+ii,  i/iijQ,  %, pv(  WUSr))  J% $  pv(K) G+I+K(FVUSrkWca~~of  {C&+Ei}i=I,..k:  WT' 
The  soundness  of  W  with  respect  to  ks  was  already  informally  stated  above. 
Proposition  11  (Soundness  W).  If  GlSr  kw  E  : z  then  GlSr  Es  E  : z. 

C.  Zenger  I Theoretical  Computer  Science  187  (1997)  X47-165  163 
We  do  not  have  completeness  for  this  system.  4  For  the  examples  in  the  paper, 
however,  W infers  an  adequate  type. 

7.  Relation  to  other  work 

There  are  no  proper  dependent  types  in  the  presented  system,  because,  if  we  regard 
the  indices  as  types,  there  is  still  no  parameterization  of  types  with  values.  Nevertheless 
we  can,  as  the  examples  above  show,  express  many  things  for  which  other  systems 
use  dependent  types. 

In  AXIOM  [ 151  there  are  very  general  dependent  types,  dependent  products,  and 
sums.  However,  equality  on  values  is  defined  by  term-equality.  This  means  for  example 
that  (Vector  n-1+1)  and  (Vector  n>  are  not  equal  types,  because  n  -  1 +  1  and 
n  are  not  equal  as  terms.  This  allows  to  handle  the  integer  modulo  case  elegantly, 
but  on  the  other  hand  one  cannot  for  example  rewrite  the  above  quicksort  example  in 
AXIOM. 

In  some  type  theoretic  theorem  provers  like  Coq  [5],  LEG0  [19],  and  NuPrl  [4]  there 
are  dependent  types  as  well.  Again,  (Vector  n-1+1)  and  (Vector  n>  do  not  have 
the  same  type,  but  it  is  easy  to  construct  a  conversion  function  from  one  to  the  other 
by  giving  a  proof  of  n  -  1 +  1 =  n.  But  the  burden  of  the  proof  is  on  the  programmer. 

Coquand  describes  a  type  checker  for  such  a  theorem  prover  [8]. 

Existential  quantification  was  studied  by  Cardelli  and  Wegner  [9],  Mitchell  and 
Plotkin  [22]  for  the  description  of  abstract  data  types.  Type  inference  for  existen- 

tial  quantification  in  algebraic  types  is  studied  in  detail  by  Perry  [24]  and  Liiufer  [ 181. 
We  do  not  use  this  in  full  generality  here,  because  we  allow  existential  quantification 
only  for  indices. 

Sulzmann  [26]  examines  type  inference  for  a  general  class  of  constraint  systems. 
But  this  framework  does  not  support  algebraic  types  with  different  constraints  for  the 

constructors,  as  we  need  it  in  our  case. 

Hughes,  Pareto  and  Sabry  [12]  describes  a  very  similar  system  using  Presburger 
arithmetic.  But  besides  using  a  different  constraint  there  are  further  essential  differ- 
ences.  They  do  not  have  arbitrary  indices,  but  the  indices  are  always  an  upper  bound 

for  the  number  of  constructors,  whereas  we  are  more  flexible  to  choose  the  seman- 
tics,  as  we  saw  in  the  matrix-list  examples.  They  use  induction  on  the  index  to  show 
the  type  correctness  of  a  recursive  definition,  where  we  basically  use  induction  on 

the  recursion  depth.  As  a  result  of  this  we  can  type  the  reverse  version  with  accu- 
mulating  parameter,  but  on  the  other  side,  we  might  infer  an  "incorrect"  type  for  a 

non-terminating  or  always  failing  (in  pattern-matching)  function. 

4 At  the  time  of  publication  we  now  use  the  more  general  constraint  system  of  quantified  boolean  formulas 
over  polynomial  equations.  We  think  that  for  this  system  we  have  complete  type  inference. 

164  C.  Zengerl  Theoretical  Computer  Science  187  (1997)  147-165 
8.  Conclusion 

We  presented  a  type  system  in  which  we  can  describe  types  in  more  detail  using 
indices.  This  allows  us  to  detect  more  type  errors  at  compile-time,  for  example  the 
incompatibility  of  sizes  in  a  matrix  multiplication.  We  believe  that  this  extension  could 
be  integrated  into  the  type  systems  of  popular  functional  languages  like  Haskell  or  ML: 

In  recent  languages  with  type  classes  [ 11,13,29]  we  can  declare  the  more  general 

type 

matmult  ::  Matrix  Int -> Matrix Int -> Matrix  Int 

determinant  ::  Matrix  Int  ->  Int 

thereby  allowing  matrix  multiplication  and  determinant  for  matrices  whose  elements  are 

from  rings  other  than  the  integers.  Indexed  trpes  should  combine  well  with  overloading 
calculi  such  as  type  classes  and  type  declarations  like  the  following  look  natural. 

data  Num  a  =>  Vector  a  n  = 
Vnil,  n  =  0  I 

Vcons  a  (Vector  a  m),  m + 1  =  n 

However,  we  cannot  expect  to describe (Matrix a n m) as  an  instance  of  Num  a, 
because  we  cannot  add  or  multiply  any  two  matrices.  But  we  could  add  and  multiply 

square  matrices  of  a  fixed  size.  Whether  such  an  instance  relation  can  be  specified  is 
to  be  investigated. 

As  already  indicated  in  the  section  on  limitations,  the  combination  of  dependent 
types  and  indexed  types  is  interesting.  The  approach  with  Int  and  Int '  indicated  in 
the  section  on  dependent  types  has  to  be  pursued  further. 

Since  the  writing  of  the  paper  we  extended  this  to  quantified  boolean  formulas  over 
polynomial  equations,  which  have  the  advantage  that  we  seem  to  get  complete  type 
inference  using  implication  instead  of  mgc.  Furthermore  we  get  rid  of  the  elimina- 
tion  condition  using  existential  quantification  over  constraints.  It  seems  promising  to 

examine  also  other  constraint  systems,  e.g.  Presburger  arithmetic.  Finite  sets  with  sub- 
set  and  element  relation  to  parameterize  the  polynomial  type  with  the  set  of  variables 
could  also  be  interesting.  The  overall  goal  here  should  be  to  understand  the  connection 
between  constraint  systems  and  algebraic  types  in  more  generality. 

At  the  time  of  publication  we  have  implemented  a  type  checker  for  a  slightly  more 
sophisticated  system  than  the  one  presented  here.  We  use  a  very  simple  heuristic  con- 
straint  solver,  that  works  very  well  with  our  simple  examples.  We  still  have  to  see, 
whether  it  is  feasible  to  use  Griibner  bases  computations  which  are  known  to  be  very 
costly,  for  the  type  inference  of  larger  examples.  We  are  confident  that  it  will  be 

feasible,  because  in  practice  most  constraints  will  be  linear. 

Acknowledgements 

We  thank  the  anonymous  referees  for  their  valuable  comments  on  the  paper. 

C.  Zengeri  Theoretical  Computer  Science  I87  (1997)  147~16s  165 
References 

[1]  B.  Buchberger,  Grijbncr  Bases:  An  algorithmic  method  in  polynomial  ideal  theory,  in:  N.K.  Bose  (Ed.), 

Recent  Trends  in  Multidimensional  Systems  Theory,  D.  Reidel,  Dordrecht,  1985,  pp.  184-232. 
[2]  R.  Bird,  P.  Wadler,  Introduction  to  Functional  Programming,  Prentice-Hall,  Englewood  Cliffs,  1988. 
[3]  T.  Becker,  V.  Weispfemting,  Griibner  Bases,  Springer,  Berlin,  1993. 
[4]  R.L.  Constable,  S.F.  Allen,  H.M.  Bromley,  W.R.  Cleaveland,  J.F.  Cremer,  R.W.  Harper,  D.J.  Howe, 

T.B.  Knoblock,  N.P.  Mendler,  P.  Panangaden,  J.T.  Sasaki,  S.F.  Smith,  Implementing  Mathematics  with 
the  Nuprl  Proof  Development  System,  Prentice-Hall,  Englewood  Cliffs,  NJ,  1986. 
[5]  C.  Comes,  J.  Courant,  J.  Filiatre,  G.  Huet,  P.  Manoury,  C.  Mutt&,  C.  Murtby,  C.  Parent, 

C.  Paulin-Mobring,  A.  SGbi,  B.  Werner,  The  Coq  Proof  Assistant  Reference  Manual.  INRIA- 
Rocquencourt  -  CNRS  -  ENS  Lyon,  5.10  ed.,  1995. 
[6]  D.  Cox,  J.  Little,  D.  O'Shea,  Ideals,  Varieties,  and  Algorithms,  Springer,  Berlin,  1992. 
[7]  G.E.  Collins,  Quantifier  elimination  for  real  closed  fields  by  cylindric  algebraic  decomposition,  in:  2nd 

GI  Conf.  on  Automata  Theory  and  Formal  Languages,  Lecture  Notes  in  Computer  Science,  vol.  33, 

Springer,  Berlin,  1975, 
[S]  T.  Coquand,  An  algorithm  for  type-checking  dependent  types,  preprint,  March  1996. 
[9]  L.  Cardelli,  P.  Wegner,  On  understanding  types,  data  abstraction,  and  polymorphism,  ACM  Comput. 

Surveys  17  (1985)  471-522. 
[lo]  L.  Damas,  R.  Milner,  Principal  type-schemes  for  functional  programs,  in:  Proc.  9th  POPL,  1982, 

pp.  207-212. 
[1 1] P.  Hudak,  S.P.  Jones,  P.  Wadler,  editors.  Report  on  the  Programming  Language  Haskell  Version  1.2, 

vol.  27.  ACM  SIGPLAN,  May  1992. 
[12]  J.  Hughes,  L.  Pareto,  A.  Sabry,  Proving  the  correctness  of  reactive  systems  using  sized  types,  in:  ACM 

Symp.  Principles  of  Programming  Languages,  January  1996. [ 
131  M.P.  Jones,  An  introduction  to  Gofer,  1994. [ 
141  M.P.  Jones,  Qualified  types:  theory  and  practice,  Ph.  D.  thesis,  University  of  Nottingham,  1994. 
[15]  R.D.  Jenks,  R.S.  Sutor,  AXIOM,  Springer,  Berlin,  1992. [ 

161  G.  Kreisel,  J.L.  Krevine,  Elements  of  Mathematical  Logic,  North-Holland,  Amsterdam,  1967. 
[ 171  A.J.  Kfoury,  J.  Tiuryn,  P.  Urzyczyn,  Type  reconstruction  in  the  presence  of  polymorphic  recursion, 

ACM  Trans.  Programming  Languages  and  Systems  15  (April  1993)  29&311. 
[IS]  K.  Laufer,  Polymorphic  type  inference  and  abstract  data  types,  Ph.  D  Thesis,  Department  of  Computer 

Science,  New  York  University,  July  1992. 
[19]  Z.  Luo,  R.  Pollack,  LEG0  proof  development  system:  user's  manual,  Department  of  Computer  Science, 

University  of  Edinburgh,  1992. 
[20]  R.  Milner,  A  theory  of  type  polymorphism  in  programming,  J.  Comput.  System  Sci.  17  (1978)  348-375. 
[21]  A.  Mycroft,  R.A.  O'Keefe,  A  polymorphic  type  system  for  Prolog,  Artificial  Intelligence  23  (1984) 

295307. 
[22]  J.  Mitchell,  G.  Plotkin,  Abstract  types  have  existential  type,  ACM  Trans.  Programming  Languages  10 

(1988)  47&502. 
[23]  M.  Odersky,  K.  Lhfer,  Putting  type  annotations  to  work,  in:  Proc.  23rd  ACM  Symp.  Principles  of 

Programming  Languages  (January  1996)  pp.  6567. 
[24]  N.  Perry,  The  implementation  of  practical  functional  programming  languages,  Ph.  D.  Thesis,  Imperial 

College  of  Science,  Technology,  and  Medicine,  University  of  London,  1990. 
[25]  S.  Peyton-Jones  (Ed.)  Implementation  of  Functional  Languages,  Prentice-Hall,  Englewood  Cliffs,  NJ, 

1990. 
[26]  M.  Sulzmann,  Typinferenz  mit  Constraints  (German),  Master's  Thesis,  University  of  Karlsruhe,  Mai 

1996. 
[27]  D.A.  Turner,  Recursion  equations  as  a  programming  language,  in:  Darlington  et  al.  (Ed.)  Functional 

Programming  and  Its  Applications,  Cambridge  Univ.  Press,  Cambridge,  1982. 
[28]  P.  Wadler,  Deforestation:  Transforming  programs  to  eliminate  trees,  Theoret.  Comput.  Sci.  73  (1990) 

231-248. 
[29]  P.  Wadler,  S.  Blott,  How  to  make  ad-hoc  polymorphism  less  ad-hoc,  in:  Proc.  16th  ACM  Symp. 

Principles  of  Programming  Languages,  1989,  pp.  6&76. 