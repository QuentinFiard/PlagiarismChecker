

Science of Computer Programming 51 (2004) 215-263www.elsevier.com/locate/scico
A discipline of dynamic programming oversequence data

Robert Giegerich* , Carsten Meyer , Peter Ste+en
Faculty of Technology, Bielefeld University, Postfach 10 01 31, 33501 Bielefeld, Germany

Received 13 June 2003; received in revised form 31 October 2003; accepted 8 December 2003

Abstract

Dynamic programming is a classical programming technique, applicable in a wide variety of
domains such as stochastic systems analysis, operations research, combinatorics of discrete struc-
tures, 2ow problems, parsing of ambiguous languages, and biosequence analysis. Little method-
ology has hitherto been available to guide the design of such algorithms. The matrix recurrences
that typically describe a dynamic programming algorithm are di6cult to construct, error-prone
to implement, and, in nontrivial applications, almost impossible to debug completely.

This article introduces a discipline designed to alleviate this problem. We describe an algebraic
style of dynamic programming over sequence data. We de8ne its formal framework, based on a
combination of grammars and algebras, and including a formalization of Bellman's Principle. We
suggest a language used for algorithm design on a convenient level of abstraction. We outline
three ways of implementing this language, including an embedding in a lazy functional language.
The workings of the new method are illustrated by a series of examples drawn from diverse
areas of computer science.

c\Theta  2004 Elsevier B.V. All rights reserved.

1. Power and scope of dynamic programming
1.1. Dynamic programming: a method "by example"

Computer science knows a handful of programming methods that are useful across
many domains of application. Such methods are, for example, structural recursion,

* Corresponding author.

E-mail addresses: robert@techfak.uni-bielefeld.de (R. Giegerich), cmeyer@techfak.uni-bielefeld.de
(C. Meyer), pste+en@techfak.uni-bielefeld.de (P. Ste+en).

0167-6423/$ - see front matter c\Delta  2004 Elsevier B.V. All rights reserved.
doi:10.1016/j.scico.2003.12.005

216 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263
divide-and-conquer, greedy algorithms and genetic algorithms. Dynamic programming
(DP) is another classical programming method, introduced even before the term Com-
puter Science was 8rmly established. When applicable, DP often allows one to solve
combinatorial optimization problems over a search space of exponential size in poly-
nomial space and time. Bellman's "Principle of Optimality" [3] belongs to the core
knowledge of every computer science graduate. Signi8cant work has gone into for-
mally characterizing this principle [37,29,27], formulating DP in di+erent programming
paradigms [28,10] and studying its relation to other general programming methods such
as greedy algorithms [5].

The scope of DP is enormous. Much of the early work was done in the area of
physical state transition systems and operations research [4]. Other, simpler examples
(more suited for computer science textbooks) are optimal matrix chain multiplication,
polygon triangulation, or string comparison. The analysis of molecular sequence data
has fostered increased interest in DP. Protein homology search, RNA structure pre-
diction, gene 8nding, and interpretation of mass spectrometry data pose combinatorial
optimization problems unprecedented in variety and data volume. A recent textbook in
biosequence analysis [11] lists 11 applications of DP in its introductory chapter, and
many more in the sequel.

Developing a DP algorithm for an optimization problem over a nontrivial domain
has intrinsic di6culties. The choice of objective function and search space are inter-
dependent, and inextricably linked to questions of e6ciency. Once completed, all DP
algorithms are expressed via recurrence relations between tables holding intermediate
results. These recurrences provide a very low level of abstraction, and subscript errors
are a major nuisance even in published articles. The recurrences are di6cult to explain,
painful to implement, and almost impossible to debug: A subtle error gives rise to a
suboptimal solution every now and then, which is virtually undetectable by human
inspection.

In this situation it is remarkable that neither the literature cited above, nor many other
computer science textbooks ([22,25,8,1,35], to name but a few) provide guidance in the
development of DP algorithms. It appears that giving some examples and an informal
discussion of Bellman's Principle is all the methodology we can o+er to our students
and practitioners. Notable exceptions are the textbooks by Cormen et al. and SchKoning
[9,33], which recognize this de8ciency and formulate guiding rules on how to approach
a new DP problem. We shall critically review these rules in our conclusion section.
This state of the art is nicely summarized in a quote from an (anonymous) referee com-
menting on an initial version of this work, who wrote: "The development of successful
dynamic programming recurrences is a matter of experience, talent, and luck."

1.2. Basic ideas of algebraic dynamic programming

Algebraic dynamic programming (ADP) is a new style of dynamic programming that
gives rise to a systematic approach to the development of DP algorithms. It allows
one to design, re2ect upon, tune and even test DP algorithms on a more abstract
level than the recurrences that used to be all that was available to deal with dynamic

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 217
programming algorithms. Four steps based on mathematical concepts guide the algorithm
design. Many tricks that have been invented by practitioners of DP can be expressed as
general techniques in ADP. The common aspects of related algorithms can be cleanly
separated from their di+erences. On the implementation side, ADP exactly reproduces
the classical DP recurrences. In principle, 1 nothing is lost in terms of e6ciency. All
this together makes us feel that DP is more and more becoming a discipline, rather
than a "matter of experience, talent and luck". How can this be achieved?

Any DP algorithm evaluates a search space of candidate solutions under a scoring
scheme and an objective function. The classical DP recurrences re2ect the four aspects
of search space construction, scoring, choice, and e6ciency in an indiscriminate fashion.
In any systematic approach, these concerns must be separated. The algebraic approach
to be presented here proceeds as follows:

The search space of the problem at hand is described by a yield grammar, which
is a tree grammar generating a string language. The ADP developer takes the view
that for a given input sequence, "8rst" the search space is constructed, leading to an
enumeration of all candidate solutions. This is a parsing problem, solved by a standard
device called a tabulating yield parser. The developer can concentrate on the design
of the grammar.

Evaluation and choice are captured by an evaluation algebra. It is important (and in
contrast to traditional presentations of DP algorithms) that this algebra comprises all
aspects relevant to the intended objective of optimization, but is independent of the de-
scription of the search space. The ADP developer takes the view that a "second" phase
evaluates the candidates enumerated by the 8rst phase, and makes choices according
to the optimality criterion.

Of course, the interleaving of search space construction and evaluation is essential to
prevent combinatorial explosion. This interleaving is contributed by the ADP method
in a way transparent to the developer.

By the separate description of search space and evaluation, ADP produces modular
and therefore re-usable algorithm components. Often, related optimization problems
over the same search space can be solved merely by a change of the algebra. More
complex problems can be approached with a better chance of success, and there is no
loss of e6ciency compared to ad-hoc approaches. Avoiding the formulation of explicit
recurrences is a major relief, an e+ect captured by early practitioners of ADP in the
slogan "No subscripts, no errors!". We hope that the application examples presented in
this article will convince the reader that following the guidance of ADP in fact brings
about a boost in programming productivity and program reliability.

The ADP approach has emerged recently in the context of biosequence analysis,
where new dynamic programming problems arise almost daily. In spite of its origin in
this application domain, ADP is relevant to dynamic programming over sequential data
in general. "Sequential data" does not mean we only study string problems--a chain
of matrices to be multiplied, for example, is sequential input data in our sense, as
well as the peak pro8les provided by mass spectrometry. An informal introduction to

1 Asymptotic e6ciency is preserved, while the constant factors depend on the mode of implementation,
discussed in Chapter 5.

218 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263
ADP, written towards the needs of the bioinformatics community, has appeared in [15].
The present article gives a complete account of the foundations of the ADP method,
and shows its application to several classical combinatorial optimization problems in
computer science.

Like any methodological work, this article su+ers from the dilemma that for the
sake of exposition, the problems treated here have to be rather simple, such that the
impression may arise that methodological guidance is not really required. The ADP
method has been applied to several nontrivial problems in the 8eld of biosequence
analysis. An early application is a program for aligning recombinant DNA [17], when
the ADP theory was just about to emerge. Two recent applications are searching for
sequence=structure motifs in DNA or RNA [26], and the problem of folding saturated
RNA secondary structures, posed by Zuker and Sanko+ in [39] and solved in [13]. We
shall give a short account of such "real world" applications.

1.3. Overview of this article

In Section 2 we shall review some new and some well known applications of dy-
namic programming over sequence data, in the form in which they are traditionally
presented. This provides a common basis for the subsequent discussion. By the choice
of examples, we illustrate the scope of dynamic programming to a certain extent. In
particular, we show that (single) sequence analysis and (pairwise) sequence compari-
son are essentially the same kind of problem when viewed on a more abstract level.
The applications studied here will later be reformulated in the spirit and notation of
ADP.

In Section 3 we introduce the formal basis of the ADP method: Yield grammars
and evaluation algebras. We shall argue that these two concepts precisely catch the
essence of dynamic programming, at least when applied to sequence data. Furthermore,
we introduce a special notation for expressing ADP algorithms. Using this notation
an algorithm is completely described on a very abstract level, and can be designed
and analyzed irrespective of how it is eventually implemented. We discuss e6ciency
analysis and point to other work concerning techniques to improve e6ciency.

In Section 4 we formulate the ADP development method and develop yield gram-
mars and evaluation algebras for the applications described in Section 2. Moreover we
show how solutions to problem variants can be expressed transparently using the ADP
approach.

Section 5 indicates three ways of actually implementing an algorithm once it is
written in ADP notation: The 8rst alternative is a direct embedding and execution in
a functional programming language, the second is manual translation to the abstrac-
tion level of an imperative programming language. The third alternative, still under
development, is the use of a system which directly compiles ADP notation into C
code.

In the conclusion, we discuss the merits of the method presented here, evaluate its
scope, and glance at its possible extensions.

This article may be read in several di+erent ways. Readers familiar with standard
examples of dynamic programming may jump right away to the theory in Section 3.

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 219
Readers mainly interested in methodology, willing to take for granted that ADP can
be implemented without loss of e6ciency, may completely skip Section 5.

2. Dynamic programming in traditional style

In this section we discuss four introductory examples of dynamic programming,
solved by recurrences in the traditional style. Three will be reformulated in algebraic
style in Section 4. We begin our series of examples with an algorithmic fable.

2.1. The oldest DP problem in the world

Our 8rst example dates back to the time at around 800. Al Chwarizmi, today known
for his numerous important discoveries in elementary arithmetic and dubbed as the
father of algorithmics, was a scholar at the House of Wisdom in Baghdad. At that
time, the patron of the House of Wisdom was El Mamun, Calif of Baghdad and son
of Harun al Raschid. It is told, that one day the Calif called for Al Chwarizmi for
a special research project. He presented the formula 1 + 2 * 3 * 4 + 5, which had its
origins in a bill for a couple of camels, as he remarked. Unfortunately, the formula
was lacking the parentheses. The task was to 8nd a general method to redraw the
parentheses in the formula (and any similar one) such that the outcome was either
minimized or maximized--depending on whether the Calif was on the buying or on
the selling side.

We now provide a DP solution for El Mamun's problem. Clearly, explicit parentheses
add some internal structure to a sequence of numbers and operators. They tell us how
subexpressions are grouped together--which are sums, and which are products. Let us
number the positions in the text t representing the formula:

t = 0 1 1 + 2 2 3 * 4 3 5 * 6 4 7 + 8 5 9 (1)
such that we can refer to substrings by index pairs: t(0; 9) is the complete string t,
and t(2; 5) is 2 * 3. A substring t(i; j) that forms an expression can, in general, be

evaluated in many di+erent ways, and we shall record the best value for t(i; j) in a
table entry T (i; j). Since addition and multiplication are strictly monotone functions on
positive numbers, an overall value (x + y) or (x * y) can only be maximal if both
subexpressions x and y are evaluated to their maximal values. So it is in fact su6cient
to record the maximum in each entry. This is our 8rst use of Bellman's Principle, to
be formalized later.

More precisely, we de8ne

T (i; i + 1) = n; if t(i; i + 1) = n; (2)
T (i; j) = max{T (i; k) \Lambda  T (k + 1; j)|i ! k ! j; t(k; k + 1) = \Lambda }; (3)
where \Lambda  is either + or *. Beginning with the shortest subwords of t, we can compute
successively all de8ned table entries.

220 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263
Fig. 1. Results for the maximization and minimization of El Mamun's bill denoted as tuple (x; y) where x
is the minimal value and y the maximal value.

In T (0; 9) we obtain the maximal possible value overall. If, together with T (i; j),
we also record the position k within (i; j) that leads to the optimal value, then we can
reconstruct the reading of the formula that yields the optimal value. It is clear that
El Mamun's minimization problem is solved by simply replacing max by min. Fig. 1
gives the results for maximization and minimization of El Mamun's bill.

Note that we have left open a few technical points: We have not provided explicit
code to compute the table T , which is actually triangular, since i is always smaller
than j. Such code has to deal with the fact that an entry remains unde8ned when t(i; j)
is not a syntactically valid expression, like t(1; 4) = "+ 2 *". In fact, there are about
as many unde8ned entries as there are de8ned ones, and we may call this a case of
sparse dynamic programming and search for a more clever form of tabulation. Another
open point is the possibility of malformed input, like the nonexpression "1 + * 2". The

implementation shown later will take care of all these cases.

The 8rst discovery Al Chwarizmi made, was that there were 14 di+erent ways to
evaluate the bill. In Section 4 we will see that the solution for this problem closely
follows the recurrences just developed, except that there is no maximization or mini-
mization involved. This is a combinatorial counting problem. Although DP is commonly
associated with optimization problems, we will see that its scope is actually wider.

2.2. Matrix chain multiplication

A classical dynamic programming example is the matrix chain multiplication problem
[9]. Given a chain of matrices A1; : : : ; An, 8nd an optimal placement of parentheses
for computing the product A1 * * * * * An. Since matrix multiplication is associative,
the placement of parentheses does not a+ect the 8nal value. However, a good choice
can dramatically reduce the number of scalar multiplications needed. Consider three
matrices A1; A2; A3 with dimensions 10 * 100; 100 * 5 and 5 * 50. Multiplication of (A1*
A2) * A3 needs 10 * 100 * 5 + 10 * 5 * 50 = 7500 scalar multiplications, in contrast to
10 * 100 * 50 + 100 * 5 * 50 = 75000 when choosing A1 * (A2 * A3).

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 221
Let M be a n * n table. Table entry M (i; j) shall hold the minimal number of
multiplications needed to calculate Ai * * * * * Aj. Compared to the previous example, the
construction of the search space is considerably easier here since it does not depend
on the structure of the input sequence but only on its length. M (i; j) = 0 for i = j.
In any other case there exist j \Phi  i possible splittings of the matrix chain Ai; : : : ; Aj
into two parts (Ai; : : : ; Ak) and (Ak+1; : : : ; Aj). Let (ri; ci) be the dimension of matrix
Ai, where ci = ri+1 for 16i!n. Multiplying the two partial product matrices requires
rick cj operations. Again we observe Bellman's Principle. Only if the partial products
have been arranged internally in an optimal fashion, can this product minimize scalar
multiplications overall. We order table calculation by increasing subchain length, such
that we can look up all the M (i; k) and M (k +1; j) when needed for computing M (i; j).

This leads to the following matrix recurrence:

for j = 1 to n do (4)

for i = j to 1 do

M (i; j) = \Delta  0 for i = jmin{M (i; k) + M (k + 1; j) + rickcj | i6k!j} for i!j
return M (1; n) (5)
Minimization over all possible splittings gives the optimal value for M (i; j).

This example demonstrates that dynamic programming over sequence data is not
necessarily limited to (character) strings, but can also be used with sequences of other
types, in this case pairs of numeric values denoting matrix dimensions.

2.3. Global and local similarity of strings

We continue our series of examples by looking at the comparison of strings. The
measurement of similarity or distance of two strings is an important operation applied
in several 8elds, for example spelling correction, textual database retrieval, speech
recognition, coding theory, or molecular biology.

A common formalization is the string edit model [22]. We measure the similarity
of two strings by scoring the di+erent sequences of character deletions (denoted by
D), character insertions (denoted by I) and character replacements (denoted by R) that
transform one string into the other. If a character is unchanged, we formally model
this as a replacement by itself. Thus, an edit operation is applied at each position.

Fig. 2 shows some possibilities to transform the string MISSISSIPPI into the string
SASSAFRAS, visualized as an alignment.

MISSI--SSIPPI MISSISSIPPI- MISSI---SSIPPI
SASSAFRAS---- ---SASSAFRAS SASSAFRAS-----

RR RIIR DDDD DDD R RRRRI RR RIII DDDDD

Fig. 2. Three out of many possible ways to transform the string MISSISSIPPI into the string SASSAFRAS.
Only deletions, insertions, and proper replacements are marked.

222 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263

A similarity scoring function j associates a similarity score of 0 with two empty
strings, a positive score with two characters that are considered similar, a negative
score with two characters that are considered dissimilar. Insertions and deletions also
receive negative scores. For strings x of length m and y of length n, we compute
the similarity matrix Em;n such that E(i; j) holds the similarity score for the pre-
8xes x1; : : : ; xi and y1; : : : ; yj. E(m; n) therefore holds the overall similarity value of
x and y.

E is calculated by the following recurrences:

E(0; 0) = 0 (6)
for i = 0 to m \Phi  1 do E(i + 1; 0) = E(i; 0) + j(D(xi+1)) (7)
for j = 0 to n \Phi  1 do E(0; j + 1) = E(0; j) + j(I (yj+1)) (8)
for i = 0 to m \Phi  1 do

for j = 0 to n \Phi  1 do

E(i + 1; j + 1) = max \Theta \Lambda \Xi 

E(i; j + 1) + j(D(xi+1))
E(i + 1; j) + j(I (yj+1))
E(i; j) + j(R(xi+1; yj+1))

\Pi \Sigma 
\Upsilon  (9)
return E(m; n) (10)

The space and time e6ciency of these recurrences is O(mn).

Often, rather than computing the (global) similarity of two strings, it is necessary to
search for local similarities within two strings. In molecular sequence analysis, we study
DNA sequences, given as strings from four types of nucleotides, or protein sequences,
given as strings from a 20-letter alphabet of amino acids. In DNA, we often have long
noncoding regions and small coding regions. If two coding regions are similar, this
does not imply that the sequences have a large global similarity. If we investigate a
protein with unknown function, we are interested in 8nding a `similar' protein with
known biological function. In this situation, the functionally important sequence parts
must be similar while the rest is arbitrary.

Local similarity asks for the best match of a subword of x with a subword of y.
The Smith and Waterman algorithm [36] requires O(mn) time and space to solve this
problem. We compute a matrix Cm;n where the entry C(i; j) contains the best score for
all pairs of su6xes of x1 : : : xi and y1 : : : yj.

C(i; j) = max{score(x\Delta ; y\Delta )|x\Delta  su6x of x1 : : : xi and y\Delta  su6x of y1 : : : yj}: (11)
Since we are looking for a local property, it must be possible to match arbitrary sub-
words of x and y without scoring their dissimilar pre8xes and su6xes. These subwords
are named x\Delta  and y\Delta  in (11), and their score is computed as in the global similarity
case. In order to reject pre8xes with negative scores, all we need to change in com-
parison to the recurrences for global similarity (see Eqs. (6)-(10)) is to 8x the 8rst
line and column to zero-values and to add a zero-value case in the calculation of the

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 223
entry C(i + 1; j + 1). This zero amounts to an empty pre8x pair joining the competition
for the best match at each point (i; j).

for i = 0 to m \Phi  1 do C(i; 0) = 0 (12)
for j = 0 to n \Phi  1 do C(0; j) = 0 (13)
for i = 0 to m \Phi  1 do

for j = 0 to n \Phi  1 do

C(i + 1; j + 1) = max

\Theta \Phi \Phi \Lambda 

\Phi \Phi \Xi 

0
C(i; j + 1) + j(D(xi+1))
C(i + 1; j) + j(I (yj+1))
C(i; j) + j(R(xi+1; yj+1))

\Pi \Phi \Phi \Sigma 
\Phi \Phi \Upsilon  (14)
return maxi;j C(i; j) (15)
Eq. (15) performs an extra traversal of table C to obtain the highest score overall.

2.4. Fibonacci numbers and the case of recursion versus tabulation

In this last introductory example, we make our 8rst deviation from the traditional
view of dynamic programming. There are many simple cases where the principles of
DP are applied without explicit notice. Fibonacci numbers are a famous case in point.
They are de8ned by

F(1) = 1; (16)
F(2) = 1; (17)
F(i + 2) = F(i + 1) + F(i): (18)
Fibonacci numbers may seem atypical as a DP problem, because there is no opti-
mization criterion. We have already remarked (cf. Section 2.1) that optimization is an
important, but not a mandatory constituent of a dynamic programming problem.

Every student of computer science knows that computing F as a recursive function
is very ine6cient--it takes 2F(n) \Phi  1 calls to F to compute F(n). Although we really
need only the n values F(1) through F(n \Phi  1) when computing F(n), each value
F(n \Phi  k) is calculated not once, but F(k + 1) times. The textbook remedy to this
ine6ciency is strengthening the recursion--de8ne

F(n) = Fib(0; 1; n); (19)
Fib(a; b; i) = if (i = 1) then b else Fib(b; a + b; i \Phi  1): (20)
Here we shall consider another solution. This one requires no rede8nition of F at
all, just a change of data type: Consider F as an integer array, whose elements are
de8ned via Eqs. (16)-(18). In a data driven programming language, its elements will
be calculated once when 8rst needed. In an imperative language, since F is now data
rather than a function, we need to add explicit control structure--an upper bound for
n and a for-loop to actually calculate the array elements in appropriate order.

224 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263

The lesson here is the observation that a table (matrix, array) over some index
domain, de8ned by recurrences, is mathematically equivalent to a recursive function
de8ned by the very same recurrences. The di+erence lies solely in the e6ciency of the
actual computation. What requires exponential e+ort in the case of recursive functions
may require only polynomial e+ort when using tabulation. This gives us a 8rst hint
at a more systematic development of DP algorithms: Think of a DP algorithm as a
family of recursive functions over some index domain. Do not worry about tabulation
and evaluation order, this can always be added when the design has stabilized.

2.5. Summary of Section In all the examples studied, there was 8rst some informal reasoning, including a
consideration of Bellman's Principle, and subsequently we wrote down the recurrences.
(In the Fibonacci example, only a single value is generated for each subproblem. Hence,
the objective function degenerates to the identity, and Bellman's Principle is trivially
satis8ed.) While these examples are simple enough to be solved this way, for more
ambitious tasks it would be nice to have a more abstract level that supports formal
reasoning about the problem. For example, none of our examples provides a description
of the search space, and asking for its size or the (non-)redundancy of its traversal
requires to develop another set of--similar, but not identical--recurrences.

Typically, the scoring scheme is meant to be a parameter of the algorithm, but
this separation is not perfect. This applies to the score function j used in the string
comparison example. Consider the zero case added in the Smith-Waterman recurrences:
It appears to be a part of the algorithm, but we shall see later, that it actually belongs
to the scoring scheme. The same holds for the fact that scores from individual edit
operations are added up rather than combined in some other fashion.

In the sequel, we shall seek a perfect separation of concerns, which will make our
programs easier to understand, and usable in a modular fashion.

3. Foundations of algebraic dynamic programming

ADP is based on the notions of yield grammars, evaluation algebras, and a formal-
ization of Bellman's Principle. They are introduced in this section, while the program
development method based on them is formulated at the beginning of Section 4.

3.1. Basic terminology

Alphabets. An alphabet A is a 8nite set of symbols. Sequences of symbols are called
strings. OE denotes the empty string, A1 = A, An+1 = {ax|a \Psi  A; x \Psi  An}, A+ = \Psi n?1
An, A* = A+ \Omega  {OE}.

Signatures and algebras. A (single-sorted) signature O/ over some alphabet A con-
sists of a sort symbol S together with a family of operators. Each operator o has a
8xed arity o : s1 : : : sko ff S, where each si is either S or A. A O/-algebra I over A,

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 225
also called an interpretation, is a set SI of values together with a function oI for each
operator o. Each oI has type oI : (s1)I : : : (sko)I ff SI where AI = A.

A term algebra TO/ arises by interpreting the operators in O/ as constructors, building
bigger terms from smaller ones. When variables from a set V can take the place of
arguments to constructors, we speak of a term algebra with variables, TO/(V ), with
V fi TO/(V ). By convention, operator names are capitalized in the term algebra.

Tree grammars. Terms will be viewed as rooted, ordered, node-labeled trees in the
obvious way. All inner nodes carry (nonnullary) operators from O/, while leaf nodes
carry nullary operators or symbols from A. A term=tree with variables is called a tree
pattern. A tree containing a designated occurrence of a subtree t is denoted C[: : : t : : :].

A tree language over O/ is a subset of TO/. Tree languages are described by tree gram-
mars, which can be de8ned by analogy to the Chomsky hierarchy of string grammars.
Here we use regular tree grammars, originally studied in [7]. In [19] they were rede-
8ned to specify term languages over some signature. This is the form of tree grammars
we use here- our further specialization in De8nition 1 lies solely in the distinguished
role of A.

Deo/nition 1 (Tree grammar over O/ and A). A (regular) tree grammar G over O/ and
A is given by

* a set V of nonterminal symbols,*

a designated nonterminal symbol Z, called the axiom, and*
a set P of productions of the form v ff t, where v \Psi  V and t \Psi  TO/(V ).

The derivation relation for tree grammars is ff*, with C[: : : v : : :] ff C[: : : t : : :] if v ff t \Psi 

P. The language of v \Psi  V is L(v) = {t \Psi TO/|vff*t}, the language of G is L(G)=L(Z).

Fig. 3 shows a tree grammar for the global similarity example of Section 2.3.

For convenience, we add a lexical level to the grammar concept, allowing strings
from A* in place of single symbols. By convention, achar denotes an arbitrary char-
acter, char c a speci8c character c, string an arbitrary string and empty the empty
string.

Also for brevity, we allow syntactic conditions associated with righthand sides.

Nil
'$'

Grammar globsim, axiom alignment

achar acharalignment

R

I

acharalignmentalignmentachar
Dalignment 

Fig. 3. The tree grammar globsim for global similarity (see Section 2.3).

226 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263
Fig. 4. The term representation of a global similarity candidate candidate1 for darling and airline, and
the tree representation of this term. Only the rightmost R is a proper replacement, the others are matches.

The yield of a tree is normally de8ned as its sequence of leaf symbols. Here we are
only interested in the symbols from A*- nullary constructors by de8nition have yield
OE. A formal de8nition follows in Section 3.4.

Fig. 4 shows a tree derived by grammar globsim, together with its yield string.

3.2. Conceptual separation of recognition and evaluation

Any dynamic programming algorithm implicitly constructs a search space from its
input. The elements of this search space have been given di+erent names: policy in
[3], solution in [29], subject under evaluation in [15]. Since the former two terms
have been used ambiguously, and the latter is rather technical, we shall use the termcandidate

for elements of the search space. Each candidate will be evaluated, yielding
a 7nal state, a cost, or a score, depending whether one follows [3,29] or [11]. We
shall use the term answer for the result of evaluating a candidate.

Typically, there is an ordering de8ned on the answer data type. The DP algorithm
returns a maximal or minimal answer, and if so desired, also one or all the candidates
that evaluate(s) to this answer. Often, the optimal answer is determined 8rst, and a
candidate that led to it is reconstructed by backtracing. The candidates themselves do
not have an explicit representation during the DP computation. Our goal to separate
recognition and evaluation requires an explicit representation of candidates.

This is our general idea of how to obtain such an explicit representation of can-
didates in any DP algorithm: Imagine that during computing an answer, we did not
actually call those functions that perform the evaluation. Instead, we would apply them
symbolically, building up a formula that--once evaluated--would yield this answer
value. This formula itself is a perfect choice for the candidate representation, because*

the formula represents everything we need to know about the candidate to eventually
evaluate it,*
the complete ensemble of such formulas, constructed for a speci8c problem instance,
is a precise description of the search space.
Apparently, the above idea works for any DP algorithm over any data domain. After
all, whenever we compute an answer value, we can as well compute it symbolically
and record the formula. The subsequent treatment, however, only considers the case of
sequential input. Our running example of global string similarity actually requires two

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 227
string inputs. Fig. 4 shows a global similarity candidate for the strings "darling" and
"airline". To represent them as a single string, the latter is reversed and appended
to the former, separated by a separator symbol $ not occurring elsewhere. 2

To design a DP algorithm, we therefore need to specify three aspects: the language
of candidate formulas, the search space of candidates spawned by a particular input,
and their eventual evaluation. We start with the latter aspect.

3.3. Evaluation algebras
Deo/nition 2 (Evaluation algebra). Let O/ be a signature with sort symbol Ans. A O/-
evaluation algebra is a O/-algebra augmented with an objective function h : [Ans] ff
[Ans], where [Ans] denotes lists over Ans.

In most DP applications, the purpose of the objective function is minimizing or
maximizing over all answers. We take a slightly more general view here. Aside from
minimization or maximization, the objective may be to calculate a sample of answers,
or all answers within a certain threshold of optimality. It could even be a complete
enumeration of answers. We may compute the size of the search space or evaluate it
in some statistical fashion, say by averaging over all answers. This is why in general,
the objective function will return a list of answers. Each answer is the evaluation of a
candidate- if the enumeration of candidates is our objective, it is the candidate itself. If
maximization is our objective, this list holds the maximal answer as its only element.
If the search space should be empty for a particular input, this list will be empty.

We formulate a signature & for the global similarity example:

Nil : A ff Ans
D : A * Ans ff Ans
I : Ans * A ff Ans
R : A * Ans * A ff Ans
h : [Ans] ff [Ans]

We formulate two evaluation algebras for signature &. The algebra unit (Fig. 5
right) scores each matching character by +1, and each character mismatch, deletion or
insertion by \Phi 1. The algebra wgap (Fig. 5 left) is a minor generalization of unit. It
uses two parameter functions w and gap, that may score (mis)matches and deletions
or insertions depending on the concrete characters involved. For example, a phoneticist
would choose w('v','b') as a (positive) similarity rather than a (negative) mismatch.

For term candidate1 of Fig. 4, we obtain:

candidate1unit = 2
candidate1wgap = gap('d') + w('a','a') + gap('i')+ w('r','r') +

w('l','l') + w('i','i')+ w('n','n') + w('e','g') + 0

2 In Section 5.1 the relation between single sequence analysis and pairwise sequence comparison is
discussed.

228 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263

Answgap = N Ansunit = N
wgap = (nil,d,i,r,h) unit = (nil,d,i,r,h)

where where
nil(a) = 0 nil(a) = 0
d(x,s) = s + gap(x) d(x,s) = s - 1
i(s,y) = s + gap(y) i(s,y) = s - 1
r(a,s,b) = s + w(a,b) r(a,s,b) = if a==b then s + 1 else s - 1
h([]) = [] h([]) = []
h (l) = [maximum(l)] h (l) = [maximum(l)]

Fig. 5. Algebras wgap (left) and unit (right).

3.4. Yield grammars

To describe the search space, we have to solve two problems: Not all elements
of TO/ are legal candidates in general, and for a given input, only the legal candi-
dates are to be considered which have this input as their yield. In our formalism,
the yield function y has type TO/ ff A* and is de8ned by y(a) = a for a \Psi  A, and
y(C(x1; : : : ; xn)) = y(x1) : : : y(xn) for n?0 and each n-ary operator C of O/.

Deo/nition 3 (Yield grammars and yield languages). Let G be a tree grammar over O/
and A, and y the yield function. The pair (G; y) is called a yield grammar. It de8nes
the yield language L(G; y) = y(L(G)).

The grammar of Fig. 3 can now be interpreted in two ways: as a regular tree grammar
de8ning the tree language L(G), or as a yield grammar, de8ning the string language
y(L(G)).

Deo/nition 4 (Yield parsing). Given a yield grammar (G; y) over A and w \Psi  A*, the
yield parsing problem is: Find PG(w):={t \Psi  L(G)|y(t) = w}.

Yield parsing is the computational engine underlying ADP. The search space spawned
by input w is PG(w). A yield parser constructs the terms t \Psi  TO/ in a bottom up fashion,
identically to the way in which an interpretation I evaluates the term tI. Thus, if we
substitute each term constructor function - in the yield parser by the function -I of
the evaluation algebra, the "parser" will produce answers of the desired kind rather
than terms representing candidates.

3.5. Algebraic dynamic programming and Bellman's Principle

Given that yield parsing traverses the search space, all that remains to do is to
evaluate the candidates in some algebra and apply the objective function.

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 229
Deo/nition 5 (Algebraic dynamic programming).*

An ADP problem is speci8ed by a signature O/ over A, a yield grammar (G; y) over
O/, and a O/-evaluation algebra I with objective function hI.*
An ADP problem instance is posed by a string w \Psi  A*. The search space it spawns
is the set of all its parses, PG(w).*
Solving an ADP problem is computing

hI{tI | t \Psi  PG(w)}:
in polynomial time and space with respect to |w|.
So far, there is one essential ingredient missing: e6ciency. Since the size of the
search space may be exponential in terms of the input size, an ADP problem can be
solved in polynomial time and space by the yield parser only under the condition well
known as Bellman's Principle of Optimality. In Bellman's own words:

An optimal policy has the property that whatever the initial state and initial de-
cision are, the remaining decisions must constitute an optimal policy with regard
to the state resulting from the 8rst decision [3].
We formalize this principle:

Deo/nition 6 (Algebraic version of Bellman's Principle). An evaluation algebra satis-
8es Bellman's Principle, if for each k-ary operator f in O/ and all answer lists z1; : : : ; zk,
the objective function h satis8es

h([f(x1; : : : ; xk) | x1 ffi z1; : : : ; xk ffi zk])
= h([f(x1; : : : ; xk) | x1 ffi h(z1); : : : ; xk ffi h(zk)]):

The practical meaning of the optimality principle is that we may push the applica-
tion of the objective function inside the computation of subproblems, thus preventing
combinatorial explosion. We have formulated Bellman's Principle such that it is correct
to reduce any intermediate answer list, computed by any function -, by an application
of the choice function h.

In practice, we can allow ourselves to cheat a little bit: We may omit the application
of h for answers computed by certain "bad" functions f not satisfying the principle.
This means we have to deal with longer intermediate answer lists, until a "good"
function is applied to them. In practice, we shall annotate the tree grammar to indicate
the cases where h is to be applied.

The above formulation of Bellman's Principle assumes that all answers from di+erent
alternatives of a production are computed before the choice function is applied to the
answer list. This is normally su6cient, and we know of only one exception, where
a choice from the answers of alternatives 1 and 2 is required before alternative 3
is considered. This exception, however, is quite an interesting one--a technique that
enables the production of an arbitrary number of answers in order of optimality, by a
merge-sorting of the intermediate answer lists [18]. In such a case, Bellman's Principle

230 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263
must be strengthened by another requirement:

h(z1 ++ z2) = h(h(z1) ++ h(z2)):
Comparing our version of Bellman's Principle to others given in the literature, we
8nd that it is quite general, because nothing is assumed about the choice function
except that it maps lists to lists. The standard case, considered by Bellman and in
most programming textbooks, arises when h is optimization with respect to some total
ordering- in this case our condition requires monotonicity of each -. In the words
of [6], - distributes over the ordering relation. Morin elaborates the case when h is
to return all smallest (or largest) answers [29]. In this case, our condition implies
strict monotonicity, consistent with Morin's analysis. Our condition also applies in
settings where no optimization is involved. In the counting algebras introduced in the
next section, h is list summation while - is *, and the counting algebras are correct
because * distributes over +. A similar situation arises with the probabilistic algebras
used for signi8cance evaluation of structural motifs in RNA [26].

In their relational "Algebra of Programming" [6], Bird and de Moor cast optimization
problems in the form min R * /(([S]) * ([Q])\Lambda ). Here, ([Q])\Lambda  is the inverse of an homo-
morphism from some intermediate data type to the input domain. ([S]) is evaluation.
/ is needed to convert relations to set-valued functions, and 8nally, min R denotes
minimization with respect to relation R. Thus, our concepts TO/; I and h are explicitly
present in the relational approach as Q; S and R, while G remains implicit. The need
for G is not felt in [6], since the grammars implicit in the examples studied there only
use a single nonterminal symbol, and structural recursion over TO/ is su6cient in such a
case. We shall later see examples where all the craftsmanship of DP lies in the design
of nontrivial grammars (Section 4.5).

The relational formalism is more general than ours, as programs can be relations
and the input domain is not restricted to sequential data. Another, minor di+erence
is that our choice function h is not restricted to optimization--this is motivated by

the development methodology we shall propose, and its usefulness will emerge in
Section 4. Aside from this aspect, the ADP approach can be seen as a specializa-
tion of the relational formalism, which operates on an intermediate level of abstrac-
tion, giving us more control over the actual implementation while retaining conceptual
clarity.

This completes the basic theoretical framework of ADP. We can now practice ADP
with pencil and paper--but we want more.

3.6. ADP notation

For practical algorithm development in the ADP framework, we need a computer
readable notation, which will be introduced in this section. The declarative semantics
of ADP notation is that it allows one to describe signatures, evaluation algebras and
yield grammars. The operational semantics of ADP notation is that of DP recurrences--
ADP notation actually constitutes executable code. How this is achieved is an aspect
completely deferred to Section 5.

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 231
The signature O/ is written as an algebraic data type de8nition in the style of the
functional programming language Haskell [31]. This is signature & in ADP notation:

data Alignment = Nil Char |

D Char Alignment |
I Alignment Char |
R Char Alignment Char

As in EBNF, the productions of the yield grammar are written as equations. The
operator <<< is used to denote the application of a tree constructor to its arguments, which
are chained via the ~~~-operator. Operator ||| separates multiple righthand sides of a non-
terminal symbol. Parentheses are used as required for larger trees. (Later, this notation
will also be embedded in Haskell (Section 5); for the moment, just take it as our ASCII
notation for yield grammars.) The axiom symbol is indicated by the keyword axiom,
and syntactic conditions may be attached to productions via the keyword with. Finally,
the evaluation algebra is a tuple of functions, provided as a single parameter alg with
the grammar, which is split up into its components by a pattern matching clause.

This is the grammar globsim in ADP notation:

globsim alg = axiom alignment where

(nil, d, i, r, h) = alg

alignment = nil <<< char '$' |||

d <<< achar ~~~ alignment |||
i <<< alignment ~~~ achar |||
r <<< achar ~~~ alignment ~~~ achar

3.7. Parsing, tabulation and choice

Given a yield grammar and an evaluation algebra, a tabulating yield parser will
solve a problem instance as declared in De8nition 5. Implementation of yield parsing
is explained in detail in Section 5.2. For programming with ADP, we do not really
have to know how yield parsing works. Think of it as a family of recursive functions,
one for each nonterminal of the grammar. However, the yield parser needs two pieces
of information not yet expressed in the grammar: tabulation and choice.

If nothing was said about tabulation, the yield parser would compute partial re-
sults many times, quite like our original Fibonacci function. By adding the keyword
"tabulated", we indicate that the parser for a particular nonterminal symbol shall
make use of tabulation. When a tabulated symbol v is used in a righthand side, this
means a table lookup rather than a recursive call.

In the small examples we have shown so far, there is only a single nonterminal
symbol, and naturally, it is tabulated. In larger grammars, typically only a subset of
all nonterminal symbols needs to be tabulated. This is why we provide an explicit
keyword to indicate tabulation. It is in fact a major advantage of ADP that we can
write the grammar 8rst and afterwards decide about tabulation. One might even think
of automating the task of table assignment, but trying to optimize both time and space
requirements makes this a di6cult problem.

232 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263

If nothing was said about choice, the parser would not apply the objective function
and hence return a list of all answers. By adding "...h" to the righthand side of a
production, we indicate that whenever a list of alternative answers has been constructed
according to this production, the objective function h is to be applied to it.

With these two kinds of annotation, our yield grammar example globsim looks like
this:

globsim alg = axiom alignment where

(nil, d, i, r, h) = alg

alignment = tabulated(

nil <<< char '$' |||
d <<< achar ~~~ alignment |||
i <<< alignment ~~~ achar |||
r <<< achar ~~~ alignment ~~~ achar ... h)

3.8. E!ciency analysis of ADP programs

From the viewpoint of programming methodology, it is important that asymptotic
e6ciency can be analyzed and controlled on the abstract level. This property is a
major virtue of ADP--it allows one to formulate e6ciency tuning as grammar and
algebra transformations. Such techniques are described in [18]. Here we give only the
de8nition and the theorem essential for determining the e6ciency of an ADP algorithm.

Deo/nition 7 (Width of productions and grammar). Let t be a tree pattern, and let k be
the number of nonterminal or lexical symbols in t whose yield size is not bounded by
a constant. We de8ne width(t) = k \Phi  1. Let 2 be a production v ff t1 | : : : | tr. We de8ne
width(2) = max{width(t1; : : : ; tr)}, and width(G) = max{width(2) | 2 is a production
in G}.

Theorem 8. Assuming the number of answers selected by each application of h isbounded by a constant

, the execution time of an ADP algorithm described by yield
grammar (G; y) on input w of length n is O(n2+width(G)).

Proof. See [20].

In a standard application using minimization or maximization, the objective function
h always reduces an answer list to a single (minimal or maximal) element. Asking
for the k best answers, where k is a constant, does not a+ect asymptotic e6ciency.
However, in some applications one might ask for all answers, or for all answers within
a certain threshold of optimality. In such a case, the algorithm will become output
sensitive, as even a fraction of all answers may have a size exponential in n.

Considering the e6ciency of globsim, we 8nd that all productions have width 0.
Hence, Theorem 8 says that the global similarity problem is solved in O(n2) space and
time, consistent with the explicit recurrences given in Eqs. (6)-(10) (Section 2.3).

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 233
3.9. A summary of the ADP framework

By means of an evaluation algebra and a yield grammar we can completely specify
a dynamic programming algorithm. We can analyze its e6ciency using Theorem 8. We
suggest a speci8c notation for writing grammars and algebras, which will be converted
into executable yield parsers in Section 5.

This completes our framework. Let us summarize the key ideas of Algebraic Dy-
namic Programming:

Phase separation: We conceptually distinguish recognition and evaluation phases.
Term representation: Individual candidates are represented as elements of a term
algebra TO/- the set of all candidates is described by a tree grammar.

Recognition: The recognition phase constructs the set of candidates arising from a
given input string, using a tabulating yield parser.

Evaluation: The evaluation phase interprets these candidates in a concrete O/-algebra,
and applies the objective function to the resulting answers.

Phase amalgamation: To retain e6ciency, both phases are amalgamated in a fashion
transparent to the programmer. The term algebra in the yield parser is substituted by
an evaluation algebra.

When running the algorithm, the candidate representation e+ectively cancels out. This
is why it is not seen in traditional DP recurrences. For algorithm design, however, it
plays a crucial role. It allows one to resolve the conglomeration of issues criticized ini-
tially. While the traditional recurrences deal with search space construction, evaluation
and e6ciency concerns in a nonseparable way, ADP has separated them: Evaluation is
in the algebra, the search space is in the grammar, and e6ciency concerns are treated
by the grammar annotation.

3.10. Yield grammars versus context free grammars

Before proceeding, let us comment on the most frequent question asked by computer
scientists when 8rst confronted with the ADP approach. It is easy to show that yield
languages are simply context free languages (cf. [20]). Could not the same be achieved
by sticking with the familiar context free grammars and their parse trees? The answer
is no. Yield grammars are a two level concept, 8rst generating a tree by the tree
grammar and then deriving its yield. Shortcutting the two-level scheme by a context
free grammar eliminates the generated tree--the candidate--which is our cornerstone
for the separation of the search space and its evaluation.

We discuss three situations where the di+erence between using CFGs or yield gram-
mars matters. The 8rst case is a matter of convenience, the second a matter of e6-
ciency, and the third a matter of ambiguity control.

Imagine we are using CFGs and an Earley or CYK-type parser that calls a semantic
routine with each production. Consider three tree grammar productions:

a = f <<< b ~~~ (g <<< c ~~~ d)
b = f <<< b ~~~ c |||

g <<< b ~~~ c

234 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263

The 8rst production uses the fact that we can write trees of any size on the righthand
side of a tree grammar. Slightly less convenient, in a CFG we would introduce a extra
nonterminal and split the production in two:

a ff b a\Delta  (call -)
a\Delta  ff c d (call g)

For nonterminal b, we obtain two identical string productions,

b ff b c | b c
The standard de8nition of CFGs speaks of a set of productions, which cannot contain
multiples. A solution would be to allow labelled productions, one labelled - and one
labelled g to make them distinct--the signature returns through the back door.

Next, we turn to e6ciency concerns and are confronted with a phenomenon called
the yield parsing paradox [20]: Parsing of ambiguous CFGs can be done in O(n3) time.
On the other hand, there are DP algorithms that require O(n4) or higher, described by
yield grammars of width ?2.

A context free production can be brought into Chomsky normal form, thereby re-
ducing its width to 1. For example,

a ff b c d
is transformed to

a ff b a\Delta 
a\Delta  ff c d

Why can we not apply this transformation to the yield grammar production

a = f <<< b ~~~ c ~~~ d ... h
by writing

a = f1 <<< b ~~~ a' ... h
a' = f2 <<< c ~~~ d ... h' ?

There are always functions f1; f2 such that

-(x; y; z) = f1(x; f2(y; z))
but a choice function h\Delta  that satis8es Bellman's Principle may not exist. In other
words, we cannot make an optimal choice based on seeing c and d alone. We may
drop the application of h\Delta  altogether--but then, a\Delta  will return a list of answers of length
proportional to n--bringing the parser back to e6ciency O(n4). This explains how the
e6ciency of DP algorithms depends not only on the grammar, but also on the scoring
scheme. Such explanation cannot be given in the terminology of CFGs.

Finally, let us look at ambiguity. This is an issue of great practical importance, and
will reoccur when we discuss "real world" applications of ADP in Section 4.5. The
CFG corresponding to a yield grammar is always ambiguous (except for trivial cases).

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 235
After all, if an input string did not have several parses, we would not have a problem of
optimization. This ambiguity, however, can have a good or a bad reason. 3 These cannot
be distinguished in CFG terminology, whereas in yield grammars, they are separated:
Many di+erent candidates have the same yield string: This is good, they constitute our
search space. The same candidate has two derivations in the tree grammar: This is bad,
as the algorithm will yield redundant answers when asking for more than one, and all
counting and probabilistic scoring will be meaningless. We remark without proof that
for tree grammars, ambiguity is decidable, while for CFGs, it is not.

Altogether, while part of our treatment could also be formulated in the terminology
of CFGs, we feel that yield grammars have a lot to o+er. And after all, they represent
a small hurdle for a trained computer scientist.

4. The ADP program development method

In this chapter, we 8rst formulate the method we advocate for developing DP algo-
rithms, based on the concepts introduced so far. We then apply this method to three of
our four introductory problems. (We shall not re-address the Fibonacci numbers prob-
lem, since it is a rather untypical problem. Several analyses performed on Fibonacci
numbers via ADP, however, can be studied on the ADP web site.) We shall empha-
size the systematics of programming with ADP. Finally, in Section 4.5, we report on
applications of ADP in our work on RNA structure prediction and analysis.

Except for minor details omitted for the sake of the presentation, all the ADP al-
gorithms developed here are executable code. In the examples, we use the notation
P ===> R to indicate that program call P delivers result R. Readers are invited to run
these programs themselves by visiting the ADP website at
http://bibiserv.techfak.uni-bielefeld.de/adp.

4.1. Systematic program development

As an ADP algorithm is completely speci8ed by the alphabet A, the signature O/,
the yield grammar (G; y) and an evaluation algebra E, we must mainly decide on the
appropriate order of designing these constituents.Step

A: We 8x the input alphabet. This is normally clear from the problem state-
ment.Step

O/: We design the signature, introducing one operator for each situation that
may be evaluated di+erently from others.Step

E: We design one or more evaluation algebras:*
a scoring algebra, solving our optimization problem,*
the enumeration algebra, implementing the enumeration of all candidates of a par-
ticular problem instance,*
the counting algebra, computing the size of the search space, in a more e6cient way
than by explicit enumeration,

3 There is actually a third reason which we ignore here--see [16] for a deeper discussion.

236 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263

* a prettyprinting algebra, useful when the application domain knows a user friendly

representation of candidates, typically di+erent from our term algebra.
While only the scoring algebra is strictly required to solve the optimization problem at
hand, we consider it part of our method also to provide the enumeration and counting
algebras, as they open up systematic testing methods.Step

G: We specify the yield grammar G in ADP notation, describing how candidates
are composed from the di+erent constructs represented by the operators of O/.

After solving each of our introductory problems, we formulate some problem variants,
in order to demonstrate how parts of the ADP design can be re-used on related problems.

4.2. The oldest DP problem in the world

The alphabet: Input to our problem is a formula written in ASCII characters, con-
sisting of digits and operator symbols. We shall also allow multi-digit numbers.The signature

: Rather than adding parentheses, our signature Bill introduces op-
erators Add and Mult to make explicit the di+erent possible internal structures of El
Mamun's bill. The operators Val and Ext represent the conversion of digit strings to
integer values.

data Bill = Mult Bill Char Bill |

Add Bill Char Bill |
Ext Bill Char |
Val Char

In the sequel, we consider three di+erent readings of El Mamun's bill:

bill1: (1 + 2) * ((3 * 4) + 5)
bill2: ((1 + 2) * 3) * (4 + 5)
bill3: 1 + ((2 * (3 * 4)) + 5)

Fig. 6 shows the representations of these candidates, both as terms and as trees.
The evaluation algebras

The enumeration and the counting algebra: Enumeration and counting algebras are
two standard algebras that come with our method. They are used for systematic test-
ing. For any given signature O/, the enumeration algebra is just the term algebra TO/,
augmented with the identity as an objective function. Using the enumeration algebra,
the yield parser strictly runs as a parser--it does no evaluation, but produces a list
of all candidates it has recognized. Mathematically speaking, all other algebras are
homomorphic images of the enumeration algebra.

Ansenum = TBill Anscount = N
enum = (val,ext,add,mult,h) where count = (val,ext,add,mult,h) where
val = Val val(c) = 1
ext = Ext ext(n,c) = 1
add = Add add(x,t,y) = x * y
mult = Mult mult(x,t,y) = x * y
h = id h([]) = []

h([x1; : : : ; xr]) = [x1 + * * * + xr]

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 237
Fig. 6. The term representations of the three candidates for El Mamun's bill and their tree visualizations.

For any given signature O/, the counting algebra evaluates each individual candidate
to 1. However, this is not done by simply interpreting each operator in O/ by a constant
function equal to 1. Instead, an operator taking (say) two constituents, multiplies their
counts. If, for a given section of the input, a candidate of form Mult a b can be built
from ca candidates for a and cb candidates for b, then itself has a count of ca * cb.
Choosing summation for the choice function in the counting algebra, we can compute
the number of candidates much more e6ciently than by enumerating all candidates and
then counting them.

We will return to the use of the enumeration and the counting algebra in the section
on testing.

The buyer's and the seller's algebra: The following two scoring algebras solve El
Mamun's problem. They use the function decode to convert a digit to an integer value.
Each candidate evaluates to its value, according to the parenthesization implicit in the
candidate's structure. On the buying side, of course, El Mamun seeks to minimize the
bill. On the selling side, he seeks to maximize it.

Ansbuyer = N Ansseller = N
buyer = (val,ext,add,mult,h) where seller = (val,ext,add,mult,h) where
val(c) = decode(c) val(c) = decode(c)
ext(n,c) = 10 * n + decode(c) ext(n,c) = 10 * n + decode(c)
add(x,t,y) = x + y add(x,t,y) = x + y
mult(x,t,y) = x * y mult(x,t,y) = x * y
h([]) = [] h([]) = []
h (l) = [minimum(l)] h (l) = [maximum(l)]

238 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263

The prettyprinting algebra: Candidates in term form are particularly hard to
read. We provide a prettyprinting algebra that computes candidates as parenthesized
strings.

Anspretty = A*
pretty = (val,ext,add,mult,h) where
val(c) = [c]
ext(n,c) = n ++ [c]
add(x,t,y) = "(" ++ x ++ (t:y) ++ ")"
mult(x,t,y) = "(" ++ x ++ (t:y) ++ ")"
h = id

The yield grammar: The yield grammar describes all possible internal readings of
El Mamun's formula (and any other such formula).

bill alg = axiom formula where

(val, ext, add, mult, h) = alg

formula = tabulated (

number |||
add <<< formula ~~~ plus ~~~ formula |||
mult <<< formula ~~~ times ~~~ formula ... h)

number = val <<< digit ||| ext <<< number ~~~ digit
digit = char '0' ||| char '1' ||| char '2' ||| char '3' |||

char '4' ||| char '5' ||| char '6' ||| char '7' |||
char '8' ||| char '9'

plus = char '+'
times = char '*'

Testing: Running the yield parser for grammar bill, using the 8ve algebras in turn,
and input "1+2*3*4+5", we obtain:

bill enum "1+2*3*4+5" ===> [

Add (Val '1') '+' (Add (Mult (Val '2') '*' (Mult (Val '3') '*'

(Val '4'))) '+' (Val '5')),
Add (Val '1') '+' (Add (Mult (Mult (Val '2') '*' (Val '3')) '*'

(Val '4')) '+' (Val '5')),
Add (Val '1') '+' (Mult (Val '2') '*' (Add (Mult (Val'3') '*'

(Val '4')) '+' (Val '5'))),
...]

bill pretty "1+2*3*4+5" ===> [

"(1+((2*(3*4))+5))",
"(1+(((2*3)*4)+5))",
"(1+(2*((3*4)+5)))",
...]

bill count "1+2*3*4+5" ===> [14]
bill buyer "1+2*3*4+5" ===> [30]
bill seller "1+2*3*4+5" ===> [81]

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 239
The 8rst call, using enum, yields a protocol of the complete search space for the
given input. This is feasible only for small inputs, but is a most helpful testing aid. It
helps us to verify that the candidates in the search space actually have the shape we
expect, all relevant cases are in fact discovered, and so on. The same applies to the
second call, using pretty, with the extension that this provides the candidates in a
more user-friendly form.

The third call, using count, merely computes the size of the search space for the
given input. We do this here to verify Al Chwarizmi's discovery that there were 14
alternative readings of El Mamun's formula.

While the enumeration algebra produces a result of potentially exponential size, the
counting algebra merely computes a single number and hence is much more e6cient.
The invariance [length(bill enum z)] = bill count z must hold for all z.

Finally, we see that the buyer and the seller algebra solve El Mamun's problems of
minimizing and maximizing the value of the formula.

Problem variation: A processor allocation problem
Computation in the days of El Mamun was very slow. A good computing slave took
about 2 min to perform an addition, and 5 min to perform a multiplication. Even then,
understanding the value of a number took practically no time. Fortunately, there were
abundant slaves, and they could work in parallel as much as the formula permitted.
On a busy day at the bazaar, it might be better to minimize the time consumed for
each individual business contact. The following algebra selects for the candidate that
has the shortest computation time:

Anstime = N (computation time in minutes)
time = (val,ext,add,mult,h) where
val(c) = 0
ext(n,c) = 0
add(x,t,y) = max(x,y) + 2
mult(x,t,y) = max(x,y) + 5
h([]) = []
h (l) = [minimum(l)]

Evaluating the three candidates shown in Fig. 6 we 8nd computation times between
12 and 14 min

h[bill1time; bill2time; bill3time] =
minimum[12, 12, 14] = 12

and we 8nd that 12 min is actually optimal:
bill time "1+2*3*4+5" ===> [12]

4.3. Optimal matrix chain multiplication

The alphabet: Our problem input here is a sequence of matrix dimensions (ri; ci).
Hence, A = N * N.The signature

: Similar to the previous example, we introduce two operators to rep-
resent parenthesization of an expression. A matrix chain can be a single matrix or a
product of two matrix chains.

240 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263
Fig. 7. The term representations of the two candidates for the example matrices and their tree representations.
data Matrixchain = Mult Matrixchain Matrixchain |

Single (Int, Int)

Taking from Section 2.2 our example matrices, A1 :10*100; A2 :100*5 and A3 :5*
50, we get two candidates for this chain multiplication. Fig. 7 shows the term repre-
sentation of these candidates and their tree representation.

The evaluation algebrasThe enumeration and the counting algebra

:

Ansenum = TMatrixchain Anscount = N
enum = (single,mult,h) where count = (single,mult,h) where
single = Single single((r,c)) = 1
mult = Mult mult(x,y) = x * y
h = id h([]) = []

h([x1; : : : ; xr]) = [x1 + * * * + xr]

The scoring algebra: The algebra for determining the minimal number of scalar
multiplications uses a triple (r; m; c) as answer type. (r; c) denotes the dimension of
the resulting matrix and m the minimal number of operations needed to calculate it.
With this answer type writing down the algebra is simple:

Ansminmult = N * N * N
minmult = (single,mult,h) where
single((r,c)) = (r,0,c)
mult((r,m,c),(r',m',c')) = (r,m + m' + r*c*c',c')
h([]) = []
h (l) = [minimum(l)] 4

4 The objective function considers all three triple elements for minimization. But since r and c are the
same for all candidates of a 8xed subchain, only m is relevant to this operation.

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 241
The yield grammar: The yield grammar describes all possible groupings of the
matrix chain product.

matrixmult alg = axiom matrices where

(single, mult, h) = alg

matrices = tabulated (

single <<< achar |||
mult <<< matrices ~~~ matrices ... h )

Note that, by the de8nition of A, achar here denotes a single "character" (ri; ci).

Testing: For input z = [(10,100),(100,5),(5,50)] we obtain:

matrixmult enum z ===> [Mult (Single (10,100)) (Mult (Single (100,5))

(Single (5,50))),
Mult (Mult (Single (10,100)) (Single (100,5)))

(Single (5,50))]
matrixmult count z ===> [2]
matrixmult minmult z ===> [(10,7500,50)]
matrixmult count (z++z++z) ===> [1430]
matrixmult minmult (z++z++z) ===> [(10,20375,50)]

Problem variation: Minimizing intermediate storage
Another interesting problem is to determine the optimal evaluation order for mini-
mizing the memory usage needed for processing the matrix chain. This is motivated by
the fact that memory allocated during calculation can be released in succeeding steps.
Consider two matrix chains C1 and C2. For multiplying C1 * C2 we have two possible
orders of calculation. When processing C1 8rst we have to store the resulting matrix
while processing C2 and then store both results during this multiplication. As a second
possibility, we can process C2 8rst and store the resulting matrix while calculating
C1. Let maxloc C be the biggest memory block allocated during calculation of matrix
chain C. Let loc C be the size of the resulting matrix. loc Ai = 0 for all input matrices.
The minimal memory usage for processing C1 * C2 is given by

maxloc C1 C2 =

min{ max{maxloc C1; loc C1 + maxloc C2; loc C1 + loc C2 + loc C1C2}

max{maxloc C2; loc C2 + maxloc C1; loc C1 + loc C2 + loc C1C2}} (21)

This can be expressed by the following algebra:

Ansminmem = N * N * N
minmem = (single,mult,h) where
single((r,c)) = (r,0,c)
mult((r,m,c),(r',m',c')) = (r, minimum

[maximum [m,r*c+ m',r*c + r'* c' + r*c'],
maximum [m',r'*c'+ m,r*c + r'* c' + r*c']],c')
h([]) = []
h (l) = [minimum(l)]

242 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263
Fig. 8. The term representation of a global similarity candidate candidate1 for darling and airline and
the tree representation of this term (lying on its side).

4.4. Global and local similarity problems

This application has been used as a running example in Section 3. We only recollect
the results, and then proceed to the problem variations.

The alphabet: A is the ASCII alphabet.The signature

:

data Alignment = Nil Char |

D Char Alignment |
I Alignment Char |
R Char Alignment Char

Fig. 8 shows the term representation of a global similarity candidate and its tree
representation.

The evaluation algebrasThe enumeration and the counting algebra

:

Ansenum = TAlignment Anscount = N
enum = (nil,d,i,r,h) where count = (nil,d,i,r,h) where
nil = Nil nil(a) = 1
d = D d(x,s) = s
i = I i(s,y) = s
r = R r(a,s,b) = s
h = id h([]) = []

h([x1; : : : ; xr]) = [x1 + * * * + xr]The scoring algebras:

Answgap = N Ansunit = N
wgap = (nil,d,i,r,h) where unit = (nil,d,i,r,h) where
nil(a) = 0 nil(a) = 0
d(x,s) = s + gap(x) d(x,s) = s - 1
i(s,y) = s + gap(y) i(s,y) = s - 1
r(a,s,b) = s + w(a,b) r(a,s,b) = if a==b then s + 1 else s - 1
h([]) = [] h([]) = []
h (l) = [maximum(l)] h (l) = [maximum(l)]

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 243
The prettyprinting algebra: We provide a prettyprinting algebra that computes can-
didates in the familiar form of two strings padded with gap symbols.

Anspretty = A* * A*
pretty = (nil,d,i,r,h) where
nil(a) = ("","")
d(x,(l,r)) = (x:l, gap:r)
i((l,r),y) = (gap:l, y:r)
r(x,(l,r),y) = (x:l,y:r)
h = id
gap = '-'

The yield grammars

Global similarity: The yield grammar describes all possible ways to transform one
string into the other by character replacement, deletion and insertion.

globsim alg = axiom alignment where

(nil, d, i, r, h) = alg

alignment = tabulated(

nil <<< char '$' |||
d <<< achar ~~~ alignment |||
i <<< alignment ~~~ achar |||
r <<< achar ~~~ alignment ~~~ achar ... h)

Local similarity: To formulate the yield grammar for local similarity, we modify the
signature. We introduce two new operators skip left and skip right for skipping
characters in the beginning of x and y. To allow skipping at the end of x and y, we
modify the argument of Nil to be an arbitrary string, including the separator symbol.

Strictly speaking, the skip operators should become part of the algebra. But since
they are useful for any case when going from a global to a local problem, we assume
they are prede8ned as shown below, and part of any algebra when desired.

skip right a b = a
skip left a b = b

locsim alg = axiom skipR where

(nil, d, i, r, h) = alg

skipR = skip right <<< skipR ~~~ achar |||

skipL ... h

skipL = skip left <<< achar ~~~ skipL |||

alignment ... h

alignment = tabulated(

nil <<< string |||
d <<< achar ~~~ alignment |||
i <<< alignment ~~~ achar |||
r <<< achar ~~~ alignment ~~~ achar ... h)

244 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263

Testing: For inputs "darling" and "airline", concatenated to z =
"darling$enilria" we obtain:

globsim enum z ===> [

D'd'(D'a'(D'r'(D'l'(D'i'(D'n'(D'g'(I(I(I(I(I(I(I(Nil'$')

'e')'n')'i')'l')'r')'i')'a'))))))),
D'd'(D'a'(D'r'(D'l'(D'i'(D'n'(I(D'g'(I(I(I(I(I(I(Nil'$')

'e')'n')'i')'l')'r')'i'))'a')))))),
D'd'(D'a'(D'r'(D'l'(D'i'(D'n'(I(I(D'g'(I(I(I(I(I(Nil'$')

'e')'n')'i')'l')'r'))'i')'a')))))),
...]

globsim pretty z ===> [

("darling-------","-------airline"),
("darlin-g------","------a-irline"),
("darlin--g-----","------ai-rline"),
...]

globsim count z ===> [48639]
globsim unit z ===> [2]

locsim enum z ===> [

Nil (7,8),
Nil (6,8),
D 'g' (Nil (7,8)),
Nil (5,8),
D 'n' (Nil (6,8)),
D 'n' (D 'g' (Nil (7,8))),
...]

locsim pretty z ===> [

("",""),
("",""),
("g","-"),
("",""),
("n","-"),
...]

locsim count z ===> [365600]
locsim unit z ===> [4]

Problem variation: A!ne gap scores
In the algebras presented so far, consecutive insertions or deletions achieve the same
score as the same number of single gaps (deletions and insertions). In order to analyze
biological sequence data, it is more adequate to use an a6ne gap score model. This
means to assign an opening cost (open) to each gap and an extension cost (extend)
for each deleted (or inserted) character. Choosing open ? extend, this results in a
better model, favoring few long gaps over many short ones. The use of a6ne gap
scores was introduced for biosequence analysis in [21].

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 245
The signature: In order to distinguish the opening of a gap and the extension of a
gap we have to extend the signature Alignment:

data Alignment = Nil Char |

D Char Alignment |
I Alignment Char |
R Char Alignment Char |
Dx Char Alignment |
Ix Alignment Char

The a!ne gap score algebra:

Ansa--ine = N
affine = (nil,d,i,r,dx,ix,h) where
nil(a) = 0
d(x,s) = s + open + extend
i(s,y) = s + open + extend
r(a,s,b) = s + w(a,b)
dx(x,s) = s + extend
ix(s,y) = s + extend
h([]) = []
h (l) = [maximum(l)]

The yield grammar: In the modi8ed yield grammar for global similarity, we have to
distinguish the opening of a gap and the extension of a gap. Thus, our yield grammar
requires three nonterminal symbols.

affineglobsim alg = axiom alignment where

(nil, d, i, r, dx, ix, h) = alg
alignment = tabulated (

nil <<< char '$' |||
d <<< achar ~~~ xDel |||
i <<< xIns ~~~ achar |||
r <<< achar ~~~ alignment ~~~ achar ... h)

xDel = tabulated (

alignment |||
dx <<< achar ~~~ xDel ... h )

xIns = tabulated (

alignment |||
ix <<< xIns ~~~ achar ... h )

To achieve the yield grammar for local alignments using the a6ne gap score model,
the grammar for global alignments has to be modi8ed in the same manner as shown
for the simple gap score model.

246 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263
Table 1
Application sizes (in practice, size restrictions are imposed that reduce the time complexity of zuker81 and
wuchty98 to O(n3))

Grammar Problem Grammar size Complexity
name solved # nonterminals # tables Time Space

nussinov78 base pair 1 1 n3 n2

maximization
zuker81 mfe 13 2 n4 n2

folding
wuchty98 non redundant 11 4 n4 n2

folding
evers01 saturated 19 9 n3 n2

structures
pknotsRE00 chained -- -- n6 n4

pseudoknots
pknotsRG03 pseudoknotted 47 17 n4 n2

structures

4.5. Applications of ADP in RNA structure prediction and analysis

In this section we report on applications of ADP in our work on RNA structure
prediction and analysis. We shall reformulate some early approaches in ADP, and
then outline some recent, more re8ned techniques, where the convenience of the ADP
approach has proved to be a major advantage. Table 1 gives a preview of the problems
discussed in this section.

All genetic information in living organisms is encoded in long chain molecules.
DNA is the storage form of genetic information. Its shape is always the double helix
discovered by Watson and Crick, consisting of two chain molecules that are comple-
mentary to each other in the following sense: Each chain is a linear arrangement of
the bases Adenine, Cytosine, Guanine, and Thymine, labeled A, C, G, T, connected
by covalent bonds to a backbone built from sugar and phosphate. Hydrogen bonds can
form between A-T and C-G, creating base pairs in the form of a densely stacked
helix. The human genome consists of roughly 3 * 109 such base pairs. Mathematically
it is a string of length 3 * 109 over the alphabet {A; C; G; T }.

RNA is the active form of genetic information. It is transcribed from DNA as a
chain of A; C; G and U , where U denotes Uracil, the RNA representative of Thymine.
Possible base pairs in RNA are G-C, A-U and also G-U. RNA is typically single
stranded, and by folding back onto itself, it forms structure. One distinguishes three
levels: The primary structure of an RNA molecule is simply the string of bases. Its
tertiary structure is the spatial arrangement of its atoms. On an intermediate and more
abstract level, we have the secondary structure: The set of base pairs that a molecule
forms in attaining its 3D shape. Some RNAs are simply building plans for proteins,
and their structure bears no signi8cance. But there are many classes of RNA whose
structure determines their function. Predicting structure given the sequence is therefore
an important task in bioinformatics.

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 247

Multiple Loop

Stacking Region

Hairpin Loop

Internal Loop
Bulge Loop (left)

Bulge Loop (right)

Fig. 9. Typical elements found in RNA secondary structure.
Structure formation is driven by the forces of hydrogen bonding between base pairs,
and energetically favorable stacking of base pairs. While the prediction of RNA tertiary
structure is inaccessible to computational methods, secondary structure can be predicted
quite reliably. Fig. 9 gives examples of typical elements found in RNA secondary
structure, called stacking regions (or helices), bulge loops, internal loops, hairpin loops
and multiple loops.

The 8rst approach to RNA structure prediction was based on the idea of maximizing
the number of base pairs [30]. In the RNA domain, our input sequence is a string
over {A; C; G; U }. The parser achar is renamed to base. The predicate basepairing
(i; j) checks whether the bases at input positions i + 1 and j can actually form a
base pair.

The grammar nussinov78 implements the algorithm of [30], with the evaluation
algebra designed for maximizing the number of base pairs.

nussinov78 alg = axiom s where

(nil,left,right,pair,split,h) = alg

s = tabulated (

nil <<< empty |||
left <<< base ~~~ s |||
right <<< s ~~~ base |||
pair <<< base ~~~ s ~~~ base

`with` basepairing |||
split <<< s ~~~ s ... h)

248 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263

An enumeration algebra can be provided in the usual way, a counting algebra, how-
ever, would be useless. The case analysis in the Nussinov algorithm is redundant--even
the base string "a" is assigned the two structures

Left('a', Nil) and Right(Nil, 'a')
which actually denote the same shape.

Base pair maximization ignores the favorable energy contributions from base pair
stacking, as well as the unfavorable contributions from loops. A major advance was
brought about by the algorithm of Zuker and Stiegler [40], which uses experimen-
tally determined energy parameters and solves structure prediction as a problem of
minimizing free energy. The grammar zuker81 implementing this algorithm uses two
tables and an algebra distinguishing 10 cases. We do not show it here, as some details
are intricate to explain. In particular, this grammar is also ambiguous. This approach
can be used to enumerate some near-optimal structures after 8ltering out redundant
answers.

A nonredundant algorithm was actually our 8rst application of ADP [14]. Simulta-
neously, the problem was also solved in the traditional way by Wuchty et al. [38]. We
show the grammar wuchty98. Here the signature has 8 operators, each one modeling
a particular structure element, plus the list constructors (nil, ul, cons) to collect
sequences of components in a unique way. We use di+erent choice functions (h s,
h l, h) operating on them. An idea of [14] was integrated in wuchty98: Nonterminal
symbol strong is used to avoid structures with isolated (unstacked) base pairs. We
know in beforehand from the energy model that unstacked base pairs are energetically
unstable. Purging them from the search space decreases the number of candidates con-
siderably. This grammar, because of its nonambiguity, can also be used to study com-
binatorics, such as the expected number of feasible structures of a particular sequence
of length n.

wuchty98 alg = axiom struct where

(str,ss,hl,sr,bl,br,il,ml,nil,cons,ul,h,h_l,h_s) = alg
struct = str <<< comps |||

str <<< (ul <<< singlestrand) |||
str <<< (nil <<< empty) ... h_s
comps = tabulated(

cons <<< block ~~~ comps |||
ul <<< block |||
cons <<< block ~~~ (ul <<< singlestrand) ... h_l)
singlestrand = ss <<< region
block = tabulated(

strong |||
bl <<< region ~~~ strong ... h)
strong = tabulated(

(sr <<< base ~~~ (strong ||| weak) ~~~ base)

`with` basepairing ... h)
weak = tabulated(

(hairpin ||| leftB ||| rightB ||| iloop ||| multiloop)

`with` basepairing ... h)

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 249
where hairpin = hl <<< base ~~~ (region `with` minsize 3) ~~~ base

leftB = sr <<< base ~~~ (bl <<< region ~~~ strong) ~~~ base
rightB = sr <<< base ~~~ (br <<< strong ~~~ region) ~~~ base
multiloop = ml <<< base ~~~ (cons <<< block ~~~ comps ) ~~~ base
iloop = sr <<< base ~~~ (il <<< region ~~~ strong

~~~ region) ~~~ base

The users of RNA folding programs are typically not satis8ed with a single answer,
a structure of minimal free energy. They would rather see an ensemble of near-optimal
structures, su6ciently distinct to characterize what shapes a molecule can actually at-
tain. If there is a single predominant structure, there is probably some biological func-
tion associated with it. If there is a large number of di+erent structures, all close to
minimal free energy, then the molecule's shape is probably unde8ned and meaning-
less. Finally, there are rare and interesting cases of exactly two near-optimal structures,
where the molecule may act as a conformational switch. Computing exactly the char-
acteristic ensemble of structures is still an unsolved problem.

Following the incentive to reduce the search space without losing interesting struc-
tures, D. Evers developed an ADP grammar describing the class of saturated structures
--those whose helices have maximal extent under the rules of base pairing. This fairly
sophisticated grammar requires 19 nonterminals and 9 tables- it requires some advanced
techniques that nicely 8t in the ADP framework. For example, evaluation functions
need to compute auxiliary information in addition to energy values, hence we use
di+erent answer types and di+erent choice functions operating on them. The gram-
mar evers01 can be found in [12], the traditional recurrences are given in [13].
Although published 8rst, they were actually derived from the ADP grammar. This
problem of saturated folding was already posed by Sanko+ in 1984 [39]; a look at
the recurrences in [13] explains why it required the help of a formal method to be
solved.

Another problem currently in focus is the folding of structures containing pseu-
doknots. All the structures discussed previously can be seen as strings of properly
nested parentheses, e.g. : : : (((: : : ) : : : )) : : : (: : : ) : : : , where matching parentheses de-
note base pairs, and dots denote unpaired bases. Pseudoknots contain base pairs that
interact in a crosswise fashion, like in : : : (((: : : [[[: : : ))) : : : ]]] : : : . Finding the opti-
mal, potentially pseudoknotted structure under the current energy model has been
proven to be an NP-complete problem [2]. Rivas and Eddy developed an algorithm
pknotsRE [32] that solves this problem for a restricted class of pseudoknots, run-
ning in O(n6) time and O(n4) space. In spite of its high computational e+ort it
is actually used in practice. However, there lies a touch of tragedy in this algo-
rithm: In theory, it can recognize quite sophisticated structures containing chains of
pseudoknots--however, such structures require a molecule of a certain minimal size,
clearly longer than the algorithm can handle in practice. Hence, it will never ful8ll its
promise.

As a reaction to this situation, we have developed a folding algorithm for the more
restricted, but still useful class of "canonical simple recursive pseudoknots". This pro-
gram pknotsRG is our largest ADP grammar so far, using 47 nonterminals, 140 alterna-
tives, and 17 tables. Its complexity is O(n4) time and O(n2) space. Its implementation

250 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263
in compiled Haskell runs on the Bielefeld Bioinformatics Server, used by the bioinfor-
matics community. It can handle sequences of up to 400 bases within 77 minutes, and
is currently the only program to solve folding problems of this size. A description of
this program is published in [34].

4.6. Summary of Section 4

We hope that, by the series of examples treated in this section, we have convinced
the reader that using the ADP framework is an aid rather than a formal obstacle to
designing dynamic programming algorithms. Often the grammar design is the most
di6cult part- by using the enumeration algebra, we can check this design before we
apply any scoring algebras. The ease of replacing one scoring algebra by another is
quite useful in a design phase where the adequate modeling of the problem domain
is not yet totally clear. We also hope to have shown that this design method can be
used without worrying about implementation details. These will be provided in the
next section, while readers mainly interested in methodology may skip ahead to the
conclusion.

5. Three ways to implement ADP

In this section we show three ways to make ADP algorithms actually run. The most
convenient one is the embedding of ADP in Haskell. Here the ADP algorithm can
be executed as is. Advocates of imperative programming are provided with translation
schemes that lead from the yield grammar to the traditional DP recurrences, to be
implemented in C or FORTRAN. This transition, when done by hand, is quite cum-
bersome. It is rewarded by better runtime (by a constant factor) and an imperative
implementation that can be tested against the same algorithm executed via the Haskell
embedding. Eventually, this transition should be automated, and to this end, we report
on an ADP compiler project currently under way.

5.1. Unifying single sequence analysis and pairwise sequence comparison

We have been considering two kinds of problems: In El Mamun's and in the matrix
chain problem, the task was to recover an internal structure of a single sequence x.
A candidate t for x has yield(t) = x. In the similarity problem, we are comparing two
sequences x and y. We saw that here a candidate t for inputs x; y has yield(t) = xy\Xi 1.
If we choose to include a separator symbol $ between x and the reverse of y, we have
yield(t) = x$y\Xi 1. This is a matter of convenience. To unify both cases, in the sequel
we assume we have a single input z, where either z = x or z = xy\Xi 1, or z = x$y\Xi 1. We
assume that z; m = |x|; n = |y|; l = |z| are known and represented by global variables.
Thus, in the pairwise case, even when we do not use the separator symbol, we know
the boundary between x and y\Xi 1 in z.

This input convention is used for the sake of a uniform treatment here. In our
practical work, we use a special version of the yield parser for the pairwise case,

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 251
which explicitly reads from two inputs in forward direction. (See ADP website for
details.)

Since z is global, a subword zi+1; : : : ; zj of z is simply represented by the subscript
pair (i,j). Note that i marks the subscript position before the 8rst character of sub-
word (i; j). This convention allows one to use k as the common boundary of adjacent
subwords when splitting (i; j) into (i; k) and (k; j).

5.2. Embedding ADP in Haskell

ADP has been designed as a domain speci8c language embedded in Haskell [31]. An
algorithm written in ADP notation can be directly executed as a Haskell program. Of
course, this requires that the functions of the evaluation algebra are coded in Haskell.
A smooth embedding is achieved by adapting the technique of parser combinators [24],
which literally turn the grammar into a parser. Hutton's technique applies to context
free grammars and string parsing. We need to introduce suitable combinator de8nitions
for yield parsing, and add tabulation.

Generally, a parser is a function that, given a subword of the input, returns a list of
all its parses.

Lexical parsers: The lexical parser achar recognizes any single character except
the separator symbol. Parser string recognizes a (possibly empty) subword. Speci8c
characters or symbols are recognized by char and symbol. Parser empty recognizes
the empty subword.

> type Subword = (Int,Int)
> type Parser b = Subword -> [b]

> empty :: Parser ()
> empty (i,j) = [() | i == j]

> achar :: Parser Char
> achar (i,j) = [z!j | i+1 == j, z!j /= '$']

> char :: Char -> Parser Char
> char c (i,j) = [c | i+1 == j, z!j == c]

> string :: Parser Subword
> string (i,j) = [(i,j) | i <= j]

> symbol :: String -> Parser Subword
> symbol s (i,j) = [(i,j)| and [z!(i+k) == s!!(k-1) | k<-[1..(j-i)]]]

Nonterminal parsers: The nonterminal symbols in the grammar are interpreted as
parsers, with the productions serving as their mutually recursive de8nitions. Each right-
hand side is an expression that combines parsers using the parser
combinators.

Parser combinators: The operators introduced in the ADP notation are now de8ned
as parser combinators: ||| concatenates result lists of alternative parses, <<< grabs the
results of subsequent parsers connected via ~~~ and successively "pipes" them into the

252 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263
algebra function on its left. Combinator ... applies the objective function to a list of
answers.

> infixr 6 |||
> (|||) :: Parser b -> Parser b -> Parser b
> (|||) r q (i,j) = r (i,j) ++ q (i,j)

> infix 8 <<<
> (<<<) :: (b -> c) -> Parser b -> Parser c
> (<<<) f q (i,j) = map f (q (i,j))

> infixl 7 ~~~
> (~~~) :: Parser (b -> c) -> Parser b -> Parser c
> (~~~) r q (i,j) = [f y | k <- [i..j], f <- r (i,k), y <- q (k,j)]

> infix 5 ...
> (...) :: Parser b -> ([b] -> [b]) -> Parser b
> (...) r h (i,j) = h (r (i,j))

Note that the operator priorities are de8ned such that an expression f <<< a ~~~ b
~~~ c is read as ((f <<< a) ~~~ b) ~~~ c. This makes use of curried functions: the
results of parser f <<< a are functions--i.e. calls to f with (only) the 8rst argument
bound.

The operational meaning of a with-clause can be de8ned by turning with into a
combinator, this time combining a parser with a 8lter. Finally, the keyword axiom
of the grammar is interpreted as a function that returns all parses for the speci8ed
nonterminal symbol and the complete input.

> type Filter = Subword -> Bool
> with :: Parser b -> Filter -> Parser b
> with q c (i,j) = if c (i,j) then q (i,j) else []

> axiom :: Parser b -> [b]
> axiom ax = ax (0,l)

When a parser is called with the enumeration algebra--i.e. the functions applied are
actually tree constructors, and the objective function is the identity function--then it
behaves like a proper yield parser and generates a list of trees according to De8nition 4.
However, called with some other evaluation algebra, it computes any desired type of
answer.Tabulation

: Adding tabulation is merely a change of data type, replacing a recursive
function by a recursively de8ned table--just in the way we did this in Section 2.4.
Now we need a general scheme for this purpose: The function table records the
results of a parser p for all subwords of an input of size n, and returns as its result

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 253
a function that does lookup in this table. Note the essential invariance (table n
f)!(i,j) = f(i,j). Therefore, table n p is a tabulated parser, that can be used in
place of parser p. In contrast to the latter, it does not compute the results for the same
subword (i,j) repeatedly--here we enjoy the blessings of lazy evaluation and avoid
exponential explosion.

The keyword tabulated is now de8ned as table bound to the global variable l,
the length of the input.

> table :: Int -> Parser b -> Parser b
> table n p = (!) (array ((0,0),(n,n))
> [((i,j), p (i,j)) | i<- [0..n], j<- [i..n]])

> tabulated = table l

Removing futile computations: Consider the production a = f <<< a ~~~ char.
Our de8nition of the ~~~ combinator splits subword (i; j) in all possible ways, in-
cluding empty subwords on either side. Obviously, achar, which recognizes a single
character, has a 8xed yield size of 1, leaving the subword (i; j \Phi  1) for the yield of
nonterminal symbol a. In this case, iteration over all splits of (i; j) into (i; k) and
(k; j) is mathematically correct, but a futile e+ort. The only successful split can be
(i; j \Phi  1) and (j \Phi  1; j). What is worse, since the production is left-recursive, the last
split considered without need is (i; j) and (j; j), which leads to in8nite recursion.

Both situations are avoided by using specializations of the ~~~ combinator that are
aware of bounded yield sizes and avoid unnecessary splits. For the case of splitting o+
a single character, we use -~~ and ~~-, while the fully general case of an arbitrary,
but known yield size limit is treated by the ~~ combinator.

> infixl 7 ~~,-~~ , ~~-
> (-~~) q r (i,j) = [x y | i<j, x <- q (i,i+1), y <- r (i+1,j)]
> (~~-) q r (i,j) = [x y | i<j, x <- q (i,j-1), y <- r (j-1,j)]

> (~~) :: (Int,Int) -> (Int,Int)
> -> Parser (b -> c) -> Parser b -> Parser c
> (~~) (l,u) (l',u') r q (i,j)
> = [x y | k <- [max (i+l) (j-u') .. min (i+u) (j-l')],
> x <- r (i,k), y <- q (k,j)]

These combinators are used in asymptotic e6ciency tuning via width reduction as
described in [18]. Using these special cases, our global similarity grammar can be
written in the form

> globsim alg = axiom alignment where
> (nil, d, i, r, h) = alg

254 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263
> alignment = tabulated(
> nil <<< char '$' |||
> d <<< achar -~~ alignment |||
> i <<< alignment ~~- achar |||
> r <<< achar -~~ alignment ~~- achar ... h)

which now, as a functional program, has the appropriate e6ciency of O(mn).

5.3. Derivation of explicit recurrences

In the previous section we showed how to embed an ADP algorithm smoothly in a
functional language. Although e6cient implementations of Haskell exist, it still seems
desirable to derive an imperative version of the algorithm. The sheer volume of data
present in many dynamic programming domains and an easy integration in existing
systems are two of the reasons. The classical approach in dynamic programming is
to implement the imperative version of the algorithm starting from the matrix recur-
rences derived by experience or intuition. In this section we show how to derive the
recurrences in a systematic way from an algorithm in ADP notation.

Each tabulated production will result in a matrix recurrence relation. The de8nitions
of nontabulated productions can be inserted directly at the occurrences of the corre-
sponding nonterminal symbols in the grammar. In the following, we assume that all
productions are tabulated.

Translation schemes: The matrix recurrences for a grammar G can be derived by
the following translation patterns starting with C<G= in Pattern 22. We use list com-
prehension notation, in analogy to set notation: [f(x; y)|x \Psi  xs; y \Psi  ys] denotes the list
of all values f(x; y) such that x is from list xs and y from list ys. To distinguish a
parser call q(i; j) from a semantically equivalent table lookup, we denote the latter by
q!(i; j). The function pair (low(p); up(p)) shall provide the yield size of a tree pattern
p and is de8ned by (low(p); up(p)) = (inf q\Pi L(p) |q|; supq\Pi L(p) |q|) if L(p) ffl= i, and
(low(p); up(p)) = (j; 0) otherwise.

C[[grammar alg = axiom p where v1 = q1 : : : vm = qm]] = (22)

for j = 0 to l

for i = 0 to j

v1!(i; j) = C[[q1]](i; j)..
.v

m!(i; j) = C[[qm]](i; j)

returnp!(0; l)

C[[q : : : h]](i; j) = h(C[[q]](i; j)) (23)
C[[q1 ||| : : : ||| qr]](i; j) = C[[q1]](i; j) ++ * * * ++ C[[qr]](i; j) (24)
C[[t <<< q1 ~~~ : : : ~~~ qr]](i; j) = (25)

[t(p1; : : : ; pr)|p1 \Psi  C[[q1]](i; k1); : : : ; pr \Psi  C[[qr]](kr\Xi 1; j)]

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 255

for k1; : : : ; kr\Xi 1; such that k0 = i; kr = j;

max(kl\Xi 1 + low(ql); kl+1 \Phi  up(ql+1)) 6 kl 6
min(kl\Xi 1 + up(ql); kl+1 \Phi  low(ql+1))
C[[q with c]](i; j) = if c(i; j) then C[[q]](i; j) else [ ] (26)
C[[v]](i; j) = v!(i; j) for v \Psi  V (27)
C[[t]](i; j) = T[[t]](i; j) for t terminal (28)

In Pattern 25, note the direct correspondence to the de8nition of the ~~ combinator
in Section 5.2.

Translation patterns T[[w]] for terminal symbols must be chosen according to their
respective semantics. We give three examples:

T[[char c]](i; j) = if i + 1 ` j ' zj ` c then [c] else [ ]
T[[achar]](i; j) = if i + 1 ` j ' zj ffl= \Delta $\Delta  then [zj] else [ ]
T[[string]](i; j) = if i 6 j then [(i; j)] else [ ]

Example. We demonstrate the translation for the global similarity example of
Section 4.4:

globsim alg = axiom alignment where

(nil, d, i, r, h) = alg

alignment = nil <<< char '$' |||

d <<< achar ~~~ alignment |||
i <<< alignment ~~~ achar |||
r <<< achar ~~~ alignment ~~~ achar ... h

Applying Pattern 22 to this grammar provides the framework of the control structure:

for j = 0 to l

for i = 0 to j

alignment!(i; j) = C[[nil <<< :::]](i; j)
return alignment!(0; l)

Starting with alignment!(i; j) = C[[nil <<< :::]](i; j) we apply Patterns 23 and 24
to the right-hand side of the production:

alignment!(i; j) = h(

C[[nil <<< char '$']](i; j) ++ (29)
C[[d <<< achar ~~~ alignment]](i; j) ++ (30)
C[[i <<< alignment ~~~ achar]](i; j) ++ (31)
C[[r <<< achar ~~~ alignment ~~~ achar]](i; j)) (32)

256 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263
Table 2
Yield sizes needed for alignment example

x (low(x), up(x))
char c (1; 1)
achar (1; 1)
alignment (1; \Sigma )

The resulting four expressions can be translated separately according to Pattern 25.
Expression 29 translates to:

[nil(p1)|p1 \Psi  T[[char '$']](i; j)]
= if i + 1 ` j ' zj ` \Delta $\Delta  then [nil(\Delta $\Delta )] else [ ]

Translation of Expressions 30-32 makes use of the yield size functions low and up.
Table 2 shows their values for the expressions needed in this example. The constant
yield sizes of the terminal symbols can be taken directly from the corresponding parser
de8nitions. For nonterminal symbols and arbitrary expressions this requires a deeper
analysis of the grammar. This is detailed in [20]. Accepting the risk of ending up with
suboptimal code for the resulting matrix recurrences, a yield size (0; j) is always a
safe approximation.

Proceeding with Expression 30 leads to the following calculation:

C[[d <<< achar ~~~ alignment]](i; j)
= [d(p1; p2)|p1 \Psi  T[[achar]](i; k1); p2 \Psi  C[[alignment]](k1; j)]

for k1 such that

max(i + low(achar); j \Phi  up(alignment)) 6 k1 6
min(i + up(achar); j \Phi  low(alignment))

With yield sizes (1; 1) and (1; j) for achar and alignment the loop variable k1
simpli8es to a constant k1 = i + 1 and the condition i + 2 6 j:

[d(p1; p2)|i + 2 6 j; p1 \Psi  T[[achar]](i; i + 1); p2 \Psi  C[[alignment]](i + 1; j)]
= [d(p1; p2)|i + 2 6 j ' zi+1 ffl= \Delta $\Delta ; p1 \Psi  [zi+1]; p2 \Psi  alignment!(i + 1; j)]
= [d(zi+1; p2)|i + 2 6 j ' zi+1 ffl= \Delta $\Delta ; p2 \Psi  alignment!(i + 1; j)]

Translating Expressions (31) and (32) in the same way we arrive at the following
recurrence relation for the matrix alignment:

alignment!(i; j) = h(

if i + 1 ` j ' zj ` \Delta $\Delta  then [nil(\Delta $\Delta )] else [ ] ++
[d(zi+1; p2)|i + 2 6 j ' zi+1 ffl= \Delta $\Delta ; p2 \Psi  alignment!(i + 1; j)] ++
[i(p1; zj)|i + 2 6 j ' zj ffl= \Delta $\Delta ; p1 \Psi  alignment!(i; j \Phi  1)] ++
[r(zi+1; p2; zj)|i + 3 6 j ' zi+1 ffl= \Delta $\Delta  ' zj ffl= \Delta $\Delta ;

p2 \Psi  alignment!(i + 1; j \Phi  1)]) (33)

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 257
The explicit recurrences derived so far can be used together with code implementing
the functions of an arbitrary evaluation algebra. If this code is simple, it can be inlined,
which often allows further simpli8cation of the recurrences.Inlining evaluation algebras

: We demonstrate inlining by means of the count algebra
and the unit cost algebra introduced in Section 4.4:

Anscount = N Ansunit = N
count = (nil,d,i,r,h) where unit = (nil,d,i,r,h) where
nil(x) = 1 nil(x) = 0
d(x,s) = s d(x,s) = s - 1
i(s,y) = s i(s,y) = s - 1
r(a,s,b) = s r(a,s,b) = if a==b then s + 1 else s - 1
h([]) = [] h([]) = []
h([x1; : : : ; xr]) = [x1 + * * * + xr] h (l) = [maximum(l)]

For the counting algebra this results in the following recurrence for the matrix
alignment:

alignment!(i; j) =

(if i + 1 ` j ' zj ` \Delta $\Delta  then 1 else 0)+
(if i + 2 6 j ' zi+1 ffl= \Delta $\Delta  then alignment!(i + 1; j) else 0)+
(if i + 2 6 j ' zj ffl= \Delta $\Delta  then alignment!(i; j \Phi  1) else 0)+
(if i + 3 6 j ' zi+1 ffl= \Delta $\Delta  ' zj ffl= \Delta $\Delta  then alignment!(i + 1; j \Phi  1) else 0)

And for the unit cost algebra:

alignment!(i; j) = max(

(if i + 1 ` j ' zj ` \Delta $\Delta  then [0] else [ ]) ++
(if i + 2 6 j ' zi+1 ffl= \Delta $\Delta  then [alignment!(i + 1; j) \Phi  1] else [ ]) ++
(if i + 2 6 j ' zj ffl= \Delta $\Delta  then [alignment!(i; j \Phi  1) \Phi  1] else [ ]) ++
(if i + 3 6 j ' zi+1 ffl= \Delta $\Delta  ' zj ffl= \Delta $\Delta  then [if zi+1 ` zj

then alignment!(i + 1; j \Phi  1) + 1
else alignment!(i + 1; j \Phi  1) \Phi  1] else [ ]))

Solving dependencies: Consider the example of string similarity. By adding the pro-
duction

loc_align = alignment |||

skip_right <<< loc_align ~~~ achar |||
skip_left <<< achar ~~~ loc_align ... h

we can extend the algorithm for global similarity to an algorithm for local similar-
ity. (Here we use a single production rather than two as in Section 4.4, to shorten
the translation example.) Following the translation scheme of the previous paragraphs

258 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263
we derive the matrix recurrence for loc align:

loc align!(i; j) = max(

[alignment!(i; j)] ++
(if i + 2 6 j ' zj ffl= \Delta $\Delta  then [loc align!(i; j \Phi  1)] else [ ]) ++
(if i + 2 6 j ' zi+1 ffl= \Delta $\Delta  then [loc align!(i + 1; j)] else [ ]))

The dependency between loc align!(i; j) and alignment!(i; j) leads us to a new issue
not present in the functional version of the algorithm. Functional languages are data-
driven, so in the functional implementation of the algorithm the computational model of
the programming language guarantees that all computations are made on demand. Since
we cannot assume this in an imperative setting, we have to 8nd a suitable ordering of
calculations, so that all dependencies are solved and all values are calculated before
they are used. For the small example shown here this is an easy task. But consider an
algorithm with about 20 productions and various dependencies between them. Finding
a suitable order of calculation is a strenuous and error-prone venture. Solving this
problem is one of the tasks of the compiler described in the next section.

5.4. Compiling ADP notation to C

In the previous section we showed how to derive the traditional recurrences in a
systematic way, as an intermediate step towards an implementation of an ADP algo-
rithm in an imperative programming language, such as C. The C program can be tested
systematically against the Haskell prototype, a procedure that guarantees much higher
reliability than ad-hoc testing. Still, the main di6culties with this approach are twofold:
It proves to be time consuming to produce a C program by hand that is equivalent to
the Haskell prototype. Furthermore, for sake of e6ciency, developers are tempted to
perform ad-hoc yield size analysis and use special combinators in the prototype. This
introduces through the back door the possibility of subscript errors otherwise banned
by the ADP approach. The ADP compiler currently under development eliminates both
problems.

Aside from parsing the ADP program and producing C code, the core of the compiler
implements yield size and dependency analysis, and performs the translation steps
described in the previous section. With respect to the evaluation algebra we follow the
strategy that simple arithmetic functions are inlined, while others must be provided as
native C functions. Compiler options provide a simpli8ed translation in the case where
the evaluation algebra computes scalar answers rather than lists. As an example, the
code produced for the grammar globsim is shown in Fig. 10.

We also added a source-to-source option to the compiler, reproducing ADP input
with all ~~~ operators replaced by variants bound to exact yield sizes. Hence, the
program designer using the functional embedding is no longer committed to delicate
tuning e+orts.

The compiler, at the time of this writing, successfully handles the simple examples
presented in this article. However, it is not yet complete, as there are some more
ambitious goals to persue, such as automating the e6ciency annotation.

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 259
void calc alignment(int i, int j){

int v1, v2, v3, v4, v5, v6, v7;
if ((j-i) == 1) { /* nil <<< (char '$') */

if (z[j] == '$') {

v1 = 0;}
else { v1 = MINVAL; }}
else { v1 = MINVAL; }

if ((j-i) >= 2) { /* d <<< achar ~~~ p alignment */

if (z[i+1] != '$') {

v2 = tbl alignment[i+1][j-(i+1)-1] + gap(z[i+1]);}
else { v2 = MINVAL; }}
else { v2 = MINVAL; }

if ((j-i) >= 2) { /* i <<< p alignment ~~~ achar */

if (z[j] != '$') {

v3 = tbl alignment[i][j-1-i-1] + gap(z[j]);}
else { v3 = MINVAL; }}
else { v3 = MINVAL; }

if ((j-i) >= 3) { /* r <<< achar ~~~ p alignment ~~~ achar */

if ((z[i+1] != '$') && (z[j] != '$')) {

v4 = tbl alignment[i+1][j-1-(i+1)-1] + w(z[i+1], z[j]);}
else { v4 = MINVAL; }}
else { v4 = MINVAL; }

v5 = v3 > v4 ? v3 : v4;
v6 = v2 > v5 ? v2 : v5;
v7 = v1 > v6 ? v1 : v6;

if ((j-i) >= 1) { tbl alignment[i][j-i-1] = v7; }}

void mainloop(){

int i, j;
for (j=0; j<=n; j++)

for (i=j; i>=0; i--)

calc alignment(i, j);
printf("%d", tbl alignment[0][n-0-1]);}

Fig. 10. C-Code produced by the ADP compiler for grammar globsim with algebra wgap.

260 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263
6. Conclusion
6.1. Review of the ADP development method

The systematic method of program development in the ADP framework was speci8ed
rather rigidly in Section 4. It comprises the steps A - O/ - E - G, named after the four
main constituents of ADP. We discuss the experiences with the use of this method,
some of which we hope to have already conveyed to the reader.

In the design of the signature O/, we perform the fundamental case analysis of our
problem domain. This records all the details that may be entering our objective of
optimization. Describing all evaluation algebras E as O/-algebras makes sure that they all
are homomorphic images of the enumeration algebra TO/. This has two major methodical
bene8ts. First, De8nition 6 formulates the proof obligation that must be met to show
that a particular evaluation algebra satis8es Bellman's Principle. Second, it assures that
various evaluation algebras work correctly with the same algorithm, as all aspects of
evaluation are encapsulated within the algebras.

In the design of the grammar, we concentrate exclusively on the top-down problem
decomposition. Di+erent types of sub-problems are cast as di+erent nonterminals, while
their potential evaluation is restricted to the operators provided by O/. There is no chance
to include ad-hoc aspects of evaluation into the grammar.

Not even the most systematic development makes testing super2uous. In our case,
testing is greatly aided by the enumeration, counting and prettyprinting algebras. The
use of the enumeration algebra enables inspection of the search space actually traversed
by the algorithm. The counting algebra sometimes indicates that the search space of
the program is much larger than we would expect--in this case the grammar contains
redundancies which we may not have chosen consciously, and whose avoidance is
essential if we are also interested in near-optimal solutions.

The bene8cial use of several algebras has led us to introducing a product operation
on algebras, denoted ***. The product algebra (alg1 *** alg2) simply operates on
pairs of answer values. However, the product of the choice functions is de8ned in a
nontrivial way, leading to a number of interesting properties that are outside the scope
of the present paper. For example, if opt is an optimizing evaluation algebra, then
(opt *** count) gives us the count of co-optimal solutions together with the optimal
score, (opt *** enum) or (opt *** pretty) gives us the optimal candidate together
with its score. Using a second table entry, we get backtracing for free. And there is
more 2exibility, as algebra products may be nested.

Altogether, our experience is that the ADP framework leads to a productive and
rewarding reconciliation of mathematical rigor with the programmer's intuition about
dynamic programming.

All the elements of methodical guidance available heretofore [9,33] re-appear in our
framework, often in a more rigorous fashion. There is only one major point where ADP
re-adjusts the classical view: Cormen et al. advocate, as the initial step, the study of
how the structure of an optimal problem solution is composed from its subproblems. In
the light of ADP, this is misleading: The structure of a solution guides its evaluation,
but does not determine its optimality. Optimality is solely in the eye of the evaluation

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 261
algebra--change the algebra, and a di+erent structure will be found to be optimal. The
structure of all solutions in the search space, optimal or not, is de8ned by the grammar.
The classical view certainly implies this. However, it cannot formulate it adequately,
as the notion of an explicit representation of candidates is lacking.

6.2. Extensions in theory and practice

Dynamic programmers have discovered many tricks that improve the e6ciency of a
DP algorithm. In the ADP framework, many such tricks turn into techniques, which can
be formalized as transformation schemes on grammars and algebras, can be taught and
re-used. This aspect is elaborated in [18]. Interestingly, the transition from a global to a
local optimization problem (as in our string comparison example) is such a transforma-
tion. Once the global problem has been solved, its local version comes (intellectually)
for free.

We have occasionally touched upon the case where one is interested in more than
a single answer. One may ask for all co-optimal answers, or all near-optimal answers
within a certain threshold of optimality. In such a context, the redundancy or ambiguity
of the grammar must be understood and controlled. This is a nontrivial issue studied
in [16]. A general technique to enumerate solutions in order of optimality is described
in [18].

In nontrivial examples, it often occurs that di+erent types of subproblems have di+er-
ent types of answers. This leads to the use of many-sorted evaluation algebras, where a
separate choice function is associated with each sort of answer. A case in point is the
grammar wuchty98. There is no theoretical di6culty associated with this extension.

6.3. Future work

In our practical work, we have used several techniques that have not yet been studied
theoretically, such as attributes associated with nonterminals of the tree grammar, or
parsers that rely on precomputed information. While the Haskell embedding of ADP
is a convenient test bed for such ideas, their adequate integration in the theoretical
framework is not obvious. When teaching ADP to our students, we strictly discourage
ad-hoc extensions borrowed from the Haskell background.

Moving on from sequences to more structured data such as trees or two-dimensional
images, the new technical problem is to provide a suitable tabulation method. To this
end, we are currently studying local similarity problems on trees [23].

An interesting extension in the realm of sequential data is to consider language
intersection and complement. We may allow productions with and and butnot operators,
written u = v &&& z and u = v --- z. The former means that an input string can
be reduced to u if it can be reduced to both v and z. The latter means that it can be
reduced to u if it can be reduced to v, but not to z. While this clearly extends beyond
the realm of context free yield languages, it is easy to implement in the parser, and
quite useful in describing complicated pattern matching applications.

The most urgent task we are pursuing at the time of this writing is the formal
de8nition of an ADP language version 1.0, and the completion of the compiler. The

262 R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263
Haskell embedding is easy to use, and e6cient enough for many realistic applications
when using the Glasgow Haskell compiler GHC. Functional programming and Haskell
are quite popular in the computer science community today, but not so in biology
and bioinformatics. Understanding and even developing an algorithm written in ADP
notation does not require any Haskell expertise--it can be based solely on the notion
of yield grammars, evaluation algebras, and ADP notation. However, in the case of
an--albeit trivial--error, the programmer is confronted with the error handling of the
underlying language system, which is not aware of the ADP concepts. Hence, the
current dependence on Haskell is a severe limitation in the application 8eld for which
ADP was originally developed.

Acknowledgements

Many people have contributed to the development of the ADP approach by pro-
found discussion, critical comments, and application challenges. We acknowledge the
contributions of Dirk Evers, Matthias HKochsmann, Stefan Kurtz, Enno Ohlebusch, Jens
Reeder, and Marc Rehmsmeier. Morris Michael has compiled the ADP web site,
where the reader is welcome to experiment with ADP in an interactive fashion. It
can found in the education department of the Bielefeld Bioinformatics Webserver at
http://bibiserv.techfak.uni-bielefeld.de/.

References

[1] A.V. Aho, J.E. Hopcroft, J.D. Ullman, Data Structures and Algorithms, Addison-Wesley, Reading, MA,

USA, 1983.
[2] T. Akutsu, Dynamic programming algorithms for RNA secondary structure prediction with pseudoknots,

Discrete Appl. Math. 104 (2000) 45-62.
[3] R. Bellman, Dynamic Programming, Princeton University Press, Princeton, NJ, 1957.
[4] R. Bellman, S.E. Dreyfus, Applied Dynamic Programming, Princeton University Press, Princeton, NJ,

1962.
[5] R.S. Bird, O. de Moor, From dynamic programming to greedy algorithms, in: B. MKoller (Ed.),

State-of-the-Art Seminar on Formal Program Development, Lecture Notes in Computer Science, vol.
755, Springer, London, 1993.
[6] R.S. Bird, O. de Moor, Algebra of Programming, Prentice-Hall, Englewood Cli+s, NJ, 1997.
[7] W.S. Brainerd, Tree generating regular systems, Information and Control 14 (1969) 217-231.
[8] G. Brassard, P. Bratley, Algorithmics: Theory and Practice, Prentice-Hall, Englewood Cli+s, NJ, 1988.
[9] T.H. Cormen, C.E. Leiserson, R.L. Rivest, Introduction to Algorithms, MIT Press, Cambridge, MA,

1990.
[10] S. Curtis, Dynamic programming: a di+erent perspective, in: R. Bird, L. Meertens (Eds.), Algorithmic

Languages and Calculi, Chapman & Hall, London, UK, 1997, pp. 1-23.
[11] R. Durbin, S. Eddy, A. Krogh, G. Mitchison, Biological Sequence Analysis, Cambridge University

Press, Cambridge, 1998.
[12] D. Evers, RNA folding via algebraic dynamic programming, Ph.D. Thesis, Faculty of Technology,

Bielefeld University, 2003.
[13] D. Evers, R. Giegerich, Reducing the conformation space in RNA structure prediction, in: German Conf.

on Bioinformatics, Brunswick, Germany, 2001.
[14] R. Giegerich, A declarative approach to the development of dynamic programming algorithms, applied

to RNA folding, Report 98-02, Technische FakultKat, UniversitKat Bielefeld, 1998.

R. Giegerich et al. / Science of Computer Programming 51 (2004) 215-263 263
[15] R. Giegerich, A systematic approach to dynamic programming in bioinformatics, Bioinformatics 16

(2000) 665-677.
[16] R. Giegerich, Explaining and controlling ambiguity in dynamic programming, in: Proc. Combinatorial

Pattern Matching, Lecture Notes in Computer Science, vol. 1848, Springer, Berlin, 2000, pp. 46-59.
[17] R. Giegerich, S. Kurtz, G.F. Weiller, An algebraic dynamic programming approach to the analysis

of recombinant DNA sequences, in: Proc. First Workshop on Algorithmic Aspects of Advanced
Programming Languages, Paris, 1999, pp. 77-88.
[18] R. Giegerich, C. Meyer, Algebraic dynamic programming, in: H. Kirchner, C. Ringeissen (Eds.),

Algebraic Methodology And Software Technology, Ninth Internat. Conf. AMAST 2002, Lecture Notes
in Computer Science, vol. 2422, Springer, Berlin, 2002, pp. 349-364.
[19] R. Giegerich, K. Schmal, Code selection techniques: pattern matching, tree parsing and inversion of

derivors, in: Proc. European Symp. on Programming 1988, Lecture Notes in Computer Science, vol.
300, Springer, Berlin, 1988, pp. 247-268.
[20] R. Giegerich, P. Ste+en. Implementing algebraic dynamic programming in the functional and the

imperative programming paradigm, in: E.A. Boiten, B. MKoller (Eds.), Mathematics of Program
Construction, Lecture Notes in Computer Science, vol. 2386, Springer, Berlin, 2002, pp. 1-20.
[21] O. Gotoh, An improved algorithm for matching biological sequences, J. Mol. Biol. 162 (1982) 705-

708.
[22] D. Gus8eld, Algorithms on Strings, Trees, and Sequences, Cambridge University Press, Cambridge,

1997.
[23] M. HKochsmann, T. TKoller, R. Giegerich, S. Kurtz, Local similarity in RNA secondary structures, in:

Proc. IEEE Bioinformatics Conf. (CSB), 2003, pp. 159-168.
[24] G. Hutton, Higher order functions for parsing, J. Funct. Programming 3 (2) (1992) 323-343.
[25] K. Mehlhorn, Data Structures and Algorithms, Springer, Berlin, 1984.
[26] C. Meyer, R. Giegerich, Matching and signi8cance evaluation of combined sequence-structure motifs

in RNA, Z. Phys. Chem. 216 (2002) 193-216.
[27] L. Mitten, Composition principles for the synthesis of optimal multi-stage processes, Oper. Res. 12

(1964) 610-619.
[28] O. de Moor, Dynamic programming as a software component, in: M. Mastorakis (Ed.), Proc. CSCC,

Athens, WSES Press, Athens, 1999.
[29] T.L. Morin, Monotonicity and the principle of optimality, J. Math. Anal. Appl. 86 (1982) 665-674.
[30] R. Nussinov, G. Pieczenik, J.R. Griggs, D.J. Kleitman, Algorithms for loop matchings, SIAM J. Appl.

Math. 35 (1978) 68-82.
[31] S. Peyton Jones (Ed.), Haskell 98 Language and Libraries--The Revised Report, Cambridge University

Press, Cambridge, April 2003.
[32] E. Rivas, S. Eddy, A dynamic programming algorithm for RNA pseudoknots, in: Poster Presentation,

ISMB98, 1998.
[33] U. SchKoning, Algorithmik, Spektrum Akad. Verl., Heidelberg, 2001.
[34] A. Sczyrba, J. KrKuger, H. Mersch, S. Kurtz, R. Giegerich, RNA-related tools on the Bielefeld

Bioinformatics Server, Nucl. Acids. Res. 31 (13) (2003) 3767-3770.
[35] R. Sedgewick, Algorithms, 2nd ed., Addison-Wesley, Reading, MA, 1989.
[36] T.F. Smith, M.S. Waterman, The identi8cation of common molecular subsequences, J. Mol. Biol. 147

(1981) 195-197.
[37] M. Sniedovich, Dynamic Programming, Marcel Dekker, New York, 1992.
[38] S. Wuchty, W. Fontana, I.L. Hofacker, P. Schuster, Complete suboptimal folding of RNA and the

stability of secondary structures, Biopolymers 49 (1999) 145-165.
[39] M. Zuker, S. Sanko+, RNA secondary structures and their prediction, Bull. Math. Biol. 46 (1984)

591-621.
[40] M. Zuker, P. Stiegler, Optimal computer folding of large RNA sequences using thermodynamics and

auxiliary information, Nucl. Acids Res. 9 (1) (1981) 133-148.