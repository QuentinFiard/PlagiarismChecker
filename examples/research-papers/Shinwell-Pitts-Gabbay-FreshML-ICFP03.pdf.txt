

FreshML: Programming with Binders Made Simple

Mark R. Shinwell Andrew M. Pitts Murdoch J. Gabbay

Cambridge University Computer Laboratory, Cambridge, CB3 0FD, UK{Mark.Shinwell,Andrew.Pitts,Murdoch.Gabbay}@cl.cam.ac.uk

Abstract
FreshML extends ML with elegant and practical constructs fordeclaring and manipulating syntactical data involving statically

scoped binding operations. User-declared FreshML datatypes in-volving binders are concrete, in the sense that values of these types
can be deconstructed by matching against patterns naming boundvariables explicitly. This may have the computational effect of
swapping bound names with freshly generated ones; previous workon FreshML used a complicated static type system inferring information about the `freshness' of names for expressions in order totame this effect. The main contribution of this paper is to show
(perhaps surprisingly) that a standard type system without fresh-ness inference, coupled with a conventional treatment of fresh name
generation, suffices for FreshML's crucial correctness property thatvalues of datatypes involving binders are operationally equivalent
if and only if they represent ff-equivalent pieces of object-levelsyntax. This is established via a novel denotational semantics.
FreshML without static freshness inference is no more impure thanML and experience with it shows that it supports a programming
style pleasingly close to informal practice when it comes to dealingwith object-level syntax modulo

ff-equivalence.

Categories and Subject Descriptors
D.3.1 [Programming Languages]: Formal Definitions andTheory--syntax; D.3.2 [Programming Languages]: Language Classifications--applicative (functional) languages; D.3.3[Programming Languages]: Language Constructs and Features--
data types and structures, patterns; F.3.2 [Logics and Meanings ofPrograms]: Semantics of Programming Languages--denotational
semantics, operational semantics
General Terms
Languages, Design, Theory

Keywords
Metaprogramming, variable binding, alpha-conversion

Permission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citationon the first page. To copy otherwise, to republish, to post on servers or to redistribute
to lists, requires prior specific permission and/or a fee.ICFP'03 August 25-29, 2003, Uppsala, Sweden.
Copyright 2003 ACM 1-58113-756-7/03/0008 ...$5.00

1 Introduction
User-declared datatypes and pattern-matching in functional pro-gramming languages like ML and Haskell simplify one of the main

tasks for which these languages were intended, namely metapro-gramming--the construction and manipulation of syntactical structures. In particular, the declaration of recursive functions for ma-nipulating the parse trees of object-level languages is made much
simpler (and hence less error prone) through the use of patterns tomatch against parts of trees. Unfortunately a pervasive problem
spoils this rosy picture: object-level languages often involve bind-ing operations. In this case meta-level programs only make sense,
or at least only have good properties, when we operate not on parsetrees but on their equivalence classes for a relation of

ff-equivalenceidentifying trees differing only in the names of bound entities. At

the moment programmers deal with this case-by-case according tothe nature of the object-level language being implemented, using a
self-imposed discipline. For example, they might work out (not sohard) and then correctly use (much harder) some `nameless' representation of ff-equivalence classes of parse trees in the style ofde Bruijn [8]. The tedious and error-prone nature of ad hoc solutions to this semantically trivial, but pragmatically non-trivial issueof

ff-equivalence is widely acknowledged [27, Sect.13]. We needbetter automatic support for object-level

ff-equivalence in metapro-gramming languages.

FreshML is an ML-like language which provides such support. Itsdesign was introduced by Pitts and Gabbay [25] and subsequently
refined and implemented by Shinwell [29]. It provides the userwith a general-purpose type construction, written hbtyity, for binding names of user-declared type bty in expressions of arbitrary typety. This can be used in datatype declarations of types representing
object-level syntax to specify information about binding in the type.For example, suppose we want to represent expressions of a small
fragment of ML with the following forms:

x value identifier
fn x => e function abstraction
e1 e2 function application
let fun f x = e1 in e2 end local recursive function

In FreshML we can declare a new type name of bindable names forobject-level value identifiers and then declare a datatype

expr forthe above ML expressions:

bindable type name
datatype expr = Vid of name

| Fn of <name>expr
| App of expr * expr
| Let of expr * <name>expr
| Letf of <name>((<name>expr ) * expr )

In this declaration, types tell the system which data constructorsare binders and how their arguments are bound. For example in
let fun f x = e1 in e2 end there is a binding occurrence of fwhose scope is both

e1 and e2; and another of x whose scope isjust
e1. These binding scopes are reflected by the argument typeof
Letf in the declaration of expr . This declarative specificationof binding structure is particularly useful because FreshML endows

datatypes like expr with two crucial properties:
Abstractness: object-level expressions represented as values of thedatatype are operationally equivalent in FreshML if and only if they

are ff-equivalent in the object language.
Indeed, datatypes like expr are equality types in the ML sense, andmeta-level equality correctly represents object-level

ff-equivalence.

Concreteness: values of such datatypes can be deconstructed bymatching against patterns which explicitly name bound entities.

Indeed, FreshML provides automatic language-level support forthe common informal idiom which refers to

ff-equivalence classesvia representative parse trees, with bound names changed `on the

fly' to make them distinct among themselves and distinct fromany other names in the current context of use. For example,
the following FreshML declaration of a function subst of type
expr ! name ! expr ! expr suffices for subst e1 x e2 to com-pute (a representation of) the ML expression obtained by captureavoiding substitution of the expression represented by e1 for all freeoccurrences of the value identifier named

x in the expression repre-sented by
e2.

fun subst e x (Vid y ) =

if x =y then e else Vid y
| subst e x (Fn (<y >e1)) =

Fn (<y >(subst e x e1))
| subst e x (App (e1,e2)) =

App (subst e x e1,subst e x e2)
| subst e x (Let (e1,<y >e2)) =

Let (subst e x e1,<y >(subst e x e2))
| subst e x (Letf (<f >(<y >e1,e2))) =

Letf (<f >(<y >(subst e x e1),subst e x e2))

Note how simple subst is!--only the first clause of the declara-tion is not `boiler plate' [15]. In particular the clauses dealing with
substitution under a binder only have to specify the result when thebound name is sufficiently fresh. Section 2 shows how FreshML
ensures only this case arises during evaluation; and subst is a to-tal function because by Sect. 5 values of type

expr represent ff-equivalence classes of expressions in the ML fragment.

The Abstractness property says FreshML is correct as a languagefor `programming modulo

ff-equivalence', and the Concretenessproperty says it is expressive. The two properties oppose each other

and it is tricky to make them co-exist. We were guided to the designin [25] that achieves this by using the `FM' mathematical model
of binding in terms of name-swapping [10, 13, 24]. This modelhas a notion of an object's support which specialises to the set of
free names when it is an ff-equivalence class of parse trees involv-ing binders. We put forward the following informal thesis relating
what is sometimes called the `Barendregt variable convention' [3,page 26] to this notion of support.

Thesis: when people carry out constructions on ff-equivalenceclasses of parse trees via representative trees using dynamically
freshened bound names, the end result is well-defined, i.e. indepen-dent of which fresh bound names are chosen, because the freshly
chosen names do not occur in the support of the final result.

The type system in [25] enforces the condition `freshly chosennames do not occur in the support of the final result' at compiletime by deducing information about a relation of freshness of namesfor expressions which is a decidable approximation to the (in general undecidable) `not-in-the-support-of' relation. The result is apure functional programming language; static freshness inference
ensures the dynamics of replacing insufficiently fresh names onthe fly is referentially transparent. Purity makes reasoning about
program properties simpler and is desirable, but our static fresh-ness inference which achieved it had a drawback: since freshness is
only an approximation of `not-in-the-support-of', the type-checkerinevitably rejects some algorithms that do in fact conform to the
above Thesis. Experience showed this happened too often (we dis-cuss why in Sect. 6).

The main contribution of this paper is to show, perhaps surpris-ingly, that static freshness inference is not necessary for the crucial
Abstractness property to hold in the presence of the Concretenessproperty, so long as the operational semantics of [25] is modified to
make the declaration of fresh bindable names generative like someother sorts of names (references, exceptions and type names) are in
ML. This fact is not at all obvious and requires proof, which wegive.

Summary
Section 2 introduces a new version of FreshML with a slightlymore `effectful' dynamics than in [25], but considerably simpler

type system. Since we wish to promote it, this new version ofthe language is simply called FreshML; the older, more complicated design from [25] will be referred to as FreshML 2000. Asexplained in Sect. 3, the essence of the dynamics is the combination of generative names with name-swapping. To prove thatthe FreshML type system controls the dynamics sufficiently for
object-level ff-equivalence to coincide with meta-level operationalequivalence (the Abstractness property), in Sect. 4 we describe a
denotational semantics of FreshML in the FM-sets model of bind-ing [13] that gave rise to the design of FreshML 2000 in the first
place. The denotational semantics is structured using a monadand makes use of FM-cpos, which seem interesting in their own
right. Section 5 contains the main technical contributions of thepaper: we prove that this denotational semantics is computationally adequate for the operational semantics (the proof uses a suit-able logical relation between semantics and syntax whose details
are omitted in this extended abstract) and then we use this result toestablish the Abstractness property (Theorem 5.6). Section 6 discusses the pros and cons of using static freshness inference as orig-inally envisioned in [25] for FreshML 2000. Section 7 describes
our experiences implementing FreshML. From the programmer'spoint of view, we claim that FreshML extends ML with elegant
and practical constructs for declaring and manipulating syntacti-cal data involving binding operations. We give a few examples:
capture-avoiding substitution, ff-equivalence, computation of freevariables (Fig. 5), and normalisation by evaluation (Fig. 7); more
can be found at http://www.freshml.org/. Finally, Sect. 8 dis-cusses related work and draws some conclusions about the results
presented here and their implications for future work.
2 FreshML-Lite
This section introduces the new version of FreshML. Comparedwith [25], we do without freshness inference in the type system and

use a generative operational semantics for fresh names. To makethe presentation more accessible, here we use a cut-down language,
which we call FreshML-Lite, combining the principal novelties ofFreshML with a pure functional subset of ML.

Types o/ 2 Ty ::= Values v 2 Val ::=bindable name

name atom aabstraction type h

nameio/ abstraction haivunit type
unit pair (v, v)product type
o/ * o/ unit ()function type
o/ ! o/ closure [E, x(x) = e]data type
ffi constructed C

C vPatterns

pat ::=variable

xabstraction
<x>xpair

(x,x)

Declarations dec ::=value

val pat = efresh atom
fresh xrecursive function
fun x (x) = esequential dec dec

Expressions e ::=value identifier

xconstructor
Catom equality test
e = eatom swapping
swap e,e in eatom abstraction
<e>eunit

()pair
(e,e)application
e ecase split
case e of (C x => e | * * * )local declaration
let dec in e end

Environments Typing contexts States
E 2 VId fin-! Val \Gamma  2 VId fin-! Ty a 2 \Gamma  fin \Delta 

Top-level datatype declaration

datatype bool = true | false
and ffi1 = C of o/ | * * *..

.
Figure 1. FreshML-Lite syntax and semantic objects

FreshML-Lite syntax is specified in Fig. 1. For simplicity we as-sume a single, top-level datatype declaration, including a type

boolof booleans and possibly some other mutually recursively defined

datatypes ffi1, ffi2, . . . There is a single type of bindable names, called
name, whose values are called atoms1 and which are the elements ofa fixed, countably infinite set \Delta  . The type h

nameio/ of abstractionshas values given by pairs, written h
aiv and consisting of an atom
a 2 \Delta  and a value v of type o/. As we see below, FreshML-Lite'ssemantics (both operational and denotational) identifies abstraction

values up to renaming the h i-enclosed atom; for example, haiaand h

a0ia0 turn out to be operationally equivalent values of typeh
nameiname. In FreshML-Lite programs, values of type name areintroduced via local declarations of fresh atoms, in much the same

way that names of references are introduced in ML; values of ab-straction type are introduced with expressions of the form

<e1>e2and eliminated via a local declaration with an abstraction pattern,

let val <x>y = e in e0 end.
FreshML-Lite's type system is quite standard compared with theone given in [25] (the latter infers freshness information in addition

to conventional ML typing properties). Figure 2 gives a selection of

1The terminology stems from the denotational model given in Sect. 4.

Expressions

\Gamma  ` e1 : name \Gamma  ` e2 : name

\Gamma  ` e1 = e2 : bool (1)

\Gamma  ` e1 : name \Gamma  ` e2 : name \Gamma  ` e3 : o/

\Gamma  ` swap e1,e2 in e3 : o/ (2)

\Gamma  ` e1 : name \Gamma  ` e2 : o/

\Gamma  ` <e1>e2 : hnameio/ (3)

\Gamma  ` e1 : o/1 \Gamma  ` e2 : o/2

\Gamma  ` (e1,e2) : o/1 * o/2 (4)

\Gamma  ` dec : \Gamma 0 \Gamma  + \Gamma 0 ` e : o/

\Gamma  ` let dec in e end : o/ (5)

Declarations

\Gamma  ` e : hnameio/ x 6= y
\Gamma  ` val <x >y = e : {x 7! name, y 7! o/} (6)

\Gamma  ` e : o/1 * o/2 x 6= y
\Gamma  ` val (x ,y ) = e : {x 7! o/1, y 7! o/2} (7)

\Gamma  ` fresh x : {x 7! name} (8)
Values

a 2 \Delta `
a : name (9)

a 2 \Delta  ` v : o/` h

aiv : hnameio/ (10)

` v1 : o/1 ` v2 : o/2`

(v1, v2) : o/1 * o/2 (11)

Figure 2. FreshML-Lite typing (excerpt)

the typing rules. Comparing rules (3), (6) and (10) with rules (4),(7) and (11) respectively, we see that as far as typing properties
are concerned, hnameio/ is like a product type name * o/ (cf. The-orem 3.1). However, the two types have different dynamic properties. We have chosen to remain close to the Definition of StandardML [18] and specify the dynamics using inductively defined evaluation relations of the form

a, E ` e + v, a0 (21)
a, E ` dec + E0, a0 (22)

where the states a and a0 are finite subsets of \Delta  and the valueenvironments E and E0 are finite functions mapping value identifiers to values.2 Figure 3 gives a selection of the evaluation rules.Rules (14) and (18) make use of the notation

(a a0) * v (23)
which stands for the value obtained from v by swapping all occur-rences of the atoms

a and a0 in it.

2In contrast to FreshML 2000 where the environment-style operational
semantics is necessary for type soundness, it is quite possible to use a`substituted-in' formulation of FreshML's dynamics, in which values form

a subset of expressions.

a, E ` e1 + a, a0 a0, E ` e2 + a, a00

a, E ` e1 = e2 + true, a00 (12)

a, E ` e1 + a, a0 a0, E ` e2 + a0, a00 a 6= a0

a, E ` e1 = e2 + false, a00 (13)

a, E ` e1 + a1, a0 a0, E ` e2 + a2, a00

a00, E ` e3 + v, a000

a, E ` swap e1,e2 in e3 + (a1 a2) * v, a000 (14)

a, E ` e1 + a, a0 a0, E ` e2 + v, a00

a, E ` <e1>e2 + haiv, a00 (15)

a, E ` e1 + v1, a0 a0, E ` e2 + v2, a00

a, E ` (e1,e2) + (v1, v2), a00 (16)

a, E ` dec + E0, a0 a0, E + E0 ` e + v, a00

a, E ` let dec in e end + v, a00 (17)

a, E ` e + haiv, a0 a0 2 \Theta  - a0 v0 = (a a0) * v
a, E ` val <x1>x2 = e + {x1 7! a0, x2 7! v0}, a0 [ {a0} (18)

a, E ` e + (v1, v2), a0
a, E ` val (x1,x2) = e + {x1 7! v1, x2 7! v2}, a0 (19)

a 2 \Theta  - a
a, E ` fresh x + {x 7! a}, a [ {a} (20)

Figure 3. FreshML-Lite evaluation (excerpt)

The state may grow during evaluation: if (21) holds, Lemma 2.4below shows that

a ` a0 (and similarly for (22)). The featuresthat cause it to grow are not only declarations of fresh atoms (see

rule (20)), but also value declarations involving abstraction pat-terns: see rule (18). This rule lies at the heart of our treatment
of binders. It says that when matching an abstraction pattern <x>yagainst an abstraction value h

aiv, we associate x not with a, butrather with a new atom
a0 not in the current state; and then y is as-sociated with
(a a0) * v. In fact the valid instances of the evaluationrelations (21) and (22) all have the property that

a0 contains all theatoms occurring in
v (provided a contains all those occurring in E,which we will always assume to be the case). So the new atom

a0 inrule (18) does not occur in
v and therefore the swapping (a a0) * vis equal to
[a:=a0] * v, the result of replacing all occurrences of ain
v with a0. We postpone to Sect. 7 discussing ways of makingthe implementation of this rule more efficient, both by avoiding the

generation of fresh atoms where possible and by delaying the com-putation of atom swaps (replacements) until needed.

FreshML-Lite permits explicit name-swapping in expressions withthe syntax

swap e1,e2 in e3; typing and evaluation rules are (2)and (14) in Figs 2 and 3. Name-swapping can express the operation

e @ x from [25] of concreting an abstraction at a (fresh) atom, using

let val <x' >y = e in swap x,x' in y .
Here is a more typical example, using swap-expressions to replacethe bound names in a number of abstractions with the same name.

Example 2.1. If eq : o/ * o/ ! bool gives a notion ofequality for

o/-values, then the following function eqa of typeh
nameio/ * hnameio/ ! bool correctly computes `equality modulo
ff-conversion' for hnameio/-values:

fun eqa (p)=

let val (z,z') = p

val <x>y = z
val <x'>y' = z'
in

eq (swap x,x' in y, y')
end.

Compare this with the characterisation of ff-equivalence via swap-ping of [32, Theorem 1]. \Lambda 

Remark 2.2. The full version of FreshML extends FreshML-Litewith a number of useful features, as well as including standard features from ML such as polymorphism, references and exceptions.*

Compound patterns are allowed, in which abstraction patternscan be nested with other forms of pattern. For example, the

declaration of eqa from Example 2.1 can be simplified to:

fun eqa (<x>y,<x'>y') = eq (swap x,x' in y, y').

* Rather than having just one type name of bindable names,users can declare as many distinct such types as they need;

they form a subclass of the equality types and expressions canbe polymorphic in the type of bindable names used.

* Abstraction types hbtyity, with bty a declared type of bindablenames, are a special case of abstraction types hetyity where ety

is an arbitrary equality type. Their values are written hhv1iiv2(so h

aiv is a synonym for hhaiiv when a is an atom). The se-mantics ensures that these values are indistinguishable up to

renaming all the free atoms in the value v1 (of equality typeety) occurring in the value

v2 (of type ty); this permits sim-ple representations of binding constructs in which the number

of bound names is not fixed, such as the ML matching con-structs (which bind all the variables occurring in a pattern), or
Scheme's general form of let-expression with a list of decla-rations.

* If ety and ety0 are equality types, then so is hetyiety0 and thebuilt-in equality function at that type is the appropriate form

of ff-equivalence (cf. Example 2.1).
We conclude this section by giving some `sanity checks' onFreshML-Lite's typing and evaluation rules.

Lemma 2.3. Given value and typing environments E and \Gamma , write` E

: \Gamma  to mean that dom(E) = dom(\Gamma ) and that for each x 2dom
(\Gamma ), ` E(x) : \Gamma (x) holds. Then if a, E ` e + v, a0, ` E : \Gamma and
\Gamma  ` e : o/ hold, so does ` v : o/. \Lambda 

Lemma 2.4. Given a state a containing all the atoms occurring ina value environment E, if

a, E ` e + v, a0 holds then a ` a0.Moreover, the pair
(v, a0) is uniquely determined up to permutingthe atoms in
a0 - a: if a, E ` e + v0, a00 also holds, then there is abijection
ss between a0 - a and a00 - a such that v0 is obtained from
v by applying ss to the atoms occurring in it. \Lambda 

3 The essence of FreshML is swapping
Although in rule (18) of Fig. 3 one can replace swapping (a a0) * vwith renaming

[a:=a0]* v, because a0 does not occur in v, neverthe-less swapping rather than renaming underlies our treatment of fresh

bindable names. This is because it is simpler to use a totally definedoperation that can be applied whether or not

a0 occurs in v; but if a0

Types

[[name]]ML = unit ref
[[hnameio/]]ML = [[name]]ML * [[o/]]ML

Expressions

[[e1 = e2]]ML = [[e1]]ML = [[e2]]ML
[[swap e1,e2 in e3]]ML = swap [[e1]]ML [[e2]]ML [[e3]]ML

[[<e1>e2]]ML = ([[e1]]ML,[[e2]]ML)
[[val <x1>x2 = e]]ML = val (x01,x02) = [[e]]ML;

val x1 = ref ();
val x2 = swap x1 x01 x02(where

x01, x02 are fresh)
[[fresh x]]ML = val x = ref ()

Values

[[a]]ML = a
[[haiv]]ML = ([[a]]ML, [[v]]ML)

The rest of the translation is the identity; for example

[[o/1 * o/2]]ML = [[o/1]]ML * [[o/2]]ML
[[(e1,e2)]]ML = ([[e1]]ML,[[e2]]ML)
[[val (x1,x2) = e]]ML = val (x1,x2) = [[e]]ML

[[(v1, v2)]]ML = ([[v1]]ML, [[v2]]ML),etc.

Figure 4. Translating FreshML-Lite into ML+swap

does occur in v, renaming can have bad properties, whereas swap-ping is well-behaved. For example if

a, a0 and a00 are distinct, ha0iaand h
a00ia are equivalent, but [a:=a0] * (-) sends the first to ha0ia0and the second to the inequivalent value h

a00ia0. We might repairthis familiar problem of `capture' of free names by binders with a

theory of capture-avoiding renaming, but a much simpler solutionis just to use swapping

(a a0)*(-); its self-inverse nature has excel-lent properties which include preserving

ff-equivalence. Indeed, agrowing body of evidence shows that name-swapping, and more

generally permutations of names, are very useful for describingproperties of syntax involving binders: see [5, 6, 11, 24, 32].

As far as dynamics are concerned, name-swapping is the only thingFreshML has over ML. To see this, consider the extension of Standard ML [18] with a primitive polymorphic function swap of type
unit ref!unit ref!ff!ff for swapping addresses (the valuesof type

unit ref) in ML values. Then the FreshML-Lite languageof the previous section can be translated into it as in Fig. 4.

Theorem 3.1. The above translation preserves and reflectsFreshML-Lite typing and evaluation:

\Gamma  ` e : o/ holds in FreshML-Lite iff
[[\Gamma ]]ML ` [[e]]ML : [[o/]]ML holds in ML+swap; and a, E ` e +
v, a0 holds in FreshML-Lite iff a, [[E]]ML ` [[e]]ML + [[v]]ML, a0 holdsin ML+swap. \Lambda 

Since the translation is compositional, this theorem implies it is`computationally adequate': if the translations of two phrases are
contextually equivalent in ML+swap, then they are already contex-tually equivalent in FreshML-Lite. (See Definition 5.3 for a precise definition of contextual equivalence.) The converse is not true;the translation is far from being `fully abstract'. This is because
abstraction values in FreshML-Lite are translated to (atom,value)-pairs in ML+swap and the identity of the first component can be
discovered there in a way that we shall prove in Sect. 5 is impossiblein FreshML-Lite. For example, the results in Sect. 5 show that the
following two expressions of type (hnameiname) * (hnameiname)

are contextually equivalent in FreshML-Lite:

let fresh x fresh y in (<x >x ,<y >y ) end,
let fresh x in (<x >x ,<x >x ) end.

Under the translation they become the contextually inequivalent ex-pressions

let val x = ref () val y = ref () in ((x ,x ),(y ,y )) end,
let val x = ref () in ((x ,x ),(x ,x )) end

which are distinguished in ML+swap by the context

let val x = [ - ] in #1(#1(x)) = #1(#2(x)) end
(where #1 and #2 are ML notation for first and second projectionfunctions). It might seem then that we could better mimic h

nameio/in ML+swap with an abstract type with underlying representation

name * o/. However, being abstract, we would lose the Concrete-ness property mentioned in the Introduction, i.e. the ability to match
against patterns involving abstraction, which seems so convenientin practice (see also Remark 5.7).

4 Denotational semantics
In this section we give meaning to FreshML-Lite types and ex-pressions with a denotational semantics in the universe of FMsets. This permutation model of set theory devised by Fraenkeland Mostowski in the 1930s is shown in [13] to provide a syntaxindependent mathematical model of fresh bindable names and ff-conversion, by expressing those concepts purely in terms of swapping names. This mathematics gave rise to the FreshML 2000 de-sign [25]. We saw in the previous section that the dynamics of
FreshML's treatment of bindable names reduces to two things: adynamically generated supply of fresh names (provided by the ML
type unit ref) and name-swapping (which we had to introduceas a primitive). So it is perhaps not surprising that a mathematical
model of freshness and name-swapping can provide a denotationalsemantics of FreshML-Lite that fits its operational semantics well.
The computational adequacy result of Theorem 5.4 shows that itdoes; from this we deduce results about the correctness of representation of object-level ff-equivalence.
What is an FM-set? Ordinary sets are members of a cumulative hi-erarchy obtained by starting with nothing (;) and continuing transfinitely, at each stage forming new sets by taking powersets. Theuniverse of FM-sets differs just in that we start with a fixed infinite
collection \Lambda  of `atoms' (so-called because they will be members ofthe universe that do not possess elements themselves), and at each
stage take only the set of subsets that possess a finite support. Bydefinition a set

a of atoms is a support for X if for all a, b 2 \Lambda  - a,
X equals (a b) * X. Here (a b) * X denotes the set obtained from
X by swapping a and b wherever they appear in it (hereditarily). Itis the case (though not obviously so: see [13, Proposition 3.4]) that

every member X of the universe of FM-sets possesses a smallestfinite support, written supp

(X).

The only restriction we have when doing FM-set theory is that wemust remain within the universe of sets with finite support. The

axiomatic development of [10] shows that nearly all logical and set-theoretical constructs have this property. Just axioms of choice, the
ability to form a set consisting of an arbitrary choice of infinitelymany objects of the universe, are limited. For example, and this will
be relevant below, if xn (for n = 0, 1, . . .) is a countable sequenceof elements of an FM-set, although each element of the sequence
possesses a finite support, there may be no single finite set of atomsthat is a support for all the

xn simultaneously; only if there is sucha finite set will the function sending each

n to xn, i.e. the set of

ordered pairs {(n, xn) | n = 0, 1, . . .}, be finitely supported andhence an FM-set.
FreshML-Lite features fixpoint recursion in both types and ex-pressions. It is well-known how to use domain theory to give
denotational semantics for this. Here we use a domain theoryin FM-sets; this gives us access to the FM-set former for atomabstractions [13, Sect. 5] to give meaning to FreshML-Lite's ab-straction types h

nameio/. We only need a relatively simple notion ofdomain, namely

!-complete partial orders (cpos), within the FM-sets universe:

Definition 4.1. An FM-cpo D is an FM-set equipped with afinitely supported partial order v

D` D * D (often written just v)such that any finitely supported !-chain d

0 v d1 v d2 v * * * 2 D(i.e. one for which there is a single finite set of atoms a with

supp(dn) ` a for all n) has a least upper bound (lub). We alsoassume supp

(D) = supp(vD) = ; (i.e. D and vD do not dependon particular atoms). A morphism of FM-cpos

f : D ! D0 is afunction
D ! D0 that preserves v, swapping (i.e. f((a b) * d) =
(a b) * f(d)), and lubs of finitely supported !-chains. \Lambda 

Such a D need not have lubs of arbitrary !-chains. For example thedenotation of

name ! unit turns out to be isomorphic to the FM-cpo of subsets of \Xi  that are either finite or whose complement is

finite, partially ordered by inclusion; if we enumerate the elementsof \Xi 

= {a0, a1, a2, . . .},3 then the chain ; v {a0} v {a0, a2} v{
a0, a2, a4} v * * * is not finitely supported and moreover does notpossess a lub in this FM-cpo.

Our semantics is monadic in the sense of Moggi [19]: each type o/ isassigned an FM-cpo

[[o/]] whose elements are used to give meaningto FreshML-Lite values, `

v : o/; whereas (closed) expressionsof type
o/ are assigned elements of T[[o/]], where T is a particular`dynamic allocation' monad on FM-cpos. We define

T below, butfirst here is the definition of
[[o/]] as o/ ranges over FreshML-Litetypes.

* [[unit]] def= {1}, [[name]] def= \Xi  : Each FM-set X determines adiscrete FM-cpo taking v as equality on

X. The one-element setinterprets
unit and the set of atoms \Xi  interprets name.

* [[ffin]] def= Dn: For datatypes we use minimal solutions to simul-taneous recursive domain equations corresponding to the datatype
declaration. We can construct them by standard techniques usingcolimits of embedding-projection pairs (see [1, Sect. 5] for example), which transfer smoothly to FM-cpos; we omit details.

* [[hnameio/]] def= [\Xi  ][[o/]]: For abstraction types we use the atom-abstraction FM-cpo

[\Xi  ]D built from an FM-cpo D, much like theatom-abstraction FM-set in [13, Sect. 5]. This consists of equivalence classes for the pre-order (i.e. reflexive-transitive relation) on\Xi  *

D given by: (a1, d1) v (a2, d2) iff a1 = a2 and d1 vD d2,or
a2 /2 supp(d1) and (a1 a2) * d1 vD d2 (cf. Example 2.1). Over-loading the notation, we write

[a]d for the element of [\Xi  ]D givenby the equivalence class of the pair

(a, d). We can calculate thatsupp
([a]d) = supp(d) - {a}.

* [[o/ * o/0]] def= [[o/]] * [[o/0]]: For product types we use the prod-uct of FM-cpos, given as for ordinary cpos by ordered pairs with
componentwise ordering.

* [[o/ ! o/0]] def= [[o/]] ! T[[o/0]]: The function FM-cpo D ! D0 of
D and D0 consists of all finitely supported subsets of D * D0 that

3Any such bijection of the set of atoms with the natural numbers is
external to the FM-sets universe since it cannot be finitely supported.

are total, monotone functions from D to D0 preserving least upperbounds of finitely supported chains. To interpret function types we
combine this construct with the dynamic allocation monad T de-scribed below. Thus values of type

o/ ! o/ 0, i.e. recursive functionclosures, are modelled by functions mapping values (elements of

[[o/]]) to `computations' of values (elements of T[[o/ 0]]).
T is the analogue for the category of FM-cpos of one of the dy-namic allocation monads on a presheaf category used by Stark [30]

to model the Pitts-Stark *-calculus [26]. Each FM-cpo TD can beconstructed as the quotient of

(\Pi  fin \Xi  * D)? by a suitable equiva-lence relation; we omit the details here and just note that

TD carriesthe following structure:

* A (mono)morphism j : D ! TD (the monad unit).*

A least element ? 2 TD.*
A morphism * : [\Xi  ]D ! D (`restriction') satisfying for all
a, b 2 \Xi  and x 2 TD that

*[a](*[b]x) = *[b](*[a]x) (24)

*[a]x = x if a /2 supp(x). (25)

TD is the minimal cpo with these properties, i.e. it has a certaincategory-theoretic universal property, which we omit; and we can
use that to define the lifting part of the monad structure and verifythe usual monad laws. We can present each non-bottom element of
TD as

*a . d def= *[a1] * * * *[an]j(d) (26)
where a = {a1, . . . , an} is a finite (possibly empty) set of atomsoccurring in the support of

d 2 D (by property (24), the orderin which we list the elements of

a on the right-hand side of (26)is immaterial). The element (26) models a convergent FreshMLLite expression whose evaluation creates some fresh atoms a andreturns a value denoted by

d. We need a dynamic allocation monadsatisfying (24) and (25), rather than a simpler one just pairing up

name sets and values, to prove Theorem 5.6.
We can now construct the denotations of FreshML-Lite values, ex-pressions and declarations:

* if ` v : o/ is derivable, then [[` v : o/]] 2 [[o/]]*

if \Gamma  ` e : o/ is derivable, then [[\Gamma  ` e : o/]] : [[\Gamma ]] ! T[[o/]]*
if \Gamma `dec : \Gamma 0 is derivable, then [[\Gamma  ` dec : \Gamma 0]] : [[\Gamma ]]!T[[\Gamma 0]]
where the denotation [[\Gamma ]] of a typing environment \Gamma  is the productof the FM-cpos

[[\Gamma (x)]] as x ranges over the finite domain of defi-nition of
\Gamma . Definition is by induction on judgements; we just givethe interesting clauses.

* Fresh name declaration, \Gamma  ` fresh x : \Gamma 0:
[[\Gamma  ` fresh x : \Gamma 0]](ae) def= *{a} . {x 7! a}, for some/any a 2 \Xi (by construction of

T, the right-hand side is independent of a).

* Value declaration for abstractions, \Gamma  ` val <x>x0 = e : \Gamma 0:Let

d = [[\Gamma  ` e : hnameio/]](ae). Then, for m as defined below,

[[\Gamma  ` val <x>x0 = e : \Gamma 0]](ae) def= (? if d = ?m otherwise.

For d 6= ?, we have that d = *a . [a]d0 and we can define m def=
*({a0} ] a) . {x 7! a0, x0 7! (a a0) * d0} for some/any a0 /2
a [ {a} [ supp(d0).

* Swap expression, \Gamma  ` swap e1,e2 in e3 : o/:Let

a1 = [[\Gamma  ` e1 : name]](ae), a2 = [[\Gamma  ` e2 : name]](ae) and
d = [[\Gamma  ` e3 : o/]](ae). Then

[[\Gamma  ` swap e1,e2 in e3 : o/]](ae) def= 8?!?:?

if a1 = ?,
or a2 = ?
(a1 a2) * d otherwise.

* Abstraction expression, \Gamma  ` <e1>e2 : hnameio/:Given

d1 = [[\Gamma  ` e1 : name]](ae) and d2 = [[\Gamma  ` e2 : o/]](ae), then

[[\Gamma  ` <e1>e2 : hnameio/]](ae) def=8?!?:?

if d1 = ?, or d2 = ?
*(a ] a0) . [a]d otherwise, where d1 = *a . a,

d2 = *a0 . d and a " a0 = ;.

* Atom value: [[` a : name]] def= a.

* Abstraction value: [[` haiv : hnameio/]] def= [a][[` v : o/]].
When we refer to `some/any atom' above, we are really using thefreshness quantifier

Nof [13]: we choose some atom satisfying thecondition, but in fact any such one will do.

5 Correctness
In this section we show the denotational semantics of Sect. 4matches the operational semantics closely enough that we can prove

prove that values of recursively defined FreshML-Lite datatypesrepresent

ff-equivalence classes of object-level syntax (the Ab-stractness property from the Introduction). For simplicity we take

as object-language the familiar untyped *-calculus, but the resultseasily generalise to other algebraic signatures with binders. We
noted in the previous section that the denotation [[ffi]] of a declaredFreshML-Lite datatype

ffi is a recursively defined FM-cpo. When
ffi arises from an algebraic signature with binders, it only involvesproduct- and abstraction-, but not function-types; in this case

[[ffi]] isa discrete FM-cpo given by an inductively-defined FM-set.

Example 5.1. Given the datatype declaration

datatype lam = Var of name

| Lam of hnameilam
| App of lam * lam

then [[lam ]] is isomorphic to the discrete FM-cpo given by the in-ductively defined FM-set

uX.(\Sigma  + [\Sigma  ]X + X * X). Previouswork [13, Theorem 6.2] shows this to be in bijection with the set

\Lambda (\Sigma  )/jff of ff-equivalence classes [t]jff of untyped *-terms twith variables in \Sigma  :

t 2 \Lambda (\Sigma  ) ::= a | *a.t | t t
(Swapping is given by (a b) * [t]jff = [(a b) * t]jff, where (a b)*interchanges all instances of

a and b in t; the support of [t]jff is thefinite set of free variables of
t.) It is not hard to see from the typingrules for values in FreshML-Lite that there is a bijection between

*-terms t 2 \Lambda (\Sigma  ) and values (t)v of type lam , given by

(a)v def= Var a
(*a.t)v def= Lam (hai(t)v)
(t1 t2)v def= App ((t1)v, (t2)v).
One can show by induction on the structure of t that under theisomorphism

\Lambda (\Sigma  )/jff ,= [[lam ]] above, [t]jff is identified with
[[` (t)v : lam ]]. Therefore for all t and t0,

t jff t0 iff [[` (t)v : lam ]] = [[` (t0)v : lam ]] (27)

\Lambda 

Thus denotations of values of FreshML-Lite datatypes like lamare in bijection with

ff-equivalence classes of terms of the object-language they represent. To connect this to operational behaviour of

FreshML-Lite programs we have to do two things. First, we exam-ine the translation of object-level terms into expressions rather than
values, since these are what the programmer writes, and second, werelate equality of denotation of expressions to an appropriate notion
of operational behaviour (Definition 5.3).
To tackle the first issue, still using an object-language of *-terms,note that atoms \Sigma  and value identifiers VId are both countably infinite sets. By enumerating each, fix some explicit bijection ai $ xi,then translate the

*-terms t of Example 5.1 into FreshML-Lite ex-pressions
(t)e as follows:

(ai)e def= Var xi
(*ai.t)e def= let fresh xi in Lam (<xi>(t)e) end

(t1 t2)e def= App ((t1)e,(t2)e).
Lemma 5.2. One can show by induction on the structure of t thatif its free variables are among {

a1, . . . , an} and if \Gamma  is the typingcontext mapping the corresponding value identifiers

x1, . . . , xn to
name, then \Gamma  ` (t)e : lam holds and for any ae 2 [[\Gamma ]] = \Sigma  n

[[\Gamma  ` (t)e : lam ]](ae) = *; . [[` (ae t)v : lam ]] 2 T[[lam ]] (28)
where ae t is the *-term obtained by simultaneous capture-avoidingsubstitution of

ae(xi) for ai in t (for i = 1, . . . , n).

PROOF. When it comes to the step for *-abstractions in the proofof (28), the `garbage collection' property (25) of the monad

T iscrucial, combined with the fact that in an atom-abstraction FM-cpo

[\Sigma  ]D, an element of the form [a]d never contains a in its support.\Lambda 

We now know for all t and t0 that

t jff t0 iff [[\Gamma  ` (t)e : lam ]] = [[\Gamma  ` (t0)e : lam ]] (29)
where \Gamma  is as in Lemma 5.2. For if t jff t0, then ae t jff ae t0 forany

ae; so from (27) we get [[` (ae t)v : lam ]] = [[` (ae t0)v : lam ]]and therefore

[[\Gamma  ` (t)e : lam ]](ae) = [[\Gamma  ` (t)e : lam ]](ae)by (28); since this holds for any

ae, we have the left-to-rightimplication in (29). Conversely, if

[[\Gamma  ` (t)e : lam ]](ae) =
[[\Gamma  ` (t)e : lam ]](ae) holds for any ae, from (28) again we get
*; . [[` (ae t)v : lam ]] = *; . [[` (ae t0)v : lam ]] in T[[lam ]]; butthis implies that

[[` (ae t)v : lam ]] = [[` (ae t0)v : lam ]] in [[lam ]](since the unit of the monad

T is a monomorphism); so by (27)we have
ae t jff ae t0; and then we can take ae to be ae(xi) = ai(
i = 1, . . . , n), for which ae t jff t and ae t0 jff t0, to conclude that
t jff t0. \Lambda 

Turning to the second issue mentioned above, namely relatingequality of denotation of expressions to operational behaviour, we

give a notion of contextual equivalence for FreshML-Lite expres-sions. Roughly speaking, two expressions (of the same type) are
contextually equivalent if they are interchangeable in any completeprogram without changing observable behaviour. We take programs
to be closed expressions of type unit, and their observable be-haviour to be whether they evaluate, ignoring any fresh atoms created along the way. The following more precise definition uses typ-ing and evaluation as defined in Sect. 2, and the notion of a context
C[-]. As usual, contexts are generated by the grammar in Fig. 1augmented by a placeholder `-'. C

[e] then denotes the result ofreplacing `-' by
e.

Definition 5.3. Given \Gamma  ` e : o/ and \Gamma  ` e0 : o/, we write

\Gamma  ` e ssctx e0 : o/
and say that e and e0 are contextually equivalent if for all contextsC

[-] with ; ` C[e] : unit and ; ` C[e0] : unit, we have 9a (;, ; `C
[e] + (), a) if and only if 9a0 (;, ; ` C[e0] + (), a0). \Lambda 

Theorem 5.4. (Computational adequacy) Suppose \Gamma  ` e : o/,` E

: \Gamma , and a contains the atoms of E. Let ae be given by ae(x) =
[[`E(x) : \Gamma (x)]], for x 2 dom(\Gamma ).

(a) If a, E ` e + v, a0, then [[\Gamma  ` e : o/]](ae) is equal to the non-bottom element

*(a0 - a) . [[` v : o/]] of T[[o/]].

(b) Conversely, if [[\Gamma  ` e : o/]](ae) 6= ?, then a, E ` e + v, a0holds for some

v and a0.

PROOF. (a) is proved by induction on the derivation of a, E ` e +
v, a0. The proof of part (b) is more involved. We use a standardmethod based on type-indexed logical relations relating domain elements to FreshML-Lite values and expressions. The constructionis complicated because, as for ML, FreshML allows function types
in recursively defined datatypes (see Fig. 7 in Sect. 6 for an exam-ple), precluding a simple inductive technique; instead, we deduce
the existence of the logical relations using the general theory ofminimal invariant relations [23] applied in the setting of FM-cpos
(details omitted in this extended abstract). \Lambda 
Parts (a) and (b) together give the first part of the following corol-lary. The second part can be deduced from the proof of the theorem,

by exploiting particular properties of the logical relation at equal-ity types, which for the simplified language given in Sect. 2 we can
take to be types not involving use of the function type construct (ei-ther in themselves, or in the declarations of any datatypes that they
involve).
Corollary 5.5. Suppose \Gamma `e : o/ and \Gamma `e0 : o/. If [[\Gamma  ` e : o/]] =
[[\Gamma  ` e : o/]], then \Gamma  ` e ssctx e0 : o/. The converse holds if o/ is anequality type. \Lambda 

Theorem 5.6. (Correctness of representation) Under the trans-lation of

*-terms t into FreshML-Lite expressions (t)e of type lamgiven above,

ff-equivalence of *-terms corresponds to contextualequivalence of FreshML-Lite expressions: given two

*-terms tand
t0, with free variables among {a1, . . . , an} say, letting \Gamma  bethe typing context that maps the corresponding value identifiers

x1, . . . , xn to name, we have

t jff t0 iff \Gamma  ` (t)e ssctx (t0)e : lam .

PROOF. The type lam is an equality type, so we can combineCorollary 5.5 with (29) to get the desired conclusion. \Lambda 
We emphasise that although this correctness theorem is for *-terms,similar results hold for object languages specified by a general notion of binding signature (such as the nominal signatures of [32,Definition 1], or the nominal algebras of [14]) versus datatypes in
FreshML-Lite whose declarations are derived from the signature inthe simple declarative fashion discussed in the Introduction.

Remark 5.7. What more could one want from such a representa-tion of object languages in a metalanguage? Well, to be useful, the
metalanguage should provide rich facilities for writing algorithmsto manipulate these representations. FreshML's abstraction patterns
are very useful in this respect. In particular we can use them toprovide an important facility, namely the ability to recognise that a
meta-level expression represents some object-level term. For an im-pure functional programming language this cannot just be a matter

1 (* remove : name -> name list -> name list *)
2 fun re move x [] = []
3 | remove x (y ::ys ) =
4 if x = y then remove x ys
5 else y ::(remove x ys );
6 (* fv : lam -> name list *)
7 fun fv (Var x ) = [x ]
8 | fv (Lam (<x >t )) = remove x (fv t )
9 | fv (App (t1,t2 )) = (fv t1 ) @ (fv t2 );
10 (* is closed t : lam -> bool *)
11 fun is closed t = ((fv t )=[])

Figure 5. Testing for closed *-terms in FreshML

of typing and termination; because of side-effects from referencesand exceptions, the full FreshML has terminating closed expressions of type lam from Example 5.1 which are not in the image ofthe translation

t 7! (t)e of *-terms. However, even the cut-downFreshML-Lite of Sect. 2 has this property. For example

genvar def= let fresh x in (Var x) end (30)
evaluates to `some fresh object-level variable'. Once we identify
[[lam ]] with \Lambda (\Upsilon  )/jff as in Example 5.1, the denotational se-mantics of

genvar is [[; ` genvar : lam ]] = *{a} . ([a]jff) 2
T[[lam ]] (and [a]jff is just {a}); from this and Sect. 5 it followsthat

genvar is not contextually equivalent to (t)e for any closed
*-term t. Nevertheless, we can easily write FreshML-Lite boolean-valued functions to recognise an expression as the encoding of some

object-level term; for example is closed declared in Fig. 5 (forlegibility we used syntax for nested patterns and standard list constructs). This uses helper functions remove for removing an atomfrom a list of atoms and

fv for computing the free variables of a *-term (possibly with repeats); and then

is closed tests whether thatlist is empty. For example
is closed genvar evaluates to false(creating a fresh atom as it does so). Our results can show that for

a closed FreshML-Lite expression e of type lam, if evaluation of
e terminates (i.e. if ;, ; ` e + v, a holds for some v and a), then;`

is closed e ssctx true : bool if and only if ;`e ssctx (t)e : lamholds for some closed

*-term t.

6 Freshness inference
Recall from Sect. 4 the important FM-sets notion of finite support(and the notation supp

(X) for the smallest set of atoms supportingan FM-set
X). In informal reasoning about ff-equivalence classesby choosing representatives with sufficiently fresh bound names

(c.f. the `Barendregt variable convention' [3, page 26]), it seemsthat the end result is always well-defined, i.e. independent of which
fresh bound names are chosen, because the freshly chosen names donot occur in the support of the final result (for if

a, b /2 supp(X),then swapping
a and b has no effect on X, i.e. (a b)*X = X). Thisis the informal Thesis put forward in the Introduction. (See [11,

Sect. 2.3] for some mathematical justification of it.) The definitionof the denotational semantics at the end of Sect. 4 contains several
examples of this phenomenon, for example.
FreshML 2000 [25] enforces that freshly chosen names not be in thesupport of final results at compile time: the type-checker builds up

additional information about a relation of freshness between valueidentifiers and expressions,

x # e, which is a sound decidable ap-proximation to the `not-in-the-support-of' relation

a /2 supp([[e]])in the denotational semantics. (Semantic `not-in-the-support-of'

is undecidable for the usual recursion-theoretic reasons.) This al-lows FreshML 2000 to reject phrases causing observable side ef1 (* remove : <name>(name list ) -> name list *)
2 fun re move(<x >[]) = []
3 | remove (<x >(y ::ys )) =
4 if x # y then y ::(remove (<x >ys ))
5 else remove (<x >ys );
6 (* fv : lam -> name list *)
7 fun fv (Var x ) = [x ]
8 | fv (Lam (<x >t )) = remove (<x >(fv t ))
9 | fv (App (t1,t2 )) = (fv t1 )@(fv t2 );

Figure 6. Free variables of *-terms in FreshML 2000

fects when fresh names are allocated dynamically. For example, xis most definitely not fresh for the expression

Var x (correspond-ing to the fact that
a 2 supp(a) = {a}); and FreshML 2000 willnot admit
genvar declared in (30) as a well-typed expression oftype
lam . In fact FreshML 2000's static freshness inference allowsone to simplify its dynamics by not threading through evaluation a

state containing the names generated so far. Not only does a cor-rectness result like Theorem 5.6 hold for FreshML 2000, but it also
satisfies `no junk' properties; for example, every closed terminatingexpression of type

lam in the fragment of FreshML 2000 withoutreferences and exceptions is of the form

(t)e for some closed *-term
t. As we saw in Sect. 5, FreshML-Lite has some `junk', but atleast it is possible to recognise it dynamically (Remark 5.7).

So static freshness-checking gives a more effect-free functional lan-guage with better programming laws. However our experiences implementing and using freshness inference indicate that the price istoo high, as we shall discuss.

As far as implementation goes, unfortunately the freshness infer-ence algorithm has to proceed not solely on the structure of expressions, but also sometimes on the structure of (inferred) types. Thisis due to the notion of purity--judgements which state that values
of certain types (such as bool, int, or string, for example) cannever contain atoms in their support. We need this to treat many
seemingly innocuous uses of freshened bound names. For exampleto deduce that

fn <x >y => y +1 respects the conditions imposedby freshness checking, we must deduce

x # y +1. To do that weexamine the type of the body of the match, which is

int, and withpurity judgements can observe that a value of type
int cannot evercontain any atoms in its support; so we deduce
x # y +1. Morecomplicated problems of this kind arise in recursive datatype declarations; to deduce which kinds4 of atoms may or may not occurin the support of values of the declared datatypes, it is necessary to
converge on a fixed point as in the procedure for maximising equal-ity in ML [18, Sect. 4.9]. With purity, more programs are typeable,
but type-checking gets harder for the user to understand and predict.
Experience writing syntax-manipulating programs in FreshML2000 was one of the main motivations for developing a simpler

FreshML without freshness inference. We were too frequentlyforced to adopt an obtuse coding style to get programs to pass the
freshness checks. For example, the code in Fig. 5 does not type-check in FreshML 2000, because at line 8 the freshness checking
algorithm cannot deduce that x # (remove x fv t ) holds. Infact when evaluating an application of the

fv function by match-ing against the clause at line 6, the final result does not depend

upon the particular fresh atom associated with the bound name x ,because an atom is not in the support of a list of atoms that has
had that atom removed. This fact has a simple proof by induction

4Both FreshML 2000 and FreshML permit the declaration of different
types of bindable names, whose values range over disjoint copies of \Phi  .

1 (* syntax *)
2 datatype lam =
3 Var of name
4 | Lam of <name> lam
5 | App of lam *lam ;
6 (* semantics *)
7 datatype sem =
8 L of (unit -> sem ) -> sem (* function *)
9 | N of neu (* neutral *)
10 and neu =
11 V of name (* variable *)
12 | A of neu *sem ; (* neutral appn *)
13 (* reification reify : sem -> lam *)
14 fun reify (L f ) =
15 let fresh x :name in
16 Lam (<x >(reify (f (fn () => N (V x ))))) end
17 | reify (N n ) = reifyn n
18 and reifyn (V x ) = Var x
19 | reifyn (A (n,d )) =
20 App (reifyn n, reify d );
21 (* evals :(name*(unit->sem ))list -> lam -> sem *)
22 fun evals [] (Var x ) = N (V x )
23 | evals ((x,v )::env )(Var y ) =
24 if x = y then v ()
25 else evals env (Var y )
26 | evals env (Lam (<x >t )) =
27 L (fn v => evals ((x,v )::env ) t )
28 | evals env (App (t1,t2 )) =
29 (case evals env t1 of
30 L f => f (fn () => evals env t2 )
31 | N n => N (A (n,evals env t2 )));
32 (* evaluation eval : lam -> sem *)
33 fun eval t = evals [] t ;
34 (* normalisation norm : lam -> lam *)
35 fun norm t = reify (eval t )

Figure 7. Normalisation by evaluation in FreshML

on the length of the list, but this is not something our freshness-checking algorithm is able to use at the point it needs to verify the
condition x # (remove x fv t ). For this particular example wecan circumvent the problem by using a

remove function of typeh
namei (name list) ! name list, as in Fig. 6.5 At line 8 of thisfigure the previous problem has gone away because

x is alwaysfresh for an object of the form
<x >e (and also because x is freshfor
remove , since the definition of that function does not dependupon any atom in particular). FreshML 2000 spots this at compiletime and allows this new version of fv as a well-typed expressionof type

lam ! name list.

Figure 7 gives a subtler example of the shortcomings in static fresh-ness inference in FreshML 2000, at the same time showing off how

FreshML can express rather clearly non-trivial syntax-manipulatingalgorithms; in this case an algorithm computing the normal form of
an untyped *-term (if there is one) using normalisation by evalua-tion in a form suggested to us by Thierry Coquand [private communication] and adapted for call-by-value by Olivier Danvy. (See [2,Sect. 3] and the references there for more on normalisation by evaluation in an untyped setting.) In FreshML the function norm hastype

lam ! lam (and does indeed compute normal forms wherethey exist); in FreshML 2000,

norm does not type-check because

5Atom inequality, written x # y , is needed in this declaration of
remove to signal to the freshness-checker that it can use the fact that xis fresh for

y when checking the first branch of the conditional.

datatype 'a am = In of 'a

| Ab of <name>('a am );
(* monad unit *)
fun return x = In x ;
(* monad lifting

op>>= : 'a am * ('a -> 'b am ) -> 'b am *)
infix >>= ;
fun ((In x ) >>= f ) = f x

| ((Ab (<n >y )) >>= f ) = Ab (<n>(y >>= f ));
(* forcing at pure types, e.g... *)
fun force (In (s :string)) = s

| force (Ab (<n >y )) = force y

Figure 8. An abstraction monad

the helper function evals does not. Checking fails at the clausein the definition of

evals at lines 26-27, where the system cannotdeduce that
x # (fn v => evals ((x,v )::env ) t ) holds,under the assumption that

x # evals and x # env hold. Indeedthe proof of the corresponding property of supports in the denotational model, though true, is far from immediate.
Remark 6.1. We can get around these shortcomings of freshnessinference within FreshML 2000 by adopting a monadic programming style that mimics the use of the dynamic allocation monad
T in the denotational semantics of Sect. 4, using an abstractionmonad, such as the one in Fig. 8. Using this monad to wrap return

types in abstractions, freshness inference only needs to use the sim-ple fact

x # <x>e; plus the fact that abstractions can be discardedat pure types, as in the function

force in the figure. The efficiencyof this style is questionable, and the resulting programs somewhat

obfuscated. Nevertheless, it was the realisation that one can adoptthis monadic style in FreshML 2000 that led us to the design of the
simpler FreshML and its denotational semantics; and using nameabstraction to model name generation (such as in Fig. 8) still has its
uses in FreshML: see [12].
We advocate use of FreshML, which does not enforce the Introduc-tion's Thesis (the property of freshly chosen names not being in the

support of final results) at compile-time. However, freshness infer-ence may still be useful for other purposes: it could be used in a
program logic for verifying properties of FreshML programs; andinformation about freshness deduced at compile-time may be useful
for optimising run-time implementation, the issue we turn to next.
7 Implementation
The source code of an experimental implementation of theFreshML language (written in Objective Caml) is available at the

web site http://www.freshml.org/. Our implementation pro-vides the Core of Standard ML [18] together with FreshML's distinctive features for programming with binders. There is an interac-tive interpreter, together with support for processing FreshML code
held in individual source files, but no modules layer. If so desired,FreshML 2000's freshness inference can be switched on by starting
freshml with the command-line argument --pure. The web sitecontains examples of programming with binders in FreshML, including programs calculating the possible labelled transitions froma

ss-calculus [17] process, using various forms of encoding [12];and Barthe's classification algorithm for type-checking injective

Pure Type Systems [4]. We invite readers to try FreshML for them-selves!

We saw in Sect. 3 that the dynamics of FreshML can be imple-mented by translating it into ML augmented with a primitive function swap : unit ref ! unit ref ! ff ! ff for swapping address

Canonical values c ::=atom

aabstraction h

aippair
(p, p)unit
()closure
[P, f(x) = e]constructed
C
C p

Non-canonical values p ::= ss * c
Explicit permutations ss ::=identity

[]composite
(a a0) :: ss

Value environments P ::= [x 7! p, . . .]

(where a, a0 range over \Psi  and x, f over VId)

Figure 9. Values with delayed swapping

names in ML values. It is possible to add this to some existingML implementations using unsafe features.6 Since the representation of values in such systems was not designed with swapping inmind, such simple hacks may not yield very efficient implementations of FreshML; but they do enable us to demonstrate FreshML'snovel features for computing with binders integrated into a complete ML system. Shinwell [28] reports on such an experimentwith Objective Caml and the resulting Fresh O'Caml is available
at http://www.freshml.org/.
To make atom-swapping more efficient, our implementation ofFreshML uses a representation of FreshML values suggested by

Mark Shields [private communication] using delayed swapping. Inthis scheme, shown in Fig. 9, values

p have at each structural level`explicit permutations' of atoms (represented by finite lists of pairs

of atoms, ss, standing for the sequential composition, reading fromleft to right, of the corresponding atom swaps). Evaluation produces values in canonical form, c, where the outermost constructoris manifest; but value environments P need only associate value
identifiers with values that are not necessarily in canonical form.For example, evaluation rule (14) from Fig. 3 becomes

a, P ` e1 + a1, a0 a0, P ` e2 + a2, a00
a00, P ` e3 + c, a000 c0 = cf((a1 a2) :: [] * c)

a, P ` swap e1,e2 in e3 + c0, a000 (31)

where p 7! cf(p) is an auxiliary function converting a non-canonical value to canonical form by pushing the outermost explicit

permutation through one structural level and applying it to any atomit meets. This is relatively inexpensive to implement compared with
traversing the whole parse tree swapping its atoms.
It seems that in practice most swappings arise from deconstructingabstraction values h

aiv. In the delayed swapping implementationscheme, the evaluation rule for this (cf. rule (18) in Fig. 3) becomes

a, P ` e + hai(ss * c), a0 a0 2 \Psi  - a0

p1 = [] * a0 p2 = (a a0) :: ss * c

a, P ` val <x1>x2 = e + {x1 7! p1, x2 7! p2}, a0 [ {a0}(32)

with (a a0) appended to ss. Another optimisation is to try to avoidchoosing a fresh atom

a0 at all. To make this possible, we canconsider `garbage collection' rules that try to reduce the state (set

of atoms) by removing atoms not in the support of the results of

6Thanks to Claudio Russo for showing how to do this in Moscow ML.

evaluation (properties such as Lemma 2.4 have to be modified if wedo this). Then in the above rule it may be the case that

a 2 \Omega  - a0and we can take
a0 = a and replace (a a0) :: ss * c with ss * c.

We have not yet fully exploited such optimisations. In particularthe freshness inference discussed in Sect. 6 could be useful for optimising the dynamics of FreshML. For example, for non-canonicalvalues of pure type, when converting to canonical form we can just
discard the outermost permutation rather than pushing it down intothe value.

8 Related work
Sheard [27, Sect. 13] gives an excellent survey of the problemsfor metaprogramming caused by statically scoped binders in object terms and some of the solutions that have been proposed.FreshML seems unique among metaprogramming languages in providing language-wide support for object-level ff-equivalence whilestill allowing the user to refer to bound entities by name. Miller [16]
proposed incorporating elements of higher order abstract syntax,HOAS [22], into an ML-like programming language,

ML*, withintentional function types
ty => ty'. HOAS also underlies Raf-falli's Bindlib Library for O'Caml.7 FreshML's underlying theory

of binders [13] lifts less to the metalevel: like HOAS it promotesobject-level renaming to the metalevel (via the swapping operation), but unlike HOAS it leaves object-level substitution to be de-fined case-by-case using structural recursion. The advantage is that
FreshML data types are concrete and their denotational semanticsin the universe of FM-sets retain the pleasant recursion/induction
properties of classical first-order algebraic data types: see [13,Sect. 6]. Also, while

ML* and Bindlib give no direct access tobound names and their distinctions (name equality and inequality),

FreshML does. The price paid for this ability is dynamic generationof fresh names. The seemingly small computational effect (which
in fact has rather subtle interactions with higher order functions:see [26]) has a long history in functional programming, from Lisp's
gensym to more recent advocates, such as [21, 7]. However, thecombination with name-swapping and abstraction types hbtyity is
unique to FreshML. Since the original design was published in [25],the use of swapping and freshness to deal with

ff-equivalence andname restriction has been taken up by others, such as in [6]. Indeed,

it was reading this work that inspired us to remove the rather restric-tive freshness checking from FreshML 2000's statics and design the
new version of FreshML presented here. FreshML 2000's approachto names and binding has also inspired work on open code types in
homogeneous metaprogramming languages by Nanevski and Pfen-ning [20].

FreshML's correctness properties established in Sect. 5 are not ob-vious, and we had to work quite hard to establish them. We introduced a new denotational model, FM-cpos, that we think is in-teresting in its own right. Traditional, Scott-Strachey models of
dynamically allocated local names are not sufficiently abstract toestablish these correctness results (roughly speaking, they do not
verify the laws (24) and (25)). Therefore, beginning with Oles,Reynolds and Moggi, various people have developed and applied
`dynamic allocation' monads in categories of functors valued in !-cpos: see [9, 31] for example. The detailed proofs of the results
in Sects 4 and 5 are less complicated than the corresponding onesin the functor category approach--both conceptually (we are just
doing traditional domain theory, but in a slightly different classicalset theory) and practically (constructions on FM-cpos, especially
function spaces, are much easier to describe concretely than are the

7http://www.lama.univ-savoie.fr/
sitelama/Membres/pages web/RAFFALLI/bindlib.html

analogous constructs in functor categories). We believe that FM-cpos should be investigated as an interesting model of restriction
(in the sense of ss-calculus) and spatial locality in general; the workin [5, 11, 12] already takes steps in this direction.

Simplifying FreshML 2000 to produce FreshML as we have de-scribed in this paper opens up many interesting possibilities. For
one thing, it opens the door to full-scale functional language im-plementations incorporating our approach to programming with
binders, as Shinwell's work on Fresh O'Caml [28] shows. It hasalso made it possible to support abstraction types for binding data
consisting of more than a single atom (see Remark 2.2). Freshnessinference is poorly-understood for such types; the main problem is
judging which atoms are in the support of a value as well as whichare not. FreshML neatly removes the need to solve this problem
and allows us to provide this generalised form of abstraction.
The features we have described here for programming with bindersseem really useful. Perhaps the school of pure, lazy functional programming should have them too--there should be a FreshHaskell!Once again, the simple form of FreshML presented here holds out
hope that this might be possible, since it removes the need to geteffective static freshness information, which appears to be much
harder for a non-strict language than for a strict one. Of course ourdesign is impure--some side-effects of generating fresh names are
left exposed in FreshML; in `FreshHaskell' one would presumablyencapsulate them using a monad, mimicking the use of a monad
in the denotational semantics of Sect. 4 (cf. the abstraction monad
'a am in Fig. 8). The design and implementation of `FreshHaskell'remains to be investigated.

9 Acknowledgements
This research was funded by UK EPSRC grant GR/R07615/01 andby a donation from Microsoft's Cambridge Research Laboratory.

We thank Luca Cardelli, Thierry Coquand, Olivier Danvy, SimonPeyton Jones, Claudio Russo, Mark Shields, Keith Wansbrough and
the anonymous referees for helpful comments and feedback on thiswork. Peter White contributed much to the implementation work,
which benefitted enormously from use of the O'Caml compiler ofINRIA's projet Cristal.

10 References

[1] S. Abramsky and A. Jung. Domain theory. In S. Abramsky,D. M. Gabbay, and T. S. E. Maibaum, editors, Handbook of

Logic in Computer Science, Volume 3. Semantic Structures,chapter 1. Oxford University Press, 1994.

[2] M. S. Ager, D. Biernacki, O. Danvy, and J. Midtgaard. Frominterpreter to compiler and virtual machine: A functional

derivation. Technical Report BRICS RS-03-14, BRICS, De-partment of Computer Science, University of Aarhus, March
2003.
[3] H. P. Barendregt. The Lambda Calculus: Its Syntax and Se-mantics. North-Holland, revised edition, 1984.

[4] G. Barthe. Type-checking injective pure type systems. Jour-nal of Functional Programming, 9(6):675-698, 1999.
[5] L. Caires and L. Cardelli. A spatial logic for concurrency(part II). In CONCUR 2002 - Concurrency Theory, 13th International Conference, Brno, Czech Republic, August 20-23,2002. Proceedings, volume 2421 of Lecture Notes in Computer Science, pages 209-225. Springer-Verlag, Berlin, 2002.
[6] L. Cardelli, P. Gardner, and G. Ghelli. Manipulating trees withhidden labels. In Foundations of Software Science and Computation Structures, 6th International Conference, FOSSACS2003, Warsaw, Poland. Proceedings, volume 2620 of Lecture
Notes in Computer Science, pages 216-232. Springer-Verlag,Berlin, 2003.

[7] K. Claessen and D. Sands. Observable sharing for func-tional circuit description. In Advances in Computing Science

ASIAN'99, 5th Asian Computing Science Conference, volume1742 of Lecture Notes in Computer Science, pages 62-73.
Springer-Verlag, 1999.
[8] N. G. de Bruijn. Lambda calculus notation with namelessdummies, a tool for automatic formula manipulation, with

application to the Church-Rosser theorem. Indag. Math.,34:381-392, 1972.

[9] M. P. Fiore, E. Moggi, and D. Sangiorgi. A fully abstractmodel for the

ss-calculus (extended abstract). In Eleventh An-nual Symposium on Logic in Computer Science, pages 43-54.

IEEE Computer Society Press, Washington, 1996.
[10] M. J. Gabbay. A Theory of Inductive Definitions with ff-Equivalence: Semantics, Implementation, Programming Language. PhD thesis, University of Cambridge, 2000.
[11] M. J. Gabbay. The ss-calculus in FM. Submitted, September2002.

[12] M. J. Gabbay. FM for process calculi that generate freshnames. Submitted, June 2003.
[13] M. J. Gabbay and A. M. Pitts. A new approach to abstractsyntax with variable binding. Formal Aspects of Computing,

13:341-363, 2002.
[14] F. Honsell, M. Miculan, and I. Scagnetto. An axiomatic ap-proach to metareasoning on nominal algebras in HOAS. In

28th International Colloquium on Automata, Languages andProgramming, ICALP 2001, Crete, Greece, July 2001. Proceedings, volume 2076 of Lecture Notes in Computer Science,pages 963-978. Springer-Verlag, Heidelberg, 2001.

[15] R. Laemmel and S. L. Peyton Jones. Scrap your boilerplate:A practical approach to generic programming. In ACM SIGPLAN Workshop on Types in Language Design and Implemen-tation (TLDI 2003), New Orleans, pages 26-37. ACM Press,
2003.
[16] D. A. Miller. An extension to ML to handle bound variablesin data structures: Preliminary report. In Proceedings of the

Logical Frameworks BRA Workshop, 1990.
[17] R. Milner, J. Parrow, and D. Walker. A calculus of mobile pro-cesses (parts I and II). Information and Computation, 100:1-

77, 1992.
[18] R. Milner, M. Tofte, R. Harper, and D. MacQueen. The Defi-nition of Standard ML (Revised). MIT Press, 1997.

[19] E. Moggi. Notions of computation and monads. Informationand Computation, 93(1):55-92, 1991.
[20] A. Nanevski. Meta-programming with names and necessity.In Proceedings of the Seventh ACM SIGPLAN International

Conference on Functional Programming, ICFP 2002, Pittsburgh, Pennsylvania, pages 206-217. ACM Press, New York,2002.
[21] M. Odersky. A functional theory of local names. In Confer-ence Record of the 21st Annual ACM Symposium on Principles of Programming Languages, pages 48-59. ACM Press,1994.

[22] F. Pfenning and C. Elliott. Higher-order abstract syntax.In Proc. ACM-SIGPLAN Conference on Programming Language Design and Implementation, pages 199-208. ACMPress, 1988.

[23] A. M. Pitts. Relational properties of domains. Informationand Computation, 127:66-90, 1996.
[24] A. M. Pitts. Nominal logic, a first order theory of names andbinding. Information and Computation, to appear. (A preliminary version appeared in the Proceedings of the 4th In-ternational Symposium on Theoretical Aspects of Computer
Software (TACS 2001), LNCS 2215, Springer-Verlag, 2001,pp 219-242.).

[25] A. M. Pitts and M. J. Gabbay. A metalanguage for program-ming with bound names modulo renaming. In Mathematics of Program Construction. 5th International Conference,MPC2000, Ponte de Lima, Portugal, July 2000. Proceedings,
volume 1837 of Lecture Notes in Computer Science, pages230-255. Springer-Verlag, Heidelberg, 2000.

[26] A. M. Pitts and I. D. B. Stark. Observable properties ofhigher order functions that dynamically create local names,

or: What's new? In Mathematical Foundations of ComputerScience, Proc. 18th Int. Symp., Gda'nsk, 1993, volume 711 of
Lecture Notes in Computer Science, pages 122-141. Springer-Verlag, Berlin, 1993.

[27] T. Sheard. Accomplishments and research challenges in meta-programming. In Semantics, Applications, and Implementation of Program Generation, Second International Workshop,SAIG 2001, Florence, Italy, September 6, 2001, Proceedings.,
volume 2196 of Lecture Notes in Computer Science, pages2-44. Springer, 2001.

[28] M. R. Shinwell. Swapping the atom: Programming withbinders in Fresh O'Caml. Submitted, June 2003.
[29] M. R. Shinwell and A. M. Pitts. FreshML User Manual. Cam-bridge University Computer Laboratory, November 2002.

Available at hhttp://www.freshml.org/docs/i.
[30] I. D. B. Stark. Categorical models for local names. Lisp andSymbolic Computation, 9(1):77-107, 1996.

[31] I. D. B. Stark. A fully abstract domain model for the ss-calculus. In 11th Annual Symposium on Logic in Computer

Science, pages 36-42. IEEE Computer Society Press, Wash-ington, 1996.

[32] C. Urban, A. M. Pitts, and M. J. Gabbay. Nominal uni-fication. In Computer Science Logic and 8th Kurt G"odel

Colloquium (CSL'03 & KGC), Vienna, Austria. Proccedings,Lecture Notes in Computer Science. Springer-Verlag, Berlin,
2003.