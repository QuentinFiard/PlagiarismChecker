

Notions of computation and monads

Eugenio Moggi*

Abstract
The *-calculus is considered an useful mathematical tool in the study of programming
languages, since programs can be identified with *-terms. However, if one goes further and
uses fij-conversion to prove equivalence of programs, then a gross simplification is introduced
(programs are identified with total functions from values to values), that may jeopardise the
applicability of theoretical results. In this paper we introduce calculi based on a categorical
semantics for computations, that provide a correct basis for proving equivalence of programs,
for a wide range of notions of computation.

Introduction
This paper is about logics for reasoning about programs, in particular for proving equivalence ofprograms. Following a consolidated tradition in theoretical computer science we identify programs
with the closed *-terms, possibly containing extra constants, corresponding to some features ofthe programming language under consideration. There are three semantic-based approaches to
proving equivalence of programs:

* The operational approach starts from an operational semantics, e.g. a partial functionmapping every program (i.e. closed term) to its resulting value (if any), which induces a

congruence relation on open terms called operational equivalence (see e.g. [Plo75]). Thenthe problem is to prove that two terms are operationally equivalent.

* The denotational approach gives an interpretation of the (programming) language in amathematical structure, the intended model. Then the problem is to prove that two terms

denote the same object in the intended model.

* The logical approach gives a class of possible models for the (programming) language.Then the problem is to prove that two terms denotes the same object in all possible models.

The operational and denotational approaches give only a theory: the operational equivalence ssor the set

T h of formulas valid in the intended model respectively. On the other hand, the logicalapproach gives a consequence relation `, namely

Ax ` A iff the formula A is true in all modelsof the set of formulas
Ax, which can deal with different programming languages (e.g. functional,imperative, non-deterministic) in a rather uniform way, by simply changing the set of axioms

Ax, and possibly extending the language with new constants. Moreover, the relation ` is oftensemidecidable, so it is possible to give a sound and complete formal system for it, while

T h and ssare semidecidable only in oversimplified cases.

We do not take as a starting point for proving equivalence of programs the theory of fij-conversion, which identifies the denotation of a program (procedure) of type

A ! B with atotal function from
A to B, since this identification wipes out completely behaviours like non-termination, non-determinism or side-effects, that can be exhibited by real programs. Instead, we

proceed as follows:

1. We take category theory as a general theory of functions and develop on top a categoricalsemantics of computations based on monads.

*Research partially supported by EEC Joint Collaboration Contract # ST2J-0374-C(EDB).

1

2. We consider simple formal systems matching the categorical semantics of computation.
3. We extend stepwise categorical semantics and formal system in order to interpret richerlanguages, in particular the

*-calculus.

4. We show that w.l.o.g. one may consider only (monads over) toposes, and we exploit this factto establish conservative extension results.

The methodology outlined above is inspired by [Sco80]1, and it is followed in [Ros86, Mog86] toobtain the

*p-calculus. The view that "category theory comes, logically, before the *-calculus"ledus to consider a categorical semantics of computations first, rather than to modify directly the

rules of fij-conversion to get a correct calculus.

Related work
The operational approach to find correct *-calculi w.r.t. an operational equivalence, was firstconsidered in [Plo75] for call-by-value and call-by-name operational equivalence. This approach

was later extended, following a similar methodology, to consider other features of computations likenondeterminism (see [Sha84]), side-effects and continuations (see [FFKD86, FF89]). The calculi
based only on operational considerations, like the *v-calculus, are sound and complete w.r.t. theoperational semantics, i.e. a program

M has a value according to the operational semantics iff itis provably equivalent to a value (not necessarily the same) in the calculus, but they are too weak

for proving equivalences of programs.Previous work on axiom systems for proving equivalence of programs with side effects has
shown the importance of the let-constructor (see [Mas88, MT89a, MT89b]). In the framework ofthe computational lambda-calculus the importance of let becomes even more apparent.

The denotational approach may suggest important principles, e.g. fix-point induction (see[Sco69, GMW79]), that can be found only after developing a semantics based on mathematical
structures rather than term models, but it does not give clear criteria to single out the generalprinciples among the properties satisfied by the model. Moreover, the theory at the heart of Denotational Semantics, i.e. Domain Theory (see [GS89, Mos89]), has focused on the mathematicalstructures for giving semantics to recursive definitions of types and functions (see [SP82]), while
other structures, that might be relevant to a better understanding of programming languages, havebeen overlooked. This paper identify one of such structures, i.e. monads, but probably there are
others just waiting to be discovered.The categorical semantic of computations presented in this paper has been strongly influenced
by the reformulation of Denotational Semantics based on the category of cpos, possibly withoutbottom, and partial continuous functions (see [Plo85]) and the work on categories of partial morphisms in [Ros86, Mog86]. Our work generalises the categorical account of partiality to othernotions of computations, indeed partial cartesian closed categories turn out to be a special case of
*c-models (see Definition 3.9).A type theoretic approach to partial functions and computations is proposed in [CS87, CS88]
by introducing a type-constructor _A, whose intuitive meaning is the set of computations of type
A. Our categorical semantics is based on a similar idea. Constable and Smith, however, do notadequately capture the general axioms for computations (as we do), since their notion of model,

based on an untyped partial applicative structure, accounts only for partial computations.

1 A categorical semantics of computations
The basic idea behind the categorical semantics below is that, in order to interpret a programminglanguage in a category C, we distinguish the object

A of values (of type A) from the object T A of

1"I am trying to find out where *-calculus should come from, and the fact that the notion of a cartesian closed
category is a late developing one (Eilenberg & Kelly (1966)), is not relevant to the argument: I shall try to explain
in my own words in the next section why we should look to it first".

2

computations (of type A), and take as denotations of programs (of type A) the elements of T A.In particular, we identify the type

A with the object of values (of type A) and obtain the objectof computations (of type
A) by applying an unary type-constructor T to A. We call T a notionof computation, since it abstracts away from the type of values computations may produce. There

are many choices for T A corresponding to different notions of computations.
Example 1.1 We give few notions of computation in the category of sets.

* partiality T A = A? (i.e. A + {?}), where ? is the diverging computation

* nondeterminism T A = Pfin(A)

* side-effects T A = (A * S)S, where S is a set of states, e.g. a set U L of stores or a set ofinput/output sequences

U *

* exceptions T A = (A + E), where E is the set of exceptions

* continuations T A = R(R

A), where R is the set of results

* interactive input T A = (ufl.A + flU ), where U is the set of characters.More explicitly

T A is the set of U -branching trees with finite branches and A-labelled leaves

* interactive output T A = (ufl.A + (U * fl)).More explicitly

T A is (isomorphic to) U * * A.

Further examples (in a category of cpos) could be given based on the denotational semantics forvarious programming languages (see [Sch86, GS89, Mos89]).

Rather than focusing on a specific T , we want to find the general properties common to all notionsof computation, therefore we impose as only requirement that programs should form a category.
The aim of this section is to convince the reader, with a sequence of informal argumentations, thatsuch a requirement amounts to say that

T is part of a Kleisli triple (T, j, *) and that the categoryof programs is the Kleisli category for such a triple.

Definition 1.2 ([Man76]) A Kleisli triple over a category C is a triple (T, j, *), where T : Obj(C) !Obj(C),

jA: A ! T A for A 2 Obj(C), f *: T A ! T B for f: A ! T B and the following equationshold:

* j*A = idT A

* jA; f * = f for f : A ! T B

* f *; g* = (f ; g*)* for f : A ! T B and g: B ! T C.
A Kleisli triple satisfies the mono requirement provided jA is mono for A 2 C.
Intuitively jA is the inclusion of values into computations (in several cases jA is indeed a mono) and
f * is the extension of a function f from values to computations to a function from computationsto computations, which first evaluates a computation and then applies

f to the resulting value. Insummary

a: A j

A7-! [a]: T A

a: A f7-! f (a): T B
c: T A f

*7-! (let x(c in f (x)): T B

In order to justify the axioms for a Kleisli triple we have first to introduce a category CT whosemorphisms correspond to programs. We proceed by analogy with the categorical semantics for
terms, where types are interpreted by objects and terms of type B with a parameter (free variable)of type

A are interpreted by morphisms from A to B. Since the denotation of programs of type Bare supposed to be elements of

T B, programs of type B with a parameter of type A ought to be

3

interpreted by morphisms with codomain T B, but for their domain there are two alternatives, either
A or T A, depending on whether parameters of type A are identified with values or computationsof type

A. We choose the first alternative, because it entails the second. Indeed computationsof type
A are the same as values of type T A. So we take CT (A, B) to be C(A, T B). It remainsto define composition and identities in C

T (and show that they satisfy the unit and associativityaxioms for categories).

Definition 1.3 Given a Kleisli triple (T, j, *) over C, the Kleisli category CT is defined asfollows:

* the objects of CT are those of C

* the set CT (A, B) of morphisms from A to B in CT is C(A, T B)

* the identity on A in CT is jA: A ! T A

* f 2 CT (A, B) followed by g 2 CT (B, C) in CT is f ; g*: A ! T C.
It is natural to take jA as the identity on A in the category CT , since it maps a parameter x to [x],i.e. to

x viewed as a computation. Similarly composition in CT has a simple explanation in termsof the intuitive meaning of

f *, in fact

x: A f7-! f (x): T B y: B g7-! g(y): T C

x: A f;g

*7-! (let y(f (x) in g(y)): T C

i.e. f followed by g in CT with parameter x is the program which first evaluates the program
f (x) and then feed the resulting value as parameter to g. At this point we can give also a simplejustification for the three axioms of Kleisli triples, namely they are equivalent to the unit and

associativity axioms for CT :

* f ; j*B = f for f : A ! T B

* jA; f * = f for f : A ! T B

* (f ; g*); h* = f ; (g; h*)* for f : A ! T B, g: B ! T C and h: C ! T D.

Example 1.4 We go through the notions of computation given in Example 1.1 and show that theyare indeed part of suitable Kleisli triples.

* partiality T A = A?(= A + {?})

jA is the inclusion of A into A?if

f : A ! T B, then f *(?) = ? and f *(a) = f (a) (when a 2 A)

* nondeterminism T A = Pfin(A)

jA is the singleton map a 7! {a}if

f : A ! T B and c 2 T A, then f *(c) = [x2cf (x)

* side-effects T A = (A * S)S

jA is the map a 7! (*s: S.ha, si)if

f : A ! T B and c 2 T A, then f *(c) = *s: S.(let ha, s0i = c(s) in f (a)(s0))

* exceptions T A = (A + E)

jA is the injection map a 7! inl(a)if

f : A ! T B, then f *(inr(e)) = e (when e 2 E) and f *(inl(a)) = f (a) (when a 2 A)

* continuations T A = R(R

A)

jA is the map a 7! (*k: RA.k(a))if

f : A ! T B and c 2 T A, then f *(c) = (*k: RB.c(*a: A.f(a)(k)))

4

* interactive input T A = (ufl.A + flU )

jA maps a to the tree consisting only of one leaf labelled with aif

f : A ! T B and c 2 T A, then f *(c) is the tree obtained by replacing leaves of c labelledby

a with the tree f(a)

* interactive output T A = (ufl.A + (U * fl))

jA is the map a 7! hffl, aiif

f : A ! T B, then f *(hs, ai) = hs * s0, bi, where f (a) = hs0, bi and s * s0 is the concatenationof

s followed by s0.

Kleisli triples are just an alternative description for monads. Although the formers are easyto justify from a computational perspective, the latters are more widely used in the literature on
Category Theory and have the advantage of being defined only in terms of funtors and naturaltransformations, which make them more suitable for abstract manipulation.

Definition 1.5 ([Mac71]) A monad over a category C is a triple (T, j, u), where T : C ! C isa functor,

j: IdC .! T and u: T 2 .! T are natural transformations and the following diagramscommute:

T 3A u

T A > T 2A T A jTA > T 2A <T jA T A

T uA.

.

uA

@@

@ idT A@

@@R .

uA

\Psi \Gamma \Gamma 

\Gamma  idT A\Gamma 

\Gamma \Gamma 

T 2A u

A > T A T A

Proposition 1.6 ([Man76]) There is a one-one correspondence between Kleisli triples and mon-ads.

Proof Given a Kleisli triple (T, j, *), the corresponding monad is (T, j, u), where T is the extensionof the function

T to an endofunctor by taking T (f ) = (f ; jB)* for f : A ! B and uA = id*T A.Conversely, given a monad (

T, j, u), the corresponding Kleisli triple is (T, j, *), where T is therestriction of the functor
T to objects and f * = (T f ); uB for f : A ! T B.

Remark 1.7 In general the categorical semantics of partial maps, based on a category C equippedwith a dominion M (see [Ros86]), cannot be reformulated in terms of a Kleisli triple over C

satisfying some additional properties, unless C has lifting, i.e. the inclusion functor from C into thecategory of partial maps P(C

, M) has a right adjoint ? characterised by the natural isomorphism

C(A, B?) *,= P(C, M)(A, B)
This mismatch disappears when considering partial cartesian closed categories.

2 Simple languages for monads
In this section we consider two formal systems motivated by different objectives: reasoning aboutprogramming languages and reasoning about programs in a fixed programming language. When
reasoning about programming languages one has different monads (for simplicity we assume thatthey are over the same category), one for each programming language, and the main aim is to
study how they relate to each other. So it is natural to base a formal system on a metalanguagefor a category and treat monads as unary type-constructors. When reasoning about programs one
has only one monad, because the programming language is fixed, and the main aim is to proveproperties of programs. In this case the obvious choice for the term language is the programming
language itself, which is more naturally interpreted in the Kleisli category.

5

Remark 2.1 We regard the metalanguage as more fundamental. In fact, its models are moregeneral, as they don't have to satisfy the mono requirement, and the interpretation of programs (of

some given programming language) can be defined simply by translation into (a suitable extensionof) the metalanguage. It should be pointed out that the mono requirement cannot be axiomatised
in the metalanguage, as we would need conditional equations [x]T = [y]T ! x = y, and thatexistence assertions cannot be translated into formulas of the metalanguage, as we would need
existentially quantified formulas (e #oe)ffi j (9!x: oe.effi = [x]T )2.In Section 2.3 we will explain once for all the correspondence between theories of a simple
programming language and categories with a monad satisfying the mono requirement. For otherprogramming languages we will give only their translation in a suitable extension of the metalanguage. In this way, issues like call-by-value versus call-by-name affect the translation, but not themetalanguage.

In Categorical Logic it is common practice to identify a theory T with a category F(T ) withadditional structure such that there is a one-one correspondence between models of T in a category
C with additional structure and structure preserving functors from F(T ) to C (see [KR77])3. Thisidentification was originally proposed by Lawvere, who also showed that algebraic theories can be
viewed as categories with finite products.In Section 2.2 we give a class of theories that can be viewed as categories with a monad, so that
any category with a monad is, up to equivalence (of categories with a monad), one of such theories.Such a reformulation in terms of theories is more suitable for formal manipulation and more
appealing to those unfamiliar with Category Theory. However, there are other advantages in havingan alternative presentation of monads. For instance, natural extensions of the syntax may suggest
extensions of the categorical structure that may not be immediate to motivate and justify otherwise(we will exploit this in Section 3). In Section 2.3 we take a programming language perspective
and establish a correspondence between theories (with equivalence and existence assertions) for asimple programming language and categories with a monad satisfying the mono requirement, i.e.
jA mono for every A.As starting point we take many sorted monadic equational logic, because it is more primitive
than many sorted equational logic, indeed monadic theories are equivalent to categories withoutany additional structure.

2.1 Many sorted monadic equational logic
The language and formal system of many sorted monadic equational logic are parametric in asignature, i.e. a set of base types A and unary function symbols f: A

1 ! A2. The language is madeof types ` A type, terms
x: A1 ` e: A2 and equations x: A1 ` e1 =A2 e2 defined by the followingformation rules:

A ` A type A base type
var ` A typex: A ` x: A

f x: A ` e1: A1x: A ` f(e

1): A2 f: A1 ! A2

eq x: A1 ` e1: A2 x: A1 ` e2: A2x: A

1 ` e1 =A2 e2

2The uniqueness of x s.t. effi = [x]T follows from the mono requirement.
3In [LS86] a stronger relation is sought between theories and categories with additional structure, namely an
equivalence between the category of theories and translations and the category of small categories with additional
structure and structure preserving functors. In the case of typed *-calculus, for instance, such an equivalence
between *-theories and cartesian closed categories requires a modification in the definition of *-theory, which allows
not only equations between *-terms but also equations between type expressions.

6

RULE SYNTAX SEMANTICS

A ` A type = [[A]]

var ` A type =

c
x: A ` x: A = idc

f: A1 ! A2

x: A ` e1: A1 = g
x: A ` f(e1): A2 = g; [[f]]

eq

x: A1 ` e1: A2 = g1
x: A1 ` e2: A2 = g2
x: A1 ` e1 =A2 e2 () g1 = g2

Table 1: Interpretation of Many Sorted Monadic Equational Language
Remark 2.2 Terms of (many sorted) monadic equational logic have exactly one free variable (theone declared in the context) which occurs exactly once, and equations are between terms with the

same free variable.
An interpretation [[ ]] of the language in a category C is parametric in an interpretation of thesymbols in the signature and is defined by induction on the derivation of well-formedness for

(types,) terms and equations (see Table 1) according to the following general pattern:

* the interpretation [[A]] of a base type A is an object of C

* the interpretation [[f]] of an unary function f: A1 ! A2 is a morphism from [[A1]] to [[A2]] inC; similarly for the interpretation of a term

x: A1 ` e: A2

* the interpretation of an assertion x: A ` OE (in this case just an equation) is either true orfalse.

Remark 2.3 The interpretation of equations is standard. However, if one want to consider morecomplex assertions, e.g. formulas of first order logic, then they should be interpreted by subobjects;

in particular equality = : A should be interpreted by the diagonal \Delta [[A]].
The formal consequence relation on the set of equations is generated by the inference rules forequivalences ((refl), (simm) and (trans)), congruence and substitutivity (see Table 2). This formal

consequence relation is sound and complete w.r.t. interpretation of the language in categories, i.e.an equation is formally derivable from a set of equational axioms if and only if all the interpretations
satisfying the axioms satisfy the equation. Soundness follows from the admissibility of the inferencerules in any interpretation, while completeness follows from the fact that any theory T (i.e. a set
of equations closed w.r.t. the inference rules) is the set of equations satisfied by the canonicalinterpretation in the category F(T ), i.e. T viewed as a category.

Definition 2.4 Given a monadic equational theory T , the category F(T ) is defined as follows:

* objects are (base) types A,

* morphisms from A1 to A2 are equivalence classes [x: A1 ` e: A2]T of terms w.r.t. the equiv-alence relation induced by the theory T , i.e.

(x: A1 ` e1: A2) j (x: A1 ` e2: A2) () (x: A1 ` e1 =A2 e2) 2 T

7

refl x: A ` e: A1x: A ` e =

A1 e

symm x: A ` e1 =A1 e2x: A ` e

2 =A1 e1

trans x: A ` e1 =A1 e2 x: A ` e2 =A1 e3x: A ` e

2 =A1 e3

congr x: A ` e1 =A1 e2x: A ` f(e

1) =A2 f(e2) f: A1 ! A2

subst x: A ` e: A1 x: A1 ` OEx: A ` [e/x]OE

Table 2: Inference Rules of Many Sorted Monadic Equational Logic

* composition is substitution, i.e.

[x: A1 ` e1: A2]T ; [x: A2 ` e2: A3]T = [x: A1 ` [e1/x]e2: A3]T

* identity over A is [x: A ` x: A]T .
There is also a correspondence in the opposite direction, namely every category C (with additionalstructure) can be viewed as a theory T

C (i.e. the theory of C over the language for C), so that C andF(TC) are equivalent as categories (with additional structure). Actually, in the case of monadic

equational theories and categories, C and F(TC) are isomorphic.In the sequel we consider other equational theories. They can be viewed as categories in the
same way described above for monadic theories; moreover, these categories are equipped withadditional structure, depending on the specific nature of the theories under consideration.

2.2 The Simple metalanguage
We extend many sorted monadic equational logic to match categories equipped with a monad (orequivalently a Kleisli triple). Although we consider only one monad, it is conceptually straightforward to have several monads at once.The first step is to extend the language. This could be done in several ways without affecting
the correspondence between theories and monads, we choose a presentation inspired by Kleislitriples, more specifically we introduce an unary type-constructor

T and the two term-constructors,[ ] and let, used informally in Section 1. The definition of signature is slightly modified, since the

domain and codomain of an unary function symbol f: o/1 ! o/2 can be any type, not just base types(the fact is that in many sorted monadic logic the only types are base types). An interpretation
[[ ]] of the language in a category C with a Kleisli triple (T, j, *) is parametric in an interpretationof the symbols in the signature and is defined by induction on the derivation of well-formedness
for types, terms and equations (see Table 3). Finally we add to many sorted monadic equationallogic appropriate inference rules capturing axiomatically the properties of the new type- and termconstructors after interpretation (see Table 4).
Proposition 2.5 Every theory T of the simple metalanguage, viewed as a category F(T ), isequipped with a Kleisli triple (

T, j, *):

* T (o/ ) = T o/ ,

* jo/ = [x: o/ `ml [x]T : T o/ ]T ,

* ([x: o/1 `ml e: T o/2]T )* = [x0: T o/1 `ml (letT x(x0 in e): T o/2]T .

8

RULE SYNTAX SEMANTICS

A `

ml A type = [[A]]

T `

ml o/ type = c`
ml T o/ type = T c

var `

ml o/ type = c
x: o/ `ml x: o/ = idc

f: o/1 ! o/2

x: o/ `ml e1: o/1 = g
x: o/ `ml f(e1): o/2 = g; [[f]]

[ ]T

x: o/ `ml e: o/ 0 = g
x: o/ `ml [e]T : T o/ 0 = g; j[[o/0]]

let

x: o/ `ml e1: T o/1 = g1
x1: o/1 `ml e2: T o/2 = g2
x: o/ `ml (letT x1(e1 in e2): T o/2 = g1; g*2

eq

x: o/1 `ml e1: o/2 = g1
x: o/1 `ml e2: o/2 = g2
x: o/1 `ml e1 =o/2 e2 () g1 = g2

Table 3: Interpretation of the Simple Metalanguage

[ ]., x: o/ `ml e1 =o/1 e2x: o/ `

ml [e1]T =T o/1 [e2]T

let., x: o/ `ml e1 =To/1 e2 x0: o/1 `ml e01 =T o/2 e02x: o/ `

ml (letT x0(e1 in e01) =T o/2 (letT x0(e2 in e02)

ass x: o/ `ml e1: T o/1 x1: o/1 `ml e2: T o/2 x2: o/2 `ml e3: T o/3x: o/ `

ml (letT x2((letT x1(e1 in e2) in e3) =T o/3 (letT x1(e1 in (letT x2(e2 in e3))

T.fi x: o/ `ml e1: o/1 x1: o/1 `ml e2: T o/2x: o/ `

ml (letT x1([e1]T in e2) =T o/2 [e1/x1]e2

T.j x: o/ `ml e1: T o/1x: o/ `

ml (letT x1(e1 in [x1]T ) =To/1 e1

Table 4: Inference Rules of the Simple Metalanguage

9

Proof We have to show that the three axioms for Kleisli triples are valid. The validity of eachaxiom amounts to the derivability of an equation. For instance,

j*o/ = idT o/ is valid provided
x0: T o/ `ml (letT x(x0 in [x]T ) =T o/ x0 is derivable, indeed it follows from (T.j). The reader cancheck that the equations corresponding to the axioms

jo/ ; f * = f and f *; g* = (f ; g*)* follow from(
T.fi) and (ass) respectively.

2.3 A Simple Programming Language
In this section we take a programming language perspective by introducing a simple programminglanguage, whose terms are interpreted by morphisms of the Kleisli category for a monad. Unlike

the metalanguage of Section 2.2, the programming language does not allow to consider more thanone monad at once.

The interpretation in the Kleisli category can also be given indirectly via a translation in thesimple metalanguage of Section 2.2 mapping programs of type

o/ into terms of type T o/ . If we try toestablish a correspondence between equational theories of the simple programming language and

categories with one monad (as done for the metalanguage), then we run into problems, since thereis no way (in general) to recover C from C

T . What we do instead is to establish a correspondencebetween theories with equivalence and existence assertions and categories with one monad satisfying

the mono requirement, i.e. jA is mono for every object A (note that jT A is always a mono, because
jTA; uA = idT A). The intended extension of the existence predicate on computations of type A isthe set of computations of the form [

v] for some value v of type A, so it is natural to require jA tobe mono and interpret the existence predicate as the subobject corresponding to

jA.The simple programming language is parametric in a signature, i.e. a set of base types and

unary command symbols. To stress that the interpretation is in CT rather than C, we use unarycommand symbols p:

o/1 * o/2 (instead of unary function symbols f: o/1 ! o/2), we call x: o/1 `pl e: o/2a program (instead of a term) and write j

o/ (instead of =T o/ ) as equality of computationsof type
o/ . Given a category C with a Kleisli triple (T, j, *) satisfying the mono requirement, aninterpretation [[ ]] of the programming language is parametric in an interpretation of the symbols

in the signature and is defined by induction on the derivation of well-formedness for types, termsand equations (see Table 5) following the same pattern given for many sorted monadic equational
logic, but with C replaced by CT , namely:

* the interpretation [[o/ ]] of a (base) type o/ is an object of CT , or equivalently an object of C

* the interpretation [[p]] of an unary command p: o/1 * o/2 is a morphism from [[o/1]] to [[o/2]] inC

T , or equivalently a morphism from [[o/1]] to T [[o/2]] in C; similarly for the interpretation of aprogram

x: o/1 `pl e: o/2

* the interpretation of an equivalence or existence assertion is a truth value.

Remark 2.6 The let-constructor play a fundamental role: operationally it corresponds to sequen-tial evaluation of programs and categorically it corresponds to composition in the Kleisli category

CT (while substitution corresponds to composition in C). In the *v-calculus (let x(e in e0) is treatedas syntactic sugar for (

*x.e0)e. We think that this is not the right way to proceed, because it ex-plains the let-constructor (i.e. sequential evaluation of programs) in terms of constructors available

only in functional languages. On the other hand, (let x(e in e0) cannot be treated as syntacticsugar for [

e/x]e0 (involving only the more primitive substitution) without collapsing computationsto values.

The existence predicate e # is inspired by the logic of partial terms/elements (see [Fou77, Sco79,Mog88]); however, there are important differences, e.g.

strict x: o/ `pl p(e) #o/2x: o/ `

pl e #o/1 p: o/1 * o/2

is admissible for partial computations, but not in general. For certain notions of computation theremay be other predicates on computations worth considering, or the existence predicate itself may

have a more specialised meaning, for instance:

10

RULE SYNTAX SEMANTICS

A `

pl A type = [[A]]

T `

pl o/ type = c`
pl T o/ type = T c

var `

pl o/ type = c
x: o/ `pl x: o/ = jc

p: o/1 * o/2

x: o/ `pl e1: o/1 = g
x: o/ `pl p(e1): o/2 = g; [[p]]*

[ ]

x: o/ `pl e: o/ 0 = g
x: o/ `pl [e]: T o/ 0 = g; jT[[o/0]]

u

x: o/ `pl e: T o/ 0 = g
x: o/ `pl u(e): o/ 0 = g; u[[o/0]]

let

x: o/ `pl e1: o/1 = g1
x1: o/1 `pl e2: o/2 = g2
x: o/ `pl (let x1(e1 in e2): o/2 = g1; g2*

eq

x: o/1 `pl e1: o/2 = g1
x: o/1 `pl e2: o/2 = g2
x: o/1 `pl e1 jo/2 e2 () g1 = g2

ex

x: o/1 `pl e: o/2 = g
x: o/1 `pl e #o/2 () 9!h: [[o/1]] ! [[o/2]] s.t. g = h; j[[o/2]]

Table 5: Interpretation of the Simple Programming Language

11

refl x: o/ `pl e: o/1x: o/ `

pl e jo/1 e

symm x: o/ `pl e1 jo/1 e2x: o/ `

pl e2 jo/1 e1

trans x: o/ `pl e1 jo/1 e2 x: o/ `pl e2 jo/1 e3x: o/ `

pl e2 jo/1 e3

congr x: o/ `pl e1 jo/1 e2x: o/ `

pl p(e1) jo/2 p(e2) p: o/1 * o/2

E.x `pl o/ typex: o/ `

pl x #o/

E.congr x: o/ `pl e1 jo/1 e2 x: o/ `pl e1 #o/1x: o/ `

pl e2 #o/1

subst x: o/ `pl e #o/1 x: o/1 `pl OEx: o/ `

pl [e/x]OE

Table 6: General Inference Rules

* a partial computation exists iff it terminates;

* a non-deterministic computation exists iff it gives exactly one result;

* a computation with side-effects exists iff it does not change the store.

Programs can be translated into terms of the metalanguage via a translation ffi s.t. for every well-formed program

x: o/1 `pl e: o/2 the term x: o/1 `ml effi: T o/2 is well-formed and [[x: o/1 `pl e: o/2]] =[[
x: o/1 `ml effi: T o/2]] (the proof of these properties is left to the reader).

Definition 2.7 Given a signature \Sigma  for the programming language, let \Sigma ffi be the signature for themetalanguage with the same base types and a function p:

o/1 ! T o/2 for each command p: o/1 * o/2in \Sigma . The translation ffi from programs over \Sigma  to terms over \Sigma ffi is defined by induction on raw

programs:

* xffi \Delta j [x]T

* (let x1(e1 in e2)ffi \Delta j (letT x1(e1ffi in e2ffi)

* p(e1)ffi \Delta j (letT x(e1ffi in p(x))

* [e]ffi \Delta j [effi]T

* u(e)ffi \Delta j (letT x(effi in x)
The inference rules for deriving equivalence and existence assertions of the simple programminglanguage can be partitioned as follows:

* general rules (see Table 6) for terms denoting computations, but with variables ranging overvalues; these rules replace those of Table 2 for many sorted monadic equational logic

* rules capturing the properties of type- and term-constructors (see Table 7) after interpretationof the programming language; these rules replace the additional rules for the metalanguage

given in Table 4.

12

[ ]., x: o/ `pl e1 jo/1 e2x: o/ `

pl [e1] jTo/1 [e2]

E.[ ] x: o/ `pl e1: o/1x: o/ `

pl [e1] #T o/1

u., x: o/ `pl e1 jTo/1 e2x: o/ `

pl u(e1) jo/1 u(e2)

u.fi x: o/ `pl e1: o/1x: o/ ` u([e

1]) jo/1 e1

u.j x: o/ `pl e1 #To/1x: o/ ` [u(e

1)] jTo/1 e1

let., x: o/ `pl e1 jo/1 e2 x0: o/1 `pl e01 jo/2 e02x: o/ `

pl (let x0(e1 in e01) jo/2 (let x0(e2 in e02)

unit x: o/ `pl e1: o/1x: o/ `

pl (let x1(e1 in x1) jo/1 e1

ass x: o/ `pl e1: o/1 x1: o/1 `pl e2: o/2 x2: o/2 `pl e3: o/3x: o/ `

pl (let x2((let x1(e1 in e2) in e3) jo/3 (let x1(e1 in (let x2(e2 in e3))

let.fi x: o/ `pl e1 #o/1 x1: o/1 `pl e2: o/2x: o/ `

pl (let x1(e1 in e2) jo/2 [e1/x1]e2

let.p x: o/ `pl e1: o/1x: o/ `

pl p(e1) jo/1 (let x1(e1 in p(x1)) p: o/1 * o/2

Table 7: Inference Rules of the Simple Programming Language

13

Soundness and completeness of the formal consequence relation w.r.t. interpretation of thesimple programming language in categories with a monad satisfying the mono requirement is
established in the usual way (see Section 2.1). The only step which differs is how to view a theoryT of the simple programming language (i.e. a set of equivalence and existence assertions closed
w.r.t. the inference rules) as a category F(T ) with the required structure.
Definition 2.8 Given a theory T of the simple programming language, the category F(T ) is de-fined as follows:

* objects are types o/ ,

* morphisms from o/1 to o/2 are equivalence classes [x: o/1 `pl e: o/2]T of existing programs x: o/1 `pl

e #o/22 T w.r.t. the equivalence relation induced by the theory T , i.e.

(x: o/1 `pl e1: o/2) j (x: o/1 `pl e2: o/2) () (x: o/1 `pl e1 jo/2 e2) 2 T

* composition is substitution, i.e.

[x: o/1 `pl e1: o/2]T ; [x: o/2 `pl e2: o/3]T = [x: o/1 `pl [e1/x]e2: o/3]T

* identity over o/ is [x: o/ `pl x: o/ ]T .
In order for composition in F(T ) to be well-defined, it is essential to consider only equivalenceclasses of existing programs, since the simple programming language satisfies only a restricted form

of substitutivity.
Proposition 2.9 Every theory T of the simple programming language, viewed as a category F(T ),is equipped with a Kleisli triple (

T, j, *) satisfying the mono requirement:

* T (o/ ) = T o/ ,

* jo/ = [x: o/ `pl [x]: T o/ ]T ,

* ([x: o/1 `pl e: T o/2]T )* = [x0: T o/1 `pl [(let x(u(x0) in u(e))]: T o/2]T .
Proof We have to show that the three axioms for Kleisli triples are valid. The validity of each axiomamounts to the derivability of an existence and equivalence assertion. For instance,

j*o/ = idT o/ isvalid provided
x0: T o/ `pl x0 #To/ and x0: T o/ `pl [(let x(u(x0) in u([x]))] jT o/ x0 are derivable. Theexistence assertion follows immediately from (E.

x), while the equivalence is derived as follows:

* x0: T o/ `pl [(let x(u(x0) in u([x]))] jT o/ [(let x(u(x0) in x)] by (

u.fi), (refl) and (let.,)

* x0: T o/ `pl [(let x(u(x0) in x)] jT o/ [u(x0)] by (unit) and (let.,)

* x0: T o/ `pl [u(x0)] jT o/ x0 by (E.x) and (u.j)

* x0: T o/ `pl [(let x(u(x0) in u([x]))] jT o/ x0 by (trans).
We leave to the reader the derivation of the existence and equivalence assertions correspondingto the other axioms for Kleisli triples, and prove instead the mono requirement i.e. that

f1; jo/ =
f2; jo/ implies f1 = f2. Let fi be [x: o/ 0 `pl ei: o/ ]T , we have to derive x: o/ 0 `pl e1 jo/ e2 from
x: o/ 0 `pl [e1] jTo/ [e2] (and x: o/ 0 `pl ei #o/ ) :

* x: o/ 0 `pl u([e1]) jo/ u([e2]) by the first assumption and (u.,)

* x: o/ 0 `pl u([ei]) jo/ ei by (u.fi)

* x: o/ 0 `pl e1 jo/ e2 by (trans).

14

Remark 2.10 One can show that the canonical interpretation of a program x: o/1 `pl e: o/2 in thecategory F(T ) is the morphism [

x: o/1 `pl [e]: T o/2]T . This interpretation establishes a one-onecorrespondence between morphisms from

o/1 to T o/2 in the category F(T ), i.e. morphisms from o/1to
o/2 in the Kleisli category, and equivalence classes of programs x: o/1 `pl e: o/2 (not necessarelyexisting). The inverse correspondence maps a morphism [

x: o/1 `pl e0: T o/2]T to the equivalence classof
x: o/1 `pl u(e0): o/2. Indeed, x: o/1 `pl e jo/2 u([e]) and x: o/1 `pl e0 jo/2 [u(e0)] are derivable provided
x: o/1 `pl e0 #T o/2.

3 Extending the simple metalanguage
So far we have considered only languages and formal systems for monadic terms x: o/1 ` e: o/2, havingexactly one free variable (occurring once). In this section we want to extend these languages (and
formal systems) by allowing algebraic terms x1: o/1, . . . , xn: o/n ` e: o/ , having a finite number of freevariables (occurring finitely many times) and investigate how this affects the interpretation and
the structure on theories viewed as categories. For convenience in relating theories and categorieswith additional structure, we also allow types to be closed w.r.t. finite products

4, in particular

a typing context x1: o/1, . . . , xn: o/n can be identified with a type. In general, the interpretation ofan algebraic term

x1: o/1, . . . , xn: o/n ` e: o/ in a category (with finite products) is a morphism from([[
o/1]] * . . . * [[o/n]]) to [[o/ ]].The extension of monadic equational logic to algebraic terms is equational logic, whose theories

correspond to categories with finite products. We will introduce the metalanguage, i.e. the ex-tension of the simple metalanguage described in Section 2.2 to algebraic terms, and show that its
theories correspond to categories with finite products and a strong monad , i.e. a monad and a natu-ral transformation t

A,B: A*T B ! T (A*B). Intuitively tA,B transforms a pair value-computationinto a computation of a pair of values, as follows

a: A, c: T B t

A,B7-! (let y(c in [ha, yi]): T (A * B)

Remark 3.1 To understand why a category with finite products and a monad is not enough tointerpret the metalanguage (and where the natural transformation t is needed), one has to look at

the interpretation of a let-expression

let \Gamma  `ml e1: T o/1 \Gamma , x: o/1 `ml e2: T o/2\Gamma  `

ml (letT x(e1 in e2): T o/2

where \Gamma  is a typing context. Let g1: c ! T c1 and g2: c * c1 ! T c2 be the interpretations of \Gamma  `ml
e1: T o/1 and \Gamma , x: o/1 `ml e2: T o/2 respectively, where c is the interpretation of the typing context \Gamma and

ci is the interpretation of the type o/i, then the interpretation of \Gamma  `ml (letT x(e1 in e2): T o/2ought to be a morphism

g: c ! T c2. If (T, j, u) is the identity monad , i.e. T is the identityfunctor over C and
j and u are the identity natural transformation over T , then computations getidentified with values. In this case (let

T x(e1 in e2) can be replaced by [e1/x]e2, so g is simplyhid
c, g1i; g2: c ! c2. In the general case Table 3 suggests that ; above is indeed composition inthe Kleisli category, therefore hid

c, g1i; g2 should be replaced by hidc, g1i; g2*. But in hidc, g1i; g2*there is a type mismatch, since the codomain of hid

c, g1i is c * T c1, while the domain of T g1 is
T (c * c1). The natural transformation tA,B: A * T B ! T (A * B) mediates between these twoobjects, so that

g can be defined as hidc, g1i; tc,c1; g2*.

4If the metalanguage does not have finite products, we conjecture that its theories would no longer correspond to
categories with finite products and a strong monad (even by taking as objects contexts and/or the Karoubi envelope,
used in [Sco80] to associate a cartesian closed category to an untyped *-theory), but instead to multicategories with
a Kleisli triple. We felt the greater generality (of not having products in the metalanguage) was not worth the
mathematical complications.

15

Definition 3.2 A strong monad over a category C with (explicitly given) finite products is amonad (

T, j, u) together with a natural transformation tA,B from A * T B to T (A * B) s.t.

T A^

rT A

I@@

@
T rA @@@

1 * T A t

1,A> T (1 * A)

(A * B) * T C t

A*B,C > T ((A * B) * C)

ffA,B,TC

.

@@

@
T ffA,B,C @@@R

A * (B * T C) id

A * tB,C > A * T (B * C) tA,B*C> T (A * (B * C))

A * B

idA * jB

.

@@

@j
A*B @@

@R
A * T B t

A,B > T (A * B)

^
idA * uB

I@@

@u
A*B @@

@
A * T 2B t

A,TB> T (A * T B) T tA,B> T 2(A * B)

where r and ff are the natural isomorphisms

rA: (1 * A) ! A , ffA,B,C: (A * B) * C ! A * (B * C)
Remark 3.3 The diagrams above are taken from [Koc72], where a characterisation of strong mon-ads is given in terms of C-enriched categories (see [Kel82]). Kock fixes a commutative monoidal

closed category C (in particular a cartesian closed category), and in this setup he establishes a
one-one correspondence between strengths stA,B: BA ! (T B)T A and tensorial strengths tA,B: A \Omega 
T B ! T (A \Omega  B) for a endofunctor T over C (see Theorem 1.3 in [Koc72]). Intuitively a strengthst

A,B internalises the action of T on morphisms from A to B, and more precisely it makes (T, st)a C-enriched endofunctor on C enriched over itself (i.e. the hom-object C(

A, B) is BA). In thissetting the diagrams of Definition 3.2 have the following meaning:

* the first two diagrams are (1.7) and (1.8) in [Koc72], saying that t is a tensorial strength of

T . So T can be made into a C-enriched endofunctor.

* the last two diagrams say that j: IdC .! T and u: T 2 .! T are C-enriched natural transfor-mations, where Id

C, T and T 2 are enriched in the obvious way (see Remark 1.4 in [Koc72]).

There is another purely categorical characterisation of strong monads, suggested to us by G.Plotkin, in terms of C-indexed categories (see [JP78]). Both characterisations are instances of a

general methodological principle for studying programming languages (or logics) categorically (see[Mog89b]):

when studying a complex language the 2-category Cat of small categories, functors andnatural transformations may not be adequate; however, one may replace

Cat with adifferent 2-category, whose objects captures better some fundamental structure of the

language, while less fundamental structure can be modelled by 2-categorical concepts.

16

Monads are a 2-categorical concept, so we expect notions of computations for a complex languageto be modelled by monads in a suitable 2-category.

The first characterisation takes a commutative monoidal closed structure on C (used in [Laf88,See87] to model a fragment of linear logic), so that C can be enriched over itself. Then a strong
monad over a cartesian closed category C is just a monad over C in the 2-category of C-enrichedcategories.

The second characterisation takes a class D of display maps over C (used in [HP87] to modeldependent types), and defines a C-indexed category C

/D . Then a strong monad over a categoryC with finite products amounts to a monad over C
/D in the 2-category of C-indexed categories,where D is the class of first projections (corresponding to constant type dependency).

In general the natural transformation t has to be given explicitly as part of the additionalstructure. However, t is uniquely determined (but it may not exists) by

T and the cartesianstructure on C, when C has enough points.

Proposition 3.4 (Uniqueness) If (T, j, u) is a monad over a category C with finite products andenough points (i.e. 8

h: 1 ! A.h; f = h; g implies f = g for any f, g: A ! B), then (T, j, u, t) isa strong monad over C if and only if t

A,B is the unique family of morphisms s.t. for all points
a: 1 ! A and b: 1 ! T B h

a, bi; tA,B = b; T (h!B; a, idBi)

where !B: B ! 1 is the unique morphism from B to the terminal object.

Proof Note that there is at most one tA,B s.t. ha, bi; tA,B = b; T (h!B; a, idBi) for all points a: 1 ! Aand

b: 1 ! T B, because C has enough points.First we show that if (

T, j, u, t) is a strong monad, then tA,B satisfies the equation above. Bynaturality of t and by the first diagram in Definition 3.2 the following diagram commutes

1 ha, bi > A * T B t

A,B > T (A * B)

^ ^@@
@ hid1, bi@

@@R

a * idTB T (a * idB)

1 * T B t

1,B > T (1 * B)

@@

@ rT B@

@@R .

T rB

T B
Since rB is an isomorphism (with inverse h!B, idBi), then the two composite morphisms ha, bi; tA,Band hid

1, bi; rT B; T (r-1B ); T (a*idB) from 1 to T (A*B) must coincide. But the second compositioncan be rewritten as

b; T (h!B; a, idBi).Second we have to show that if t is the unique family of morphisms satisfying the equation

above, then (T, j, u, t) is a strong monad. This amount to prove that t is a natural transformationand that the three diagrams in Definition 3.2 commute. The proof is a tedious diagram chasing,
which relies on C having enough points. For instance, to prove that t1,A; T rA = rT A it is enoughto show that hid

1, ai; t1,A; T rA = hid1, ai; rTA for all points a: 1 ! A.

Example 3.5 We go through the monads given in Example 1.4 and show that they have a tensorialstrength.

* partiality T A = A?(= A + {?})t

A,B(a, ?) = ? and tA,B(a, b) = ha, bi (when b 2 B)

* nondeterminism T A = Pfin(A)t

A,B(a, c) = {ha, bi|b 2 c}

17

* side-effects T A = (A * S)St

A,B(a, c) = (*s: S.(let hb, s0i = c(s) in hha, bi, s0i))

* exceptions T A = (A + E)t

A,B(a, inr(e)) = inr(e) (when e 2 E) andt
A,B(a, inl(b)) = inl(ha, bi) (when b 2 B)

* continuations T A = R(R

A)

tA,B(a, c) = (*k: RA*B.c(*b: B.k(ha, bi)))

* interactive input T A = (ufl.A + flU )t

A,B(a, c) is the tree obtained by replacing leaves of c labelled by b with the leaf labelled byh
a, bi

* interactive output T A = (ufl.A + (U * fl))t

A,B(a, hs, bi) = hs, ha, bii.

Remark 3.6 The tensorial strength t induces a natural transformation A,B from T A * T B to

T (A * B), namely

A,B = cT A,T B; tTB,A; (cTB,A; tA,B)*

where c is the natural isomorphism cA,B: A * B ! B * A.The morphism

A,B has the correct domain and codomain to interpret the pairing of a com-putation of type
A with one of type B, obtained by first evaluating the first argument and thenthe second, namely

c1: T A, c2: T B 

A,B7-! (let x(c

1 in (let y(c2 in [hx, yi])): T (A * B)

There is also a dual notion of pairing, ~A,B = cT A,TB; B,A; T cB,A (see [Koc72]), which amountsto first evaluating the second argument and then the first.

3.1 Interpretation and formal system
We are now in a position to give the metalanguage for algebraic terms, its interpretation andinference rules.

Definition 3.7 (metalanguage) An interpretation [[ ]] of the metalanguage in a category C with
terminal object !A: A ! 1, binary products ssA1,A2i : A1 * A2 ! Ai and a strong monad (T, j, u, t)is parametric in an interpretation of the symbols in the signature and is defined by induction on

the derivation of well-formedness for types (see Table 8), terms and equations (see Table 9).

Finite products ssA1,...,Ani : A1 *. . .*An ! Ai used to interpret contexts and variables are definedby induction on

n:

0 A1 * . . . * A0 \Delta = 1
n + 1 A1 * . . . * An+1 \Delta = (A1 * . . . * An) * An+1

- ssA1,...,An+1n+1 = ss(A1*...*An),An+12
- ssA1,...,An+1i = ss(A1*...*An),An+11 ; ssA1,...,Ani
The inference rules for the metalanguage (see Table 10) are divided into three groups:

* general rules for many sorted equational logic

* rules for finite products

* rules for T

18

RULE SYNTAX SEMANTICS

A `

ml A type = [[A]]

T `

ml o/ type = c`
ml T o/ type = T c

1 `

ml 1 type = 1

* `

ml o/1 type = c1`
ml o/2 type = c2`
ml o/1 * o/2 type = c1 * c2

; `

ml o/i type (1 <= i <= n) = ci
x1: o/1, . . . , xn: o/n ` = c1 * . . . * cn

Table 8: Interpretation of types in the Metalanguage
Proposition 3.8 Every theory T of the metalanguage, viewed as a category F(T ), is equippedwith finite products and a strong monad whose tensorial strength is

to/1,o/2 = [x: o/1 * T o/2 `ml (letT x2(ss2x in [hss1x, x2i]T ): T (o/1 * o/2)]T
Proof Similar to that of Proposition 2.5

Once we have a metalanguage for algebraic terms it is straightforward to add data-types charac-terised by universal properties and extend the categorical semantics accordingly

5. For instance, if

we want to have function spaces, then we simply require the category C (where the metalanguageis interpreted) to have exponentials

BA and add the inference rules for the simply typed *-calculus(see Table 11) to those for the metalanguage. From a programming language perspective the situation is more delicate. For instance, the semantics of functional types should reflect the choice ofcalling mechanism

6:

* in call-by-value a procedure of type A ! B expects a value of type A and computes a resultof type

B, so the interpretation of A ! B is (T B)A;

* in call-by-name a procedure of type A ! B expects a computation of type A, which isevaluated only when needed, and computes a result of type

B, so the interpretation of
A ! B is (T B)T A.

In both cases the only exponentials needed to interpret the functional types of a programminglanguage are of the form (

T B)A. By analogy with partial cartesian closed categories (pccc), whereonly p-exponentials are required to exists (see [Mog86, Ros86]), we adopt the following definition

of *c-model:

5The next difficult step in extending the metalanguage is the combination of dependent types and computations,
which is currently under investigation.

6call-by-need does not have a simple categorical semantics, since the environment in which an expression is
evaluated may itself undergo evaluation.

19

RULE SYNTAX SEMANTICS

vari `

ml o/i type (1 <= i <= n) = ci
x1: o/1, . . . , xn: o/n ` xi: o/i = ssc1,...,cni

* \Gamma  ` *: 1 = !

[[\Gamma ]]

hi \Gamma  `

e1: o/1 = g1\Gamma  `
e2: o/2 = g2\Gamma  ` h

e1, e2i: o/1 * o/2 = hg1, g2i

ssi \Gamma  `

e: o/1 * o/2 = g

\Gamma  ` ssi(e): o/1 = g; ss[[o/1]],[[o/2]]i

f: o/1 ! o/2 \Gamma  `

ml e1: o/1 = g\Gamma  `
ml f(e1): o/2 = g; [[f]]

[ ]T \Gamma  `

ml e: o/ = g\Gamma  `
ml [e]T : T o/ = g; j[[o/]]

let \Gamma  `

ml e1: T o/1 = g1\Gamma 
, x: o/1 `ml e2: T o/2 = g2\Gamma  `

ml (letT x(e1 in e2): T o/2 = hid[[\Gamma ]], g1i; t[[\Gamma ]],[[o/1]]; g*2

eq \Gamma  `

ml e1: o/ = g1\Gamma  `
ml e2: o/ = g2\Gamma  `
ml e1 =o/ e2 () g1 = g2

Table 9: Interpretation of terms in the Metalanguage

20

refl \Gamma  ` e: o/\Gamma  ` e =

o/ e

symm \Gamma  ` e1 =o/ e2\Gamma  ` e

2 =o/ e1

trans \Gamma  ` e1 =o/ e2 \Gamma  ` e2 =o/ e3\Gamma  ` e

2 =o/ e3

congr \Gamma  ` e1 =o/1 e2\Gamma  ` f(e

1) =o/2 f(e2) f: o/1 ! o/2

subst \Gamma  ` e: o/ \Gamma , x: o/ ` OE\Gamma  ` [e/x]OE

Inference Rules of Many Sorted Equational Logic
1.j \Gamma  ` * =1 x

hi., \Gamma  ` e1 =o/1 e01 \Gamma  ` e2 =o/2 e02\Gamma  ` he

1, e2i =o/1*o/2 he01, e02i

*.fi \Gamma  ` e1: o/1 \Gamma  ` e2: o/2\Gamma  ` ss

i(he1, e2i) =o/i ei

*.j \Gamma  ` e: o/1 * o/2\Gamma  ` hss

1(e), ss2(e)i =o/1*o/2 e

rules for product types

[ ]., \Gamma  `ml e1 =o/ e2\Gamma  `

ml [e1]T =To/ [e2]T

let., \Gamma  `ml e1 =To/1 e2 \Gamma , x: o/1 `ml e01 =To/2 e02\Gamma  `

ml (letT x(e1 in e01) =T o/2 (letT x(e2 in e02)

ass \Gamma  `ml e1: T o/1 \Gamma , x1: o/1 `ml e2: T o/2 \Gamma , x2: o/2 `ml e3: T o/3\Gamma  `

ml (letT x2((letT x1(e1 in e2) in e3) =T o/3 (letT x1(e1 in (letT x2(e2 in e3))

T.fi \Gamma  `ml e1: o/1 \Gamma , x1: o/1 `ml e2: T o/2\Gamma  `

ml (letT x1([e1]T in e2) =T o/2 [e1/x1]e2

T.j \Gamma  `ml e1: T o/1\Gamma  `

ml (letT x1(e1 in [x1]T ) =T o/1 e1

Table 10: Inference Rules of the Metalanguage

app., \Gamma  ` e1 =o/1 e01 \Gamma  ` e =o/1!o/2 e0\Gamma  ` ee

1 =o/2 e0e01

*., \Gamma , x: o/1 ` e1 =o/2 e2\Gamma  ` (*x: o/

1.e1) =o/1!o/2 (*x: o/1.e2)

! .fi \Gamma  ` e1: o/1 \Gamma , x: o/1 ` e2: o/2\Gamma  ` (*x: o/

1.e2)e1 =o/2 [e1/x]e2

! .j \Gamma  ` e: o/1 ! o/2\Gamma  ` (*x: o/

1.ex) =o/1!o/2 e x 62 DV(\Gamma )

Table 11: rules for function spaces

21

Definition 3.9 A *c-model is a category C with finite products, a strong monad (T, j, u, t) satisfying the mono requirement (i.e. jA mono for every A 2 C) and T -exponential (T B)A for every
A, B 2 C.

Remark 3.10 The definition of *c-model generalises that of pccc, in the sense that every pccccan be viewed as a

*c-model. By analogy with p-exponentials, a T -exponential can be defined bygiving an isomorphism C

T (C * A, B) ,= C(C, (T B)A) natural in C 2 C. We refer to [Mog89c] forthe interpretation of a call-by-value programming language in a

*c-model and the correspondingformal system, the

*c-calculus.

4 Strong monads over a topos
In this section we show that, as far as monads or strong monads are concerned, we can assumew.l.o.g. that they are over a topos (see Theorem 4.9). The proof of Theorem 4.9 involves nonelementary notions from Category Theory, and we postpone it after discussing some applications,with particular emphasis on further extensions of the metalanguage and on conservative extension
results.Let us take as formal system for toposes the type theory described in [LS86], this is a many
sorted intuitionistic higher order logic with equality and with a set of types satisfying the followingclosure properties

7:

* the terminal object 1, the natural number object N and the subobject classifier \Omega  are types

* if A is a type, then the power object P A is a type

* if A and B are types, then the binary product A * B and the function space A ! B aretypes

* if A is a type and OE: A ! \Omega  is a predicate, then {x 2 A|OE(x)} is a type.
Notation 4.1 We introduce some notational conventions for formal systems:

* MLT is the metalanguage for algebraic terms, whose set of types is closed under terminalobject, binary products and

T A;

* *MLT is the extension of MLT with function spaces A ! B (interpreted as exponentials);

* HMLT is the type theory described above (see [LS86]) extended with objects of computations

T A;

* PL is the programming language for algebraic terms (see [Mog89c]);

* *cPL is the extension of PL with function spaces A * B (interpreted as T -exponentials),called

*c-calculus in [Mog89c].

Definition 4.2 We say that a formal system (L2, `2), where `2` P(L2) * L2 is a formal conse-quence relation

8 over L2, is a conservative extension of (L1, `1) provided L1 ` L2 and `1 is

the restriction of `2 to P(L1) * L1.

Theorem 4.3 HMLT is a conservative extension of MLT and *MLT . In particular *MLT is aconservative extension of ML

T .

7Lambek and Scott do not require closure under function spaces and subsets {x 2 A|OE(x)}.
8For instance, in the case of MLT the elements of L are well-formed equality judgements \Gamma  `ml e1 =o/ e2 and
P ` C iff there exists a derivation of C, where all assumptions are in P .

22

Proof The first result follows from Theorem 4.9, which implies that for every model C of MLTthe Yoneda embedding maps the interpretation of an ML

T -term in C to its interpretation in ^C,and the faithfulness of the Yoneda embedding, which implies that two ML

T -terms have the sameinterpretation in C iff they have the same interpretation in ^C. The second result follows, because

the Yoneda embedding preserves function spaces. The third conservative extension result followsimmediately from the first two.

The above result means that we can think of computations naively in terms of sets and func-tions, provided we treat them intuitionistically, and can use the full apparatus of higher-order
(intuitionistic) logic instead of the less expressive many sorted equational logic.Before giving a conservative extension result for the programming language, we have to express
the mono requirement, equivalence and existence in HMLT . The idea is to extend the translationfrom PL-terms to ML

T -terms given in Definition 2.7 and exploit the increased expressiveness ofHML
T over MLT to axiomatise the mono requirement and translate existence and equivalenceassertions (see Remark 2.1):

* the mono requirement for o/ , i.e. jo/ is mono, is axiomatised by

mono.o/ (8x, y: o/.[x]T =T o/ [y]T ! x =o/ y)

* the equalising requirement for o/ , i.e. jo/ is the equaliser of T (jo/ ) and jT o/ , is axiomatisedby (mono.

o/ ) and the axiom

eqls.o/ (8x: T o/.[x]T =T 2o/ (letT y(x in [[y]T ]T ) ! (9!y: o/.x =T o/ [y]T ))

* the translation ffi is extended to assertions and functional types as follows:

- (e1 jo/ e2)ffi \Delta j e1ffi =To/ e2ffi
- (e1 #o/ )ffi \Delta j (9!x: o/.e1ffi =T o/ [x]T )
- (o/1 * o/2)ffi \Delta j o/1ffi ! T o/2ffi
Theorem 4.4 HMLT +{(mono.o/ )| o/ type of PL} (i.e. o/ is built using only base types, 1, T A, and
A*B) is a conservative extension of PL (after translation). Similarly, HMLT +{(mono.o/ )| o/ type of *cPL}(i.e.

o/ is built using only base types, 1, T A, A * B and A ! B) is a conservative extension of
*cPL (after translation).

Proof The proof proceeds as in the previous theorem. The only additional step is to show that forevery type

o/ of PL (or *cPL) the axiom (mono.o/ ) holds in ^C, under the assumption that C satisfiesthe mono requirement. Let

c be the interpretation of o/ in C (therefore Yc is the interpretation of
o/ in ^C), then the axiom (mono.o/ ) holds in ^C provided ^jYc is a mono. jc is mono (by the monorequirement), so ^

jYc = Y(jc) is mono (as Y preserves monos).

In the theorem above only types from the programming language have to satisfy the mono require-ment. Indeed, HML

T + {(mono.o/ )| o/ type of HMLT } is not a conservative extension of PL (or
*cPL).

Lemma 4.5 If (T, j, u) is a monad over a topos C satisfying the mono requirement, then it satisfiesalso the equalising requirement.

Proof See Lemma 6 on page 110 of [BW85].

In other words, for any type o/ the axiom (eqls.o/) is derivable in HMLT from the set of axioms{(mono.

o/ )| o/ type of HMLT }. In general, when C is not a topos, the mono requirement does notentail the equalising requirement; one can easily define strong monads (over an Heyting algebra)

that satisfy the mono but not the equalising requirement (just take T (A) = A . B, for someelement

B 6= ? of the Heyting algebra). In terms of formal consequence relation this means

23

that in HMLT + mono requirement the existence assertion \Gamma  `pl e #o/ is derivable from \Gamma  `pl[

e] jTo/ (let x(e in [x]), while such derivation is not possible in *cPL. We do not know whetherHML

T + equalising requirement is a conservative extension of PL + equalising requirement, orwhether

*cPL is a conservative extension of PL.A language which combines computations and higher order logic, like HML

T , seems to be theideal framework for program logics that go beyond proving equivalence of programs, like Hoare's

logic for partial correctness of imperative languages. In HMLT (as well as MLT and PL) one candescribe a programming language by introducing additional constant and axioms. In

*MLT or
*cPL such constants correspond to program-constructors, for instance:

* lookup: L ! T U , which given a location l 2 L produces the value of such location in thecurrent store, and

update: L * U ! T 1, which changes the current store by assigning to l 2 Lthe value
u 2 U ;

* if : Bool * T A * T A ! T A and while: T (Bool) * T 1 ! T 1;

* new: 1 ! T L, which returns a newly created location;

* read: 1 ! T U , which computes a value by reading it from the input, and write: U ! T 1,which writes a value

u 2 U on the output.

In HMLT one can describe also a program logic, by adding constants p: T A ! \Omega  corresponding toproperties of computations.

Example 4.6 Let T be the monad for non-deterministic computations (see Example 1.4), then wecan define a predicate

may: A * T A ! \Omega  such that may(a, c) is true iff the value a is a possibleoutcome of the computation

c (i.e. a 2 c). However, there is a more uniform way of defining the
may predicate for any type. Let 3: T \Omega  ! \Omega  be the predicate such that 3(X) = ? iff ? 2 X,where \Omega  is the set {?

, ?} (note that 3( ) = may(?, )). Then, may(a, c) can be defined as
3(letT x(c in [a =o/ x]T ).

The previous example suggests that predicates defined uniformly on computations of any typecan be better described in terms of modal operators

fl: T \Omega  ! \Omega , relating a computation of truthvalues to a truth value. This possibility has not been investigated in depth, so we will give only a

tentative definition.
Definition 4.7 If (T, j, u) is a monad over a topos C, then a T -modal operator is a T -algebra
fl: T \Omega  ! \Omega , i.e.

T 2\Omega  u

\Omega  > T \Omega  < j\Omega  \Omega 

T fl

. .

fl

\Psi \Gamma \Gamma 

\Gamma  idT \Omega \Gamma 

\Gamma \Gamma 

T \Omega  fl > \Omega 
where \Omega  is the subobject classifier in C.
The commutativity of the two diagrams above can be expressed in the metalanguage:

* x: \Omega  ` fl([x]T ) ! x

* c: T 2\Omega  ` fl(let x(c in x) ! fl(let x(c in [fl(x)]T )
We consider some examples and non-examples of modal operators.
Example 4.8 For the monad T of non-deterministic computations (see Example 1.4) there areonly two modal operators

2 and 3:

* 2(X) = ? iff ? 2 X;

24

* 3(X) = ? iff ? 2 X.
Given a nondeterministic computation e of type o/ and a predicate A(x) over o/, i.e. a term of type\Omega , then

2(letT x(e in [A(x)]T ) is true iff all possible results of e satisfy A(x).For the monad

T of computations with side-effects (see Example 1.4) there is an operator
2: (\Omega  * S)S ! \Omega  that can be used to express Hoare's triples:

* 2f = ? iff for all s 2 S there exists s0 2 S s.t. f s = h?, s0i

this operator does not satisfy the second equivalence, as only one direction is valid, namely
c: T 2\Omega  ` fl(let x(c in [fl(x)]T ) ! fl(let x(c in x)

Let P : U ! \Omega  and Q: U * U ! \Omega  be predicates over storable values, e 2 T 1 a computation of type1 and

x, y 2 L locations. The intended meaning of the triple {P (x)}e{Q(x, y)} is "if in the initialstate the content

u of x satisfies P (u), then in the final state (i.e. after executing e) the content
v of y satisfies Q(u, v)". This intended meaning can be expressed formally in terms of the modaloperator

2 and the program-constructors lookup and update as follows:

8u: U.P (u) ! 2(letT v((update(x, u); e; lookup(y)) in [Q(u, v)]T )

where ; : T A * T B ! T B is the derived operation e1; e2 \Delta j (letT x(e1 in e2) with x not free in e2.

Finally, we state the main theorem and outline its proof. In doing so we assume that the readeris familiar with non-elementary concepts from Category Theory.

Theorem 4.9 Let C be a small category, ^C the topos of presheaves over C and Y the Yonedaembedding of C into ^C. Then for every monad (

T, j, u) over C, there exists a monad ( ^T , ^j, ^u) over^C such that the following diagram commutes
9

C T > C
Y. .Y

^C

^T

> ^C

and for all a 2 C the following equations hold

^jYa = Y(ja) , ^uYa = Y(ua)
Moreover, for every strong monad (T, j, u, t) over C, there exists a natural transformation ^t suchthat ( ^

T , ^j, ^u, ^t) is a strong monad over ^C and for all a, b 2 C the following equation holds

^tYa,Yb = Y(ta,b)

where we have implicitly assume that the Yoneda embedding preserves finite products on the nose,i.e. the following diagrams commute

1 1 > C < * C * C

@@

@1 @

@@R

Y. .Y * Y

^C < * ^C * ^C

9This is a simplifying assumption. For our purposes it would be enough to have a natural isomorphism oe: T ; Y .!
Y; ^T , but then the remaining equations have to be patched. For instance, the equation relating j and ^j would become

^jYa = Y(ja); oea.

25

and for all a, b 2 C. the following equations hold

!Ya = Y(!a) , ssYa,Ybi = Y(ssa,bi )
Definition 4.10 ([Mac71]) Let T : C ! D be a functor between two small categories and A acocomplete category. Then, the left Kan extension LA

T : AC ! AD is the left adjoint of AT andcan be defined as follows:

LAT (F )(d) = ColimAT#d(ss; F )
where F : C ! A , d 2 D, T # d is the comma category whose objects are pairs hc 2 C, f: T c ! di,
ss: T # d ! C is the projection functor (mapping a pair hc, f i to c) and ColimAI : AI ! A (with Ismall category) is a functor mapping an

I-diagram in A to its colimit.

The following proposition is a 2-categorical reformulation of Theorem 1.3.10 of [MR77]. For thesake of simplicity, we use the strict notions of 2-functor and 2-natural transformation, although we

should have used pseudo-functors and pseudo-natural transformations.
Proposition 4.11 Let Cat be the 2-category of small categories, CAT the 2-category of locallysmall categories and : Cat ! CAT the inclusion 2-functor. Then, the following ^: Cat ! CAT

is a 2-functor*

if C is a small category, then ^C is the topos of presheaves SetC

op

* if T : C ! D is a functor, then ^T is the left Kan extension LSetTop

* if oe: S .! T : C ! D is a natural transformation and F 2 ^C, then ^oeF is the natural transfor-mation corresponding to id

^T F via the following sequence of steps

^C(F, T op; ^T F ) < , ^D( ^T F, ^T F )

.

^C(F, oeop; ^T F )

^C(F, Sop; ^T F ) , > ^D( ^SF, ^T F )
Moreover, Y: .! ^ is a 2-natural transformation.
Since monads are a 2-categorical concept (see [Str72]), the 2-functor ^ maps monads in Cat tomonads in CAT. Then, the statement of Theorem 4.9 about lifting of monads follows immediately

from Proposition 4.11. It remains to define the lifting ^t of a tensorial strength t for a monad (T, j, u)over a small category C.

Proposition 4.12 If C is a small category with finite products and T is an endofunctor overC, then for every natural transformation t

a,b: a * T b ! T (a * b) there exists a unique naturaltransformation ^
tF,G: F * ^T G ! ^T (F * G) s.t. ^tYa,Yb = Y(ta,b) for all a, b 2 C.

Proof Every F 2 ^C is isomorphic to the colimit Colim ^CY#F (ss; Y) (shortly ColimiYi), where Y is

the Yoneda embedding of C into ^C. Similarly G is isomorphic to ColimjYj. Both functors ( * ^T )
and ^T ( * ) from ^C * ^C to ^C preserves colimits (as ^T and * F are left adjoints) and commutewith the Yoneda embedding (as Y(

a * b) = Ya * Yb and ^T (Ya) = Y(T a)). Therefore, F * ^T G and^
T (F * G) are isomorphic to the colimits Colimi,jYi * ^T (Yj) and Colimi,j ^T (Yi * Yj) respectively.

Let ^t be the natural transformation we are looking for, then

Yi * ^T (Yj) Y(t

i,j )> ^T (Yi * Yj)

f * ^T g. .^T (f * g)

F * ^T (G) ^

tF,G

> ^T (F * G)

26

for all f : Yi ! F and g: Yj ! g (by naturality of ^t and ^tYi,Yj = Y(ti,j )). But there exists exactlyone morphism ^t

F,G making the diagram above commute, as hti,j |i, ji is a morphism betweendiagrams in ^C of the same shape, and these diagrams have colimit cones h

f * ^T g|f, gi and h ^T (f *
g)|f, gi respectively.

Remark 4.13 If T is a monad of partial computations, i.e. it is induced by a dominion M on Cs.t. P(C

, M)(a, b) ,= C(a, T b), then the lifting ^T is the monad of partial computations induced bythe dominion ^M on ^C, obtained by lifting M to the topos of presheaves, as described in [Ros86].

For other monads, however, the lifting is not the expected one. For instance, if T is the monadof side-effects ( *

S)S, then ^T is not (in general) the endofunctor ( * YS)YS on the topos ofpresheaves.

Conclusions and further research
The main contribution of this paper is the category-theoretic semantics of computations and thegeneral principle for extending it to more complex languages (see Remark 3.3 and Section 4), while
the formal systems presented are a straightforward fallout, easy to understand and relate to othercalculi.

Our work is just an example of what can be achieved in the study of programming languagesby using a category-theoretic methodology, which avoids irrelevant syntactic detail and focus instead on the important structures underlying programming languages. We believe that there is agreat potential to be exploited here. Indeed, in [Mog89b] we give a categorical account of phase
distinction and program modules, that could lead to the introduction of higher order modules inprogramming languages like ADA or ML (see [HMM90]), while in [Mog89a] we propose a "modular
approach" to Denotational Semantics based on the idea of monad-constructor (i.e. an endofunctoron the category of monads over a category C).

The metalanguage open also the possibility to develop a new Logic of Computable Functions(see [Sco69]), based on an abstract semantic of computations rather than domain theory, for
studying axiomatically different notions of computation and their relations. Some recent work byCrole and Pitts (see [CP90]) has consider an extension of the metalanguage equipped with a logic
for inductive predicates, which goes beyond equational reasoning. A more ambitious goal wouldbe to try exploiting the capabilities offered by higher-order logic in order to give a uniform account
of various program logics, based on the idea of "T -modal operator" (see Definition 4.7).The semantics of computations corroborates the view that (constructive) proofs and programs
are rather unrelated, although both of them can be understood in terms of functions. Indeed,monads (and comonads) used to model logical modalities, e.g. possibility and necessity in modal
logic or why not and of course of linear logic, usually do not have a tensorial strength. In general,one should expect types suggested by logic to provide a more fine-grained type system without
changing the nature of computations.We have identified monads as important to model notions of computations, but computational
monads seem to have additional properties, e.g. they have a tensorial stregth and may satisfy themono requirement. It is likely that there are other properties of computational monads still to be
identified, and there is no reason to believe that such properties have to be found in the literatureon monads.

Acknowledgements
I have to thank many people for advice, suggestions and criticisms, in particular: R. Amadio, R.Burstall, M. Felleisen, R. Harper, F. Honsell, M. Hyland, B. Jay, A. Kock, Y. Lafont, G. Longo,

R. Milner, A. Pitts, G. Plotkin, J. Power and C. Talcott.

References

[BW85] M. Barr and C. Wells. Toposes, Triples and Theories. Springer Verlag, 1985.

27

[CP90] R.L. Crole and A.M. Pitts. New foundations for fixpoint computations. In 4th LICSConf. IEEE, 1990.

[CS87] R.L. Constable and S.F. Smith. Partial objects in constructive type theory. In 2ndLICS Conf. IEEE, 1987.
[CS88] R.L. Constable and S.F. Smith. Computational foundations of basic recursive functiontheory. In 3rd LICS Conf. IEEE, 1988.
[FF89] M. Felleisen and D.P. Friedman. A syntactic theory of sequential state. TheoreticalComputer Science, 69(3), 1989.
[FFKD86] M. Felleisen, D.P. Friedman, E. Kohlbecker, and B. Duba. Reasoning with continua-tions. In 1st LICS Conf. IEEE, 1986.

[Fou77] M.P. Fourman. The logic of topoi. In J. Barwise, editor, Handbook of MathematicalLogic, volume 90 of Studies in Logic. North Holland, 1977.
[GMW79] M.J.C. Gordon, R. Milner, and C.P. Wadsworth. Edinburgh LCF: A Mechanized Logicof Computation, volume 78 of Lecture Notes in Computer Science. Springer Verlag,

1979.
[GS89] C. Gunter and S. Scott. Semantic domains. Technical Report MS-CIS-89-16, Dept.of Comp. and Inf. Science, Univ. of Pennsylvania, 1989. to appear in North Holland

Handbook of Theoretical Computer Science.
[HMM90] R. Harper, J. Mitchell, and E. Moggi. Higher-order modules and the phase distinction.In 17th POPL. ACM, 1990.

[HP87] J.M.E. Hyland and A.M. Pitts. The theory of constructions: Categorical semantics andtopos-theoretic models. In Proc. AMS Conf. on Categories in Comp. Sci. and Logic

(Boulder 1987), 1987.
[JP78] P.T. Johnstone and R. Pare, editors. Indexed Categories and their Applications, volume661 of Lecture Notes in Mathematics. Springer Verlag, 1978.

[Kel82] G.M. Kelly. Basic Concepts of Enriched Category Theory. Cambridge University Press,1982.
[Koc72] A. Kock. Strong functors and monoidal monads. Archiv der Mathematik, 23, 1972.

[KR77] A. Kock and G.E. Reyes. Doctrines in categorical logic. In J. Barwise, editor, Handbookof Mathematical Logic, volume 90 of Studies in Logic. North Holland, 1977.

[Laf88] Y. Lafont. The linear abstract machine. Theoretical Computer Science, 59, 1988.

[LS86] J. Lambek and P.J. Scott. Introduction to Higher-Order Categorical Logic, volume 7 ofCambridge Studies in Advanced Mathematics. Cambridge University Press, 1986.

[Mac71] S. MacLane. Categories for the Working Mathematician. Springer Verlag, 1971.
[Man76] E. Manes. Algebraic Theories, volume 26 of Graduate Texts in Mathematics. SpringerVerlag, 1976.

[Mas88] I.A. Mason. Verification of programs that destructively manipulate data. Science ofComputer Programming, 10, 1988.
[Mog86] E. Moggi. Categories of partial morphisms and the partial lambda-calculus. In Pro-ceedings Workshop on Category Theory and Computer Programming, Guildford 1985,

volume 240 of Lecture Notes in Computer Science. Springer Verlag, 1986.

28

[Mog88] E. Moggi. The Partial Lambda-Calculus. PhD thesis, University of Edinburgh, 1988.
[Mog89a] E. Moggi. An abstract view of programming languages. Technical Report ECS-LFCS-90-113, Edinburgh Univ., Dept. of Comp. Sci., 1989. Lecture Notes for course CS 359,

Stanford Univ.
[Mog89b] E. Moggi. A category-theoretic account of program modules. In Proceedings of theConference on Category Theory and Computer Science, Manchester, UK, Sept. 1989,

volume 389 of Lecture Notes in Computer Science. Springer Verlag, 1989.
[Mog89c] E. Moggi. Computational lambda-calculus and monads. In 4th LICS Conf. IEEE, 1989.

[Mos89] P. Mosses. Denotational semantics. Technical Report MS-CIS-89-16, Dept. of Comp.and Inf. Science, Univ. of Pennsylvania, 1989. to appear in North Holland Handbook

of Theoretical Computer Science.
[MR77] M. Makkai and G. Reyes. First Order Categorical Logic. Springer Verlag, 1977.
[MT89a] I. Mason and C. Talcott. Programming, transforming, and proving with function ab-stractions and memories. In 16th Colloquium on Automata, Languages and Programming. EATCS, 1989.
[MT89b] I. Mason and C. Talcott. A sound and complete axiomatization of operational equiva-lence of programs with memory. In POPL 89. ACM, 1989.

[Plo75] G.D. Plotkin. Call-by-name, call-by-value and the *-calculus. Theoretical ComputerScience, 1, 1975.
[Plo85] G.D. Plotkin. Denotational semantics with partial functions. Lecture Notes at C.S.L.I.Summer School, 1985.
[Ros86] G. Rosolini. Continuity and Effectiveness in Topoi. PhD thesis, University of Oxford,1986.

[Sch86] D.A. Schmidt. Denotational Semantics: a Methodology for Language Development.Allyn & Bacon, 1986.

[Sco69] D.S. Scott. A type-theoretic alternative to CUCH, ISWIM, OWHY. Oxford notes,1969.
[Sco79] D.S. Scott. Identity and existence in intuitionistic logic. In M.P. Fourman, C.J. Mul-vey, and D.S. Scott, editors, Applications of Sheaves, volume 753 of Lecture Notes in

Mathematics. Springer Verlag, 1979.
[Sco80] D.S. Scott. Relating theories of the *-calculus. In R. Hindley and J. Seldin, editors, ToH.B. Curry: essays in Combinarory Logic, lambda calculus and Formalisms. Academic

Press, 1980.
[See87] R.A.G. Seely. Linear logic, *-autonomous categories and cofree coalgebras. In Proc.AMS Conf. on Categories in Comp. Sci. and Logic (Boulder 1987), 1987.

[Sha84] K. Sharma. Syntactic aspects of the non-deterministic lambda calculus. Master's thesis,Washington State University, September 1984. available as internal report CS-84-127

of the comp. sci. dept.
[SP82] M. Smith and G. Plotkin. The category-theoretic solution of recursive domain equa-tions. SIAM Journal of Computing, 11, 1982.

[Str72] R. Street. The formal theory of monads. Journal of Pure and Applied Algebra, 2, 1972.

29