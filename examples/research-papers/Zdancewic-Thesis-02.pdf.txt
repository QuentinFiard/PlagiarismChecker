

PROGRAMMING LANGUAGES FOR INFORMATION

SECURITY

A Dissertation
Presented to the Faculty of the Graduate School

of Cornell University
in Partial Fulfillment of the Requirements for the Degree of

Doctor of Philosophy

by
Stephan Arthur Zdancewic

August 2002

c\Delta  Stephan Arthur Zdancewic 2002

ALL RIGHTS RESERVED

PROGRAMMING LANGUAGES FOR INFORMATION SECURITY

Stephan Arthur Zdancewic, Ph.D.

Cornell University 2002

Our society's widespread dependence on networked information systems for everything from personal finance to military communications makes it essential to improvethe security of software. Standard security mechanisms such as access control and encryption are essential components for protecting information, but they do not provide
end-to-end guarantees. Programming-languages research has demonstrated that secu-rity concerns can be addressed by using both program analysis and program rewriting

as powerful and flexible enforcement mechanisms.

This thesis investigates security-typed programming languages, which use static typ-ing to enforce information-flow security policies. These languages allow the programmer to specify confidentiality and integrity constraints on the data used in a program;
the compiler verifies that the program satisfies the constraints.

Previous theoretical security-typed languages research has focused on simple mod-els of computation and unrealistically idealized security policies. The existing practical

security-typed languages have not been proved to guarantee security. This thesis addresses these limitations in several ways.

First, it establishes noninterference, a basic information-flow policy, for languagesricher than those previously considered. The languages studied here include recursive,

higher-order functions, structured state, and concurrency. These results narrow the gapbetween the theory and the practice of security-typed languages.

Next, this thesis considers more practical security policies. Noninterference is oftentoo restrictive for real-world programming. To compensate, a restricted form of declassification is introduced, allowing programmers to specify a richer set of information-flowpolicies. Previous work on information-flow security also assumed that all computation
occurs on equally trusted machines. To overcome this unrealistic premise, additional
security constraints for systems distributed among heterogeneously trusted hosts areconsidered.

Finally, this thesis describes Jif/split, a prototype implementation of secure program
partitioning, in which a program can automatically be partitioned to run securely on

heterogeneously trusted hosts. The resulting communicating subprograms collectively
implement the original program, yet the system as a whole satisfies the security require-ments without needing a universally trusted machine. The theoretical results developed

earlier in the thesis justify Jif/split's run-time enforcement mechanisms.

BIOGRAPHICAL SKETCH

Steve was born on June 26, 1974 in Allentown, Pennsylvania to Arthur and DeborahZdancewic. After living briefly in Eastern Pennsylvania and California, his family,
which includes his brother, David, and sister, Megan, settled in Western Pennsylva-nia in the rural town of Friedens. His family remained there until the autumn of 1997,
when his parents moved back to Eastern PA.

Steve attended Friedens Elementary School and Somerset Area Junior and SeniorHigh Schools. His first computer, a Commodore 64, was a family Christmas gift in 1982.

Although he learned a smattering of Commodore BASIC1, he mainly used the computerto play games, the best of which were Jumpman, Archon, and the classic Bard's Tale.
Steve pursued his interest in computers through senior high school, although he never
took the programming courses offered there. His most influential high school teacherwas Mr. Bruno, who taught him Precalculus, Calculus I & II, and Statistics.

After graduating with Honors from Somerset Area Senior High in 1992, Steve enrolled in Carnegie Mellon University's Department of Electrical and Computer Engi-neering. Shortly into his second semester there, he decided that the computer science

courses were more fun than the engineering ones and transferred into the School ofComputer Science.

Steve graduated from Carnegie Mellon University with a B.S. in Computer Science
and Mathematics. He decided to continue his education by obtaining a Ph.D. and enteredCornell's CS department in the fall of 1996. There, he met Stephanie Weirich, also a

computer scientist, when they volunteered to organize the department's Fall picnic. BothSteve and Stephanie were recipients of National Science Foundation Fellowships and
Intel Fellowships; they also both spent the Summer of 1999 doing internships at Lucent
Technologies in Murray Hill, New Jersey. On August 14, 1999 Steve and Stephaniewere married in Dallas, Texas.

Steve received a M.S. in Computer Science from Cornell University in 2000, and a
Ph.D. in Computer Science in 2002.

1Anyone familiar with the Commodore machines will recall with fondness the arcane command
\Delta \Theta \Lambda \Xi  \Pi \Sigma \Upsilon \Phi \Psi \Omega  ff and the often used fi\Theta flffi ffl\Omega \Phi \Omega \Psi .

iii

ACKNOWLEDGEMENTS
First, I thank my wife, Stephanie Weirich, without whom graduate school would have
been nearly impossible to survive. She has been my best friend, my unfaltering com-panion through broken bones and job interviews, my source of sanity, my reviewer and

editor, my dinner partner, my bridge partner, my theater date, my hockey teammate, mymost supportive audience, my picnic planner, and my love. I cannot thank her enough.

Next, I thank my parents, Arthur and Deborah Zdancewic, my brother Dave and mysister Megan for their encouragement, love, and support. Thanks also to Wayne and
Charlotte Weirich, for welcoming me into their family and supporting me as they do
Stephanie.

I also thank my thesis committee. Andrew Myers, my advisor and friend, made it funto do research; his ideas, suggestions, questions, and feedback shaped this dissertation

more than anyone else's. Greg Morrisett advised me for my first three years at Cornell
and started me on the right path. Fred Schneider, with his sharp insights and unfailinglyaccurate advice, improved not only this thesis, but also my writing and speaking skills.

Karen Vogtmann challenged my mathematical abilities in her algebraic topology course.

I also thank Jon Riecke, whom I worked with one fun summer at Lucent Tech-nologies; our discussions that summer formed the starting point for the ideas in this

dissertation.

I am especially indebted to Nate Nystrom and Lantian Zheng, who not only did thebulk of the programming for the Jif and Jif/split projects, but also contributed immensely

to the results that make up Chapter 8.

Many, many thanks to my first set of officemates, Tug,kan Batu, Tobias Mayr, andPatrick White, who shared numerous adventures with me during our first years as graduate students. Thanks also to my second set of officemates: Dan Grossman and YanlingWang, from whom I've learned much. I also thank Dan for coffee filters, for grammatical and editorial acumen, and for always being prepared to talk shop.

Lastly, I would like to add to all of the above, a big thanks to many others who made
Ithaca such a fun place to be for the last six years:

Bert Adams, Gary Adams, Kavita Bala, Matthew Baram, Jennifer Bishop, James
Cheney, Bob Constable, Karl Crary, Jim Ezick, Adam Florence, Annette Florence, Neal

iv

Glew, Mark Hayden, Jason Hickey, Takako Hickey, Kim Hicks, Mike Hicks, Timmy
Hicks, Amanda Holland-Minkley, Nick Howe, Susannah Howe, David Kempe, DanKifer, Jon Kleinberg, Dexter Kozen, Lillian Lee, Lyn Millet, Tonya Morrisett, Riccardo

Pucella, Andrei Sabelfeld, Dave Walker, Vicky Weisman, and Allyson White.

This research was supported in part by a National Science Foundation Fellowship(1996 through 1999) and an Intel Fellowship (2001 through 2002).

vvi
TABLE OF CONTENTS
1 Introduction 1

1.1 Security-typed languages . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.2 Contributions and Outline . . . . . . . . . . . . . . . . . . . . . . . . . 9

2 Defining Information-Flow Security 11

2.1 Security lattices and labels . . . . . . . . . . . . . . . . . . . . . . . . 11

2.1.1 Lattice constraints . . . . . . . . . . . . . . . . . . . . . . . . 14
2.2 Noninterference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
2.3 Establishing noninterference . . . . . . . . . . . . . . . . . . . . . . . 19
2.4 Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

3 Secure Sequential Programs 23

3.1 \Delta \Delta \Theta \Lambda : a secure, simply-typed language . . . . . . . . . . . . . . . . . . 23

3.1.1 Operational semantics . . . . . . . . . . . . . . . . . . . . . . 25
3.1.2 An aside on completeness . . . . . . . . . . . . . . . . . . . . 29
3.1.3 \Delta \Delta \Theta \Lambda  type system . . . . . . . . . . . . . . . . . . . . . . . . . 29
3.1.4 Noninterference for \Delta \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . . 33
3.2 \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  : a secure language with state . . . . . . . . . . . . . . . . . . . . 38

3.2.1 Operational semantics . . . . . . . . . . . . . . . . . . . . . . 41
3.2.2 Type system . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
3.2.3 Noninterference for \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . . 49
3.3 Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

4 Noninterference in a Higher-order Language with State 52

4.1 CPS and security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53

4.1.1 Linear Continuations . . . . . . . . . . . . . . . . . . . . . . . 56
4.2 \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda : a secure CPS calculus . . . . . . . . . . . . . . . . . . . . . . . 56

4.2.1 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
4.2.2 Operational semantics . . . . . . . . . . . . . . . . . . . . . . 59
4.2.3 An example evaluation . . . . . . . . . . . . . . . . . . . . . . 61

vii

4.2.4 Static semantics . . . . . . . . . . . . . . . . . . . . . . . . . . 63
4.3 Soundness of \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
4.4 Noninterference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
4.5 Translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
4.6 Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88

5 Secure Concurrent Programs 89

5.1 Thread communication, races, and synchronization . . . . . . . . . . . 90

5.1.1 Shared memory and races . . . . . . . . . . . . . . . . . . . . 91
5.1.2 Message passing . . . . . . . . . . . . . . . . . . . . . . . . . 94
5.1.3 Synchronization . . . . . . . . . . . . . . . . . . . . . . . . . 97
5.2 \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  : a secure concurrent calculus . . . . . . . . . . . . . . . . . . 100

5.2.1 Syntax and operational semantics . . . . . . . . . . . . . . . . 100
5.2.2 \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  type system . . . . . . . . . . . . . . . . . . . . . . 108
5.2.3 Race prevention and alias analysis . . . . . . . . . . . . . . . . 117
5.3 Subject reduction for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . . . 122
5.4 Noninterference for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . . . . 127

5.4.1 \Theta -equivalence for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . 128
5.5 Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142

6 Downgrading 144

6.1 The decentralized label model . . . . . . . . . . . . . . . . . . . . . . 145
6.2 Robust declassification . . . . . . . . . . . . . . . . . . . . . . . . . . 147
6.3 Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149

7 Distribution and Heterogeneous Trust 151

7.1 Heterogeneous trust model . . . . . . . . . . . . . . . . . . . . . . . . 152
7.2 \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  : a secure distributed calculus . . . . . . . . . . . . . . . . . . . . 154

7.2.1 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
7.2.2 Operational semantics . . . . . . . . . . . . . . . . . . . . . . 155
7.2.3 Type system . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
7.3 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159

8 Jif/split 160

8.1 Jif: a security-typed variant of Java . . . . . . . . . . . . . . . . . . . . 162

8.1.1 Oblivious Transfer Example . . . . . . . . . . . . . . . . . . . 163
8.2 Static Security Constraints . . . . . . . . . . . . . . . . . . . . . . . . 165

8.2.1 Field and Statement Host Selection . . . . . . . . . . . . . . . 165
8.2.2 Preventing Read Channels . . . . . . . . . . . . . . . . . . . . 166
8.2.3 Declassification Constraints . . . . . . . . . . . . . . . . . . . 167

viii

8.3 Dynamic Enforcement . . . . . . . . . . . . . . . . . . . . . . . . . . 168

8.3.1 Access Control . . . . . . . . . . . . . . . . . . . . . . . . . . 1698.3.2 Data Forwarding . . . . . . . . . . . . . . . . . . . . . . . . . 169

8.3.3 Control Transfer Integrity . . . . . . . . . . . . . . . . . . . . 170
8.3.4 Example Control Flow Graph . . . . . . . . . . . . . . . . . . 1718.3.5 Control Transfer Mechanisms . . . . . . . . . . . . . . . . . . 172

8.4 Proof of Protocol Correctness . . . . . . . . . . . . . . . . . . . . . . . 1758.4.1 Hosts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176

8.4.2 Modeling Code Partitions . . . . . . . . . . . . . . . . . . . . 177
8.4.3 Modeling the Run-time Behavior . . . . . . . . . . . . . . . . 1788.4.4 The stack integrity invariant . . . . . . . . . . . . . . . . . . . 180

8.4.5 Proof of the stack integrity theorem . . . . . . . . . . . . . . . 183
8.5 Translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1928.6 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193

8.6.1 Benchmarks . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1948.6.2 Experimental Setup . . . . . . . . . . . . . . . . . . . . . . . . 194
8.6.3 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
8.6.4 Optimizations . . . . . . . . . . . . . . . . . . . . . . . . . . . 1978.7 Trusted Computing Base . . . . . . . . . . . . . . . . . . . . . . . . . 197

8.8 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
9 Conclusions 1999.1 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199

9.2 Future Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
BIBLIOGRAPHY 202

ix

LIST OF TABLES
8.1 Benchmark measurements . . . . . . . . . . . . . . . . . . . . . . . . 195

x

LIST OF FIGURES
3.1 \Delta \Delta \Theta \Lambda  grammar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
3.2 Standard large-step operational semantics for \Delta \Delta \Theta \Lambda  . . . . . . . . . . . 26
3.3 Labeled large-step operational semantics for \Delta \Delta \Theta \Lambda  . . . . . . . . . . . . 26
3.4 Subtyping for pure \Delta \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . . . . . . 30
3.5 Typing \Delta \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
3.6 \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  grammar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
3.7 Operational semantics for \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . . . 44
3.8 Value subtyping in \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . . . . . . 46
3.9 Value typing in \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
3.10 Expression typing in \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . . . . . 48

4.1 Examples of information flow in CPS . . . . . . . . . . . . . . . . . . 54
4.2 Syntax for the \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  language . . . . . . . . . . . . . . . . . . . . . . . 58
4.3 Expression evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
4.4 Example program evaluation . . . . . . . . . . . . . . . . . . . . . . . 62
4.5 Value typing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
4.6 Value subtyping in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . . . . . . 65
4.7 Linear value subtyping in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . . . 66
4.8 Linear value typing in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . . . . . 66
4.9 Primitive operation typing in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . 67
4.10 Expression typing in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  . . . . . . . . . . . . . . . . . . . . . . . . 68
4.11 CPS translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
4.12 CPS translation (continued) . . . . . . . . . . . . . . . . . . . . . . . . 85

5.1 Synchronization structures . . . . . . . . . . . . . . . . . . . . . . . . 99
5.2 Process syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
5.3 Dynamic state syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
5.4 \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  operational semantics . . . . . . . . . . . . . . . . . . . . . 104
5.5 \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  operational semantics (continued) . . . . . . . . . . . . . . . 105
5.6 Process structural equivalence . . . . . . . . . . . . . . . . . . . . . . 106
5.7 Network structural equivalence . . . . . . . . . . . . . . . . . . . . . . 107

xi

5.8 Process types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
5.9 \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  subtyping . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1105.10

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  value typing . . . . . . . . . . . . . . . . . . . . . . . . . . 1105.11
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  linear value types . . . . . . . . . . . . . . . . . . . . . . . . 111
5.12 \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  primitive operation types . . . . . . . . . . . . . . . . . . . . 1115.13 Process typing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112

5.14 Process typing (continued) . . . . . . . . . . . . . . . . . . . . . . . . 1135.15 Join pattern bindings . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
5.16 \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  heap types . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
5.17 \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  synchronization environment types . . . . . . . . . . . . . . 1165.18 Network typing rules . . . . . . . . . . . . . . . . . . . . . . . . . . . 116

5.19 Primitive operation simulation relation . . . . . . . . . . . . . . . . . . 130
5.20 Memory simulation relation . . . . . . . . . . . . . . . . . . . . . . . 1315.21 Synchronization environment simulation relation . . . . . . . . . . . . 131

5.22 Network simulation relation . . . . . . . . . . . . . . . . . . . . . . . 132
6.1 The need for robust declassification . . . . . . . . . . . . . . . . . . . 148
7.1 \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  operational semantics . . . . . . . . . . . . . . . . . . . . . . . 156
7.2 \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  operational semantics continued . . . . . . . . . . . . . . . . . . 1577.3

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  typing rules for message passing . . . . . . . . . . . . . . . . . . 158
7.4 \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  typing rules for primitive operations . . . . . . . . . . . . . . . . 158

8.1 Secure program partitioning . . . . . . . . . . . . . . . . . . . . . . . 1618.2 Oblivious transfer example in Jif . . . . . . . . . . . . . . . . . . . . . 164

8.3 Run-time interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1688.4 Control flow graph of the oblivious transfer program . . . . . . . . . . 171
8.5 Distributed implementation of the global stack . . . . . . . . . . . . . . 173
8.6 Host \Lambda 's reaction to transfer requests from host \Xi  . . . . . . . . . . . . . 175

xii

Chapter 1
Introduction
The widespread use of computers to archive, process, and exchange information via theInternet has led to explosive growth in e-commerce and on-line services. This increasing
connectivity of the web means that more and more businesses, individual users, and
organizations have come to depend critically on computers for day-to-day operation. Ina world where companies exist whose sole purpose is to buy and sell electronic data and

everyone's personal computer is connected to everyone else's, it is information itselfthat is valuable.

Protecting valuable information has long been a concern for security--cryptography,for example, has been in use for centuries [Sch96] Ironically, the features that make
computers so useful--the ease and speed with which they can duplicate, process, andtransmit data--are the same features that threaten information security.

This thesis focuses on two fundamental types of policies that relate to informationsecurity.

Confidentiality policies deal with disseminating data [BL75, Den75, GM82,
GM84]. They restrict who is able to learn information about a piece data and are in-tended to prevent secret information from becoming available to an untrusted party.

Integrity policies deal with generating data [Bib77]. They restrict what sources of in-formation are used to create or modify a piece of data and are intended to prevent an
untrusted party from corrupting or destroying it.

The approach is based on security-typed languages, in which extended type systems express security policies on programs and the data they manipulate. The compilerchecks the policy before the program is run, detecting potentially insecure programs before they can possibly leak confidential data, tamper with trusted data, or perform unsafe
actions. Security-typed languages have been used to enforce information-flow policiesthat protect the confidentiality and integrity of data [ABHR99, HR98, Mye99, PC00,

SV98, VSI96, ZM01b].

1

2
This thesis addresses the problem of how to provably enforce confidentiality and
integrity policies in computer systems using security-typed languages. 1For example, the following program declares

\Delta  to be a secret integer and \Theta  to be apublic integer:

\Lambda \Xi \Pi \Sigma \Upsilon \Phi \Psi \Omega \Phi \Pi ff \Delta fi
\Lambda \Xi \Pi \Sigma flffiffl\Theta \Lambda \Psi ff \Theta fi
\Pi  \Pi  \Pi  \Delta \Theta \Lambda \Xi  \Pi \Sigma \Upsilon \Phi \Psi  \Delta  \Omega \Phi \Lambda  \Theta  \Pi  \Pi  \Pi 

Conceptually, the computer's memory is divided into a low-security portion visibleto all parts of the system (the

flffiffl\Theta \Lambda \Psi  part) and a high-security portion visible onlyto highly trusted components (the

\Upsilon \Phi \Psi \Omega \Phi \Pi  part). Intuitively, the declaration that \Delta  is
\Upsilon \Phi \Psi \Omega \Phi \Pi  means that it is stored in the \Upsilon \Phi \Psi \Omega \Phi \Pi  portion of the memory and hence shouldnot be visible to any part of the system that does not have clearance to access secret data.

Of course, simply dividing memory into regions does not prevent learning about
high-security data indirectly, for instance by observing the behavior of a program thatalters the

flffiffl\Theta \Lambda \Psi  portion of the memory. For example, a program that copies \Upsilon \Phi \Psi \Omega \Phi \Pi 
data to a flffiffl\Theta \Lambda \Psi  variable is insecure. When the observable behavior of the programis affected by the

\Upsilon \Phi \Psi \Omega \Phi \Pi  data, the low-clearance program might be able to deduceconfidential information, which constitutes a security violation.

This model assumes that the low-security observer knows which program is beingrun and hence can correlate the observed behaviors of the program with its set of possible
behaviors to make deductions about confidential data. If the flffiffl\Theta \Lambda \Psi  observer is able to
infer some information about the contents of the \Upsilon \Phi \Psi \Omega \Phi \Pi  portion of data, there is saidto be an

information flow from \Upsilon \Phi \Psi \Omega \Phi \Pi  to flffiffl\Theta \Lambda \Psi . Information flows from flffiffl\Theta \Lambda \Psi  to
\Upsilon \Phi \Psi \Omega \Phi \Pi  are possible too, but they are permitted.These information flows arise for many reasons:

1. Explicit flows are information channels that arise from the ways in which thelanguage allows data to be assigned to memory locations or variables. Here is an

example that shows an explicit flow from the high-security variable \Delta  to a low-security variable

\Theta :

\Theta  ij \Delta fi
Explicit flows are easy to detect because they are readily apparent from the text of
the program.

1Confidentiality and integrity of data are of course not the only cause for concern in networked information systems, but they are essential components of information security. See Trust in Cyberspace[Sch99] for a comprehensive review of security challenges. Security-typed languages can enforce security

policies other than information flow, for example arbitrary safety policies [Wal00].

3
2. Implicit flows arise from the control-flow structure of the program. For example,

whenever a conditional branch instruction is performed, information about thecondition variable is propagated into each branch. The program below shows

an implicit flow from the high-security variable \Delta  to a low-security variable \Theta ; it
copies one bit of the integer \Delta  into the variable \Theta :

\Lambda ` '\Delta  ^ *_ \Pi \Delta \Phi \Xi  \Theta  ij * \Phi \Theta ,\Phi  \Theta  ij *
Similar information flows arise from other control mechanisms such as functioncalls,

ssae\Pi ae's, or exceptions.

3. Alias channels arise from sharing of a mutable resource that can be affected by

both high- and low-security data. For example, if memory locations are first-class constructs in the programming language, aliases between references can leak

information. In the following example, the expression \Omega \Phi ` * creates a reference
to the integer *, the expression oeo/ reads the value stored in the reference o/, andthe statement

AE ij * updates the location pointed to by reference AE to hold thevalue
*:

AE j \Omega \Phi ` *fi fffi\Xi \Omega fl\Xi  \Omega  fi\Xi ffi\Xi fi\Xi \Phi \Delta \Xi  AE fl\Theta  ffl\Omega i\Pi \Xi  j
o/ j AEfi fffi\Xi \Omega fl\Xi  \Omega \Phi  \Omega i\Upsilon \Omega \Sigma  o/ \Theta ffi AE
AE ij \Delta fi `\Sigma \Sigma \Upsilon \Psi \Phi '\Xi \Phi fl fl^fi\Theta \Pi \Psi ^ AE \Omega *\Xi \Delta fl\Sigma  \Delta \Theta \Phi fl\Xi \Phi fl\Sigma  \Theta ffi o/
\Theta  ij oeo/fi ff\Theta \Phi fl\Xi \Phi fl\Sigma  \Theta ffi \Delta  \Omega fi\Xi  \Sigma fl\Theta fi\Xi \Lambda  \Upsilon \Phi  \Theta 

Because the problem of determining when two program variables alias is, in gen-eral undecidable, the techniques for dealing with alias channels make use of conservative approximations to ensure that potential aliases (such as AE and o/) arenever treated as though their contents have different security levels.

4. Timing channels are introduced when high-security data influences the amountof time it takes for part of a program to run. The code below illustrates a timing

channel that transmits information via the shared system clock.

\Theta  ij \Pi \Lambda OE\Phi '_fi _\Xi fl fl^\Xi  \Delta \Pi fifi\Xi \Phi fl fl\Upsilon '\Xi 
\Lambda ` \Delta  \Pi \Delta \Phi \Xi  O/\Phi \Theta o/'**_fi *\Xi i\Omega , ss\Omega \Sigma \Xi \Lambda  \Theta \Phi  \Delta 
\Lambda ` '\Pi \Lambda OE\Phi '_ ! \Theta  " **_ ae\Xi \Xi  oe^\Xi fl^\Xi fi fl^\Xi fi\Xi  oe\Omega \Sigma  \Lambda \Xi i\Omega ,

\Pi \Delta \Phi \Xi  \Theta  ij * \Delta  \Upsilon \Sigma  ffi\Omega i\Sigma \Xi 
\Phi \Theta ,\Phi  \Theta  ij *fi \Delta  \Upsilon \Sigma  flfi\Pi \Xi 

The kind of timing channel shown above is internal to the program; the program
itself is able to determine that time has passed by invoking the \Pi \Lambda OE\Phi '_ routine.

4
This particular flow can be avoided by making the clock high-security, but concurrent threads may time each other without using the system clock.

A second kind of timing channel is external to the program, in the sense that a user
observing the time it takes for a program to complete is able to determine extrainformation about secret data, even if the program itself does not have access to

the system clock. One approach to dealing with external timing channels is toforce timing behavior to be independent of the high-security data by adding extra
delays [Aga00] (at a potentially severe performance penalty).
5. Abstraction-violation channels arise from under-specification of the context inwhich a program will be run. The level of abstraction presented to the programmer

by a language may hide implementation details that allow someone with knowledge of run-time environment to deduce high-security information.

For example, the memory allocator and garbage collector might provide an in-formation channel to an observer who can watch memory consumption behavior,

even though the language semantics do not rely on a particular implementation of
these features. Similarly, caching behavior might cause an external timing leakby affecting the program's running time. External timing channels are a form of

abstraction-violation--they are apparent only to an observer with access to the"wall clock" running time of the program.

These are the hardest sources of information flows to prevent as they are not cov-ered by the language semantics and are not apparent from the text or structure
of the program. While it is nearly impossible to protect against all abstraction-violation channels, it is possible to rule out more of them by making the language
semantics more specific and detailed. For instance, if one were to model the memory manager formally, then that class of covert channels might be eliminated. Ofcourse making such refined assumptions about the run-time environment means

that the assumptions are harder to validate--any implementation must meet the
specific details of the model.

Noninterference is the basic information-flow policy enforced by the security-typedlanguages considered in this thesis. It prohibits all explicit, implicit, and internal timing
information flows from \Upsilon \Phi \Psi \Omega \Phi \Pi  to flffiffl\Theta \Lambda \Psi .

Although the above discussion has focused on confidentiality, similar observations
hold for integrity: A low-integrity (#\Lambda \Xi \Pi \Phi O/) variable should not be able to influencethe contents of a high-integrity (

$\Xi \Pi \Lambda \Xi \Pi \Phi O/) variable. Thus, a security analysis shouldalso rule out explicit and implicit flows from

#\Lambda \Xi \Pi \Phi O/ to $\Xi \Pi \Lambda \Xi \Pi \Phi O/.
The security-typed languages in this thesis are designed to ensure noninterference,
but noninterference is often not the desired policy in practice. Many useful security

5
policies include intentional release of confidential information. For example, although
passwords are \Upsilon \Phi \Psi \Omega \Phi \Pi , the operating system authentication mechanism reveals informa-tion about the passwords--namely whether a user has entered a correct password.

Noninterference should be thought of as a baseline security policy from which othersare constructed. Practical security-typed languages include

declassification mechanisms
that allow controlled release of confidential data, relaxing the strict requirements of non-interference. Although noninterference results are the focus, this thesis also discusses

declassification and controlling its use.

1.1 Security-typed languages
Language-based security is a useful complement to traditional security mechanisms likeaccess control and cryptography because it can enforce different security policies.

Access-control mechanisms grant or deny access to a piece of data at particularpoints during the system's execution. For example, the read-write permissions provided by a file system prevent unauthorized processes from accessing the data at thepoint when they try to open the file. Such discretionary access controls are wellstudied [Lam71, GD72, HRU76] and widely used in practice.

Unlike traditional discretionary access-control mechanisms, a security-typed language provides end-to-end protection--the data is protected not just at certain points,but throughout the duration of the computation. To the extent that a system can be described as a program or a collection of communicating programs written in a securitytyped language, the compositional nature of the type-system extends this protectionsystem-wide.

As an example of the difference between information flow and access control, con-sider this policy: "the information contained in this e-mail may be obtained only by
me and the recipient." Because it controls information rather than access, this policy isconsiderably stronger than the similar access-control policy: "only processes authorized
by me or the recipient may open the file containing the e-mail." The latter policy does
not prohibit the recipient process from forwarding the contents of the e-mail (perhapscleverly encoded) to some third party.

Program analysis is a useful addition to run-time enforcement mechanisms such asreference monitors because such purely run-time mechanisms can enforce only safety
properties, which excludes many useful information-flow policies [Sch01]2. Run-timemechanisms can monitor sequences of actions and allow or deny them; thus, they can
enforce access control and capability-based policies. However, dynamic enforcement of

2This analysis assumes that the run-time enforcement mechanism does not have access to the program text; otherwise the run-time mechanism could itself perform program analysis. Run-time programanalysis is potentially quite costly.

6
information-flow policies is usually expensive and too conservative because information
flow is a property of all possible executions of a program, not just the single executionavailable during the course of one run [Den82].

Encryption is another valuable tool for protecting information security, and it is cru-cial in settings where data must be transmitted via an untrusted medium--for example
sending a secret over the Internet. However, encryption works by making it infeasible toextract information from the ciphertext without possessing a secret key. This property is
exactly what is needed for transmitting the data, but it also makes it (nearly) impossible
to compute usefully over the data; for instance it is difficult to create an algorithm thatsorts an encrypted array of data.

3 For such non-trivial computation to take place over

encrypted data, the data must be decrypted, at which point the problem again becomesregulating information flow through a computation.

The following examples illustrate scenarios in which access control and cryptog-raphy alone are insufficient to protect confidential data, but where security-typed languages can be used:

1. A home user wants a guarantee that accounting software, which needs accessto both personal financial data and a database of information from the software

company, doesn't send her credit records or other private data into the Internetwhenever it accesses the web to query the database. The software company does
not want the user to download the database because then proprietary information
might fall into the hands of a competitor. The accounting software, however, isavailable for download from the company's web site.

Security-typed languages offer the possibility that the user's home computer couldverify the information flows in the tax program after downloading it. That verification gives assurance that the program will not leak her confidential data, eventhough it communicates with the database.

With the rise of the Internet, such examples of mobile code are becoming a widespread phenomenon: Computers routinely download Java applets, web-scripts andVisual Basic macros. Software is distributed via the web, and dynamic software

updates are increasingly common. In many cases, the downloaded software comes
from untrusted or partially untrustworthy parties.

2. The ability for the sender of an e-mail to regulate how the recipient uses it is

an information-flow policy and would be difficult to enforce via access control.

3There are certain encryption schemes that support arithmetic operations over ciphertext so that
\Delta \Theta \Lambda \Xi \Pi \Sigma \Upsilon \Delta \Phi \Theta  \Delta  \Delta \Theta \Lambda \Xi \Pi \Sigma \Upsilon \Delta \Pi \Theta  \Lambda  \Delta \Theta \Lambda \Xi \Pi \Sigma \Upsilon \Delta \Phi  \Xi  \Pi \Theta , for example. They are too impractical to be used forlarge amounts of computation [CCD88].

7
While cryptography would almost certainly be used to protect confidential email and for authenticating users, the e-mail software itself could be written ina security-typed language.

3. Many programs written in C are vulnerable to buffer overrun and format stringerrors. The problem is that the C standard libraries do not check the length of

the strings they manipulate. Consequently, if a string obtained from an untrustedsource (such as the Internet) is passed to one of these library routines, parts of
memory may be unintentionally overwritten with untrustworthy data--this vulnerability can potentially be used to execute an arbitrary program such as a virus.

This situation is an example of an integrity violation: low-integrity data from theInternet should not be used as though it is trustworthy. Security-typed languages

can prevent these vulnerabilities by specifying that library routines require high-integrity arguments [STFW01, Wag00].

4. A web-based auction service allows customers to bid on merchandise. Multipleparties may bid on a number of items, but the parties are not allowed to see which

items others have bid on nor how much was bid. Because the customers do notnecessarily trust the auction service, the customer's machines share information
sufficient to determine whether the auction service has been honest. After the bidding period is over, the auction service reveals the winning bids to all participants.

Security policies that govern how data is handled in this auction scenario canpotentially be quite complex. Encryption and access control are certainly useful

mechanisms for enforcing these policies, but the client software and auction servercan be written in a security-typed language to obtain some assurance that the bids
are not leaked.

Despite the historical emphasis on policies that can be enforced by access controland cryptographic mechanisms, computer security concerns have advanced to the point
where richer policies are needed.

Bill Gates, founder of Microsoft, called for a new emphasis on what he calls "Trust-worthy Computing" in an e-mail memorandum to Microsoft employees distributed on

January 15, 2002. Trustworthy Computing incorporates not only the reliability andavailability of software, but also security in the form of access control and, of particular
relevance to this thesis, privacy [Gat02]:

Users should be in control of how their data is used. Policies for informationuse should be clear to the user. Users should be in control of when and if
they receive information to make best use of their time. It should be easy for

8
users to specify appropriate use of their information including controlling
the use of email they send.4

-Bill Gates, January 15, 2002

Trustworthy Computing requires the ability for users and software developers to ex-press complex security policies. Commercial operating systems offer traditional access
control mechanisms at the file-system and process level of granularity and web browserspermit limited control over how information flows to and from the Internet. But, as indicated in Gates' memo, more sophisticated, end-to-end policies are desired.

Security-typed languages provide a formal and explicit way of describing complexpolicies, making them auditable and enforceable via program analysis. Such automation is necessitated both by the complexity of security policies and by the sheer size of
today's programs. The security analysis can potentially reveal subtle design flaws thatmake security violations possible.

Besides complementing traditional enforcement mechanisms, security-typed lan-guages can help software developers detect security flaws in their programs. Just as
type-safe languages provide memory safety guarantees that rule out a class of program
errors, security-typed languages can rule out programs that contain potential informa-tion leaks or integrity violations. Security-typed languages provide more confidence

that programs written in them are secure.

Consider a developer who wants to create digital-signature software that is supposedto run on a smart card. The card provides the capability to digitally sign electronic data

based on a password provided by the user. Because the digital signatures authorizefurther computations (such as transfers between bank accounts), the password must be
protected--if it were leaked, anyone could forge the digital signatures and initiate bogus
transactions. Consequently, the developer would like some assurance that the digital-signature software does not contain any bugs that unintentionally reveal the password.

Writing the digital-signature software in a security-typed language would help improve
confidence in its correctness.

There is no magic bullet for security. Security-typed languages still rely in part on
the programmer to implement the correct policy, just as programmers are still trusted toimplement the correct algorithms. Nevertheless, security-typed languages provide a way

to ensure that the policy implemented by the programmer is self-consistent and that it
agrees with the policy provided at the program's interface to the external environment.For example, the operating system vendor can specify a security policy on the data

passed between the file system and applications written to use the file system. The
compiler of a security-typed language can verify that the application obeys the policy

4Is it ironic that the text of this e-mail was available on a number of web sites shortly after it was sent?

9
specified in the OS interface; therefore the OS vendor need not trust the applications
programmer. Symmetrically, the application writer need not trust the OS vendor.

Absolute security is not a realistic goal. Improved confidence in the security ofsoftware systems

is a realistic goal, and security-typed programming languages offer a
promising way to achieve it.

1.2 Contributions and Outline
This thesis develops the theory underlying a variety of security-typed languages, starting
with a simple toy language sufficient for sequential computation on a trusted computerand building up to a language for describing multithreaded programs. It also address the

problem of secure computation in a concurrent, distributed setting in which not all the
computers are equally trusted.

Chapter 2 introduces the lattice-model of information-flow policies and the notationused for it in this thesis. This chapter defines noninterference--making precise what

it means for a security-typed language to protect information security. This chapteris largely based on the existing work on using programming language technology to
enforce information-flow policies.

Chapter 3 gives an elementary proof of noninterference for a security-typed, purelambda calculus. This is not a new result, but the proof and the language's type system serve as the basis for the more complex ones presented later. Chapter 3 explainsthe proof and discusses the difficulties of extending it to more realistic programming
languages.

The subsequent chapters describe the main contributions of this thesis. The contri-butions are:

1. The first proof of noninterference for a security-typed language that includes highorder functions and state. This result is described in Chapter 4. The materialthere is drawn from a conference paper [ZM01b] and its extended version, which

appears in the Journal of Higher Order and Symbolic Computation special issue
on continuations [ZM01a]. The proofs of Soundness and Noninterference forthe language that appear in Sections 4.3 and 4.4 are adapted from a technical

report [ZM00]. Since the original publication of this result, other researchers
have proposed alternatives to this approach [PS02, HY02, BN02].

2. An extension of the above noninterference proof to the case of multithreaded programs. The main difficulty in a concurrent setting is preventing information leaksdue to timing and synchronization behavior. The main contribution of Chapter 5

is a proposal that, contrary to what is done in existing security-typed languages

10
for concurrent programs, internal timing channels should be controlled by eliminating race conditions entirely. This chapter gives a type system for concurrentprograms that eliminates information leaks while still allowing threads to communicate in a structured way.
3. The observation that declassification, or intentional release of confidential data,ties together confidentiality and integrity constraints. Because declassification

is a necessary part in any realistic secure system, providing a well-understoodmechanism for its use is essential. Chapter 6 explains the problem and a proposed
solution that is both simple and easy to put into practice. Intuitively, the decision
to declassify a piece of confidential information must be protected from beingtampered with by an untrusted source.

4. A consideration of the additional security requirements imposed when the system consists of a collection of distributed processes running on heterogeneouslytrusted hosts. Previous security-typed languages research has assumed that the underlying execution platform (computers, operating systems, and run-time support)is trusted equally by all of the principals whose security policies are expressed in
a program. This assumption violates the principle of least privilege. Furthermore,
it is unrealistic for scenarios involving multiple parties with mutual distrust (orpartial distrust)--the very scenarios for which multilevel security is most desirable
This approach, described in Chapter 7, is intended to serve as a model for understanding confidentiality and integrity in distributed settings in which the hostscarrying out the computation are trusted to varying degrees.

5. An account of a prototype implementation for obtaining end-to-end information-flow security by automatically partitioning a given source program to run in a

network environment with heterogeneously trusted hosts. This prototype, called
Jif/split, extends Jif [MNZZ01], a security-typed variant of Java, to include theheterogeneous trust model. Jif/split serves both as a test-bed and motivating application for the theoretical results described above.
The Jif/split prototype described in Chapter 8, which is adapted from a paper that
appeared in the Symposium on Operating Systems Principles in 2001 [ZZNM01]and a subsequent journal version that will appear in Transactions on Computer

Systems [ZZNM02]. The proof from 8.4 is taken in its entirety from the latter.
Finally, Chapter 9 concludes with a summary of the contributions and some futuredirections.

Chapter 2
Defining Information-Flow Security
This chapter introduces the lattice model for specifying confidentiality and integritylevels of data manipulated by a program. It then shows how to use those security-level
specifications to define the noninterference security policy enforced by the type systemsin this thesis.

2.1 Security lattices and labels
Security-typed languages provide a way for programmers to specify confidentiality andintegrity requirements in the program. They do so by adding explicit annotations at
appropriate points in the code. For example, the declaration \Lambda \Xi \Pi \Sigma \Upsilon \Phi \Psi \Omega \Phi \Pi ff \Delta  indicates
that \Delta  has confidentiality label \Upsilon \Phi \Psi \Omega \Phi \Pi .Following the work on multilevel security [BP76, FLR77, Fei80, McC87, MR92b]

and Denning's original work on program analysis [Den75, Den76, DD77], the securitylevels that can be ascribed to the data should form a lattice.

Definition 2.1.1 (Lattice) A lattice \Theta  is a pair \Lambda \Sigma \Upsilon  \Xi \Pi . Where \Sigma  is a set of elements
and \Xi  is a reflexive, transitive, and anti-symmetric binary relation (a partial order) on
\Sigma . In addition, for any subset \Phi  of \Sigma , there must exist both least upper and greatest
lower bounds with respect to the \Xi  ordering.

An upper bound for a subset \Phi  of \Sigma  is an element \Psi  \Sigma  \Sigma  such that \Omega  \Sigma  \Phi  \Upsilon  \Omega  \Xi  \Psi .
The least upper bound or join of \Phi  is an upper bound \Psi  such that for any other upper
bound ff of \Phi , it is the case that \Psi  \Xi  ff. It is easy to show that the least upper bound of a
set \Phi , denoted by \Phi , is uniquely defined. In the special case where \Phi  consists of two
elements \Omega fl and \Omega ffi, the notation \Omega fl \Phi  \Omega ffi is used to denote their join.

A lower bound for a subset \Phi  of \Sigma  is an element \Psi  \Sigma  \Sigma  such that \Omega  \Sigma  \Phi  \Upsilon  \Psi  \Xi  \Omega .
The greatest lower bound or meet of \Phi  is a lower bound \Psi  such that for any other
lower bound ff of \Phi , it is the case that ff \Xi  \Psi . It is easy to show that the greatest lower

11

12
bound of a set \Phi , denoted by \Phi , is uniquely defined. In the special case where \Phi 
consists of two elements \Omega fl and \Omega ffi, the notation \Omega fl \Psi  \Omega ffi is used to denote their meet.

Note that because a lattice is required to have a join for all subsets of \Sigma  there must

be a join for \Sigma  itself, denoted by \Omega  fflij\Delta  \Sigma . By definition, it must be the case that \Psi  \Xi  \Omega 
for any element \Psi  \Sigma  \Sigma , that is, \Omega  is the greatest or top element of the lattice. Similar
reasoning establishes that there is a least or bottom element of the lattice, denoted by

ff fflij\Delta  \Sigma .

One example of a confidentiality lattice is the classification used by the Department
of Defense in their "Orange Book" [DOD85]:

$\Xi \Psi \Theta ,,\Lambda `\Lambda \Phi O/ \Xi  %ae\Xi `\Lambda O/\Phi \Xi \Pi \Lambda \Theta  \Xi  \Upsilon \Phi \Psi \Omega \Phi \Pi  \Xi  #ae& \Upsilon \Phi \Psi \Omega \Phi \Pi 
An even simpler lattice that will be useful for examples in what follows is the two pointlattice:

ff \Xi  \Omega 
This lattice is just a renaming of the lattice already used in the examples at the beginningof this chapter:

flffiffl\Theta \Lambda \Psi  \Xi  \Upsilon \Phi \Psi \Omega \Phi \Pi 
Another example is a readers lattice that is generated from a set of principal identi-fiers,

fi . The elements of the lattice are given by fi\Theta fi \Lambda , the powerset of fi . The order
\Xi  is the reverse of the usual set inclusion. Intuitively, information about a piece of datalabeled with the set of principals

flflfl\Upsilon  \Pi  \Pi  \Pi  \Upsilon  fl\Delta ffi ffl fi should only be observable by mem-bers
flfl through fl\Delta . Thus the set fi itself is the most public element, and the empty set
(indicating that the information should be invisible to all principals) is the most confi-dential.

As an example of a readers lattice, consider the case where there are two principals,
Alice and Bob. The resulting label lattice is:

flffi

fl\Xi \Pi \Sigma \Upsilon \Phi ffi

\Delta 

\Delta \Delta \Delta \Delta \Delta \Delta 
\Delta \Delta \Delta \Delta \Delta 
\Delta \Delta \Delta \Delta 

fl\Psi \Omega ffffi

\Theta 
\Theta \Theta \Theta \Theta \Theta \Theta \Theta 

\Theta \Theta \Theta \Theta \Theta 

\Theta \Theta 

fl\Xi \Pi \Sigma \Upsilon \Phi \Upsilon  \Psi \Omega ffffi
\Theta 

\Lambda \Lambda \Theta \Theta \Theta \Theta \Theta 

\Theta \Theta \Theta \Theta \Theta 

\Theta  \Delta 

\Xi \Xi \Delta \Delta \Delta \Delta 
\Delta \Delta \Delta \Delta \Delta 
\Delta \Delta 

All of the lattices shown above are intended to describe confidentiality policies; lat-tices can also describe integrity policies. The simplest such lattice is:

$\Xi \Pi \Lambda \Xi \Pi \Phi O/ \Xi  #\Lambda \Xi \Pi \Phi O/

13
Note that this lattice is isomorphic to the flffiffl\Theta \Lambda \Psi  \Xi  \Upsilon \Phi \Psi \Omega \Phi \Pi  lattice. Why is that?
Intuitively, \Upsilon \Phi \Psi \Omega \Phi \Pi  information has more restrictions on where it can flow than flffiffl\Theta \Lambda \Psi information--

\Upsilon \Phi \Psi \Omega \Phi \Pi  data should not flow to a flffiffl\Theta \Lambda \Psi  variable, for instance. Similarly,
#\Lambda \Xi \Pi \Phi O/ information has more restrictions on its use than $\Xi \Pi \Lambda \Xi \Pi \Phi O/ information. Both
\Upsilon \Phi \Psi \Omega \Phi \Pi  and #\Lambda \Xi \Pi \Phi O/ data should be prevented from flowing to points lower in thelattice. Formally, confidentiality and integrity are duals [Bib77].

In view of this duality, in this thesis, high security means "high confidentiality" or"low integrity" and

low security means "low confidentiality" or "high integrity." Highand
low are informal ways of referring to relative heights in a lattice where \Psi fl \Xi  \Psi ffi
means that \Psi fl is bounded above by \Psi ffi and \Psi fl i\Xi  \Psi ffi means that \Psi fl is not bounded above by
\Psi ffi. The terminology "\Psi fl is protected by \Psi ffi" will also be used to indicate that \Psi fl \Xi  \Psi ffi--intuitively it is secure to treat data with label

\Psi fl as though it has label \Psi ffi because the
latter label imposes more restrictions on how the data is used.

As a final example of a security lattice, both integrity and confidentiality can be
combined by forming the appropriate product lattice, as shown below:

\Lambda \Upsilon \Phi \Psi \Omega \Phi \Pi \Upsilon  #\Lambda \Xi \Pi \Phi O/\Pi 
\Lambda flffiffl\Theta \Lambda \Psi \Upsilon  #\Lambda \Xi \Pi \Phi O/\Pi 

\Delta  \Pi \Pi \Lambda \Lambda \Lambda \Lambda \Lambda \Lambda \Lambda \Lambda \Lambda \Lambda \Lambda \Lambda 
\Lambda \Lambda \Lambda \Lambda 

\Lambda \Upsilon \Phi \Psi \Omega \Phi \Pi \Upsilon  $\Xi \Pi \Lambda \Xi \Pi \Phi O/\Pi 

\Theta \Sigma \Sigma \Xi \Xi \Xi \Xi \Xi \Xi \Xi \Xi \Xi \Xi \Xi \Xi \Xi 

\Xi \Xi \Xi \Xi 

\Lambda flffiffl\Theta \Lambda \Psi \Upsilon  $\Xi \Pi \Lambda \Xi \Pi \Phi O/\Pi 
\Theta 

\Sigma \Sigma \Xi \Xi \Xi \Xi \Xi \Xi \Xi 

\Xi \Xi \Xi \Xi \Xi \Xi \Xi \Xi 

\Xi  \Delta 

\Pi \Pi \Lambda \Lambda \Lambda \Lambda \Lambda \Lambda \Lambda 
\Lambda \Lambda \Lambda \Lambda \Lambda \Lambda \Lambda \Lambda 
\Lambda \Lambda 

The lattice elements are also used to describe the privileges of users of the program,hence determining what data should be visible to them. For instance, in the DoD lattice, a user with clearance \Upsilon \Phi \Psi \Omega \Phi \Pi  is able to learn information about $\Xi \Psi \Theta ,,\Lambda `\Lambda \Phi O/,
%\Theta ,,\Lambda `\Lambda \Phi O/, and \Upsilon \Phi \Psi \Omega \Phi \Pi  data, but should not learn anything about #ae& \Upsilon \Phi \Psi \Omega \Phi \Pi  data.

The choice of which lattice to use is dependent on the desired security policies andlevel of granularity at which data is to be tracked. For simple security, the DoD style lattice may suffice; for finer control over the security levels of data more complex lattices,
such as those found in Myers' and Liskov's decentralized label model [ML98, ML00]should be used.

Despite the importance of the security lattice with regard to the security policies that
can be expressed, it is useful to abstract from the particular lattice in question. Con-sequently, all of the results in this thesis are derived for an arbitrary choice of security

lattice.

14
2.1.1 Lattice constraints
The type systems in this thesis can be thought of as generating a system of lattice in-equalities based on security annotations of a program in question. For example, consider

the program that assigns the contents of the variable AE to the variable o/:

o/ ij AE
Suppose that the labels assigned to the variables AE and o/ are \Delta \Theta \Lambda \Xi \Delta \Theta AE\Lambda  and \Delta \Theta \Lambda \Xi \Delta \Theta o/\Lambda  respec-tively. The assignment is permissible if

\Delta \Theta \Lambda \Xi \Delta \Theta AE\Lambda  \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta o/\Lambda , because this constraint says
that AE contains more public (or less tainted) data than o/ is allowed to hold. Concretely,suppose that

\Delta \Theta \Lambda \Xi \Delta \Theta AE\Lambda  \Delta  \Upsilon \Phi \Psi \Omega \Phi \Pi  and \Delta \Theta \Lambda \Xi \Delta \Theta o/\Lambda  \Delta  flffiffl\Theta \Lambda \Psi . The program above wouldgenerate the constraint

\Upsilon \Phi \Psi \Omega \Phi \Pi  \Xi  flffiffl\Theta \Lambda \Psi , which is not satisfiable in the simple security
lattice. On the other hand, if \Delta \Theta \Lambda \Xi \Delta \Theta o/\Lambda  \Delta  \Upsilon \Phi \Psi \Omega \Phi \Pi , then the constraint \Delta \Theta \Lambda \Xi \Delta \Theta AE\Lambda  \Xi  \Upsilon \Phi \Psi \Omega \Phi \Pi is satisfiable no matter what

\Delta \Theta \Lambda \Xi \Delta \Theta AE\Lambda  is.
The lattice structure is used to approximate the information contained in a piece ofdata that results from combining two pieces of data. For example, the expression

AE " o/
is given the security label \Delta \Theta \Lambda \Xi \Delta \Theta AE\Lambda  \Phi  \Delta \Theta \Lambda \Xi \Delta \Theta o/\Lambda , which intuitively says that the expression
AE " o/ may reveal information about either AE or o/. If either AE or o/ is \Upsilon \Phi \Psi \Omega \Phi \Pi , then theresult of

AE " o/ is \Upsilon \Phi \Psi \Omega \Phi \Pi .
To determine whether the assignment ' ij AE " o/ is legal, we determine whetherthe constraint

\Delta \Theta \Lambda \Xi \Delta \Theta '\Lambda  \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta AE\Lambda  \Phi  \Delta \Theta \Lambda \Xi \Delta \Theta o/\Lambda  is satisfiable.
The type system generates similar lattice inequations for all of the program state-ments, reducing the problem of determining whether a program is secure to a latticeinequality constraint satisfaction problem. The correctness theorem for a security-typesystem says that if the constraints are satisfiable then the program does not leak information. The meaning of "does not leak information" is made precise in the next section.

The complexity of determining whether a program obeys the noninterference policy
rests on the ability to solve systems of lattice inequalities. In general, this problemis NP-complete for finite lattices: it is simple to reduce 3SAT to the lattice constraint

satisfaction problem because Boolean algebras constitute lattices and implication can be
encoded via \Xi .

There are properties of the security lattice and the system of inequalities that can
make it easier to determine whether a solution exists [RM96]. One possibility is that thesystem has only inequalities that can be written in the form

ffi \Xi  ffl \Phi  i, for example, and
does not contain more complex constraints like ffi \Psi  ffl \Xi  i \Phi  j. Disallowing meets on theleft of inequalities reduces the search space of candidate solutions.

Another useful lattice property is distributivity, which means that:

ffi \Psi  \Theta ffl \Phi  i\Lambda  \Delta  \Theta ffi \Psi  ffl\Lambda  \Phi  \Theta ffi \Psi  i\Lambda 

15
Distributivity alone is not enough to admit a polynomial time constraint satisfaction algorithm (Boolean algebras are also distributive). However, distributitivy allows inequal-ities to be put into normal forms that, with additional restrictions like the one above,

make efficient constraint satisfaction algorithms possible.

Despite the importance of obtaining tractable constraint sets from the type system,this thesis is not concerned with the complexity of solving the lattice constraints. Happily, however, practical applications often make use of distributive lattices (see Myers'and Liskov's Decentralized Label Model [ML98, ML00] for example). The constraints
generated by the type systems in this thesis also do not contain meets on the left of
inequalities.

2.2 Noninterference
This section describes a general methodology for defining information-flow security inprogramming languages. The goal is a formal definition of

noninterference, a basic security policy that intuitively says that high-security information cannot affect the resultsof low-security computation.

This thesis is concerned with regulating information flows that are internal to a program. In particular, the type systems presented attempt to address only informationflows that can be detected because they alter the behavior of a program as it runs. This

means that programs deemed to be secure might still contain external timing leaks orabstraction-violation channels.

For instance, the following Java-like1 insecure, under the assumption that the method
\Upsilon o/,\Pi \Phi OE(&\Omega \Lambda \Xi \Pi  prints to a public location:

\Psi \Theta ,, % \Sigma 

&ffiffl\Theta \Lambda \Psi  ,\Pi \Pi \Lambda \Psi  )ae\Lambda O/ OE\Lambda \Xi ',\Pi \Omega \Lambda \Xi ss*+ \Omega ss,_ \Sigma 

\Upsilon \Pi \Omega \Lambda \Xi ss\Sigma \Upsilon \Phi \Psi \Omega \Phi \Pi ff \Psi aeOEffl\Lambda \Xi \Pi \Lambda ae\Xi  j \Upsilon o/,\Pi \Phi OE(\Lambda \Xi &ffi\Pi '_fi
\Upsilon o/,\Pi \Phi OE(&\Omega \Lambda \Xi \Pi ',#\Delta \Phi  ,\Phi \Psi \Omega \Phi \Pi  \Psi aeOEffl\Lambda \Xi \Pi \Lambda ae\Xi  \Lambda , i , " \Psi aeOEffl\Lambda \Xi \Pi \Lambda ae\Xi _fi
ff
ff

Here, the value of the string stored in the variable \Psi aeOEffl\Lambda \Xi \Pi \Lambda ae\Xi  (which has been explicitly declared to be secret) affects the behavior of the program. The purpose of thesecurity-typed languages is to rule out these kind of information flows.

The basic approach to defining noninterference is the following. Each step is described in more detail below.

1Java's keyword \Delta ijfi`', in contrast to the label ^ijfi`', describes the scope of fields or methods, not
their confidentiality level. Such scoping mechanisms are considerably weaker than the information-flowpolicies described in this thesis.

16
1. Choose an appropriate formal model of computation equipped with a meaningful

(implementable) semantics. The language should have values--data objects--andprograms should describe computations over those values.

-\Upsilon  \Pi \Omega ffi\Phi \Upsilon  \Pi  \Pi  \Pi  \Sigma  \Pi \Theta \Delta \Sigma \Xi \Upsilon  ' ij AE " -\Upsilon  \Pi  \Pi  \Pi  \Sigma  \Phi \Psi \Omega ff\Psi \Theta fi\Upsilon 
2. Derive from the semantics a definition of program equivalence, starting from anapparent equivalence on the values of the language. This equivalence should be

sound with respect to the language semantics in the sense that equivalent programsshould produce equivalent observable results.

jfifl\Upsilon  fiffi \Sigma  \Phi \Psi \Omega ff\Psi \Theta fi\Upsilon \Pi  fifl ` fiffi ' \Pi  \Pi  \Pi 
3. Enrich the program model using a security lattice as described in the previoussection. This yields a way of specifying the high- and low-security interfaces

(written with a o/ ) to a program fi .
An interface o/ to a program describes a set of contexts in which it makes sense torun the program. In this thesis, the interfaces will be type environments that describe what variables or memory locations are available for use within the program
fi . Assertions like the following say that program fi has high- and low-securityinterfaces

o/\Delta \Theta \Lambda \Xi  and o/\Pi \Sigma \Upsilon :

o/\Delta \Theta \Lambda \Xi \Upsilon  o/\Pi \Sigma \Upsilon  ^ fi
4. Define the powers of the low-security observers of the system. This is doneby coarsening the standard notion of process equivalence

` to ignore the high-security parts of the program. This new equivalence,
`\Pi \Sigma \Upsilon  represents the lowsecurity view of the computation; it depends on the low-security interface to theprogram (

o/\Pi \Sigma \Upsilon ). Treating the equivalence relations as sets, coarsening ` is the
requirement that ` ffl `\Pi \Sigma \Upsilon .

5. Define a set of high-security inputs for the program, these values should matchthe interface

o/\Delta \Theta \Lambda \Xi , so that ` \Sigma  \Pi \Theta \Delta \Sigma \Xi \Upsilon \Theta o/\Delta \Theta \Lambda \Xi \Lambda .

6. Define noninterference from the above components: There is no illegal information flow through a program fi iff the low-security behavior of the program isindependent of what high-security inputs are given to the program. Formally,

fi \Sigma  \Phi \Psi \Omega ff\Psi \Theta fi\Upsilon  is information-flow secure (satisfies noninterference) iff

o/\Delta \Theta \Lambda \Xi \Upsilon  o/\Pi \Sigma \Upsilon  ^ fi \Upsilon  j`fl\Upsilon  `ffi \Sigma  \Pi \Theta \Delta \Sigma \Xi \Upsilon \Theta o/\Delta \Theta \Lambda \Xi \Lambda \Pi  fi \Theta `fl\Lambda  `\Pi \Sigma \Upsilon  fi \Theta `ffi\Lambda 

17
This basic recipe for defining information-flow security will be used in this thesis
for a variety of different programming languages. For each language, a type system thatestablishes noninterference for programs written in the language are given. However,

there are many details left unspecified in the high-level overview given above, so it is
worth going into each of the steps in more depth.

Step 1: Language definition
The first step is to choose a notion of program (or process, or system) that includesa computationally meaningful semantics. For example, one could pick the untyped
lambda calculus and give its semantics via '-reduction. Another choice could be theJava programming language with semantics given by translation to the bytecode interpreter (which in turn has its own semantics).

The language semantics should include an appropriate notion of the observable behavior of programs written in the language. The observable behavior is usually formal-ized as an evaluation relation between program terms and values computed (large-step

operational semantics), or perhaps a finer-grained model of the computation via a suitable abstract machine (small-step operational semantics).

Step 2: Program equivalence
The next step is to choose a basic definition of program equivalence; typically this equiv-alence is derived from and must respect the behavioral semantics of the language. For
example, one might choose '-^ equivalence for the untyped lambda calculus. Giv-ing an appropriate definition of equivalence for Java programs is considerably harder;
nevertheless, some well-defined notion of equivalence is necessary. (Programmers and
compiler writers make use of program equivalences all the time to reason about changesthey make to a program, so this is not an unreasonable requirement.)

The choice of language behavioral semantics, together with the accompanying equi-valence, determines the level of detail in the model. For example, the lambda calculus
provides a very abstract model of computation that is quite far from the behavior ofactual computers, whereas, in principle, one could characterize the precise operational
specification of a particular microprocessor.

There is a trade off between the accuracy of the information-flow analysis and thegenerality of the results. This thesis concentrates on a relatively abstract level of detail

in an idealized computer.

18
Step 3: Security types
It is impossible to define security without specifying a security policy to be enforced.Consequently, the next step in defining information-flow security is to enrich the programming language so it can describe the confidentiality or integrity of the data it ma-nipulates. This is done by associating a label, drawn from a security lattice, with the
types of the data manipulated by the program.

Consider the example Java-like program from the introduction:

\Psi \Theta ,, % \Sigma 

&ffiffl\Theta \Lambda \Psi  ,\Pi \Pi \Lambda \Psi  )ae\Lambda O/ OE\Lambda \Xi ',\Pi \Omega \Lambda \Xi ss*+ \Omega ss,_ \Sigma 

\Upsilon \Pi \Omega \Lambda \Xi ss\Sigma \Upsilon \Phi \Psi \Omega \Phi \Pi ff \Psi aeOEffl\Lambda \Xi \Pi \Lambda ae\Xi  j \Upsilon o/,\Pi \Phi OE(ss\Phi \Pi '_fi
\Upsilon o/,\Pi \Phi OE(&\Omega \Lambda \Xi \Pi ',#\Delta \Phi  ,\Phi \Psi \Omega \Phi \Pi  \Psi aeOEffl\Lambda \Xi \Pi \Lambda ae\Xi  \Lambda , i , " \Psi aeOEffl\Lambda \Xi \Pi \Lambda ae\Xi _fi
ff
ff

The declaration \Upsilon \Pi \Omega \Lambda \Xi ss\Sigma \Upsilon \Phi \Psi \Omega \Phi \Pi ff indicates that the variable contains secret data. Asimilar annotation on the

&\Omega \Lambda \Xi \Pi  method can indicate that its \Upsilon \Pi \Omega \Lambda \Xi ss argument is printed
to a console visible to the public--&\Omega \Lambda \Xi \Pi  constitutes a channel through which the pro-gram's behavior can be observed. In Java-like notation,

2 &\Omega \Lambda \Xi \Pi 's type can be written as:

)ae\Lambda O/ \Upsilon o/,\Pi \Phi OE(&\Omega \Lambda \Xi \Pi '\Upsilon \Pi \Omega \Lambda \Xi ss\Sigma flffiffl\Theta \Lambda \Psi ff AE_Except where Java or Jif programs are considered (see Chapters 6 and 8), this thesis

adopts a more abstract syntax for security types. If * is a type in the language and \Psi  is
a security label, then *\Theta  is a security type. This notation is more compact than the *\Sigma \Psi ffused in the example above.

Step 4: Low-security behavioral equivalence
The next step is to define an appropriate notion of low-level or low-security equivalence.
Intuitively, this equivalence relation hides the parts of the program that should not bevisible to a low-level observer.

For example, consider the set of states consisting of pairs \Lambda \Lambda \Upsilon  _\Pi , where \Lambda  rangesover some high-security data and

_ ranges over low-security data. An observer withlow-security access (only permitted to see the

_ component) can see that the states
\Lambda \Pi \Pi \Psi . \Pi  O//\Xi \Upsilon  fi\Pi  and \Lambda O/ae \Xi ae\Pi  \Pi \Pi \Psi .\Upsilon  fl\Pi  are different (because fi i\Delta  fl), but willbe unable to distinguish the states

\Lambda \Pi \Pi \Psi . \Pi  O//\Xi \Upsilon  fi\Pi  and \Lambda O/ae \Xi ae\Pi  \Pi \Pi \Psi .\Upsilon  fi\Pi . Thus,with respect to this view (
`\Pi \Sigma \Upsilon ):

\Lambda \Pi \Pi \Psi . \Pi  O//\Xi \Upsilon  fi\Pi  `\Pi \Sigma \Upsilon  \Lambda O/ae \Xi ae\Pi  \Pi \Pi \Psi .\Upsilon  fi\Pi 
\Lambda \Pi \Pi \Psi . \Pi  O//\Xi \Upsilon  fi\Pi  i`\Pi \Sigma \Upsilon  \Lambda O/ae \Xi ae\Pi  \Pi \Pi \Psi .\Upsilon  fl\Pi 

2In more traditional type-theoretic notation, this type might be written as:
*_*,\Xi ssae\Delta oe`o/, AE *,oe`o/OEO/^ijfi`' \Theta  io/`,

19
It is necessary to generalize this idea to include other parts of the program besides
its state--the computations must also have a suitable notion of low equivalence. Thechoice of observable behavior impacts the strength of the noninterference result. For

example, if the equivalence on computations takes into account running time, then noninterference will require that high-security information not affect the timing behaviorof the program. This thesis, as elsewhere in the security literature, generalizes lowequivalence to computations via appropriate bisimulation relations [LV95, Mil89].Also, because the security lattice contains many points, and the program should be
secure only if all illegal information flows are ruled out, we must also generalize to
equivalence relations indexed by an arbitrary lattice element \Psi . The relation `\Theta  repre-sents the portion of the computation visible to an observer at security level

\Psi .

Step 5: High-security inputs
Because we are interested in preventing information flows from high-security sourcesto lower-security computation, we must specify how the high-security information is

generated. The next step of defining information flows is to pick an appropriate notionof high-security inputs.

For simple datatypes such as Booleans and integers, any value of the appropriate type
is suitable as a high-security input. However, if the high-security input is a functionor some other higher-order datatype (like an object), then this input itself can lead to

insecure behavior--when the insecure function is invoked, for instance.

Any security analysis that establishes noninterference must guarantee that insecureinputs are not used by the program. In practice, this can be accomplished by analyzing

the inputs, i.e. requiring them to type check.

Step 6: Noninterference
Combining the steps above, we obtain a suitable definition of noninterference:

o/\Delta \Theta \Lambda \Xi \Upsilon  o/\Pi \Sigma \Upsilon  ^ fi \Upsilon  j`fl\Upsilon  `ffi \Sigma  \Pi \Theta \Delta \Sigma \Xi \Upsilon \Theta o/\Delta \Theta \Lambda \Xi \Lambda \Pi  fi \Theta `fl\Lambda  `\Pi \Sigma \Upsilon  fi \Theta `ffi\Lambda 
This definition says that a program fi is secure if changing the high-security values of
the initial state does not affect the low-security observable behavior of the program.

2.3 Establishing noninterference
The security-typed languages studied in this thesis rule out insecure information flowsby augmenting the type system to constrain how high-security data is handled by the
program. To connect these nonstandard type systems to information security, we must

20
prove that well-typed programs satisfy an appropriate definition of noninterference. As
we have seen, noninterference is a statement about how the program behaves. Thereforeone must connect the static analysis of a program to the program's operational behavior.

As with ordinary type systems, the main connection is a soundness theorem that implies
that well-typed programs do not exhibit undesired behavior (such as accessing initializedmemory locations).

In the case of information-flow properties, we take this proof technique one step fur-ther: we instrument the operational semantics of the programming language to include
labels. This nonstandard operational semantics is constructed so that it tracks information flows during program execution. For example, suppose that the standard semanticsfor the language specifies integer addition using rules like

fiffi fl * ffl, where the * symbolcan be read as "evaluates to". The labeled operational semantics requires that the values

fi and fl to be tagged with security labels. Supposing that the labels are drawn from thetwo point lattice, we might have

fi\Lambda  and fl\Xi . The nonstandard rule for arithmetic addition would show that fi\Lambda  ffi fl\Xi  * ffl`\Lambda \Pi \Xi ', where we use the lattice join operation (\Phi ) tocapture that the resulting value reveals information about both of the operands.

Importantly, the instrumented operational semantics agrees with the original semantics: erasing all of the additional label information from an execution trace of the non-standard programs yields a valid execution trace of the standard program. This implies

that any results about the nonstandard operational semantics apply to the standard pro-gram as well. This

erasure property is also important, because it means that, eventhough the instrumented operational semantics makes use of labels at run time, a real

implementation of the security-typed language does not need to manipulate labels at runtime.

The strategy adopted in this thesis for establishing noninterference thus consists of
four steps.

1. Construct a labeled operational semantics safely approximates the informationflows in a program.

2. Show that the security type system is sound with respect to the nonstandard semantics.

3. Use the additional structure provided by the labeled semantics to show that non-interference conditions hold for instrumented programs.

4. Use the erasure property to conclude that the standard behavior of a program

agrees with the nonstandard behavior, which implies that the standard programsatisfies noninterference.

The next three chapters illustrate this process for three different languages that incorporate increasingly rich programming features.

21
2.4 Related work
There is a considerable amount of work related to specifying noninterference-styleinformation-policies and generalizing those definitions to various models of computation.

The enforcement of information-flow policies in computer systems has its inceptionin Bell and La Padula's work on a multi-level security policy for the MULTICS operating

system [BL75]. At roughly the same time, Denning proposed the lattice-model of secure
information flow [Den76] followed by a means of certifying that programs satisfy astrong information-flow policy [DD77]. However, no correctness result was given for

this approach, partly due to a lack of a formal characterization of what it means for a
program to be insecure.

Goguen and Meseguer addressed this problem of formalizing information-securityby proposing the first definition of noninterference in 1982 [GM82]. The intuitions

underlying their definition of noninterference are the same as those used to motivatethe definition of noninterference in this thesis. Their original definition was suitable for
deterministic state machines and used traces of states to represent systems, rather thanthe language and context formulation used here.

Many definitions of information security similar to noninterference have been proposed, and there is no general agreement about which definition is appropriate for whatscenarios. Two major classifications of security properties have emerged.

In the possibilistic setting, the set of possible outcomes that might result from a
computation are considered the important factor [Sut86, McC88, McL88b, McL88a,McL90, WJ90, McL94, ZL97, Zha97]. A system is considered possibilistically secure

if the actions of a high-security observer do not affect the set of possible outcomes.
Probabilistic security, in contrast, requires that high-security events are not able to affectthe probability distribution on the possible outcomes of a system [Gra90, Gra91, GS92].

For sequential programs, possibilistic and probabilistic security coincide--there is only
one possible outcome of running the system and it occurs with probability 1.

The results in the work discussed above are presented at the level of state machinesthat represent an entire system, typically a whole computer or complete program. Security properties are expressed as predicates over sets of traces which correspond toruns of the state machine on various inputs. This level of detail abstracts away from the
implementation details of the system, which is good from the point of view of specifica-tion, but does not contain enough detail to give rise to any principle for building secure
system. Sabelfeld and Mantel bridge the gap between the labeled transition models and
programming-languages approaches to information security [MS01] by showing how toencode the actions of a simple programming language in the labeled transition model.

The definition of noninterference used here is closer to those used in the programming languages community [VSI96, HR98, PC00] and is equivalent to them for se22
quential programs. The presentation of nointerference in this thesis draws on the idea
contextual equivalence [Mor68].Language-based security extends beyond information-flow control [SMH00]. Work

on Typed Assembly Language [MWCG99, MCG^99, CWM99] and proof-carrying
code [Nec97] emphasizes static checking of program properties. In-lined referencemonitors [ES99, ET99] use code rewriting techniques to enforce security policies on existing software. Buffer overflow detection, a common source of security holes, has alsobeen treated via static program analysis [LE01] and dynamic techniques [CPM

^98].Chapter 3

Secure Sequential Programs

This chapter introduces two secure source calculi. They serve as examples of the basicmethodology introduced in Chapter 2, and the remainder of this thesis builds on them.

The first language, \Delta \Delta \Theta \Lambda , is a case study for introducing the basic definitions and notation. It is a purely functional, simply-typed lambda calculus that includes the minimalextensions for expressing confidentiality policies. Section 3.1 describes

\Delta \Delta \Theta \Lambda  in detail,explains its type system, and proves that well-typed programs enjoy the noninterference

security property.

The second language, \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  , serves as a vehicle for discussing the problems of information flows that can occur through side effects in a program. It extends \Delta \Delta \Theta \Lambda  withmutable state and recursion, to obtain a Turing-complete language. The type system for

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  must be more complicated to account for information flows that can arise fromaliasing and mutations to the store. Section 3.2 describes the language, its operational
semantics and the type system for ensuring security. Noninterference is not proved for
\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  directly; instead, that result is obtained in Chapter 4 using a semantics-preservingtranslation into a CPS-style language.

3.1 \Delta ij`: a secure, simply-typed language
Figure 3.1 describes the grammar for \Delta \Delta \Theta \Lambda , a purely functional variant of the simply-typed lambda calculus that includes security annotations. This language is a simplified
variant of the SLam calculus, developed by Heintze and Riecke [HR98].

In the grammar, the metavariables \Psi  and flffi range over elements of the security lat-tice. The possible types include the type

fflaeae\Theta  of Boolean values and the types of functions \Theta * _ *\Lambda  that expect a security-annotated value as an argument and produce asecurity-annotated type as a result. Security types, ranged over by the metavariable

*,
are just ordinary types labeled with an element from the security lattice.

23

24
\Psi \Upsilon  flffi \Sigma  \Theta  Security labels

* ''\Delta  fflaeae\Theta  Boolean type

* * _ * Function type

* ''\Delta  *\Theta  Security types
ffl` ''\Delta  \Pi  * ` Boolean base values

* \Delta \Omega  ' *\Pi  , Functions

` ''\Delta  \Omega  Variables

* ffl`\Theta  Secure Values

, ''\Delta  ` Values

* , , Function application
* , , , Primitive operations
* \Lambda ` , \Pi \Delta \Phi \Xi  , \Phi \Theta ,\Phi  , Conditional

, ''\Delta  ss * ae * \Pi  \Pi  \Pi  Boolean operations

Figure 3.1: \Delta \Delta \Theta \Lambda  grammar
Base values, in the syntactic class ffl`, include the Boolean constants for true and falseas well as function values. All computation in a security-typed language operates over
secure-values, which are simply base values annotated with a security label. Variables,ranged over by the metavariable

\Omega , denote secure values.

Expressions include values, primitive Boolean operations such as the logical "and"operation

ss, function application, and a conditional expression.

To obtain the underlying unlabeled lambda-calculus term from a \Delta \Delta \Theta \Lambda  term, we simply erase the label annotations on security types and secure values. For any \Delta \Delta \Theta \Lambda  term
,, let \Xi \Psi \Theta \Upsilon \Xi \Theta ,\Lambda  be its label erasure. The resulting language is identical to standard definitions of the simply typed lambda-calculus [Mit96].

Definition 3.1.1 (Free and Bound Variables) Let ^*_*\Theta ,\Lambda  be the set of all variables occurring in an expression ,. The free and bound variables of an expression , are defined
as usual for the lambda calculus. They are denoted by the functions ,^\Theta oe\Lambda  and ff^\Theta oe\Lambda 

25
respectively:

,^\Theta \Pi \Theta \Lambda  \Delta  o/
,^\Theta `\Theta \Lambda  \Delta  o/
,^\Theta \Theta \Delta \Omega  ' *\Pi  ,\Lambda \Theta \Lambda  \Delta  ,^\Theta ,\Lambda  AE fl\Omega ffi

,^\Theta ,fl ,ffi\Lambda  \Delta  ,^\Theta ,fl\Lambda  OE ,^\Theta ,ffi\Lambda 
,^\Theta ,fl , ,ffi\Lambda  \Delta  ,^\Theta ,fl\Lambda  OE ,^\Theta ,ffi\Lambda 
,^\Theta \Lambda ` , \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi\Lambda  \Delta  ,^\Theta ,\Lambda  OE ,^\Theta ,fl\Lambda  OE ,^\Theta ,ffi\Lambda 

ff^\Theta ,\Lambda  \Delta  ^*_*\Theta ,\Lambda  AE ,^\Theta ,\Lambda 
Following Barendregt[Bar84], this thesis uses the bound variable convention: theterms are identified up to consistent renaming of their bound variables. Two such terms
are said to be ss-equivalent, and this is indicated by the notation ,fl \Delta \Lambda  ,ffi. Usually,however, terms will be considered to implicitly stand for their

\Delta \Lambda -equivalence classes;
consequently, bound variables may be renamed so as not to conflict.

Definition 3.1.2 (Program) A program is an expression , such that ,^\Theta ,\Lambda  \Delta  o/. Such
an expression is said to be closed. Expressions that contain free variables are open.

3.1.1 Operational semantics
For simplicity, we give \Delta \Delta \Theta \Lambda  a large-step operational semantics. The standard evaluationrelation is of the form

, *\Xi  `, which means that the (closed) program , evaluates to the
value `. The definition of the *\Xi  relation is given in Figure 3.2.1 Figure 3.3 showsthe instrumented operational semantics, which is derived from the standard operational

semantics by adding labels.

Values evaluate to themselves; they require no further computation, as indicated by
the rule \Delta \Delta \Theta \Lambda -EVAL-VAL .

Binary Boolean operators are evaluated using the rule \Delta \Delta \Theta \Lambda -EVAL-BINOP . Here,the notation

ssss,aeae is the standard semantic function on primitive values corresponding to
the syntactic operation ,. For example:

\Pi  ssssssaeae \Pi  \Delta  \Pi 
\Pi  ssssssaeae ` \Delta  `
` ssssssaeae \Pi  \Delta  `
` ssssssaeae ` \Delta  `

1The box at the top of the figure (and subsequent figures in this thesis) illustrates the form of the
relation defined by the figure. Rules are named by appending a short description in SMALL CAPS to thename of the language to which the rule pertains.

26
, *\Xi  `

\Delta \Delta \Theta \Lambda -SEVAL-VAL ` *\Xi  `

\Delta \Delta \Theta \Lambda -SEVAL-BINOP

,fl *\Xi  ffl`fl ,ffi *\Xi  ffl`ffi
,fl , ,ffi *\Xi  ffl`flssss,aeaeffl`ffi

\Delta \Delta \Theta \Lambda -SEVAL-COND1

, *\Xi  \Pi  ,fl *\Xi  `
\Lambda ` , \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi *\Xi  `

\Delta \Delta \Theta \Lambda -SEVAL-COND2

, *\Xi  ` ,ffi *\Xi  `
\Lambda ` , \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi *\Xi  `

\Delta \Delta \Theta \Lambda -SEVAL-APP

,fl *\Xi  \Delta \Omega  ' *\Pi  , ,ffi *\Xi  ` ,fl`ae\Omega ffi *\Xi  `\Sigma 

,fl ,ffi *\Xi  `\Sigma 

Figure 3.2: Standard large-step operational semantics for \Delta \Delta \Theta \Lambda 

, * `

\Delta \Delta \Theta \Lambda -EVAL-VAL ` * `

\Delta \Delta \Theta \Lambda -EVAL-BINOP

,fl * \Theta ffl`fl\Lambda \Theta \Delta  ,ffi * \Theta ffl`ffi\Lambda \Theta \Theta 
,fl , ,ffi * \Theta ffl`flssss,aeaeffl`ffi\Lambda `\Theta \Delta \Pi \Theta \Theta '

\Delta \Delta \Theta \Lambda -EVAL-COND1

, * \Pi \Theta  ,fl * `
\Lambda ` , \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi * ` \Phi  \Psi 

\Delta \Delta \Theta \Lambda -EVAL-COND2

, * `\Theta  ,ffi * `
\Lambda ` , \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi * ` \Phi  \Psi 

\Delta \Delta \Theta \Lambda -EVAL-APP

,fl * \Theta \Delta \Omega  ' *\Pi  ,\Lambda \Theta  ,ffi * ` ,fl`ae\Omega ffi * `\Sigma 

,fl ,ffi * `\Sigma  \Phi  \Psi 

Figure 3.3: Labeled large-step operational semantics for \Delta \Delta \Theta \Lambda 

27
As shown in the evaluation rule, the labels on the arguments to the binary operation are
joined to produce the label on the result. This is necessary because it is possible to learninformation about the arguments based on the outcome of the operation. As a simple

example, we have:

\Pi \Lambda  ss `\Xi  * `\Lambda 

The pair of rules \Delta \Delta \Theta \Lambda -EVAL-COND1 and \Delta \Delta \Theta \Lambda -EVAL-COND2 describe the behav-ior of conditional expressions. First, the conditional expression is evaluated to a Boolean

value. If the result is \Pi \Theta  the first branch is evaluated, otherwise the second branch is. Theconfidentiality label

\Psi  of the \Lambda ` guard propagates to the result of the condition expressionbecause the result depends on information contained in the guard.

The notation ` \Phi  \Psi  in these rules is a convenient abbreviation used throughout thisthesis. This operation simply joins the label

\Psi  into the label tagging a secure value:

Definition 3.1.3 (Label Stamping) Let ffl`\Theta  be any secure value and \Psi \Sigma  be any label in
the security lattice.

ffl`\Theta  \Phi  \Psi \Sigma  fflij\Delta  ffl``\Theta \Pi \Theta \Delta '

As an example of how this operational semantics propagates the security labels toaccount for information flows, we have the following derivation tree, which says that
the results of branching on high-security data are high-security:

\Pi \Lambda  * \Pi \Lambda  \Pi \Xi  * \Pi \Xi 
\Lambda ` \Pi \Lambda  \Pi \Delta \Phi \Xi  \Pi \Xi  \Phi \Theta ,\Phi  `\Xi  * \Pi \Lambda 

Finally, rule \Delta \Delta \Theta \Lambda -EVAL-APP shows the operational behavior of function applica-tion. The left expression must evaluate to a function value. The right expression must
evaluate to a value. Finally the actual parameter to the function call is substituted for the
bound variable in the body of the function to obtain the result.

The application rules make use of capture-avoiding substitution, a concept usedthroughout this thesis:

Definition 3.1.4 (Capture-Avoiding Substitution) Let ,fl and ,ffi be expressions and
let \Omega  be a variable. The capture-avoiding substitution of ,fl for \Omega  within ,ffi is written
,ffifl,flae\Omega ffi. Such a substitution is well defined when ,^\Theta ,fl\Lambda O/ff^\Theta ,ffi\Lambda  \Delta  o/, that is, whenever
none of the binding occurrences of variables in ,ffi can capture the free variables of ,fl.
Note that it is always possible to choose a term ss-equivalent to ,ffi so that substitution
may occur.

A substitution ,ffifl,flae\Omega ffi results in a new term in which the free occurrences of the
variable \Omega  in ,fl have been replaced by the expression ,fl. It is defined inductively on the

28
structure of ,ffi:

\Omega fl,flae\Omega ffi fflij\Delta  ,fl

oefl,flae\Omega ffi fflij\Delta  oe (when \Omega  i\Delta  oe)
\Pi \Theta fl,flae\Omega ffi fflij\Delta  \Pi \Theta 
`\Theta fl,flae\Omega ffi fflij\Delta  `\Theta 
\Theta \Delta oe ' *\Pi  ,\Lambda \Theta fl,flae\Omega ffi fflij\Delta  \Theta \Delta oe ' *\Pi  ,fl,flae\Omega ffi\Lambda \Theta  (\Omega  i\Delta  oe by assumption)

\Theta , ,\Sigma \Lambda fl,flae\Omega ffi fflij\Delta  \Theta ,fl,flae\Omega ffi ,\Sigma fl,flae\Omega ffi\Lambda 
\Theta \Lambda ` , \Pi \Delta \Phi \Xi  ,\Sigma  \Phi \Theta ,\Phi  ,\Sigma \Sigma \Lambda fl,flae\Omega ffi fflij\Delta  \Lambda ` ,fl,flae\Omega ffi \Pi \Delta \Phi \Xi  ,\Sigma fl,flae\Omega ffi \Phi \Theta ,\Phi  ,\Sigma \Sigma fl,flae\Omega ffi

In \Delta \Delta \Theta \Lambda -EVAL-APP the security label on the function being applied is stamped intothe results of calling the function. Such a restriction, in combination with the rule for

conditionals, prevents information flows that arise when high-security data influences
the choice of which function gets applied to a piece of data.As an example, consider the following program that applies either the Boolean identity or Boolean negation, based on high-security information. It also results in a high-security value:

\Theta \Lambda ` `\Lambda  \Pi \Delta \Phi \Xi  \Theta \Delta \Omega  ' fflaeae\Theta \Xi \Pi  \Omega \Lambda \Xi  \Phi \Theta ,\Phi  \Theta \Delta \Omega  ' fflaeae\Theta \Xi \Pi  \Omega  \Upsilon  `\Xi \Lambda \Xi \Lambda  \Pi \Xi  * `\Lambda 
This program shows the propagation of a high-security label through the conditionalexpression and then through the resulting function application, as seen in these subderivations that are part of its evaluation:

\Delta \Lambda  \Delta  \Delta \Lambda  \Delta \Delta \Theta  \Theta  \Theta \Lambda \Lambda \Xi \Xi \Lambda  \Theta  \Theta  \Delta \Xi \Lambda \Xi  \Delta  \Delta \Delta \Theta  \Theta  \Theta \Lambda \Lambda \Xi \Xi \Lambda  \Theta  \Theta  \Delta \Xi \Lambda \Xi 
\Delta \Pi \Delta  \Delta \Lambda  \Sigma \Upsilon \Phi \Psi  \Delta \Delta \Theta  \Theta  \Theta \Lambda \Lambda \Xi \Xi \Lambda  \Theta \Lambda \Xi  \Phi \Xi \Omega \Phi  \Delta \Delta \Theta  \Theta  \Theta \Lambda \Lambda \Xi \Xi \Lambda  \Theta  \Theta  \Delta \Xi \Lambda \Xi \Lambda  \Delta  \Delta \Delta \Theta  \Theta  \Theta \Lambda \Lambda \Xi \Xi \Lambda  \Theta  \Theta  \Delta \Xi \Lambda \Lambda 

\Theta \Delta \Omega  ' fflaeae\Theta \Xi \Pi  \Omega  \Upsilon  `\Xi \Lambda \Lambda  * \Theta \Delta \Omega  ' fflaeae\Theta \Xi \Pi  \Omega  \Upsilon  `\Xi \Lambda \Lambda  \Pi \Xi  * \Pi \Xi 

\Pi \Xi  * \Pi \Xi  `\Xi  * `\Xi 
\Theta \Omega  \Upsilon  `\Xi \Lambda fl\Pi \Xi ae\Omega ffi * `\Xi 
\Theta \Delta \Omega  ' fflaeae\Theta \Xi \Pi  \Omega  \Upsilon  `\Xi \Lambda \Lambda  \Pi \Xi  * \Pi \Lambda 

Finally, we note that the instrumented operational semantics of \Delta \Delta \Theta \Lambda  terms corre-sponds to the standard operational semantics.

Lemma 3.1.1 (Erasure) If , * ` then \Xi \Psi \Theta \Upsilon \Xi \Theta ,\Lambda  * \Xi \Psi \Theta \Upsilon \Xi \Theta `\Lambda .
Proof (sketch): By induction on the derivation of , * `. For \Delta \Delta \Theta \Lambda -EVAL-APP one
must show that erasure commutes with substitution:

\Xi \Psi \Theta \Upsilon \Xi \Theta ,\Lambda fl\Xi \Psi \Theta \Upsilon \Xi \Theta `\Lambda ae\Omega ffi \Delta  \Xi \Psi \Theta \Upsilon \Xi \Theta ,fl`ae\Omega ffi\Lambda 

\Delta 

29
3.1.2 An aside on completeness
It is worth noting that the labels used in the operational semantics of this simple languageare an approximation to the true information flows. For example, the following program

could be deemed to produce a low-security result because its result does not depend onthe high-security value used in the conditional. Nevertheless, it is considered to return a
high-security value

\Lambda ` \Pi \Lambda  \Pi \Delta \Phi \Xi  \Pi \Xi  \Phi \Theta ,\Phi  \Pi \Xi 
\Delta \Delta \Theta \Lambda , a toy language, is not Turing complete: all \Delta \Delta \Theta \Lambda  programs eventually halt be-cause their label erasures are simply-typed lambda calculus programs, which are known

to terminate [Mit96]. In principle, it would be possible to fully characterize the informa-tion flows that arise in a

\Delta \Delta \Theta \Lambda  program, but such an analysis would amount to running
the program on all possible high-security inputs and determining whether it producedthe same low-security output in each run. In the worst case, such an analysis could take

time exponential in the program size, so approximating the information flows with the
security lattice elements is justified.In Turing-complete languages, like those presented later in this thesis, the problem of

determining security is even harder. Because it is possible to reduce the halting problem
to the problem of determining whether a program is secure, the question is undecidable.Thus, some form of approximation, like the lattice elements used here, is necessary.

3.1.3 \Delta \Pi \Sigma \Upsilon  type system
The type system for \Delta \Delta \Theta \Lambda  is designed to prevent unwanted information flows. The ba-sic idea is to associate security-labels to the type information of the program and then

take the confidentiality lattice into account when type checking so as to rule out illegal(downward) information flows.

This section examines the type system for \Delta \Delta \Theta \Lambda  in detail, and proves some basic
properties that establish its soundness. The next section proves the desired noninterfer-ence result: well-typed programs are secure.

Because upward information flows are allowed (e.g. low-confidentiality data mayflow to a high-confidentiality variable), the lattice ordering is incorporated as a subtyping relationship [VSI96]. This subtyping eliminates the need for the programmer to
make explicit when information flows are permissible.The subtype relationship is shown in Figure 3.4, which contains mutually-recursive

rules of the form ^ *fl  *ffi and ^ *fl  *ffi. The rules establish that  is a reflexive,
transitive relation that obeys the expected contravariance for function types.The interesting rule is

\Delta \Delta \Theta \Lambda -SLAB, which allows a low-security type to be treated as
a high-security type. For example, ^ fflaeae\Theta \Xi   fflaeae\Theta \Lambda  because anywhere a high-security

30
^ *fl  *ffi ^ *fl  *ffi

\Delta \Delta \Theta \Lambda -TREFL ^ *  *

\Delta \Delta \Theta \Lambda -TTRANS

^ *  *\Sigma  ^ *\Sigma   *\Sigma \Sigma 

^ *  *\Sigma \Sigma 

\Delta \Delta \Theta \Lambda -TFUNSUB

^ *\Sigma fl  *fl ^ *ffi  *\Sigma ffi
^ *fl _ *ffi  *\Sigma fl _ *\Sigma ffi

\Delta \Delta \Theta \Lambda -SLAB

^ *  *\Sigma  \Psi  \Xi  \Psi \Sigma 

^ *\Theta   *\Sigma \Theta \Delta 

Figure 3.4: Subtyping for pure \Delta \Delta \Theta \Lambda 

Boolean can be safely used, a low-security Boolean can also be used. Intuitively, if the
program is sufficiently secure to protect high-security data, it also provides sufficientsecurity to "protect" low-security data.

The rules for type checking terms of \Delta \Delta \Theta \Lambda  are given in Figure 3.5. They are judg-ments of the form

o/ ^ , ' *, which says "under the assumptions provided by o/ , the
term , is a secure program that evaluates to a value of type *." Here, o/ is a type contextthat maps the free variables of the term

, to their types:

Definition 3.1.5 (Type Environment) A type environment is a finite map from variables to security types. Syntactically, type environments are written as terms in the
following grammar:

o/ ''\Delta  ! * o/ \Upsilon  \Omega  ' *

Here, ! stands for the empty type environment, and if o/ is any environment, then
o/ \Upsilon  \Omega  ' * stands for a new environment in which the variable \Omega  is mapped to the type *.

The domain of a type environment o/ , written oe\Omega o/\Theta o/ \Lambda , is simply the set of variables
on which the finite map is defined. The notation o/ \Theta \Omega \Lambda  is used to indicate the type * to
which \Omega  is mapped by o/ , and is undefined if o/ does not contain a mapping for \Omega .

To avoid unnecessary clutter, whenever the type environment is empty, the symbol
! will be elided from the judgment. For example ! ^ \Pi \Theta  ' fflaeae\Theta \Theta  will be written as
^ \Pi \Theta  ' fflaeae\Theta \Theta .

The rules of the type system make use of the intuitions formed from the operational
semantics of the language--appropriate security information is propagated in such a

31
o/ ^ , ' *

\Delta \Delta \Theta \Lambda -TRUE o/ ^ \Pi \Theta  ' fflaeae\Theta \Theta 
\Delta \Delta \Theta \Lambda -FALSE o/ ^ `\Theta  ' fflaeae\Theta \Theta 

\Delta \Delta \Theta \Lambda -VAR

o/ \Theta \Omega \Lambda  \Delta  *

o/ ^ \Omega  ' *

\Delta \Delta \Theta \Lambda -FUN

o/ \Upsilon  \Omega  ' *fl ^ , ' *ffi \Omega  i\Sigma  oe\Omega o/\Theta o/ \Lambda 

o/ ^ \Theta \Delta \Omega  ' *fl\Pi  ,\Lambda \Theta  ' \Theta *fl _ *ffi\Lambda \Theta 

\Delta \Delta \Theta \Lambda -BINOP

o/ ^ ,fl ' fflaeae\Theta \Theta \Delta  o/ ^ ,ffi ' fflaeae\Theta \Theta \Theta 

o/ ^ ,fl , ,ffi ' fflaeae\Theta `\Theta \Delta \Pi \Theta \Theta '

\Delta \Delta \Theta \Lambda -APP

o/ ^ ,fl ' \Theta *ffi _ *\Lambda \Theta  o/ ^ ,ffi ' *ffi

o/ ^ ,fl ,ffi ' * \Phi  \Psi 

\Delta \Delta \Theta \Lambda -COND

o/ ^ , ' fflaeae\Theta \Theta  o/ ^ ,\Pi  ' * \Phi  \Psi  \Xi  \Sigma  flAE\Upsilon  OEffi

o/ ^ \Lambda ` , \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi ' * \Phi  \Psi 

\Delta \Delta \Theta \Lambda -SUB

o/ ^ , ' * ^ *  *\Sigma 

o/ ^ , ' *\Sigma 

Figure 3.5: Typing \Delta \Delta \Theta \Lambda 

way that the potential dependencies of computation on high-security information are
tracked. Because information is propagated only when data is examined in some way--that is, its value is used to alter the behavior of the computation--the interesting rules

are the so-called elimination forms, which deconstruct values.

Rule \Delta \Delta \Theta \Lambda -BINOP is a typical elimination rule: it ensures that the binary Booleanoperations are applied to Boolean values, but it additionally carries along the appropriate

security information. If the two operands are of security label \Psi fl and \Psi ffi respectively, thenthe results of the binary operation should be labeled with their join,

\Psi fl\Phi \Psi ffi to approximatethe information that the resulting Boolean reveals about the operands.

Similarly, the rule for function application \Delta \Delta \Theta \Lambda -APP ensures not only that the func-tion is applied to an argument of the correct type, but also that the results of the function
call will be no less secure than the function itself, namely * \Phi  \Psi .

32
Lastly, the \Lambda ` expression must propagate the security label of the condition to the
results of the computation, thus avoiding implicit information flows. Rule \Delta  \Delta \Theta \Lambda -CONDincorporates this constraint.

The introduction rules show how to create data values; consequently it is in these
rules that security annotations supplied by the programmer affect the labels that appearin the types of the expressions.

Rules \Delta \Delta \Theta \Lambda -TRUE and \Delta \Delta \Theta \Lambda -FALSE say that Boolean constants have type fflaeae\Theta , andthat they inherit whatever security annotation was declared in the program. Variables are
simply looked up in the appropriate type environment, as indicated in rule \Delta \Delta \Theta \Lambda -VAR.
Similarly, the rule for function values, \Delta \Delta \Theta \Lambda -FUN is standard: it says that the body of thefunction is well-typed when the formal parameter is assumed to have the type declared

by the programmer.

The remaining rule, \Delta \Delta \Theta \Lambda -SUB, plays an important role in the type system: it allowsan expression that results in a low-security value to be used in a position where highsecurity data is expected.
Definition 3.1.6 (Substitution) A substitution o/ is a finite map from variables to values. If o/ is a typing environment and o/ is a substitution, we write o/ *\Delta  o/ to mean that o/
assigns each variable a value of the type required by O/. It should be read "substitution
o/ satisfies environment O/." Formally, we have:

oe\Omega o/\Theta o/ \Lambda  \Delta  oe\Omega o/\Theta o/\Lambda  ss j\Omega  \Sigma  oe\Omega o/\Theta o/ \Lambda \Pi  ^ o/\Theta \Omega \Lambda  ' o/ \Theta \Omega \Lambda 
The notation o/\Theta ,\Lambda  is short-hand for the simultaneous capture-avoiding substitutions: 2

o/\Theta ,\Lambda  fflij\Delta  ,flo/\Theta \Omega fl\Lambda ae\Omega flffiflo/\Theta \Omega ffi\Lambda ae\Omega ffiffi \Pi  \Pi  \Pi  flo/\Theta \Omega \Delta \Lambda ae\Omega \Delta ffi where fl\Omega fl\Upsilon  \Pi  \Pi  \Pi  \Upsilon  \Omega \Delta ffi \Delta  oe\Omega o/\Theta o/\Lambda 

In order to show that the \Delta \Delta \Theta \Lambda -EVAL-APP rule preserves typing, we must show thatsubstitution of well-typed values does not yield an ill-typed term. This requirement is
captured in the following lemma.
Lemma 3.1.2 (Value Substitutions) If o/ ^ , ' * and o/ *\Delta  o/ then ^ o/\Theta ,\Lambda  ' *.
Proof: Standard proof by induction on the derivation of o/ ^ , ' *. \Delta 

In order to assess the outcome of evaluating a program, it is helpful to associate thetypes of the result with their possible values. The connection is quite strong: The types

of values determine their syntactic structure.
Lemma 3.1.3 (Canonical Forms)

2Note that because the values in the range of \Psi  are closed, the substitutions may be done in any order.

33
" If ^ ` ' fflaeae\Theta \Theta  then ` \Delta  \Pi \Theta \Delta  or ` \Delta  `\Theta \Delta  and \Psi \Sigma  \Xi  \Psi .
" If ^ ` ' \Theta *fl _ *ffi\Lambda \Theta  then ` \Delta  \Theta \Delta \Omega  ' *\Sigma fl\Pi  ,\Lambda \Theta \Delta  and ^ *fl  *\Sigma fl and \Psi \Sigma  \Xi  \Psi .

Proof: By inspection of the forms for values and the typing rules. \Delta 

Lemma 3.1.4 (\Delta \Delta \Theta \Lambda  Preservation) If ^ , ' * and there exists a value ` such that , * `
then ^ ` ' *.

Proof: Standard proof by induction on the derivation that ^ , ' *, appealing to
Lemma 3.1.2 in the case of \Delta \Delta \Theta \Lambda -EVAL-APP. \Delta 

Preservation is weaker than full type soundness because it doesn't say that a well-typed program does not go "wrong" (makes progress). The standard way to prove such a

result for a language with large-step operational semantics is to provide evaluation rulesthat result in errors and then show that well-typed programs never produce an error.
Although such a soundness result could easily be formulated for this language, there isno reason to include it here.

3.1.4 Noninterference for \Delta \Pi \Sigma \Upsilon 
This section establishes a noninterference result for \Delta \Delta \Theta \Lambda . In this simple setting, the
only possible observation of a program is the value to which it evaluates, consequently,noninterference simply says that confidential information should not alter the public

results of any expression. Formally, we want to establish:
Theorem 3.1.1 (Noninterference) If \Omega  ' *\Sigma  ^ , ' fflaeae\Theta \Upsilon  and ^ `fl\Upsilon  `ffi ' *\Sigma  then

,fl`flae\Omega ffi * ` ' ,fl`ffiae\Omega ffi * `
Proof: This theorem follows by using the method of logical relations as a special caseof Lemma 3.1.6 below.

\Delta 

The intuition behind the proof comes from thinking of the behavior of a secure pro-gram from the perspective of a low-security observer. For the program to be secure, you

(the low-security observer) should not be able to see any of the actions performed on
high-security data. On the other hand, you can see the low-security data and computa-tions. The program is secure if you can't see any of the high-security data.

To formalize this intuition, we need to mathematically model what it means for an
observer to be able to "see" (or not "see") a piece of data. If you can "see" a value,you can distinguish it from other values of the same type: for instance if you can see

the Boolean value \Pi , you should be able to tell that it is not the value `. On the other

34
hand, if you cannot see some Boolean value \Omega , you should not be able to distinguish
it from either \Pi  or `. Thus, to model the fact that two values are indistinguishable, wesimply use an appropriate equivalence relation--two values are related if they can't be

distinguished.

Whether or not a piece of data is visible to the low-security observer depends onits security annotation. Consequently, which equivalence relation to use to capture the

observer's view of the data depends on the relationship between the observer's security
clearance and the label on the value. Thus, we parameterize the equivalence relationswith

\Theta , the security level of the observer.
Using the standard technique of logical relations [Mit96], we can extend these equiv-alence relations to higher-order pieces of data and computations over the data as follows:

Definition 3.1.7 (Security Logical Relations) For an arbitrary element \Theta  of the security lattice, the \Theta -level security logical relations are type-indexed binary relations on
closed terms defined inductively as follows. The notation `fl `\Phi  `ffi ' * indicates that `fl
is related to `ffi at type *. Similarly, the notation ,fl `\Phi  ,ffi ' #\Theta *\Lambda  indicates that ,fl and ,ffi
are related computations that produce values of type *.

`fl `\Phi  `ffi ' fflaeae\Theta \Theta  ' ^ `\Pi  ' fflaeae\Theta \Theta  ss \Psi  \Xi  \Theta  \Upsilon  `fl \Delta  `ffi
`fl `\Phi  `ffi ' \Theta *fl _ *ffi\Lambda \Theta  ' ^ `\Pi  ' \Theta *fl _ *ffi\Lambda \Theta  ss

\Psi  \Xi  \Theta  \Upsilon  j `\Sigma fl `\Phi  `\Sigma ffi ' *fl\Pi  \Theta `fl `\Sigma fl\Lambda  `\Phi  \Theta `ffi `\Sigma ffi\Lambda  ' #\Theta *ffi \Phi  \Psi \Lambda 

,fl `\Phi  ,ffi ' #\Theta *\Lambda  ' ^ ,\Pi  ' * ss ,fl * `fl ss ,ffi * `ffi ss `fl `\Phi  `ffi ' *
To show that a well-typed program , that produces a \Theta -observable output of type *
(i.e. \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda  \Xi  \Theta ) is secure, we simply show that , `\Phi  , ' #\Theta *\Lambda .

To do so, we must first show that the logical relations are well-behaved with respectto the subtyping relation. Intuitively, the following lemma shows that if two values with

some security label are indistinguishable to an observer, they remain indistinguishableif given a higher-security label.

Lemma 3.1.5 (Subtyping Relations) If `fl `\Phi  `ffi ' *fl and ^ *fl  *ffi then `fl `\Phi  `ffi ' *ffi.
If ,fl `\Phi  ,ffi ' #\Theta *fl\Lambda  and ^ *fl  *ffi then ,fl `\Phi  ,ffi ' #\Theta *ffi\Lambda .

Proof: We strengthen the hypothesis with the auxiliary claims (and similarly for rela-tions on computations):

`fl `\Phi  `ffi ' *\Theta  ss ^ *  *\Sigma  \Upsilon  `fl `\Phi  `ffi ' *\Sigma \Theta 

`fl `\Phi  `ffi ' *\Theta  ss \Psi  \Xi  \Psi \Sigma  \Upsilon  `fl `\Phi  `ffi ' *\Theta \Delta 

35
We proceed by induction on this strengthened hypothesis. For \Delta \Delta \Theta \Lambda -TREFL, the
result follows immediately. The case for \Delta \Delta \Theta \Lambda -TTRANS follows by straightforwardinduction.

The interesting case is when rule \Delta \Delta \Theta \Lambda -TFUNSUB is the next-to-last rule used in the
derivation that ^ *fl  *ffi. Assume *fl \Delta  *fl\Theta \Delta  and *ffi \Delta  *ffi\Theta \Theta . By \Delta \Delta \Theta \Lambda -SLAB it must bethe case that

\Psi fl \Xi  \Psi ffi. We want to show that `fl `\Phi  `ffi ' *ffi\Theta \Theta .
If \Psi ffi i\Xi  \Theta , then any two values of the correct type are related, and the typing rule
\Delta \Delta \Theta \Lambda -SUB allows us to show that ^ `\Pi  ' *ffi, so we are done. Otherwise, we have \Psi ffi \Xi  \Theta ,from which we conclude that

\Psi fl \Xi  \Theta . It must be that *fl \Delta  *\Psi  _ *\Omega  and *ffi \Delta  *\Sigma \Psi  _ *\Sigma \Omega 
such that ^ *\Sigma \Psi   *\Psi  and ^ *\Omega   *\Sigma \Omega . It remains to show that

j `\Sigma fl `\Phi  `\Sigma ffi ' *\Sigma \Psi \Pi  \Theta `fl `\Sigma fl\Lambda  `\Phi  \Theta `ffi `\Sigma ffi\Lambda  ' #\Theta *\Sigma \Omega  \Phi  \Psi ffi\Lambda 
But, by the induction hypothesis on $ relations it follows that ` \Sigma fl `\Phi  `\Sigma ffi ' *\Psi  and bythe assumption that

`fl `\Phi  `ffi ' *fl it follows that \Theta `fl `\Sigma fl\Lambda  `\Phi  \Theta `ffi `\Sigma ffi\Lambda  ' #\Theta *\Omega  \Phi  \Psi fl\Lambda .
Using the induction hypothesis on the # relations and an easy induction that shows
^ *\Omega  \Phi  \Psi fl  *\Sigma \Omega  \Phi  \Psi ffi we obtain the desired result that \Theta `fl `\Sigma fl\Lambda  `\Phi  \Theta `ffi `\Sigma ffi\Lambda  ' #\Theta *\Sigma \Omega  \Phi  \Psi ffi\Lambda .The inductive step on computation relations

#s relations follows directly from the
mutual induction with the value relations. \Delta 

We need to prove the noninterference result for open programs, but to do so, we mustestablish that the substitution operation preserves the

\Theta -equivalence relations. First,
we define a notion of related substitutions; two substitutions are related if they arecomponent-wise related.

Definition 3.1.8 (Related Substitutions) Two substitutions o/fl and o/ffi are related, indicated by writing o/ ^ o/fl `\Phi  o/ffi, if o/\Pi  *\Delta  o/ and

j\Omega  \Sigma  oe\Omega o/\Theta o/ \Lambda \Pi  o/fl\Theta \Omega \Lambda  `\Phi  o/ffi\Theta \Omega \Lambda  ' o/ \Theta \Omega \Lambda 
We next must show that substitution preserves the logical relations:
Lemma 3.1.6 (Substitution) If o/ ^ , ' * and o/ ^ o/fl `\Phi  o/ffi then o/fl\Theta ,\Lambda  `\Phi  o/ffi\Theta ,\Lambda  '
#\Theta *\Lambda .

Proof: By induction on the derivation that , has type *. Consider the last step used in
the derivation:

\Delta \Delta \Theta \Lambda -TRUE Then o/ ^ \Pi \Theta  ' fflaeae\Theta \Theta  and * \Delta  fflaeae\Theta \Theta . By the definition of substitutions,

o/fl\Theta ,\Lambda  \Delta  o/ffi\Theta ,\Lambda  \Delta  \Pi \Theta . By two applications of the rule \Delta \Delta \Theta \Lambda -EVAL-VAL, it followsthat

o/fl\Theta ,\Lambda  * \Pi \Theta  and o/ffi\Theta ,\Lambda  * \Pi \Theta . By definition, \Pi \Theta  `\Phi  \Pi \Theta  ' * as required.

\Delta \Delta \Theta \Lambda -FALSE Analogous to the previous case.

36
\Delta \Delta \Theta \Lambda -VAR Follows immediately from the facts that substitutions map variables to values and that o/fl\Theta \Omega \Lambda  `\Phi  o/ffi\Theta \Omega \Lambda  ' o/ \Theta \Omega \Lambda  because o/ ^ o/fl `\Phi  o/ffi.

\Delta \Delta \Theta \Lambda -BINOP Then , \Delta  ,fl , ,ffi and * \Delta  fflaeae\Theta \Theta  where \Psi  \Delta  \Psi fl \Phi  \Psi ffi. That each o/\Pi \Theta ,fl , ,ffi\Lambda is well-typed and has type

* follows from the Lemma 3.1.2. It thus remains toshow:

o/fl\Theta ,fl , ,ffi\Lambda  * `fl ss o/ffi\Theta ,fl , ,OE\Lambda \Lambda  * `ffi ss `fl `\Phi  `ffi ' fflaeae\Theta \Theta 
But, from the definition of substitution, we have

o/\Pi \Theta ,fl , ,ffi\Lambda  \Delta  o/\Pi \Theta ,fl\Lambda  , o/\Pi \Theta ,ffi\Lambda 
So by inversion of the typing judgment and two applications of the induction
hypothesis, we obtain

o/fl\Theta ,fl\Lambda  `\Phi  o/ffi\Theta ,fl\Lambda  ' #\Theta fflaeae\Theta \Theta \Delta \Lambda 
and

o/fl\Theta ,ffi\Lambda  `\Phi  o/ffi\Theta ,ffi\Lambda  ' #\Theta fflaeae\Theta \Theta \Theta \Lambda 

Consequently, we have o/fl\Theta ,fl\Lambda  * `flfl and o/ffi\Theta ,fl\Lambda  * `ffifl where `flfl `\Phi  `ffifl ' fflaeae\Theta \Theta \Delta .
Similarly o/fl\Theta ,ffi\Lambda  * `flffi and o/ffi\Theta ,ffi\Lambda  * `ffiffi where `flffi `\Phi  `ffiffi ' fflaeae\Theta \Theta \Theta . By CanonicalForms (Lemma 3.1.3) we have:

`flfl \Delta  \Theta ffl`flfl\Lambda \Theta \Delta \Delta  `flffi \Delta  \Theta ffl`flffi\Lambda \Theta \Delta \Theta 
`ffifl \Delta  \Theta ffl`ffifl\Lambda \Theta \Theta \Delta  `ffiffi \Delta  \Theta ffl`ffiffi\Lambda \Theta \Theta \Theta 

By two applications of rule \Delta \Delta \Theta \Lambda -EVAL-BINOP we have:

o/fl\Theta ,fl , ,ffi\Lambda  * \Theta ffl`flflssss,aeae ffl`flffi\Lambda `\Theta \Delta \Delta \Pi \Theta \Delta \Theta '
o/ffi\Theta ,fl , ,ffi\Lambda  * \Theta ffl`ffiflssss,aeae ffl`ffiffi\Lambda `\Theta \Theta \Delta \Pi \Theta \Theta \Theta '

It remains to show that

\Theta ffl`flflssss,aeae ffl`flffi\Lambda `\Theta \Delta \Delta \Pi \Theta \Delta \Theta ' `\Phi  \Theta ffl`ffiflssss,aeae ffl`ffiffi\Lambda `\Theta \Theta \Delta \Pi \Theta \Theta \Theta ' ' fflaeae\Theta \Theta 
If \Psi  i\Xi  \Theta  then the result follows trivially because `\Phi  relates all well-typed Booleanexpressions. So assume that

\Psi  \Xi  \Theta , and from the definition of `\Phi  relations atBoolean type, we must show that the expressions are equal. By the inequalities

expressed above, it follows that both \Psi fl \Xi  \Theta  and \Psi ffi \Xi  \Theta . Thus, `flfl `\Phi  `ffifl\Lambda  '
fflaeae\Theta \Theta \Delta  and `flffi `\Phi  `ffiffi\Lambda  ' fflaeae\Theta \Theta \Theta  but then we have that `flfl \Delta  `ffifl and `ffifl \Delta  `ffiffi.
Consequently, we obtain

\Theta ffl`flflssss,aeae ffl`flffi\Lambda `\Theta \Delta \Delta \Pi \Theta \Delta \Theta ' \Delta  \Theta ffl`ffiflssss,aeae ffl`ffiffi\Lambda `\Theta \Theta \Delta \Pi \Theta \Theta \Theta '
as required.

37
\Delta \Delta \Theta \Lambda -FUN In this case, , \Delta  \Theta \Delta \Omega  ' *\Sigma \Pi  ,\Sigma \Lambda \Theta  and * \Delta  \Theta *\Sigma  _ *\Sigma \Sigma \Lambda \Theta . From the bound-variable

assumption, we have o/\Pi \Theta ,\Lambda  \Delta  \Theta \Delta \Omega  ' *\Sigma \Pi o/\Pi \Theta ,\Sigma \Lambda \Lambda \Theta . Because Lemma 3.1.2 indicates thatthe resulting term is well-typed and these terms are already evaluated, it simply

remains to show that

\Theta \Delta \Omega  ' *\Sigma \Pi  o/fl\Theta ,\Sigma \Lambda \Lambda \Theta  `\Phi  \Theta \Delta \Omega  ' *\Sigma \Pi  o/ffi\Theta ,\Sigma \Lambda \Lambda \Theta  ' \Theta *\Sigma  _ *\Sigma \Sigma \Lambda \Theta 
To do so, note that if \Psi  i\Xi  \Theta  then the terms are related in $ trivially. Otherwise, wehave

\Psi  \Xi  \Theta  and we must show that for `fl `\Phi  `ffi ' *\Sigma  that

\Theta \Theta \Delta \Omega  ' *\Sigma \Pi  o/fl\Theta ,\Sigma \Lambda \Lambda \Theta  `fl\Lambda  `\Phi  \Theta \Theta \Delta \Omega  ' *\Sigma \Pi  o/ffi\Theta ,\Sigma \Lambda \Lambda \Theta  `ffi\Lambda  ' #\Theta *\Sigma \Sigma  \Phi  \Psi \Lambda 
But by the evaluation rule \Delta \Delta \Theta \Lambda -EVAL-APP , these computations are related when-ever

o/fl\Theta ,\Sigma \Lambda fl`flae\Omega ffi * `\Sigma fl ss o/ffi\Theta ,\Sigma \Lambda fl`ffiae\Omega ffi * `\Sigma ffi ss `\Sigma fl `\Phi  `\Sigma ffi ' \Theta *\Sigma \Sigma  \Phi  \Psi \Lambda 
By inversion of the typing rule, we have that o/ \Upsilon  \Omega  ' *\Sigma  ^ ,\Sigma  ' *\Sigma \Sigma  and that \Omega  i\Sigma 
oe\Omega o/\Theta o/ \Lambda . Observe that because `fl `\Phi  `ffi ' *\Sigma  it follows that

o/ \Upsilon  \Omega  ' *\Sigma  ^ \Theta o/flfl\Omega  %_ `flffi\Lambda  `\Phi  \Theta o/ffifl\Omega  %_ `ffiffi\Lambda 
Now by the induction hypothesis it follows that

\Theta o/flfl\Omega  %_ `flffi\Theta ,\Sigma \Lambda \Lambda  `\Phi  \Theta o/ffifl\Omega  %_ `ffiffi\Theta ,\Sigma \Lambda \Lambda  ' #\Theta *\Sigma \Sigma  \Phi  \Psi \Lambda 
But because \Omega  i\Sigma  oe\Omega o/\Theta o/ \Lambda  the above statement is equivalent to

o/fl\Theta ,\Sigma \Lambda fl`flae\Omega ffi * `\Sigma fl ss o/ffi\Theta ,\Sigma \Lambda fl`ffiae\Omega ffi * `\Sigma ffi ss `\Sigma fl `\Phi  `\Sigma ffi ' \Theta *\Sigma \Sigma  \Phi  \Psi \Lambda 
as required.
\Delta \Delta \Theta \Lambda -APP In this case, , \Delta  ,fl ,ffi and * \Delta  *\Sigma \Sigma  \Phi  \Psi  for some appropriate *\Sigma \Sigma  and \Psi . Itfollows that

o/\Pi \Theta ,\Lambda  \Delta  o/\Pi \Theta ,fl ,ffi\Lambda  \Delta  o/\Pi \Theta ,fl\Lambda  o/\Pi \Theta ,ffi\Lambda . It follows from the inductionhypothesis and the well-typing of

, that \Theta o/fl\Theta ,fl\Lambda \Lambda  `\Phi  \Theta o/ffi\Theta ,fl\Lambda \Lambda  ' #\Theta *\Sigma  _ *\Sigma \Sigma \Lambda \Theta  and
\Theta o/fl\Theta ,ffi\Lambda \Lambda  `\Phi  \Theta o/ffi\Theta ,ffi\Lambda \Lambda  ' #\Theta *\Sigma \Lambda . It follows from the definitions that

o/fl\Theta ,fl\Lambda  * `flfl ss o/ffi\Theta ,fl\Lambda  * `ffifl ss `flfl `\Phi  `ffifl ' \Theta *\Sigma  _ *\Sigma \Sigma \Lambda \Theta 
and that

o/fl\Theta ,ffi\Lambda  * `flffi ss o/ffi\Theta ,ffi\Lambda  * `ffiffi ss `flffi `\Phi  `ffiffi ' *\Sigma 

But now, by definition of the value `\Phi  at function type relations, we have

\Theta `flfl `flffi\Lambda  `\Phi  \Theta `ffifl `ffiffi\Lambda  ' \Theta *\Sigma \Sigma  \Phi  \Psi \Lambda 

38
\Delta \Delta \Theta \Lambda -COND In this case, , \Delta  \Lambda ` ,\Sigma  \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi where O/ ^ , ' fflaeae\Theta \Theta  and O/ ^ ,\Pi  '

*\Sigma  \Phi  \Psi  and * \Delta  *\Sigma  \Phi  \Psi . We must show that

\Theta o/fl\Theta \Lambda ` ,\Sigma  \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi\Lambda \Lambda  `\Phi  \Theta o/ffi\Theta \Lambda ` ,\Sigma  \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi\Lambda \Lambda  ' #\Theta *\Sigma  \Phi  \Psi \Lambda 
By definition of substitution, this is just
\Theta \Lambda ` o/fl\Theta ,\Sigma \Lambda  \Pi \Delta \Phi \Xi  o/fl\Theta ,fl\Lambda  \Phi \Theta ,\Phi  o/fl\Theta ,ffi\Lambda \Lambda  `\Phi  \Theta \Lambda ` o/ffi\Theta ,\Sigma \Lambda  \Pi \Delta \Phi \Xi  o/ffi\Theta ,fl\Lambda  \Phi \Theta ,\Phi  o/ffi\Theta ,ffi\Lambda \Lambda  ' #\Theta *\Sigma \Phi \Psi \Lambda 

If \Psi  i\Xi  \Theta  then the two terms are related trivially, because the `\Phi  relations relate
all such well-typed terms. So assume that \Psi  \Xi  \Theta . By the induction hypothesis, itfollows that

o/fl\Theta ,\Sigma \Lambda  `\Phi  o/ffi\Theta ,\Sigma \Lambda  ' #\Theta fflaeae\Theta \Theta \Lambda , so by definition we have o/fl\Theta ,\Sigma \Lambda  * `fl and
o/ffi\Theta ,\Sigma \Lambda  * `ffi and `fl `\Phi  `ffi ' fflaeae\Theta \Theta . But, since \Psi  \Xi  \Theta , we have that `fl \Delta  `ffi. Thus,either rule

\Delta \Delta \Theta \Lambda -EVAL-COND1 applies to both terms or \Delta \Delta \Theta \Lambda -EVAL-COND2 ap-plies to both terms; assume the former applies (the latter case is analogous). In

this case,

o/fl\Theta \Lambda ` , \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi\Lambda  * `flfl where o/fl\Theta ,fl\Lambda  * `flfl
Similarly,

o/ffi\Theta \Lambda ` , \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi\Lambda  * `ffifl where o/ffi\Theta ,fl\Lambda  * `ffifl
but by the induction hypothesis of this lemma, we already have `flfl `\Phi  `ffifl '
#\Theta *\Sigma  \Phi  \Psi \Lambda  as needed.

\Delta \Delta \Theta \Lambda -SUB This follows directly from Lemma 3.1.5.

\Delta 
Finally, we obtain the noninterference proof as a simple corollary of Lemma 3.1.6.

3.2 \Delta j!ij` : a secure language with state
This section describes how to augment \Delta \Delta \Theta \Lambda  to include mutable state.

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  includes a new type, * \Omega \Phi `, that describes mutable references that point to
objects of type *. For example, if \Sigma  is a memory location that stores the secure Booleanvalue

\Pi \Xi , then \Sigma  can be given the type fflaeae\Theta \Xi  \Omega \Phi `.The memory location

\Sigma  may be updated to contain the value `\Xi  by doing an assignment with the program expression \Sigma  '\Delta  `\Xi . The contents of \Sigma  may be retrieved by thedereference operation. For example, after the assignment just described, the program

\Theta \Phi \Pi  \Omega  \Delta  "\Sigma  \Lambda \Xi  , binds the variable \Omega  to the value `\Xi .

39
It is unsafe to assign a high-security value to a low-security memory location. For
example, assuming \Sigma  has type fflaeae\Theta \Xi  \Omega \Phi ` we must prevent the assignment \Sigma  '\Delta  \Pi \Lambda because such an assignment constitutes a direct flow from

\Omega  to ff. This typing restrictionalso prevents
aliases, program variables that refer to the same memory location, from
being used to leak information. For instance, in the following program3, the variables AEand

o/ must both be given the type fflaeae\Theta \Xi  \Omega \Phi `

\Theta \Phi \Pi  AE j \Sigma  \Lambda \Xi 
\Theta \Phi \Pi  o/ j AE \Lambda \Xi 

Otherwise, the alias could be used to leak information to the low-security location \Sigma .

Because references are themselves first-class values, they must also be given securityannotations. To see why, consider the following program in which

\Sigma  and \Sigma \Sigma  are bothlow-security memory locations (they both contain data of type
fflaeae\Theta \Xi ) and \Lambda  is of type
fflaeae\Theta \Lambda .

\Sigma  ij \Pi \Xi fi
\Sigma \Sigma  ij \Pi \Xi fi
\Theta \Phi \Pi  AE j \Lambda ` \Lambda  \Pi \Delta \Phi \Xi  \Sigma  \Phi \Theta ,\Phi  \Sigma \Sigma  \Lambda \Xi 

AE ij `\Xi fi
\Lambda ` oe\Sigma  \Pi \Delta \Phi \Xi  ((( ^ \Upsilon \Sigma  ffi\Omega i\Sigma \Xi 

\Phi \Theta ,\Phi  ((( ^ \Upsilon \Sigma  flfi\Pi \Xi 

This program contains an information flow from \Omega  to ff because whether the variable
\Omega  refers to \Sigma  or \Sigma \Sigma  depends on high security information. To prevent this flow, securereference types include an additional security label, and are of the form

* \Omega \Phi `\Theta . Here, \Sigma 
and \Sigma \Sigma  might be given type fflaeae\Theta \Xi  \Omega \Phi `\Xi  but because the variable \Omega  depends on the high-security

\Lambda , \Omega  must be given the type fflaeae\Theta \Xi  \Omega \Phi `\Lambda . The labeled operational semanticsand type system prevent the "bad" assignment

\Omega  '\Delta  `\Xi  in the above program requiring
that the label of the reference be protected by the label of its contents. To assign to areference of type

* \Omega \Phi `\Theta  it must be the case that \Psi  \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda . The example is ruled outbecause
\Omega  i\Xi  ff.
There is one more subtlety in dealing with mutable state. There can be an implicitflow. Consider the following program, where

\Sigma  again has type fflaeae\Theta \Xi  \Omega \Phi `\Xi  and \Lambda  is of
type fflaeae\Theta \Lambda .

\Lambda ` \Lambda  \Pi \Delta \Phi \Xi  \Sigma  ij \Pi \Xi  \Phi \Theta ,\Phi  \Sigma  ij `\Xi 
Here, the problem is that, even though the assignments to \Sigma  are individually secure,
which of them occurs depends on high-security data. To prevent such implicit flows,

3The example (and others in this chapter) uses standard syntactic sugar for fi\Xi , and sequencing operations.

40
the type system for \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  associates a label flffi with the program counter. Intuitively, the
program counter label approximates the information that can be learned by observingthat the program has reached a particular point during the execution. In the example

above, the program counter reveals the value of \Lambda , so inside the branches of the conditional, we have flffi \Delta  \Omega . To prevent these implicit flows, the labeled semantics requiresthat

flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda  whenever an assignment to a reference of type * \Omega \Phi `\Theta  occurs in the
context with program counter label flffi. This rules out the above example.Another implicit information flow can arise due to the interaction between functions

and state. For example, consider a function AE that takes no argument and assigns the
location \Sigma  the constant \Pi \Xi . Function AE can be written as:

AE fflij\Delta  \Delta \Theta \Lambda \Pi  \Sigma  '\Delta  \Pi \Xi 
This function is perfectly secure and can be used in many contexts, but it can also be
used to leak information. For example, consider the program below:

\Sigma  ij `\Xi fi
\Lambda ` \Lambda  \Pi \Delta \Phi \Xi  AE \Theta \Lambda  \Phi \Theta ,\Phi  ,.\Lambda &fi

This program is insecure because AE writes to the low-security memory location \Sigma . Callsto functions that have side effects (writes to memory locations) can leak information in

the same way that assignment leaks information about the program counter.

To detect and rule out such implicit flows, function types in \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  include an addi-tional label; they are of the form

ss\Psi ae*fl _ *ffi. The label \Psi  is a lower bound on the labels of
any locations that might be written when calling the function. To call a function of thistype in a context where the program counter has label

flffi, the operational semantics andtype system require that
flffi \Xi  \Psi . Thus, because AE writes to a low security location, AE is
given the type ssffaeffi\Xi \Lambda \Pi \Xi  _ ffi\Xi \Lambda \Pi \Xi ; since flffi \Delta  \Omega  inside the branches of the conditionalguarded by

\Lambda , the above program is ruled out.With these intuitions in mind, we can now present details of

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  . Figure 3.6 contains the grammar for this new source language, called \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  .As just described, function types now include a label

flffi in their syntax ssflffiae* _ *.
This label bounds the effects--writes to memory--that may occur when a function withthis type is invoked.

To model state, \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  includes locations, ranged over by \Sigma ff, which are the names of
memory cells that contain values of type *. Concrete memory locations are written usinglowercase letters like

ff\Upsilon  fflff

\Delta \Upsilon  etc., although the type annotations will often be omitted

when they are unimportant or clear from context. The type * decorating a location is
used for type checking purposes.

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  provides a mechanism for allocating a new memory cell and storing a value
there: The expression \Omega \Phi `ff , first evaluates the expression , to a value `, creates a fresh

41
location in memory, and then stores the value into that location. The result of \Omega \Phi `ff , is
the newly created location.

The expression dereference operation ", evaluates , to obtain a location and thenreturns the value stored in the memory at that location. The form

,fl '\Delta  ,ffi updates thelocation indicated by
,fl to contain the value obtained by evaluating ,ffi and then returns
\Lambda \Pi . If the dereferenced or assigned location has not been created in memory, the programhalts (crashes).

Definition 3.2.1 (Memory) A memory OE is a finite map from locations to values. Locations, ranged over by the metavariable \Sigma  and decorated with a type *, are written \Sigma ff.
The notation OE \Theta \Sigma ff\Lambda  denotes the value associated with location \Sigma ff in memory OE . The
notation OE ss\Sigma ff %_ `ae indicates the memory formed by replacing the contents of \Sigma ff by
the value `. If \Sigma ff is not in oe\Omega o/\Theta OE \Lambda , then a new binding is created.

As an example, if OE is the memory ss\Delta \Theta \Theta \Lambda \Delta  %_ \Pi \Theta ae, the expression \Delta \Theta \Theta \Lambda \Delta  '\Delta  `\Theta  causes
the memory to be updated to OE ss\Delta \Theta \Theta \Lambda \Delta  %_ `\Theta ae \Delta  ss\Delta \Theta \Theta \Lambda \Delta  %_ `\Theta ae.

An additional difference between \Delta \Delta \Theta \Lambda  and \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  is that \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  allows functions to berecursive. The syntax

\Delta ssflffiae AE '\Omega  ' *_\Pi  , describes a function named AE whose body isable to assign to references that point to data with confidentiality label

flffi or higher. As
shown below, the flffi is used to rule out insecure information flows that might arise dueto control flow involving calls to this function. The name

AE is bound within the body ,;
it is used to invoke the function recursively. For example, the following function, wheninvoked, goes into an infinite loop by calling itself immediately:

\Delta ssffae AE '\Omega  ' *_\Pi  AE \Omega 
This function can be given the type ssffae* _ * for any secure type *.

3.2.1 Operational semantics
For \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  (and the other languages discussed in the remainder of this thesis), we present
only the labeled syntax and nonstandard operational semantics--from them it is straight-forward to define the label erasure to a standard programming model.

The operational semantics for \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  is more complex than that of \Delta \Delta \Theta \Lambda  because itmust keep track of the effects that take place in the mutable storage. Accordingly, we
augment the abstract machine configurations to include memories as defined above.
Definition 3.2.2 (Machine configuration) A machine configuration is a triple, written \Lambda OE\Upsilon  flffi\Upsilon  ,\Pi , containing a memory OE , a program counter label flffi \Sigma  \Theta , and an
expression , representing the program.

42
\Psi \Upsilon  flffi \Sigma  \Theta  Security labels

* ''\Delta  ffi\Xi \Lambda \Pi  Unit type

* fflaeae\Theta  Boolean type
* * \Omega \Phi ` Reference type
* ssflffiae* _ * Function type

* ''\Delta  *\Theta  Security types
ffl` ''\Delta  \Pi  * ` Boolean base values

* \Lambda \Pi  Unit value
* \Delta ssflffiae AE '\Omega  ' *_\Pi  , Recursive functions
* \Sigma ff Memory locations

` ''\Delta  \Omega  Variables

* ffl`\Theta  Secure Values

, ''\Delta  ` Values

* , , Function applications
* , , , Primitive operations
* \Omega \Phi `ff, Reference creations
* ", Dereferences
* , '\Delta  , Assignments
* \Lambda ` , \Pi \Delta \Phi \Xi  , \Phi \Theta ,\Phi  , Conditionals

, ''\Delta  ss * ae * \Pi  \Pi  \Pi  Boolean operations
OE ''\Delta  o/ * OE ss\Sigma ff %_ `ae Machine memories

O/ ''\Delta  \Lambda OE\Upsilon  flffi\Upsilon  ,\Pi  Machine configurations

Figure 3.6: \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  grammar

43
A given machine configuration \Lambda OE\Upsilon  flffi\Upsilon  ,\Pi  may evaluate to a final state of the form
\Lambda OE \Sigma \Upsilon  `\Pi  or it may diverge. Figure 3.7 summarizes the operational rules. Just as with
\Delta \Delta \Theta \Lambda , the operational semantics models function application using substitution.

The state also contains a security label flffi that describes the information flows im-plicit in the control flow of the program. For instance, recall the following example,

where \Lambda  is of type fflaeae\Theta \Lambda :

\Lambda ` \Lambda  \Pi \Delta \Phi \Xi  \Sigma  '\Delta  \Pi  \Phi \Theta ,\Phi  \Sigma  '\Delta  `
This program copies the value in \Lambda  into the value pointed to by reference \Sigma  but returns
\Lambda \Pi  no matter which branch is taken. If \Sigma  represents a low-security memory location (i.e.has type

\Omega \Phi `\Delta \Theta \Theta \Lambda \Theta ), this program is insecure. The problem is that the effect of writing tothe location

\Sigma  reveals information about the program counter at which the write occurs.
In order to determine that the program above is insecure, an analysis must be aware
that the assignment to \Sigma  takes place in a context that reveals high-security information.That fact is captured by a label

flffi, the program counter label, that conservatively boundsthe information that can be learned by observing that the program has reached that point

in the code. Within the body of a conditional guarded by a high-security Boolean, theprogram counter label is high-security.

The operational semantics presented in Figure 3.7 includes additional checks thatregulate when it is safe to store a value in a memory location. For example, the rule
\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -EVAL-ASSIGN requires that flffi \Phi  \Psi  \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda : the information contained in theprogram counter together with the information label on the reference must be more
public than the label on the contents of the location. This run-time check prevents the
program above from writing to the location \Sigma  if it stores low-security information.

References also have labels associated with them to prevent information flows thatresult from aliasing: two variables that hold references may point to the same memory

location, and hence information may be leaked by assigning to one reference and detecting the change through the other. One example of such aliasing was already described.For another example, consider the following program:

 '\Delta  \Pi \Xi fi
\Theta \Phi \Pi  AE j '\Lambda ` \Lambda  \Pi \Delta \Phi \Xi   \Phi \Theta ,\Phi  '\Omega \Phi ` \Pi \Xi __ \Lambda \Xi 
\Theta \Phi \Pi  )* j "AE \Lambda \Xi 

 '\Delta  '& )*_fi
\Lambda ` '"AE_ j '& )*_ \Pi \Delta \Phi \Xi  \Theta  '\Delta  \Pi \Xi 

\Phi \Theta ,\Phi  \Theta  '\Delta  `\Xi 

Where the variables might be given the following types.

44
\Lambda OEfl\Upsilon  flffi\Upsilon  ,\Pi  * \Lambda OEffi\Upsilon  `\Pi 

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -EVAL-VAL \Lambda OE\Upsilon  flffi\Upsilon  `\Pi  * \Lambda OE\Upsilon  ` \Phi  flffi\Pi 

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -EVAL-PRIM

\Lambda OE\Upsilon  flffi\Upsilon  ,fl\Pi  * \Lambda OE \Sigma \Upsilon  \Theta `fl\Lambda \Theta \Delta \Pi  \Lambda OE \Sigma \Upsilon  flffi\Upsilon  ,ffi\Pi  * \Lambda OE \Sigma \Sigma \Upsilon  \Theta `ffi\Lambda \Theta \Theta  \Pi 

\Lambda OE\Upsilon  flffi\Upsilon  ,fl , ,ffi\Pi  * \Lambda OE \Sigma \Sigma \Upsilon  \Theta `fl ssss,aeae `ffi\Lambda `\Theta \Delta \Pi \Theta \Theta '\Pi 

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -EVAL-APP

\Lambda OE\Upsilon  flffi\Upsilon  ,fl\Pi  * \Lambda OE \Sigma \Upsilon  \Theta \Delta ssflffi\Sigma ae AE '\Omega  ' *_\Pi  ,\Lambda \Theta \Pi 
\Lambda OE \Sigma \Upsilon  flffi\Upsilon  ,ffi\Pi  * \Lambda OE \Sigma \Sigma \Upsilon  `\Pi  flffi \Phi  \Psi  \Xi  flffi\Sigma 
\Lambda OE \Sigma \Sigma \Upsilon  flffi\Sigma \Upsilon  ,fl`ae\Omega ffifl\Theta \Delta ssflffi\Sigma ae AE '\Omega  ' *_\Pi  ,\Lambda \Theta aeAE ffi\Pi  * \Lambda OE \Sigma \Sigma \Sigma \Upsilon  `\Sigma \Pi 

\Lambda OE\Upsilon  flffi\Upsilon  ,fl ,ffi\Pi  * \Lambda OE \Sigma \Sigma \Sigma \Upsilon  `\Sigma \Pi 

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -EVAL-COND1

\Lambda OE\Upsilon  flffi\Upsilon  ,\Pi  * \Lambda OE \Sigma \Upsilon  \Pi \Theta \Pi  \Lambda OE \Sigma \Upsilon  flffi \Phi  \Psi \Upsilon  ,fl\Pi  * \Lambda OE \Sigma \Sigma \Upsilon  `\Pi 

\Lambda OE\Upsilon  flffi\Upsilon  \Lambda ` , \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi\Pi  * \Lambda OE \Sigma \Sigma \Upsilon  `\Pi 

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -EVAL-COND2

\Lambda OE\Upsilon  flffi\Upsilon  ,\Pi  * \Lambda OE \Sigma \Upsilon  `\Theta \Pi  \Lambda OE \Sigma \Upsilon  flffi \Phi  \Psi \Upsilon  ,ffi\Pi  * \Lambda OE \Sigma \Sigma \Upsilon  `\Pi 

\Lambda OE\Upsilon  flffi\Upsilon  \Lambda ` , \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi\Pi  * \Lambda OE \Sigma \Sigma \Upsilon  `\Pi 

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -EVAL-REF

flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 
\Lambda OE\Upsilon  flffi\Upsilon  ,\Pi  * \Lambda OE \Sigma \Upsilon  `\Pi  \Sigma ff i\Sigma  oe\Omega o/\Theta OE \Sigma \Lambda 

\Lambda OE\Upsilon  flffi\Upsilon  \Omega \Phi `ff,\Pi  * \Lambda OE \Sigma ss\Sigma ff %_ `ae\Upsilon  \Sigma ff\Phi \Psi \Pi 

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -EVAL-DEREF

\Lambda OE\Upsilon  flffi\Upsilon  ,\Pi  * \Lambda OE \Sigma \Upsilon  \Sigma ff\Theta \Pi  OE \Sigma \Theta \Sigma ff\Lambda  \Delta  `

\Lambda OE\Upsilon  flffi\Upsilon  ",\Pi  * \Lambda OE \Sigma \Upsilon  ` \Phi  \Psi \Pi 

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -EVAL-ASSIGN

flffi \Phi  \Psi  \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda  \Sigma ff \Sigma  oe\Omega o/\Theta OE \Sigma \Lambda 
\Lambda OE\Upsilon  flffi\Upsilon  ,fl\Pi  * \Lambda OE \Sigma \Upsilon  \Sigma ff\Theta \Pi  \Lambda OE \Sigma \Upsilon  flffi\Upsilon  ,ffi\Pi  * \Lambda OE \Sigma \Sigma \Upsilon  `\Pi 

\Lambda OE\Upsilon  flffi\Upsilon  ,fl '\Delta  ,ffi\Pi  * \Lambda OE \Sigma \Sigma ss\Sigma ff %_ `ae\Upsilon  \Lambda \Pi \Phi \Psi \Pi 

Figure 3.7: Operational semantics for \Delta \Xi \Theta \Pi \Delta \Theta \Lambda 

45
\Lambda  ' fflaeae\Theta \Lambda 
 ' fflaeae\Theta \Xi  \Omega \Phi `\Xi 
AE ' fflaeae\Theta \Xi  \Omega \Phi `\Lambda 
)* ' fflaeae\Theta \Xi 
\Theta  ' fflaeae\Theta \Xi  \Omega \Phi `\Xi 

This program copies the high-security boolean \Lambda  into a location \Theta . It does so byconditionally creating an alias

AE to the location  and then testing whether in fact analias has been created. In this case, it is not the contents of the location

 or AE that
leak the information, it is the fact that  and AE alias. (Pierce and Sangiorgi [PS99]point out that a similar problem with aliasing in ML allows a programmer to violate

parametricity--aliasing provides a means for leaking type information.)

The label annotations on references rule out the program above when )* is a low-security Boolean because any value read through the reference high-security reference

AE becomes high-security. This program will be rejected with the types given abovebecause

"\Psi  has type fflaeae\Theta \Lambda  by )* expects a ff-security Boolean. If instead, )* were
given the type fflaeae\Theta \Lambda , the program would still be ruled out because of the implicit flowto the variable

\Theta  in the branches of the second conditional. The only way for the aboveprogram to be considered secure, is when, in addition to

)* having high security, variable
\Theta  is a reference to high security data.

3.2.2 Type system
The source type system is reminiscent of the type system for \Delta \Delta \Theta \Lambda , but also draws onthe type systems found in previous work on information-flow languages such as the

one proposed by Volpano, Smith and Irvine [VSI96] and Heintze and Riecke's SLamcalculus [HR98]. Unlike the SLam calculus, which also performs access control checks,
the source language type system is concerned only with secure information flow. Thetype system rules out insecure information flows and thus eliminates the need for the
dynamic checks found in the operational semantics.

As with \Delta \Delta \Theta \Lambda , the \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  type system lifts the ordering on the security lattice to asubtyping relation on the values of the language (Figure 3.8).

Reference types obey the expected invariant subtyping, which is already expressedby the

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -TREFL rule. The security labels of the references themselves obey the
usual covariant subtyping given by \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -SLAB. Consequently, * \Omega \Phi `\Xi   * \Omega \Phi `\Lambda  forany

*, but it is never the case that * \Omega \Phi `\Theta   *\Sigma  \Omega \Phi `\Theta \Delta  when * i\Delta  *\Sigma .
The judgment o/ ssflffiae ^ , ' * shows that expression , has source type * under typecontext

o/ , assuming the program-counter label is bounded above by flffi. Intuitively,
the flffi appearing in the judgment approximates the information that can be learned by

46
^ *fl  *ffi ^ *fl  *ffi

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -TREFL ^ *  *

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -TTRANS

^ *  *\Sigma  ^ *\Sigma   *\Sigma \Sigma 

^ *  *\Sigma \Sigma 

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -TFUNSUB

flffi\Sigma  \Xi  flffi ^ *\Sigma fl  *fl ^ *ffi  *\Sigma ffi
^ ssflffiae*fl _ *ffi  ssflffi\Sigma ae*\Sigma fl _ *\Sigma ffi

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -SLAB

^ *  *\Sigma  \Psi  \Xi  \Psi \Sigma 

^ *\Theta   *\Sigma \Theta \Delta 

Figure 3.8: Value subtyping in \Delta \Xi \Theta \Pi \Delta \Theta \Lambda 

observing that the program counter has reached a particular point in the program. Therules for checking program expressions appear in Figure 3.10.

Function types are labeled with their latent effect, a lower bound on the securitylevel of memory locations that will be written to by that functions. A function with type
ssflffiae*fl _ *ffi may be called safely only from contexts for which the program-counterlabel,

flffi\Sigma  satisfies flffi\Sigma  \Xi  flffi because the side effects within the function body may leakinformation visible at level

flffi. Rule \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -FUN in Figure 3.9 shows that the label appearing in a function's type is used to check the body of the function.

The ssflffiae component of \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  function types is contravariant, as shown in the rule
\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -TFUN-SUB. This contravariance arises because the ssflffiae component is a lowerbound on the side effects that may occur in the body of a function. A function that has a

higher lower bound can exhibit fewer side effects, consequently such a function may be
used anywhere a function that is permitted to exhibit more side effects is required.

It is easy to see that this type system conservatively takes into account the information flows from the context of the program to the value produced by the computation, asshown by the following lemma:

Lemma 3.2.1 If o/ ssflffiae ^ , ' * then flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda .
Proof: By a trivial induction on the derivation that , has type *, observing that in the
base case (rule \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -VAL) the condition flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda  appears as an antecedent. \Delta 

Even though a well-formed source program contains no label values, memory locations may be allocated during the course of its evaluation. The \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -EVAL-DEREF

47
o/ ^ ` ' *

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -TRUE o/ ^ \Pi \Theta  ' fflaeae\Theta \Theta 
\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -FALSE o/ ^ `\Theta  ' fflaeae\Theta \Theta 
\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -UNIT o/ ^ \Lambda \Pi \Theta  ' ffi\Xi \Lambda \Pi \Theta 
\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -LOC o/ ^ \Sigma ff\Theta  ' * \Omega \Phi `\Theta 

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -VAR

o/ \Theta \Omega \Lambda  \Delta  *

o/ ^ \Omega  ' *

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -FUN

AE\Upsilon  \Omega  i\Sigma  oe\Omega o/\Theta o/ \Lambda 
*\Sigma  \Delta  \Theta ssflffiae*fl _ *ffi\Lambda \Theta 
o/ \Upsilon  AE ' *\Sigma \Upsilon  \Omega  ' *fl ssflffiae ^ , ' *ffi

o/ ^ \Theta \Delta ssflffiae AE '\Omega  ' *_\Pi  ,\Lambda \Theta  ' *\Sigma 

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -SUB

o/ ^ ` ' * ^ *  *\Sigma 

o/ ^ ` ' *\Sigma 

Figure 3.9: Value typing in \Delta \Xi \Theta \Pi \Delta \Theta \Lambda 

48
o/ ssflffiae ^ , ' *

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -VAL

o/ ^ ` ' * flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 

o/ ssflffiae ^ ` ' *

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -APP

o/ ssflffiae ^ , ' \Theta ssflffi\Sigma ae*\Sigma  _ *\Lambda \Theta  o/ ssflffiae ^ ,\Sigma  ' *\Sigma  flffi \Phi  \Psi  \Xi  flffi\Sigma 

o/ ssflffiae ^ , ,\Sigma  ' * \Phi  \Psi 

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -PRIM

o/ ssflffiae ^ ,fl ' fflaeae\Theta \Theta  o/ ssflffiae ^ ,ffi ' fflaeae\Theta \Theta 

o/ ssflffiae ^ ,fl , ,ffi ' fflaeae\Theta \Theta 

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -REF

o/ ssflffiae ^ , ' *
o/ ssflffiae ^ \Omega \Phi `ff, ' * \Omega \Phi `\Phi \Psi 

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -DEREF

o/ ssflffiae ^ , ' * \Omega \Phi `\Theta 

o/ ssflffiae ^ ", ' * \Phi  \Psi 

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -ASSN

o/ ssflffiae ^ ,fl ' * \Omega \Phi `\Theta  o/ ^ ,ffi ' * \Psi  \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 

o/ ssflffiae ^ ,fl '\Delta  ,ffi ' ffi\Xi \Lambda \Pi \Phi \Psi 

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -COND

o/ ssflffiae ^ , ' fflaeae\Theta \Theta  o/ ssflffi \Phi  \Psi ae ^ ,\Pi  ' * \Xi  \Sigma  flAE\Upsilon  OEffi

o/ ssflffiae ^ \Lambda ` , \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi ' *

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -EXPRSUB

o/ ssflffiae ^ , ' * ^ *  *\Sigma 

o/ ssflffiae ^ , ' *\Sigma 

Figure 3.10: Expression typing in \Delta \Xi \Theta \Pi \Delta \Theta \Lambda 

49
implicitly requires that the location being dereferenced be in the domain of the memory. Consequently, for the type system to rule out dereferencing of unallocated memorycells, there must be a notion of when a memory is well formed. More formally, for

any program expression ,, the set \Sigma i\Theta ,\Lambda  consists of all location names appearing in
,. The memory reference invariant says that in any well-formed machine configuration
\Lambda OE\Upsilon  flffi\Upsilon  ,\Pi  it should be the case that \Sigma i\Theta ,\Lambda  ffl oe\Omega o/\Theta OE \Lambda . Indeed this is the case, but
to show that such a property holds, the type system must show that the memory OE iswell-formed.

Because memories may contain cyclic data structures, we must carefully formulate
the notion of when a memory is well-formed. Intuitively, we want a location \Sigma ff to pointto a value

` of type *, but ` may contain references to other locations--even \Sigma ff itself.We thus must use a kind of "assume"-"guarantee" reasoning, in which we assume that

all the required locations are present and well-typed in the memory when showing thata particular memory item is well-formed.

Definition 3.2.3 (Memory well-formedness) A memory OE is well-formed, written ^
OE #, if and only if

j\Sigma ff \Sigma  oe\Omega o/\Theta OE \Lambda \Pi  \Sigma i\Theta OE \Theta \Sigma ff\Lambda \Lambda  \Sigma  oe\Omega o/\Theta OE \Lambda  ss ^ OE \Theta \Sigma ff\Lambda  ' *
The intention is that whenever a closed program is placed in the context of a wellformed memory that provides a meaning to all of the locations occurring in the program,the type system guarantees that there will be no illegal information flows or unexpected

errors during the evaluation of the program. Formally:
Lemma 3.2.2 (\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  Preservation) If ! ssflffiae ^ , ' * and ^ OE #, and \Sigma i\Theta ,\Lambda  ffl *OE *
and \Lambda OE\Upsilon  flffi\Upsilon  ,\Pi  * \Lambda OE \Sigma \Upsilon  `\Pi  then ! ^ ` ' * and ^ OE \Sigma  #, and \Sigma i\Theta `\Lambda  ffl *OE \Sigma *.

Proof: A standard proof on the derivation that \Lambda OE\Upsilon  flffi\Upsilon  ,\Pi  * \Lambda OE \Sigma \Upsilon  `\Pi  . \Delta 

3.2.3 Noninterference for \Delta \Phi \Sigma \Psi \Pi \Sigma \Upsilon 
The type system for \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  is sufficient to establish a noninterference result, but doing
so requires a more sophisticated proof than the logical relations argument used for \Delta \Delta \Theta \Lambda in Section 3.1.4. The difficulty is that

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  has mutable state and first-class references.Consequently, the equivalence relations must be extended to account for the contents of

memory.Rather than prove noninterference for

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  directly, we shall translate \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  to alanguage that makes the operational behavior of the programs more explicit and prove

noninterference for that language instead. Correctness of the translation then impliesthat

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  inherits the security properties of the target language.
The next chapter proves the desired noninterference result for the target language.

50
3.3 Related work
Palsberg and O/rbaek studied a simply-typed lambda calculus that included facilities fordistinguishing trusted and untrusted computation [PO95]. Their type system enforces
an information-flow property intended to protect the integrity of data.

Volpano, Smith and Irvine [VSI96, VS97] were among the first to propose a securitytype system. They considered a small imperative language with

/\Delta \Lambda \Theta \Phi  loops and con-ditionals. Memory locations are tagged with their security level and may contain only

integers. This work contributed the first soundness result for a security-typed languageintended to protect confidentiality.

Heintze and Riecke created the SLam (Secure Lambda) Calculus to investigate noninterference in higher-order languages [HR98]. SLam is a variant of the simply-typedlambda calculus, similar to the languages presented in this chapter. In addition, SLam

includes fixed-point recursion, products, and sum type constructors.

In the purely functional case, Heintze and Riecke provide a noninterference proofusing a logical-relations style argument over a denotational semantics of the program.

The idea is to interpret the type-structure of the language as partial equivalence relations
(PERs) over the denotations of the terms. Low-security views of high-security dataare represented by complete relations, and the fact that well-formed programs must

preserve all relations implies that high-security data cannot be observed by looking atlow-security data. This proof of noninterference for

\Delta \Delta \Theta \Lambda  given in this chapter is anoperational semantics adaptation of their approach. They do not prove a noninterference

result for the stateful version of SLam.

The idea that noninterference can be captured by using a partial equivalence relationsemantics is further investigated by Abadi and others [ABHR99]. This work observes

that noninterference can be framed as a dependency analysis, and that several well-known analyses including binding time, SLam's type system, and the type system of
Smith and Volpano could be unified into a common theoretical framework. This model,
called the Dependency Core Calculus (DCC), builds on a long thread of research tounderstand parametric polymorphism [Str67, Rey74, Rey83, MPS86, CGW89, AP90,

MR92a].

Program slicing techniques [Tip95] also provide information about the data depen-dencies in a piece of software. The use of backward slices to investigate integrity and related security properties has been proposed [FL94, LWG^95]. Program debugging andunderstanding existing software is the focus of the slicing work, and these approaches
typically do not allow programmer specified annotations to guide the slicing analysis.

Sabelfeld and Sands have extended the denotational semantics approach to proving
noninterference properties to the case of nondeterministic and probabilistic programs[SS99]. They confine themselves to a simple imperative programming language similar

to the one studied by Volpano and Smith. The technique is essentially the same one

51
used in DCC: logical relations are built over a denotational semantics of the program.
The new twist is that powerdomains (the domain-theoretic analog to the powerset) areused to accommodate the set of possible outputs due to nondeterminism. The interesting

observation here is that the choice of powerdomain operator (there are three) gives rise
to different ways of handling nonterminating programs: one powerdomain correspondsto total correctness, one to partial correctness, and one to a "mixture" of the two that

yields more accurate results with respect to information flow.Pottier and Conchon [PC00] describe a means of automatically extending an existing, sound type system so that a type inference algorithm also infers information flows
within a program. This effectively separates the mechanism for discovering informationflows from the policy about which flows are acceptable.

Reitman [Rei78] and Andrews [AR80] propose a Hoare-style logic for reasoning
about information flows in a simple imperative language. They extend the axiomaticsemantics to handle concurrency primitives, but give no correctness proofs of the logic.

Their work is less concerned with providing ways to enforce security policies than withsimply reasoning about the flows within the program.

Chapter 4
Noninterference in a Higher-orderLanguage with State

This chapter proves a noninterference result for a higher-order language with state, andshows how to apply that result to the language

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  . Rather than prove noninterference
for \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  directly, we instead translate \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  to a new, lower-level language called \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda .

The purpose of \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  is to make the operational behavior of programs more explicit
by introducing the notion of a continuation. A continuation is an abstraction of the (po-tential) future computation of a program. Like functions, continuations take arguments

and encapsulate a piece of code to run when supplied a value for the argument. Unlike functions, continuations never return to the calling context. Instead, a continuationeither halts the whole program or invokes another continuation.

Because continuations are themselves first-class objects that can be manipulated as
data values, more structured control-flow mechanisms, like procedure call and return,can be decomposed into

continuation-passing style (CPS) [Fis72, Rey72, Ste78, App92,
DF92, FSDF93]. Continuations are thus more primitive than functions.

Compiling a structured, higher-order program to CPS exposes its control-transferbehavior. There are a number of reasons why this compilation approach to establishing

noninterference is useful:

1. In contrast to \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  , \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  has a small-step operational semantics. This means thatthe sequence of states through which the memory passes during evaluation is more

apparent in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  than in \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  . Consequently, the noninterference result for \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda is stronger than the corresponding result for

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  because the former says that the
sequence of states induced must not reveal information to a low-security observer

52

53
whereas the latter says only that the final state reached by the program (if any)
should not reveal information to a low-security observer.1

2. The target language \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  is more expressive than the source language in the sensethat it permits certain code transformations, like tail-call optimizations, that are

useful in practice.
3. Because the semantics of \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  are closer to those of an actual computer, studyinghow information-flow policies can be enforced at this level of abstraction opens

up the potential for checking security of assembly code [MWCG99], perhaps byway of proof-carrying code [Nec97].

4. Finally, using continuations, rather than more structured control transfers like pro-cedure calls, provides a stepping stone to the distributed computing setting. Message passing in distributed systems, like continuation invocation, is a fundamentally unidirectional operation from which more complex behaviors are defined.Understanding continuation-passing style in a sequential, single-processor setting

leads to a better understanding of the problems that arise in the concurrent, distributed setting.

This chapter explores the problem of CPS compilation for security-typed languages.
It shows how a type system that captures the structured operations of the source languagecan enforce information-flow security in low-level programming languages.

4.1 CPS and security
As we was shown in the last chapter, type systems for secrecy or integrity are concerned with tracking dependencies in programs. Recall that one difficulty is implicit
flows, which arise from the control flow of the program. Consider the code fragment
'0_ in Figure 4.1.2 There is an implicit flow between the value stored in \Delta  and thevalue stored in

, because examining the contents of  after the program has run givesinformation about the value in

\Delta . There is no information flow between \Delta  and ffl, however. Consequently, this code is secure when \Delta  and  are high-security variables and fflis low-security.

1One could also formulate a small-step semantics for \Omega \Delta \Theta \Lambda 

\Xi \Theta \Pi  directly; doing so and establishing anoninterference result requires essentially the same amount of work as proving noninterference for

\Omega  \Pi \Sigma \Xi \Xi \Theta \Pi .The other benefits favor the CPS approach.

2The examples are written in an imperative pseudo-code in which continuations can be introduced
explicitly (as in \Lambda  ! "\Omega \Lambda \Xi ae #flfi,$) and invoked (as in \Lambda  \Lambda \Xi ). The actual syntax of \Omega  \Pi \Sigma \Xi \Xi \Theta \Pi  is given inSection 4.2.1.

54
'0_ \Lambda ` \Delta  \Pi \Delta \Phi \Xi  \Sigma   ij \Pi fi ff \Phi \Theta ,\Phi  \Sigma   ij `fi ff

ffl ij `fi \Delta \Theta \Pi fi

'1_ \Theta \Phi \Pi  . j '\Delta \Lambda \Pi ( ffl ij `fi \Delta \Theta \Pi _ \Lambda \Xi 

\Lambda ` \Delta  \Pi \Delta \Phi \Xi  \Sigma   ij \Pi fi . \Lambda \Pi fi ff \Phi \Theta ,\Phi  \Sigma   ij `fi . \Lambda \Pi fi ff

'%_ \Theta \Phi \Pi  . j '\Delta \Lambda \Pi ( ffl ij `fi \Delta \Theta \Pi _ \Lambda \Xi 

\Lambda ` \Delta  \Pi \Delta \Phi \Xi  \Sigma   ij \Pi fi . \Lambda \Pi fi ff \Phi \Theta ,\Phi  \Sigma   ij `fi \Delta \Theta \Pi fi ff

'2_ \Theta \Phi \Pi \Theta \Lambda \Xi  . j '\Delta \Lambda \Pi ( ffl ij `fi \Delta \Theta \Pi _ \Lambda \Xi 

\Lambda ` \Delta  \Pi \Delta \Phi \Xi  \Sigma   ij \Pi fi . \Lambda \Pi fi ff \Phi \Theta ,\Phi  \Sigma   ij `fi . \Lambda \Pi fi ff

'3_ \Theta \Phi \Pi \Theta \Lambda \Xi  .* j '\Delta \Lambda \Pi ( \Delta \Theta \Pi _ \Lambda \Xi 

\Theta \Phi \Pi \Theta \Lambda \Xi  .* j '\Delta .( ffl ij \Pi fi . \Lambda \Pi _ \Lambda \Xi 
\Theta \Phi \Pi \Theta \Lambda \Xi  .4 j '\Delta .( ffl ij `fi . \Lambda \Pi _ \Lambda \Xi 
\Lambda ` \Delta  \Pi \Delta \Phi \Xi  \Sigma  \Theta \Phi \Pi \Theta \Lambda \Xi  . j '\Delta \Lambda \Pi ( .* .*_ \Lambda \Xi  .4 . ff

\Phi \Theta ,\Phi  \Sigma  \Theta \Phi \Pi \Theta \Lambda \Xi  . j '\Delta \Lambda \Pi ( .4 .*_ \Lambda \Xi  .* . ff

Figure 4.1: Examples of information flow in CPS
A programmer using a type system for enforcing information flow policies mightassign

\Delta  the type fflaeae\Theta \Lambda  (high-security Boolean) and ffl the type fflaeae\Theta \Xi  (low-securityBoolean). If

 were given the type fflaeae\Theta \Lambda , program fragment '0_ would type check, but
if  were given a low-security type '0_ would not type check due to the implicit flowfrom

\Delta  to . As we saw in the previous chapter, security-typed languages deal with these
implicit flows by associating a security annotation with the program counter (which wewill usually indicate by

flffi). In example '0_, the program counter at the point before the
\Lambda ` statement might be labeled with \Sigma  to indicate that it does not depend on high-security
data. Recall that within the branches of the conditional the program counter depends onthe value of

\Delta , and hence the flffi must be \Omega --the security label of \Delta . Values (suchas the constants

\Pi  and ` of the example) pick up the security annotation of the program
counter, and consequently when  has type fflaeae\Theta \Xi  the assignment  ij \Pi  is illegal--the(implicitly) high-security value

\Pi  is being assigned to a low-security memory location.
Suppose we were to straightforwardly adapt the source rule \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -APP, which type-checks function application, to account for continuation invocation. The resulting rule

would look something like:

CONSERVATIVE

o/ ssflffiae ^ ! ' ssflffi\Sigma ae* _ * o/ ssflffiae ^ ` ' * flffi \Xi  flffi\Sigma 

o/ ssflffiae ^ ! `

55
Here, the type of a continuation expecting an argument of type * is written ssflffi\Sigma ae* _ *.
As with function types, the label flffi\Sigma  is a lower bound on the security level of effectsthat occur inside the body of the continuation

!. The _ * part indicates that, unlikefunctions, continuations never return to their calling context. Just as for

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -APP, the
condition flffi \Xi  flffi\Sigma  requires that the information contained in the program counter of thecaller is more public than the effects that occur once the continuation has been called.

Fragment '1_ illustrates the problem with this naive rule for continuations. It showsthe code from

'0_ after CPS translation has made control transfer explicit. The variable
. is bound to the continuation of the \Lambda `, and the jump is indicated by the application
. \Lambda \Pi . Because the invocation of . has been lifted into the branches of the conditional, therule C

ONSERVATIVE will require that the body of . not write to low-security memory
locations. The value of \Delta  would apparently be observable by low-security code andprogram

'1_ would be rejected because . writes to a low-security variable, ffl.
However, this code is secure; there is no information flow between \Delta  and ffl in '1_because the continuation

. is invoked in both branches. On the other hand, as example
'%_ shows, if . is not used in one of the branches, then information about \Delta  can belearned by observing

ffl. Linear type systems [Abr93, Gir87, Wad90, Wad93] can expressexactly the constraint that

. is used in both branches. By making .'s linearity explicit,
the type system can use the additional information to recover the precision of the typesystem for

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  . Fragment '2_ illustrates this simple approach; in addition to a normal
\Theta \Phi \Pi  construct, we include \Theta \Phi \Pi \Theta \Lambda \Xi  for introducing linear continuations. The program
'2_ certifies as secure even when ffl is a low-security variable, whereas '%_ does not.

Although linearity allows for more precise reasoning about information flow, lin-earity alone is insufficient for security in the presence of first-class continuations. In

example '3_, continuations .*, .*, and .4 are all linear, but there is an implicit flowfrom

\Delta  to ffl because ffl lets us observe the order in which .* and .4 are invoked. It isthus necessary to regulate the ordering of linear continuations. The type system presented in Section 4.2.4 requires that exactly one linear continuation be available at anypoint--thus eliminating the possibility of writing code like example

'3_. We show inSection 4.4 that these constraints are sufficient to prove a noninterference result.

It is easier to make information-flow analysis precise for \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  than \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  because
the structure of \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  limits control flow. For example, it is known that both branchesof a conditional return to a common merge point. This knowledge is exploited by

the type system to obtain less conservative analysis of implicit flows than the rule

CONSERVATIVE above. Unfortunately, the standard CPS transformation loses this in-formation by unifying all forms of control to a single mechanism. With the linearity

approach, the target language still has a single underlying control transfer mechanism
(examples '1_ and '2_ execute exactly the same code), but the type system staticallydistinguishes between different kinds of continuations, allowing information flow to be

analyzed with the same precision as in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda .

56
4.1.1 Linear Continuations
Before diving into the formal definition of the secure CPS language, it is helpful to havesome intuition about what a linear continuation is. Ordinary continuations represent a
possible future computation of a program. How they are manipulated encapsulates thecontrol flow aspects of a piece of code. Powerful language constructs such as

\Psi \Theta \Theta \Psi \Psi (found in the high level languages Scheme and Standard ML of New Jersey) expose the

continuations to the programmer in a first-class way, allowing direct manipulation ofthe control flow. However, such use of continuations is far from common. As observed
by Berdine et al. [BORT01], many control-flow constructs use continuations linearly(exactly once). This linearity arises from restrictions of the source language: functions
return exactly once, merge-points of conditional statements are reachable in exactly one
way from each branch, etc. The fact that \Psi \Theta \Theta \Psi \Psi  and other nonstandard control-flowoperators discard or duplicate continuations is part of what makes reasoning about them

difficult.

Combining linearity with an ordering on continuations restricts their manipulation
even further. Ordered linear continuations enforce a stack discipline on control [PP00].Introducing a linear continuation is analogous to pushing a return address onto a stack;

invoking a linear continuation corresponds to popping that address and jumping to the
return context. Because many constructs (function call/return, nested blocks, and merge-points of conditionals) of high-level structured programs can be implemented via a stack

of activation records, ordered linear continuations are a natural fit to describing theircontrol flow behavior.

Using ordered linear continuations in a type system divorces the description of thestack-like control constructs of a programming language from its syntax (block structure). This separation is essential for preserving control-flow information across compi-lation steps such as CPS transformation, because the syntactic structure of the program
is altered. The main insight is that we can push information implicitly found in the
structure of a program into explicit descriptions (the types) of the program.

4.2 \Delta `$iij`: a secure CPS calculus
This section describes the secure CPS language, its operational behavior, and its static
semantics. \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  is a call-by-value, imperative language similar to those found in thework on Typed Assembly Language [CWM99, MWCG99], although its type system is

inspired by previous language-based security research [HR98, Mye99, VSI96].

57
4.2.1 Syntax
The syntax for \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  is given in Figure 4.2.

Following the proposal for labeling data outlined in Chapter 2, we assume a lattice
of security labels, \Theta . The \Xi  symbol denotes the lattice ordering. As before, the latticejoin and meet operations are given by

\Phi  and \Psi , respectively, and the least and greatest
elements are written ff and \Omega . Elements of \Theta  are ranged over by meta-variables \Psi  and
flffi. As in the \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  semantics, we reserve the meta-variable flffi to suggest that the securitylabel corresponds to information learned by observing the program counter.

Types fall into two main syntactic classes: security types, *, and linear types, ".Security types are the types of ordinary values and consist of a base-type component,
*, annotated with a security label, \Psi . Base types include Booleans, unit, and references.Continuation types, written

ssflffiae\Theta *\Upsilon  "\Lambda  _ *, indicate a security level and the types of theirarguments. The notation
* describes the "void" type, and it indicates that a continuation
never returns.

Corresponding to these types, base values, ffl`, include the Booleans \Pi  and `, a unit
value \Lambda \Pi , type-annotated memory locations, \Sigma ff, and continuations, \Delta ssflffiaeAE'\Omega  ' *\Upsilon  oe ' "_\Pi  ,.All computation occurs over secure values,

`, which are base values annotated with a
security label. Variables, \Omega , range over values.

As an example, the value \Pi \Xi  represents a low-security Boolean (one of type fflaeae\Theta \Xi )that is observable by any computation. On the other hand, the value

`\Lambda  represents a highsecurity Boolean that should be observable only by high-security computations--thosecomputations that do not indirectly influence the low-security portions of the memory.

The operational semantics will ensure that labels are propagated correctly. For instancewe have

\Pi \Xi  ss `\Lambda  \Delta  `\Lambda , because low-security computation, which can affect the low-security portions of memory and hence leak information to a low-security observer of

the program, should be prevented from observing the result--it contains informationabout the high-security value

`\Lambda .

As in \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  , references contain two security annotations. For example, the type
fflaeae\Theta \Lambda  \Omega \Phi `\Xi  represents the type of low-security pointers to high-security Booleans,which is distinct from

fflaeae\Theta \Xi  \Omega \Phi `\Lambda , the type of high-security pointers to low-security
Booleans. The data returned by a dereference operation is protected by the join of thetwo labels. Thus, Booleans obtained through pointers of either of these two reference

types will receive a security label of \Omega .

An ordinary continuation \Delta ssflffiaeAE'\Omega  ' *\Upsilon  oe ' "_\Pi  , is a piece of code (the expression ,)that accepts a nonlinear argument of type

* and a linear argument of type ". Continuations may recursively invoke themselves using the name AE , which is bound in ,. Thenotation

ssflffiae indicates that this continuation may be called only from a context in which
the program counter carries information of security at most flffi. To avoid unsafe implicit

58
\Psi \Upsilon  flffi \Sigma  \Theta  Security Labels

* ''\Delta  ffi\Xi \Lambda \Pi  Unit type

* fflaeae\Theta  Boolean type
* * \Omega \Phi ` Reference types
* ssflffiae\Theta *\Upsilon  "\Lambda  _ * Ordinary continuation types

* ''\Delta  *\Theta  Security types
" ''\Delta  * _ * Linear continuation types
ffl` ''\Delta  \Lambda \Pi  Unit value

* \Pi  * ` Boolean values
* \Sigma ff Memory locations
* \Delta ssflffiaeAE'\Omega  ' *\Upsilon  oe ' "_\Pi  , Continuation values

` ''\Delta  \Omega  Variables

* ffl`\Theta  Secure Values

_` ''\Delta  oe Linear variables

* \Delta \Lambda flffi\Pi '\Omega  ' *_\Pi  , Linear continuations

fl#\Xi O/ ''\Delta  ` Primitive value

* ` , ` Primitive Boolean operation
* "` Location dereference

, ''\Delta  \Theta \Phi \Pi  \Omega  \Delta  fl#\Xi O/ \Lambda \Xi  , Primitive value binding

* \Theta \Phi \Pi  \Omega  \Delta  \Omega \Phi `ff, \Lambda \Xi  , Reference creation
* ,\Phi \Pi  ` '\Delta  ` \Lambda \Xi  , Assignment
* \Theta \Phi \Pi \Theta \Lambda \Xi  oe \Delta  _` \Lambda \Xi  , Linear binding
* \Lambda ` ` \Pi \Delta \Phi \Xi  , \Phi \Theta ,\Phi  , Conditional
* ssae\Pi ae ` ` _` Ordinary continuation invocation
* \Theta ssae\Pi ae _` ` Linear continuation invocation
* \Delta \Theta \Pi ff ` Program termination

Figure 4.2: Syntax for the \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  language

59
flows, the body of the continuation may create effects observable only by principals able
to read data with label flffi.A linear value,

_`, is either a variable (ranged over by oe), or a linear continuation,
which contains a code expression , parameterized by a nonlinear argument just as forordinary continuations. Linear continuations may not be recursive, but they may be invoked from any calling context; hence linear types do not require any flffi annotation. The
syntax \Lambda flffi\Pi  serves to distinguish linear continuation values from nonlinear ones. As forordinary continuations, the label

flffi restricts the continuation's effects, but unlike ordinary continuations, the flffi is constrained only by the context at the point of their creation(as opposed to the context in which they are invoked). Intuitively, linear continuations

capture the security context in which they are created and, when invoked, restore the
program counter label to the one captured.The primitive operations include binary arithmetic,

,, dereference, and a means of
copying secure values. Primitive operations are side-effect free. Program expressionsconsist of a sequence of

\Theta \Phi \Pi  bindings for primitive operations, reference creation, and
imperative updates (via ,\Phi \Pi ). The \Theta \Phi \Pi \Theta \Lambda \Xi  construct introduces a linear continuation. Astraight-line code sequence is terminated by a conditional statement, a

ssae\Pi ae or a \Theta ssae\Pi ae.
The expression \Delta \Theta \Pi ff ` is a program that terminates and produces the final output `of type

*.

4.2.2 Operational semantics
The operational semantics (Figure 4.3) is given by a transition relation between machineconfigurations of the form

\Lambda OE\Upsilon  flffi\Upsilon  ,\Pi . The notation ,fl`ae\Omega ffi indicates capture-avoidingsubstitution of value
` for variable \Omega  in expression ,.
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  memories, OE , are defined just as for \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  , except that the types annotating thememory locations are

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  types and the locations store \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  values. We use the same
notational conventions for describing memory updates. A memory is well-formed if itis closed under the dereference operation and each value stored in the memory has the

correct type. We use o/ to denote the empty memory, and we write \Sigma i\Theta ,\Lambda  for the set of
location names occurring in ,.

The label flffi in a machine configuration represents the security level of informationthat could be learned by observing the location of the program counter. Instructions executed with a program-counter label of flffi are restricted so that they update only memory
locations with labels more secure than flffi. For example, \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-SET shows thatit is valid to store a value to a memory location of type

* only if the security label ofthe data joined with the security labels of the program counter and the reference itself is

lower than \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda , the security clearance needed to read the data stored at that location.Rules

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-COND1 and \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-COND2 show how the program-counter label changes after branching on data of security level \Psi . Observing which branch is taken

60
\Lambda OE\Upsilon  flffi\Upsilon  fl#\Xi O/\Pi  * ` \Lambda OEfl\Upsilon  flffifl\Upsilon  ,fl\Pi  _ \Lambda OEffi\Upsilon  flffiffi\Upsilon  ,ffi\Pi 

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-PRIM \Lambda \Xi \Pi  \Delta \Theta \Pi  \Sigma \Upsilon \Theta \Xi  \Delta  \Sigma \Upsilon \Theta \Pi \Phi \Psi 
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-BINOP \Lambda \Xi \Pi  \Delta \Theta \Pi  \Phi \Theta  \Pi  \Phi \Sigma \Theta \Delta \Xi  \Delta  \Delta \Phi \Xi \Xi \Pi \Pi \Pi \Phi \Sigma \Lambda \Theta \Pi \Theta \Delta \Pi \Phi \Psi 

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-DEREF

\Xi  \Delta \Psi ff\Lambda  \Sigma  \Sigma \Upsilon \Theta \Delta 
\Lambda \Xi \Pi  \Delta \Theta \Pi  \Upsilon \Psi ff\Theta \Xi  \Delta  \Sigma \Upsilon \Theta \Pi \Theta \Delta \Pi \Phi \Psi 

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LETPRIM

\Lambda \Xi \Pi  \Delta \Theta \Pi  \Omega fffifl\Xi  \Delta  \Upsilon 
\Lambda \Xi \Pi  \Delta \Theta \Pi  \Xi \Phi \Sigma  \Theta  \Sigma  \Omega fffifl \Pi \Psi  ffi\Xi  \Sigma  \Lambda \Xi \Pi  \Delta \Theta \Pi  ffi\Upsilon \Upsilon ffl\Theta \Phi \Xi 

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LETREF

i \Psi  \Delta \Theta  \Omega  \Lambda \Xi \Pi \Sigma \Lambda \Delta j\Lambda  \Psi ff fffi \Phi \Psi \Omega \Delta \Xi  \Lambda 
\Lambda \Xi \Pi  \Delta \Theta \Pi  \Xi \Phi \Sigma  \Theta  \Sigma  ff\Phi \Delta ff\Sigma \Upsilon \Theta  \Pi \Psi  ffi\Xi  \Sigma 

\Lambda \Xi  \Xi \Psi ff fl\Sigma  \Sigma \Upsilon \Theta \Pi \Phi \Psi \Pi \Pi  \Delta \Theta \Pi  ffi\Upsilon \Psi ff\Phi \Psi ffl\Theta \Phi \Xi 

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-SET

i \Psi  i\Sigma  \Psi  \Delta \Theta  \Omega  \Lambda \Xi \Pi \Sigma \Lambda \Delta j\Lambda  \Psi ff fi \Phi \Psi \Omega \Delta \Xi  \Lambda 
\Lambda \Xi \Pi  \Delta \Theta \Pi  \Omega \Phi \Sigma  \Psi ff\Theta  \Theta \Sigma  \Sigma \Upsilon \Theta \Delta  \Pi \Psi  ffi\Xi  \Sigma  \Lambda \Xi  \Xi \Psi ff fl\Sigma  \Sigma \Upsilon \Theta \Pi \Theta \Delta \Pi \Phi \Psi \Pi \Pi  \Delta \Theta \Pi  ffi\Xi 

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LETLIN \Lambda \Xi \Pi  \Delta \Theta \Pi  \Xi \Phi \Sigma \Xi \Pi \Psi  ` \Sigma  '\Upsilon  \Pi \Psi  ffi\Xi  \Sigma  \Lambda \Xi \Pi  \Delta \Theta \Pi  ffi\Upsilon '\Upsilon ffl`\Phi \Xi 
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-COND1 \Lambda \Xi \Pi  \Delta \Theta \Pi  \Pi \Delta  \Sigma \Theta  \Sigma \Upsilon \Phi \Psi  ffifl \Phi \Xi \Omega \Phi  ffiffi\Xi  \Sigma  \Lambda \Xi \Pi  \Delta \Theta  \Psi  i\Pi  ffifl\Xi 
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-COND2 \Lambda \Xi \Pi  \Delta \Theta \Pi  \Pi \Delta  \Delta \Theta  \Sigma \Upsilon \Phi \Psi  ffifl \Phi \Xi \Omega \Phi  ffiffi\Xi  \Sigma  \Lambda \Xi \Pi  \Delta \Theta  \Psi  i\Pi  ffiffi\Xi 

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-GOTO

\Delta \Theta  \Omega  \Delta \Theta \Sigma  \Upsilon  \Sigma  \Delta \Delta \Xi \Delta \Theta \Sigma \Pi ^fi\Theta  \Theta  j\Pi  ` \Theta  *fl\Lambda  ffi\Lambda \Theta 

ffi\Sigma  \Sigma  ffi\Upsilon \Upsilon ffl^ \Phi \Upsilon \Sigma \Upsilon \Theta \Delta \Pi \Phi \Psi ffl\Theta \Phi \Upsilon '\Upsilon ffl`\Phi 

\Lambda \Xi \Pi  \Delta \Theta \Pi  ffi\Lambda \Sigma \Lambda  \Delta \Delta \Xi \Delta \Theta \Sigma \Pi ^fi\Theta  \Theta  j\Pi  ` \Theta  *fl\Lambda  ffi\Lambda \Theta  \Sigma \Upsilon \Theta \Delta  '\Upsilon \Xi  \Sigma  \Lambda \Xi \Pi  \Delta \Theta \Sigma  \Psi  i\Pi  ffi\Sigma \Xi 

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LGOTO \Lambda \Xi \Pi  \Delta \Theta \Pi  \Xi ffi\Lambda \Sigma \Lambda  \Delta \Delta \Lambda \Delta \Theta \Sigma \Xi fi\Theta  \Theta  jfl\Lambda  ffi\Lambda  \Sigma \Upsilon \Theta \Xi  \Sigma  \Lambda \Xi \Pi  \Delta \Theta \Sigma \Pi  ffi\Upsilon \Sigma \Upsilon \Theta \Pi \Phi \Psi ffl\Theta \Phi \Xi 

Figure 4.3: Expression evaluation

61
reveals information about the condition variable, so the program counter must have the
higher security label flffi \Phi  \Psi .

As shown in rules \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-PRIM through \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-DEREF , computed values
are stamped with the flffi label. The notation ssss,aeae denotes the semantic counterpart tothe syntactic operation

,. Run-time label checks prevent illegal information flows via
direct means such as assignment. For example, \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-SET requires the followinglabel constraint to hold:

\Psi  \Phi  \Psi \Sigma  \Phi  flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 
This constraint says that the label on the data being assigned into the reference, joinedwith the label that regulates reference aliases and the current

flffi label should be morepublic than the label on the type of data the location stores. This prevents direct, alias,

and indirect information leaks from occurring due to the assignment operation.

Section 4.4 shows that, for well-typed programs, all illegal information flows are
ruled out, and hence these dynamic label checks are unnecessary.

Operationally, the rules for ssae\Pi ae and \Theta ssae\Pi ae are very similar--each causes con-trol to be transferred to the target continuation. They differ in their treatment of the

program-counter label, as seen in rules \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-GOTO and \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LGOTO.
Ordinary continuations require that the program-counter label of the calling context, flffi,be protected by the program-counter label of the continuation, and the computation proceeds with the label declared in the continuation. Linear continuations instead cause
the program-counter label to be restored (potentially, lowered) to that of the context inwhich they were declared. In accordance with the label-stamping intuition, both

ssae\Pi ae
and \Theta ssae\Pi ae stamp the flffi label of the calling context into the value passed to the contin-uation.

As mentioned above, well-formed programs stop when they reach the expression
\Delta \Theta \Pi ff `. Consequently the "stuck" term \Delta \Theta \Pi ff ` represents a valid terminal state.

4.2.3 An example evaluation
This section gives a concrete example of the operational semantics.

Consider the evaluation shown in Figure 4.4. It shows the program fragment '2_
from Figure 4.1 of the introduction using the syntax of our secure CPS language. In thisinstance, the condition variable is the high-security value

\Pi \Lambda , and the program-counterlabel is initially
ff, the lowest security label. The memory, OE , initially maps the highsecurity location  to the value \Pi \Lambda  and the low-security location ffl to the value \Pi \Xi . (Thisinformation is summarized in the figure.)

Step (1) is a transition via \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LETLIN that introduces the linear continu-ation,

!\Pi fiflffi and binds it to the variable .. As indicated by the notation \Lambda ff\Pi  in !\Pi fiflffi's
definition, when invoked, !\Pi fiflffi will set the flffi label back to ff. In step (2), the program

62
\Lambda  \Xi \Pi  ffi\Pi  \Xi \Phi \Sigma \Xi \Pi \Psi  ffl i _\Pi fiflffi \Pi \Psi 

\Pi \Delta  \Sigma \Lambda  \Sigma \Upsilon \Phi \Psi  \Omega \Phi \Sigma  j `i \Sigma \Xi  \Pi \Psi  \Xi ffi\Lambda \Sigma \Lambda  ffl \Lambda \Xi 

\Phi \Xi \Omega \Phi  \Omega \Phi \Sigma  j `i \Delta \Xi  \Pi \Psi  \Xi ffi\Lambda \Sigma \Lambda  ffl \Lambda \Xi  \Xi 
\Delta ff\Lambda  \Sigma  \Lambda  \Xi \Pi  ffi\Pi  \Pi \Delta  \Sigma \Lambda  \Sigma \Upsilon \Phi \Psi  \Omega \Phi \Sigma  j `i \Sigma \Xi  \Pi \Psi  \Xi ffi\Lambda \Sigma \Lambda  _\Pi fiflffi \Lambda \Xi 

\Phi \Xi \Omega \Phi  \Omega \Phi \Sigma  j `i \Delta \Xi  \Pi \Psi  \Xi ffi\Lambda \Sigma \Lambda  _\Pi fiflffi \Lambda \Xi  \Xi 
\Delta fi\Lambda  \Sigma  \Lambda  \Xi \Pi  ffl\Pi  \Omega \Phi \Sigma  j `i \Sigma \Xi  \Pi \Psi  \Xi ffi\Lambda \Sigma \Lambda  _\Pi fiflffi \Lambda \Xi  \Xi 
\Delta fl\Lambda  \Sigma  \Lambda  \Xi  \Sigma \Pi  ffl\Pi  \Xi ffi\Lambda \Sigma \Lambda  _\Pi fiflffi \Lambda \Xi  \Xi 
\Delta ffi\Lambda  \Sigma  \Lambda  \Xi  \Sigma \Pi  ffi\Pi  \Omega \Phi \Sigma  \Theta  `i \Delta \Xi  \Pi \Psi  \Upsilon j\Xi \Sigma \Xi \Pi \Sigma \Upsilon \Theta  \Xi 
\Delta ffl\Lambda  \Sigma  \Lambda  \Xi  \Sigma \Sigma \Pi  ffi\Pi  \Xi ffi\Lambda \Sigma \Lambda  \Upsilon j\Xi \Sigma \Xi \Pi \Sigma \Upsilon \Theta  \Xi 

Where \Xi  \Sigma  \Upsilon 

j fl\Sigma  \Sigma \Lambda \Pi  ' fl\Sigma  \Sigma \Xi \Phi 

\Xi  \Sigma  \Sigma  \Upsilon j fl\Sigma  \Sigma \Lambda \Pi  ' fl\Sigma  \Sigma \Xi \Phi 
\Xi  \Sigma \Sigma  \Sigma  \Upsilon j fl\Sigma  \Sigma \Lambda \Pi  ' fl\Sigma  \Delta \Xi \Phi 

j \Theta  \Theta \Lambda \Lambda \Xi \Lambda  ff\Phi \Delta \Xi 
\Theta  \Theta  \Theta \Lambda \Lambda \Xi \Xi  ff\Phi \Delta \Xi 
_\Pi fiflffi \Sigma  \Delta \Lambda ffi\Xi fi\Upsilon  \Theta  ^\Psi \Pi \Sigma \Xi fl\Lambda  \Omega \Phi \Sigma  \Theta  `i \Delta \Xi  \Pi \Psi  \Upsilon j\Xi \Sigma \Xi \Pi \Sigma \Upsilon \Theta 

Figure 4.4: Example program evaluation

transitions via rule E5, testing the condition variable. In this case, because \Pi \Lambda  is high-security, the program counter label increases to

\Omega  \Delta  ff \Phi  \Omega , and the program takes the
first branch. Next, step (3) is a transition by rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-SET, which updates thecontents of memory location

. The new value stored is high-security, because, instanti-ating
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-SET , we have: \Psi  \Delta  ff\Upsilon  \Psi \Sigma  \Delta  ff\Upsilon  flffi \Delta  \Omega  and \Psi \Sigma \Phi \Psi \Phi flffi \Delta  ff\Phi ff\Phi \Omega  \Delta  \Omega .
This assignment succeeds because  is a location that stores high-security data; if  werea location of type

fflaeae\Theta \Xi  \Omega \Phi `\Xi , the check \Psi \Sigma  \Phi  \Psi  \Phi  flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta fflaeae\Theta \Xi \Lambda  \Delta  ff would fail--however, the type system presented in the next section statically rules out such behavior,

making such dynamic checks unnecessary.

The fourth step is the linear invocation, via rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LGOTO. As promised,
!\Pi fiflffi resets the program counter label to ff, and in addition, we substitute the actualarguments for the formal parameters in the body of the continuation. The last transition

is another instance of rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-SET , this time updating the contents of ffl with
the low-security value `\Xi .

How would this program differ if an ordinary continuation were used instead of
!\Pi fiflffi? The crucial difference would appear in step (4), where instead of evaluating via
rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LGOTO, we would be forced to use rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-GOTO. Note that
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-GOTO requires the flffi label of the continuation to be higher than the one
in the machine configuration. In this case, because the calling context has flffi \Delta  \Omega ,

63
the body of the continuation would be forced to \Omega  as well. It is not possible to write a
value to the low-security location ffl in such circumstances, and hence we cannot writethis program using an ordinary continuation in place of

!\Pi fiflffi without forcing ffl to be ahigh-security location.

4.2.4 Static semantics
The type system for the secure CPS language enforces the linearity and ordering constraints on continuations and guarantees that security labels on values are respected.Together, these restrictions rule out illegal information flows and impose enough structure on the language for us to prove a noninterference property.

As in other mixed linear-nonlinear type systems [TW99], the type context is splitinto an ordinary, nonlinear section and a linear section.

o/ is a finite partial map fromnonlinear variables to security types, whereas
$ is an ordered list (with concatenation
denoted by ",") mapping linear variables to their types. The order in which continuationsappear in

$ defines the order in which they are invoked: Given $ \Delta  !\Upsilon  \Theta oe\Delta  ' "\Delta \Lambda \Upsilon  \Pi  \Pi  \Pi  \Upsilon  \Theta oefl '
"fl\Lambda , the continuations will be executed in the order oefl \Pi  \Pi  \Pi  oe\Delta . Thus, the context $ spellsout explicitly the stack-like behavior of ordered linear continuations. A key part of

the type system is ensuring that this stack is respected by the program. The nonlinear
context o/ admits the usual weakening and exchange rules (which we omit), but thelinear context does not. The two parts of the context are separated by

' in the judgmentsto make them more distinct (as in
o/ ' $). We use ! to denote an empty nonlinear
context.

Figures 4.5 through 4.10 show the rules for type-checking. The judgment form
o/ ^ ` ' * says that ordinary value ` has security type * in context o/ . Linear values
may mention linear variables and so have judgments of the form o/ % $ ^ _` ' ". Likevalues, primitive operations may not contain linear variables, but the security of the

value produced depends on the program-counter. We thus use the judgment o/ ssflffiae ^
fl#\Xi O/ ' * to say that in context o/ where the program-counter label is bounded above by
flffi, fl#\Xi O/ computes a value of type *. Similarly, o/ % $ ssflffiae ^ , means that expression ,
is type-safe and contains no illegal information flows in the type context o/ ' $, whenthe program-counter label is at most

flffi. Because expressions represent continuations,and hence do not return values, no type is associated with judgments

o/ % $ ssflffiae ^ ,.
Alternatively, we could write o/ % $ ssflffiae ^ , ' * to indicate that , does not return. But,as all expressions have type

*, we simply omit the ' *. In the latter two forms, flffi is
a conservative approximation to the security label of information affecting the programcounter.

The rules for checking ordinary values, shown in Figure 4.5, are, for the most part,
the same as for those of \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  . A value cannot contain free linear variables because

64
o/ ^ ` ' *

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -BOOL o/ ^ \Pi \Theta  ' fflaeae\Theta \Theta  o/ ^ `\Theta  ' fflaeae\Theta \Theta 
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -UNIT o/ ^ \Lambda \Pi \Theta  ' ffi\Xi \Lambda \Pi \Theta 
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LOC o/ ^ \Sigma ff\Theta  ' * \Omega \Phi `\Theta 

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -VAR

o/ \Theta \Omega \Lambda  \Delta  *

o/ ^ \Omega  ' *

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -CONT

AE\Upsilon  \Omega  i\Sigma  oe\Omega o/\Theta o/ \Lambda 
*\Sigma  \Delta  \Theta ssflffiae\Theta *\Upsilon  "\Lambda  _ *\Lambda \Theta 
o/ \Upsilon  AE ' *\Sigma \Upsilon  \Omega  ' *% oe ' " ssflffiae ^ ,

o/ ^ \Theta \Delta ssflffiaeAE'\Omega  ' *\Upsilon  oe ' "_\Pi  ,\Lambda \Theta  ' *\Sigma 

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -SUB

o/ ^ ` ' * ^ *  *\Sigma 

o/ ^ ` ' *\Sigma 

Figure 4.5: Value typing

65
^ *fl  *ffi ^ *fl  *ffi

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -TREFL ^ *  *

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -TTRANS

^ *  *\Sigma  ^ *\Sigma   *\Sigma \Sigma 

^ *  *\Sigma \Sigma 

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -TCONTSUB

flffi\Sigma  \Xi  flffi ^ *\Sigma   * ^ "\Sigma   "
^ ssflffiae\Theta *\Upsilon  "\Lambda  _ *  ssflffi\Sigma ae\Theta *\Sigma \Upsilon  "\Sigma \Lambda  _ *

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -SLAB

^ *  *\Sigma  \Psi  \Xi  \Psi \Sigma 

^ *\Theta   *\Sigma \Theta \Delta 

Figure 4.6: Value subtyping in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda 

discarding (or copying) the value would break the linearity constraint on the variable. A
continuation type contains the flffi label used to check its body (rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -CONT).

The lattice ordering on security labels lifts to a subtyping relationship on values(shown in Figure 4.6). Continuations exhibit the expected contravariance, as shown in

rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -TCONTSUB. References, are, as in \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  , invariant with respect to the databeing stored but covariant with respect to their outer label.

Linear values are checked using the rules in Figures 4.7 and 4.8. Subtyping lineartypes is standard. As shown in 4.8, linear values may safely mention free linear variables, but the variables must not be discarded or reordered. Thus we may conclude thata linear variable is well-formed exactly when the only variable in the linear context is
the variable in question (rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LVAR).

In a linear continuation (rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LCONT) the linear context must be used withinthe body of the continuation, but the non-linear argument is added to

o/ .
The rules for primitive operations (in Figure 4.9) require that the calculated valuehave security label at least as restrictive as the current

flffi, reflecting the "label stamping"
behavior of the operational semantics. Values read through O/\Phi \Omega \Phi ` (rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -DEREF)pick up the label of the reference as well, which prevents illegal information flows due

to aliasing.

Figure 4.10 lists the rules for type checking expressions. Primitive operations areintroduced by a

\Theta \Phi \Pi  expression as shown in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -PRIM. The rules for creating new
references and doing reference update, rules \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -REF and \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -ASSN, require thatthe reference protect the security of the program counter. The condition

flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 
says that any data read through the created reference may only be observed by contexts

66
^ "fl  "ffi

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LREFL ^ "  "

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LTRANS

^ "  "\Sigma  ^ "\Sigma   "\Sigma \Sigma 

^ "  "\Sigma \Sigma 

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LCONTSUB

^ *\Sigma   *
^ * _ *  *\Sigma  _ *

Figure 4.7: Linear value subtyping in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda 

o/ % $ ^ _` ' "

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LVAR o/ % oe ' " ^ oe ' "

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LCONT

\Omega  i\Sigma  oe\Omega o/\Theta o/ \Lambda 
o/ \Upsilon  \Omega  ' *% $ ssflffiae ^ ,

o/ % $ ^ \Delta \Lambda flffi\Pi '\Omega  ' *_\Pi  , ' * _ *

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LSUB

o/ % $ ^ _` ' " ^ "  "\Sigma 

o/ % $ ^ _` ' "\Sigma 

Figure 4.8: Linear value typing in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda 

67
o/ ssflffiae ^ fl#\Xi O/ ' *

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -VAL

o/ ^ ` ' * flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 

o/ ssflffiae ^ ` ' *

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -BINOP

o/ ^ ` ' fflaeae\Theta \Theta  o/ ^ `\Sigma  ' fflaeae\Theta \Theta  flffi \Xi  \Psi 

o/ ssflffiae ^ ` , `\Sigma  ' fflaeae\Theta \Theta 

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -DEREF

o/ ^ ` ' * \Omega \Phi `\Theta  flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta * \Phi  \Psi \Lambda 

o/ ssflffiae ^ "` ' * \Phi  \Psi 

Figure 4.9: Primitive operation typing in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda 

able to observe the current program counter. The reference itself starts initially with a
secrecy determined by the current flffi3 The condition flffi \Phi  \Psi  \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda  in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -ASSNprevents explicit flows in a similar way.

Rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -COND illustrates how the conservative bound on the information contained in the program-counter is propagated: the label used to check the branches is thelabel before the test,

flffi, joined with the label on the data being tested, \Psi . The rule for
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -GOTO restricts the program-counter label of the calling context, flffi, joined with
the label on the continuation itself, \Psi , to be less than the program-counter label underwhich the body was checked,

flffi\Sigma . This prevents implicit information flows from propa-gating into function bodies. Likewise, the values passed to a continuation (linear or not)

must pick up the calling context's flffi (via the constraint flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda ) because theycarry information about the context in which the continuation was invoked.

The rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -HALT requires an empty linear context, indicating that the program
consumes all linear continuations before stopping. The * annotating \Delta \Theta \Pi  is the type ofthe final output of the program; its label should be constrained by the security clearance

of the user of the program.

The rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LETLIN manipulates the linear context to enforce the ordering prop-erty on continuations. The top of the continuation stack,

$ffi, must be used in the bodyof the continuation being declared. The body of the declaration,

,, is checked under the
assumption that the new continuation, oe, is available. Collectively, these manipulationsamount to pushing the continuation

oe onto the control stack.

3It is possible to allow users to annotate the oe\Xi % creation instruction with a security label, but permitting such annotation does not yield any interesting insights, so it is omitted here.

68
o/ % $ ssflffiae ^ ,

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -PRIM

o/ ssflffiae ^ fl#\Xi O/ ' *
o/ \Upsilon  \Omega  ' *% $ ssflffiae ^ ,

o/ % $ ssflffiae ^ \Theta \Phi \Pi  \Omega  \Delta  fl#\Xi O/ \Lambda \Xi  ,

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -REF

o/ ^ ` ' * flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 

o/ \Upsilon  \Omega  ' * \Omega \Phi `\Phi \Psi % $ ssflffiae ^ ,

o/ % $ ssflffiae ^ \Theta \Phi \Pi  \Omega  \Delta  \Omega \Phi `ff` \Lambda \Xi  ,

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -ASSN

o/ ^ ` ' * \Omega \Phi `\Theta  o/ % $ ssflffiae ^ ,

o/ ^ `\Sigma  ' * flffi \Phi  \Psi  \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 

o/ % $ ssflffiae ^ ,\Phi \Pi  ` '\Delta  `\Sigma  \Lambda \Xi  ,

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LETLIN

o/ % $ffi ^ \Delta \Lambda flffi\Sigma \Pi '\Omega  ' *_\Pi  ,\Sigma  ' * _ *
flffi \Xi  flffi\Sigma  o/ % $fl\Upsilon  oe ' * _ * ssflffiae ^ ,

o/ % $fl\Upsilon  $ffi ssflffiae ^ \Theta \Phi \Pi \Theta \Lambda \Xi  oe \Delta  \Delta \Lambda flffi\Sigma \Pi '\Omega  ' *_\Pi  ,\Sigma  \Lambda \Xi  ,

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -COND

o/ ^ ` ' fflaeae\Theta \Theta  o/ % $ ssflffi \Phi  \Psi ae ^ ,\Pi 

o/ % $ ssflffiae ^ \Lambda ` ` \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -GOTO

o/ ^ ` ' \Theta ssflffi\Sigma ae\Theta *\Upsilon  "\Lambda  _ *\Lambda \Theta 
o/ ^ `\Sigma  ' * o/ % $ ^ _` ' "
flffi \Phi  \Psi  \Xi  flffi\Sigma  flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 

o/ % $ ssflffiae ^ ssae\Pi ae ` `\Sigma  _`

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LGOTO

o/ % $ ^ _` ' * _ *

o/ ^ ` ' *
flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 

o/ % $ ssflffiae ^ \Theta ssae\Pi ae _` `

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -HALT

o/ ^ ` ' * flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 

o/ % ! ssflffiae ^ \Delta \Theta \Pi ff `

Figure 4.10: Expression typing in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda 

69
Linear continuations capture the flffi (or a more restrictive label) of the context in
which they are introduced, as shown in rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LETLIN. Unlike the rule for ssae\Pi ae, therule for

\Theta ssae\Pi ae does not constrain the program-counter label of the target continuation,because the linear continuation

restores the program-counter label to the one it captured.
Because linear continuations capture the flffi of their introduction context, we makethe mild assumption that

initial programs introduce all linear continuation values (except
variables) via \Theta \Phi \Pi \Theta \Lambda \Xi . This assumption rules out trivially insecure programs; during ex-ecution this constraint is not required, and programs in the image of the CPS translation

of Section 4.5 satisfy this property.

4.3 Soundness of \Delta `$iij`
This section proves the soundness theorem for \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda . The proof is, for the most part,standard, following in the style of Wright and Felleisen [WF92, WF94]. As usual for
a language with subtyping, our proofs assume that typing derivations are in a canonical form in which applications of subsumption alternate with other rules. That suchcanonical proofs exist follows from the reflexive and transitive nature of the subtyping

relation.We first begin by establishing a few standard properties of typed languages. A simple
proposition that we shall not prove is the following, which says that if a base value is
well-typed when stamped with one label, it is well-typed when stamped with any otherlabel.

Proposition 4.3.1 (Base Value Relabeling) If o/ ^ ffl`\Theta  ' %\Theta  then o/ ^ ffl`\Theta \Delta  ' %\Theta \Delta .

We shall use the Base Value Relabeling proposition without mentioning it explicitlyin the proofs below.
Next, we establish that capture-avoiding substitution of a well-typed term into another well-typed term yields a well-typed term:

Lemma 4.3.1 (Substitution I) Assume o/ ^ ` ' * then
(i) If o/ \Upsilon  \Omega  ' * ^ `\Sigma  ' *\Sigma  then o/ ^ `\Sigma fl`ae\Omega ffi ' *\Sigma .
(ii) If o/ \Upsilon  \Omega  ' *% $ ^ _` ' " then o/ % $ ^ _`fl`ae\Omega ffi ' ".
(iii) If o/ \Upsilon  \Omega  ' * ssflffiae ^ fl#\Xi O/ ' *\Sigma  then o/ ssflffiae ^ fl#\Xi O/fl`ae\Omega ffi ' *\Sigma .
(iv) If o/ \Upsilon  \Omega  ' *% $ ssflffiae ^ , then o/ % $ ssflffiae ^ ,fl`ae\Omega ffi.

Proof: By mutual induction on the (canonical) derivations of (i)-(iv).

70
(i) By assumption, there exists a derivation of the form

o/ \Upsilon  \Omega  ' * ^ `\Sigma  ' *\Sigma \Sigma  ^ *\Sigma \Sigma   *\Sigma 

o/ \Upsilon  \Omega  ' * ^ `\Sigma  ' *\Sigma 

We proceed by cases on the rule used to conclude o/ \Upsilon  \Omega  ' * ^ `\Sigma  ' *\Sigma \Sigma . In cases
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -BOOL, \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -UNIT, and \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LOC we have `\Sigma fl`ae\Omega ffi \Delta  `\Sigma , and the resultfollows by Strengthening and derivation above. In the case of

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -VAR, we have
either \Omega fl`ae\Omega ffi \Delta  `, which, by assumption, has type * \Delta  *\Sigma \Sigma  or \Omega \Sigma fl`ae\Omega ffi \Delta  \Omega \Sigma , alsoof type

*\Sigma \Sigma . In either case, this information plus the derivation above yields the
desired result. The case of \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -CONT follows from induction hypothesis (iv).

(ii) This cases follows analogously to the case for (i); the rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LCONT makes use

of induction hypothesis (iv).

(iii) This follows directly from the induction hypothesis (i).
(iv) Follows by induction hypotheses (i)-(iv).

\Delta 
Note that neither ordinary values nor primitive operations may contain free linearvariables. This means that substitution of a linear value in them has no effect. The

following lemma strengthens substitution to open linear values and also shows that the
ordering on the linear context is maintained.

Lemma 4.3.2 (Substitution II) Assume !% $ ^ _` ' " then:
(i) If o/ % $fl\Upsilon  oe ' "\Upsilon  $ffi ^ _`\Sigma  ' "\Sigma  then o/ % $fl\Upsilon  $\Upsilon  $ffi ^ _`\Sigma fl_`aeoeffi ' "\Sigma .
(ii) If o/ % $fl\Upsilon  oe ' "\Upsilon  $ffi ssflffiae ^ , then o/ % $fl\Upsilon  $\Upsilon  $ffi ssflffiae ^ ,fl_`aeoeffi.
Proof: By mutual induction on the (canonical) typing derivations of (i) and (ii).
(i) The canonical typing derivation for _`\Sigma  is:

o/ % $fl\Upsilon  oe ' "\Upsilon  $ffi ^ _`\Sigma  ' "\Sigma \Sigma  ^ "\Sigma \Sigma   "\Sigma 

o/ % $fl\Upsilon  oe ' "\Upsilon  $ffi ^ _`\Sigma  ' "\Sigma 

We proceed by cases on the rule used to conclude o/ % $fl\Upsilon  oe ' "\Upsilon  $ffi ^ _`\Sigma  ' "\Sigma \Sigma .
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LVAR Then _`\Sigma  \Delta  oe and "\Sigma \Sigma  \Delta  ", it follows that $fl\Upsilon  oe ' "\Upsilon  $ffi \Delta  oe ' ", and

hence $fl \Delta  $ffi \Delta  !. This implies that $fl\Upsilon  $\Upsilon  $ffi \Delta  $ and thus by the as-sumption that

_` \Delta  oefl_`aeoeffi is well-typed under $, we have o/ % $fl\Upsilon  $\Upsilon  $ffi ^
_` ' ", and the result follows from the subtyping of "  "\Sigma .

71
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LCONT This case follows immediately from induction hypothesis (ii).
(ii) This part of the lemma follows almost immediately from the induction hypotheses.The interesting case is

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LETLIN, which must ensure that the ordering on thelinear context is maintained.

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LETLIN By assumption, there is a derivation of the following form:

o/ % $\Omega  ^ \Delta \Lambda flffi\Sigma \Pi '\Omega \Sigma  ' *\Sigma _\Pi  ,\Sigma  ' "\Sigma \Sigma 

"\Sigma \Sigma  \Delta  *\Sigma  _ *
flffi \Xi  flffi\Sigma  o/ % $\Psi \Upsilon  oe\Sigma \Sigma  ' "\Sigma \Sigma  ssflffiae ^ ,

o/ % $fl\Upsilon  oe ' "\Upsilon  $ffi ssflffiae ^ \Theta \Phi \Pi \Theta \Lambda \Xi  oe\Sigma \Sigma  \Delta  \Delta \Lambda flffi\Sigma \Pi '\Omega \Sigma  ' *\Sigma _\Pi  ,\Sigma  \Lambda \Xi  ,

Where $fl\Upsilon  oe ' "\Upsilon  $ffi \Delta  $\Psi \Upsilon  $\Omega . If oe appears in $\Psi  then $\Psi  \Delta  $fl\Upsilon  oe ' "\Upsilon  $\Upsilon ffiand

$\Omega  \Delta  $^ffi where $\Upsilon ffi \Upsilon  $^ffi \Delta  $ffi. In this case, oe can't appear in
$\Omega  and it follows that ,\Sigma fl_`aeoeffi \Delta  ,\Sigma . Induction hypothesis (ii) applied
to o/ % $fl\Upsilon  oe ' "\Upsilon  $\Upsilon ffi ssflffiae ^ , yields the judgment o/ % $fl\Upsilon  $\Upsilon  $\Upsilon ffi ssflffiae ^
,fl_`aeoeffi. Thus, an application of rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LETLIN yields the desired result, as $fl\Upsilon  $\Upsilon  $\Upsilon ffi \Upsilon  $^ffi \Delta  $fl\Upsilon  $\Upsilon  $ffi.

The case in which oe appears in $\Omega  is similar to the one above, except that
$fl is split into $ \Upsilon fl and $^fl .

\Delta 
Next we must establish that the syntactic form of a value is determined by its type.

Lemma 4.3.3 (Canonical Forms I) If ! ^ ` ' * then
(i) If * \Delta  fflaeae\Theta \Theta  then ` \Delta  \Pi \Theta \Delta  or ` \Delta  `\Theta \Delta  for some \Psi \Sigma  \Xi  \Psi .
(ii) If * \Delta  ffi\Xi \Lambda \Pi \Theta  then ` \Delta  \Lambda \Pi \Theta \Delta  for some \Psi \Sigma  \Xi  \Psi .
(iii) If * \Delta  *\Sigma  \Omega \Phi `\Theta  then ` \Delta  \Sigma ff

\Delta 

\Theta \Delta  and \Psi 

\Sigma  \Xi  \Psi .

(iv) If * \Delta  \Theta ssflffiae\Theta *\Sigma \Upsilon  "\Lambda  _ *\Lambda \Theta  then ` \Delta  \Theta \Delta ssflffi\Sigma ae AE '\Omega  ' *\Sigma \Sigma \Upsilon  oe ' "\Sigma _\Pi  ,\Lambda \Theta \Delta  where \Psi \Sigma  \Xi  \Psi ,

flffi \Xi  flffi\Sigma , ^ *\Sigma   *\Sigma \Sigma , and ^ "  "\Sigma .

Proof (sketch): By inspection of the typing rules and the form of values. \Delta 

Lemma 4.3.4 (Canonical Forms II) If !% ! ^ _` ' * _ * then _` \Delta  \Delta \Lambda flffi\Pi '\Omega  ' *\Sigma _\Pi  ,
where ^ *  *\Sigma .

Proof (sketch): By inspection of the typing rules and the form of linear values. \Delta 

72
Definition 4.3.1 (Locations) For any well-typed primitive operation, fl#\Xi O/ (or program, ,), let \Sigma i\Theta fl#\Xi O/\Lambda  (respectively \Sigma i\Theta ,\Lambda ), be the set of all locations \Sigma ff appearing
in fl#\Xi O/ (respectively ,).

Recall the definition of Memory Well-formedness:
Definition 4.3.2 (Memory well formedness) A memory OE is well formed, written ^
OE #, if and only if

j\Sigma ff \Sigma  *OE *\Pi  \Sigma i\Theta OE \Theta \Sigma ff\Lambda \Lambda  \Sigma  *OE * ss ! ^ OE \Theta \Sigma ff\Lambda  ' *
Next, we show that evaluation of primitive operations preserves typing, so long asthe memory contains the appropriate locations used by the primitive operation.

Lemma 4.3.5 (Primitive Evaluation) If ! ssflffiae ^ fl#\Xi O/ ' *, ^ OE #, and \Sigma i\Theta fl#\Xi O/\Lambda  ffl
oe\Omega o/\Theta OE \Lambda  and \Lambda OE\Upsilon  flffi\Upsilon  fl#\Xi O/\Pi  * ` then ! ^ ` ' *.

Proof: By cases on the evaluation rule used.
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-PRIM By assumption, we have the canonical derivation:

! ^ ffl`\Theta  ' %\Theta  ^ %\Theta   % \Sigma \Theta \Delta 

! ^ ffl`\Theta  ' % \Sigma \Theta \Delta  flffi \Xi  \Psi \Sigma 

! ssflffiae ^ ffl`\Theta  ' % \Sigma \Theta \Delta 

We need to show ! ^ ffl`\Theta \Pi \Phi \Psi  ' % \Sigma \Theta \Delta . It follows from the derivation above that \Psi  \Xi  \Psi \Sigma ,and as

flffi \Xi  \Psi \Sigma  it is the case that \Psi  \Phi  flffi \Xi  \Psi \Sigma . Thus we have the inequality
%\Theta \Pi \Phi \Psi   % \Sigma \Theta \Delta  , and so the result follows by \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -SUB and an application of the rule
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -VAL.

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-BINOP This case is similar to the previous one.
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-DEREF In this case, we assume a derivation of the following form:

! ^ \Sigma ffl\Delta \Theta \Delta  ' %\Theta  \Omega \Phi `\Theta \Delta  ^ %\Theta  \Omega \Phi `\Theta \Delta   %\Theta  \Omega \Phi `\Theta \Delta \Delta 

! ^ \Sigma ffl\Delta \Theta \Delta  ' %\Theta  \Omega \Phi `\Theta \Delta \Delta  flffi \Xi  \Psi  \Phi  \Psi \Sigma \Sigma 

! ssflffiae ^ "\Sigma ffl\Delta \Theta \Delta  ' %\Theta \Pi \Theta \Delta \Delta 

By the well-formedness of OE , OE \Theta \Sigma ffl\Delta  \Lambda  \Delta  ffl`\Theta \Delta \Delta \Delta  and we also have ! ^ ffl`\Theta \Delta \Delta \Delta  ' %\Theta .This implies that

\Psi \Sigma \Sigma \Sigma  \Xi  \Psi . We must show that ! ^ ffl`\Theta \Delta \Pi \Theta \Delta \Delta \Delta \Pi \Phi \Psi  ' %\Theta \Pi \Theta \Delta \Delta  but this follows
from the transitivity of subtyping and \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -SUB because the label inequalities inthe above derivation yield:

\Psi \Sigma  \Phi  \Psi \Sigma \Sigma \Sigma  \Phi  flffi \Xi  \Psi \Sigma \Sigma  \Phi  \Psi \Sigma \Sigma \Sigma  \Phi  flffi

\Xi  \Psi \Sigma \Sigma  \Phi  \Psi  \Phi  flffi
\Xi  \Psi \Sigma \Sigma  \Phi  \Psi  \Phi  \Theta \Psi  \Phi  \Psi \Sigma \Sigma \Lambda 
\Xi  \Psi  \Phi  \Psi \Sigma \Sigma 

73

\Delta 
The next lemma is used in the proof of subject reduction in the case for evaluating
conditional expressions. The idea is that because the static labels are just approximationsto the actual run-time labels that appear in the operational semantics, we must have a

way of accounting for the difference between what is statically inferred and what takesplace during evaluation. Thus, while the static label of the variable

\Omega  in the conditional
\Lambda ` \Omega  \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi may be \Psi , dynamically the value substituted for \Omega  might have any
label \Psi \Sigma  \Xi  \Psi . Since the rules for evaluating conditionals use the dynamic label \Psi \Sigma , in orderto establish subject-reduction, the branches of the conditional must be well-typed under

the weaker constraint.
Lemma 4.3.6 (Program Counter Variance)

If o/ % $ ssflffi \Phi  \Psi ae ^ , and \Psi \Sigma  \Xi  \Psi  then o/ % $ ssflffi \Phi  \Psi \Sigma ae ^ ,.
Proof: The proof is by induction on the derivation that , is well-typed. Note that
because flffi \Phi  \Psi \Sigma  \Xi  flffi \Phi  \Psi  all inequalities involving flffi \Phi  \Psi  on the left of \Xi  in the typingrules will still hold with

flffi \Phi  \Psi \Sigma . \Delta 

The subject reduction lemma follows almost immediately from the previous lemmas.It says that well-typing is preserved by evaluation.

Lemma 4.3.7 (Subject Reduction) If !% $ ssflffiae ^ ,, and ^ OE #,, and \Sigma i\Theta ,\Lambda  ffl
oe\Omega o/\Theta OE \Lambda  and \Lambda OE\Upsilon  flffi\Upsilon  ,\Pi  _ \Lambda OE \Sigma \Upsilon  flffi\Sigma \Upsilon  ,\Sigma \Pi  then !% $ ssflffi\Sigma ae ^ ,\Sigma  and ^ OE \Sigma  #,, and
\Sigma i\Theta ,\Sigma \Lambda  ffl oe\Omega o/\Theta OE \Sigma \Lambda .

Proof: By cases on the transition step taken:
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LETPRIM Because \Theta \Phi \Pi  \Omega  \Delta  fl#\Xi O/ \Lambda \Xi  , is well-typed, fl#\Xi O/ is too. Thus

by the Primitive Evaluation Lemma, fl#\Xi O/ evaluates to a value ` of the same type.Substitution I, part (iv) tells us that

,fl`ae\Omega ffi is well-typed. Because OE doesn'tchange it is still well-formed, and to see that

\Sigma i\Theta ,fl`ae\Omega ffi\Lambda  ffl oe\Omega o/\Theta OE \Lambda  consider
that the only way \Sigma i\Theta ,fl`ae\Omega ffi\Lambda  could be larger than \Sigma i\Theta \Theta \Phi \Pi  \Omega  \Delta  fl#\Xi O/ \Lambda \Xi  ,\Lambda is if

fl#\Xi O/ is a dereference operation and the memory location contains anotherlocation not in

,. This case is covered by the requirement that OE is well-formed
and hence closed under dereference.

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LETREF By assumption, that !% $ ssflffiae ^ \Theta \Phi \Pi  \Omega  \Delta  \Omega \Phi `ffffl`\Theta  \Lambda \Xi  ,. Working

backwards through the canonical derivation yields the following antecedents: ! ^
ffl`\Theta  ' %\Theta , and ^ %\Theta   *, and flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda , and \Omega  ' * \Omega \Phi `\Phi \Psi % $ ssflffiae ^ ,. From
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LOC we have ! ^ \Sigma ff\Theta \Delta \Pi \Phi \Psi  ' * \Omega \Phi `\Theta \Delta . This fact, plus the well-typedness of , lets

74
us apply Substitution Lemma I, (iv) to conclude !% $ ssflffiae ^ ,fl\Sigma ff\Theta \Delta \Pi \Phi \Psi ae\Omega ffi. Now, to
see that the conditions on OE are maintained, note that if ffl` contains a location,then it is contained in the set of locations of the entire let expression and thus, by

assumption must occur in the domain of OE . This implies that OE ss\Sigma ff %_ ffl`\Theta \Pi \Phi \Psi ae is
still closed under dereference. Finally, we must check that ! ^ ffl`\Theta \Pi \Phi \Psi  ' *, but thisfollows from subsumption and the facts that

%\Theta   * and flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda .

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-SET This case follows similarly to the previous case.
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LETLIN This case follows from Substitution II, (ii), and the fact that theconditions on

OE are satisfied after the substitution. Note that the order of $ is
preserved by the step.

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-COND1 Assume that !% $ ssflffiae ^ \Lambda ` \Pi \Theta  \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi. It follows that

! ^ &\Theta  ' fflaeae\Theta \Theta \Delta  and \Psi  \Xi  \Psi \Sigma  and that !% $ ssflffi \Phi  \Psi \Sigma ae ^ ,fl. It follows by the ProgramCounter Variance Lemma that

!% $ ssflffi \Phi  \Psi ae ^ ,fl. Because OE doesn't change andit initially satisfied the well-formedness conditions and the locations of

,fl are a
subset of the locations of the entire conditional, OE is still valid after the transition.

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-COND2 This case is nearly identical to the previous one.
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-GOTO This case follows from the well-typedness of the body of the con-tinuation being jumped to, plus two applications of Substitution I, (iv) and one

application of Substitution II, (ii). The fact that ffl`\Theta \Delta \Pi \Phi \Psi  has type * follows fromsubsumption and the facts that

flffi\Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda  and \Psi \Sigma  \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda .

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LGOTO This case is similar to the previous case.

\Delta 
The progress lemma says that the dynamic checks performed by the operational
semantics are actually unnecessary: a well-typed program is either already a value, or itcan perform a step of computation.

Lemma 4.3.8 (Progress) If !% ! ssflffiae ^ , and OE #, and \Sigma i\Theta ,\Lambda  ffl oe\Omega o/\Theta OE \Lambda , then either
, is of the form \Delta \Theta \Pi ff ` or there exist OE \Sigma , &\Sigma \Upsilon  flffi\Sigma , and ,\Sigma  such that

\Lambda OE\Upsilon  flffi\Upsilon  ,\Pi  _ \Lambda OE \Sigma \Upsilon  &\Sigma \Upsilon  flffi\Sigma \Pi ,\Sigma 
Proof (sketch): By the Canonical Forms lemmas and inspection of the rules. We mustensure that conditions such as

\Psi  \Phi  flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda  on rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LETREF are met by
well-typed terms. These constraints are taken from the typing derivations. For example,for

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LETREF the fact that flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda  is an immediate antecedent; wehave

\Psi  \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda  from the subtyping rules and the fact that the value is well formed.
\Delta 

75
Definition 4.3.3 A configuration \Lambda OE\Upsilon  flffi\Upsilon  ,\Pi  is stuck if , is not \Delta \Theta \Pi ff ` for some value
` or no transition rule applies.

Theorem 4.3.1 (Type Soundness) Well-typed programs do not get stuck.
Proof: By induction on the number of transition steps taken, using Subject Reduction
and Progress. \Delta 

Note that Subject Reduction holds for terms containing free occurrences of linearvariables. This fact is important for proving that the ordering on linear continuations is

respected. The Progress Lemma (and hence Soundness) applies only to closed terms.

4.4 Noninterference
This section proves a noninterference result for the secure CPS language, generalizing a
previous result from Smith and Volpano [SV98]. The approach is to use a preservation-style argument that shows a particular invariant related to low-security views of a welltyped program is maintained by each computation step.

In contrast to the previous work, the proof here handles the case of first-class contin-uations and structured memories. The Smith and Volpano language permits only simple

/\Delta \Lambda \Theta \Phi -loops and \Lambda ` statements and restricts memories locations to hold only integer
values. Heintze and Riecke's SLam calculus [HR98] permits first-class functions andreference cells, but their work does not prove a noninterference result.

Since this proof was originally published [ZM01a, ZM02], other researchers havegiven alternative approaches to proving noninterference. Pottier and Conchon give
a proof for Core ML, a language with higher-order functions, references, and \Theta \Phi \Pi -
polymorphism in the style of SML [MTHM97]. Their proof differs quite substantiallyfrom the one presented here. Honda and Yoshida extend the Smith and Volpano system

to include general references, first-class functions, and concurrency. Their noninterference result is established by a CPS-like translation to a secure version of Milner's picalculus [HY02], but the full proof of noninterference has not been published.

Informally, the noninterference result says that low-security computations are notable to observe high-security data. Here, the term "low-security" is relative to an arbitrary point, \Theta , in the security lattice \Theta . Thus, \Psi  is a low-security label whenever \Psi  \Xi  \Theta .
Similarly, "high-security" refers to those labels i\Xi  \Theta . The security level of a computationis indicated by the label of the program counter under which the computation is taking

place. Thus, by "low-security computation", we mean a transition step in the operational
semantics whose starting configuration (the one before the step) contains a flffi \Xi  \Theta .The proof shows that high-security data and computation can be arbitrarily changed

without affecting the value of any computed low-security result. Furthermore, memory

76
locations visible to low-security observers (locations storing data labeled \Xi  \Theta ) are likewise unaffected by high-security values. This characterization reduces noninterferenceto the problem of showing that a given program

,fl is equivalent (from a low-securityobserver's point of view) to any program
,ffi that differs from ,fl only in its high-security
parts.Key to the argument is a formal definition of "low-equivalence," by which we intend to capture the property that two programs' executions are indistinguishable by anobserver only able to see the low-security portions of memory and machine state.

How do we show that configurations \Lambda OEfl\Upsilon  flffifl\Upsilon  ,fl\Pi  and \Lambda OEffi\Upsilon  flffiffi\Upsilon  ,ffi\Pi  behave identically from the low-security point of view? Clearly, the memories OEfl and OEffi mustagree on the values contained in low-security locations. In addition, if

flffifl\Upsilon  flffiffi \Xi  \Theta ,meaning that
,fl and ,ffi might perform actions visible to low observers (such as modifying a low-security memory location), the programs necessarily must perform the samecomputation on low-security values. On the other hand, when

flffi i\Xi  \Theta , the actions of ,fl
and ,ffi should be invisible to the low view.This intuition guides the formal definition of low-equivalence, which we write

`\Phi  .The definition builds on standard alpha-equivalence (written
(\Lambda ) as a base notion of
equality. We use substitutions to factor out the relevant high-security values and thoselinear continuations that reset the program-counter label to be

\Xi  \Theta .

Definition 4.4.1 (Substitutions) For context o/ , let o/ *\Delta  o/ mean that o/ is a finite map
from variables to closed values such that oe\Omega o/\Theta o/\Lambda  \Delta  oe\Omega o/\Theta o/ \Lambda  and for every \Omega  \Sigma  oe\Omega o/\Theta o/\Lambda 
it is the case that ! ^ o/\Theta \Omega \Lambda  ' o/ \Theta \Omega \Lambda .

Substitution application, written o/\Theta ,\Lambda , indicates capture-avoiding substitution of thevalue

o/\Theta \Omega \Lambda  for free occurrences of \Omega  in ,, for each \Omega  in the domain of o/.To show

\Theta -equivalence between ,fl and ,ffi, we should find substitutions o/fl and o/ffi
containing the relevant high-security data such that ,fl (\Lambda  o/fl\Theta ,\Lambda  and ,ffi (\Lambda  o/ffi\Theta ,\Lambda --both
,fl and ,ffi look the same as , after factoring out the high-security data.The other important piece of the proof is that we can track the linear continuations

that restore the program counter to a label that is i\Xi  \Theta . Here is where the stack orderingon linear continuations comes into play: The operational semantics guarantees that the
program-counter label is monotonically increasing except when a linear continuation isinvoked. If

,fl invokes a linear continuation that causes flffifl to fall below \Theta , ,ffi must fol-low suit and call an equivalent continuation; otherwise the low-security observer might

distinguish ,fl from ,ffi. The stack ordering on linear continuations is exactly the propertythat forces

,ffi to invoke the same low-security continuation as ,fl.Note that only the low-security linear continuations are relevant to the

\Theta -equivalence
of two programs--the high-security linear continuations in the programs may differ.Furthermore, our plan is to establish an invariant with respect to the operational semantics. This means we must be able to keep track of the relevant low-security continuations

77
as they are introduced and consumed by \Theta \Phi \Pi \Theta \Lambda \Xi  and \Theta ssae\Pi ae. There is a slight technical
difficulty in doing so in the substitution-style operational semantics we have presented:We want to maintain the invariant that

\Theta -equivalent programs always have equivalentpending low-security continuations. Statically, the linear context names these continuations, but dynamically, these variables are substituted away--there is no way to namethe "next" low-security linear continuation.

To get around this problem, our approach is to introduce auxiliary substitutions thatmap stacks of linear variables to low-security linear continuations. The top of stack
corresponds to the next low-security linear continuation that will be invoked.
Definition 4.4.2 (Linear Continuation Stack) Let $ be an ordered list (a stack) of
linear variables oefl ' "fl\Upsilon  \Pi  \Pi  \Pi  \Upsilon  oe\Delta  ' "\Delta  such that ' ) &. We write o/ ^ ! *\Delta  $ to indicate
that ! is a substitution that maps each oe\Pi  to a linear value such that o/ % ! ^ !\Theta oefl\Lambda  ' "fl
and o/ % oe\Pi \Upsilon fl ' "\Pi \Upsilon fl ^ !\Theta oe\Pi \Lambda  ' "\Pi  for \Xi  \Sigma  flOE \Pi  \Pi  \Pi  'ffi.

Application of a stack substitution ! to a term , is defined as:

!\Theta ,\Lambda  \Delta  ,fl!\Theta oe\Delta \Lambda aeoe\Delta ffifl!\Theta oe\Delta \Upsilon fl\Lambda aeoe\Delta \Upsilon flffi \Pi  \Pi  \Pi  fl!\Theta oefl\Lambda aeoeflffi\Pi 
Note that the order of the substitutions is important because the continuation !\Theta oe\Delta \Lambda  may
refer to the linear variable oe\Delta \Upsilon fl.

Two linear continuation stacks !fl and !ffi are equivalent if they have the same domain
and map each variable to equivalent continuations. We must also ensure that the stackcontains

all of the pending low-security continuations.

Definition 4.4.3 (\Theta \Phi \Pi \Theta \Lambda \Xi  Invariant) A term satisfies the \Theta \Phi \Pi \Theta \Lambda \Xi  invariant if every linear continuation expression \Delta \Lambda flffi\Pi '\Omega  ' *_\Pi  , appearing in the term is either in the binding
position of a \Theta \Phi \Pi \Theta \Lambda \Xi  or satisfies flffi i\Xi  \Theta .

The idea behind the \Theta \Phi \Pi \Theta \Lambda \Xi  invariant is that when !\Theta ,\Lambda  is a closed term such that ,satisfies the

\Theta \Phi \Pi \Theta \Lambda \Xi  invariant, any invocation of a low-security linear continuation in ,
must arise from the substitution !--in other words, ! contains any pending low-securitylinear continuations.

Extending these ideas to values, memories, and machine configurations we obtainthe definitions below:

Definition 4.4.4 (\Theta -Equivalence)

o/ ^ o/fl `\Phi  o/ffi If o/fl\Upsilon  o/ffi *\Delta  o/ and for every \Omega  \Sigma  oe\Omega o/\Theta o/ \Lambda  it is the case that

\Delta \Theta \Lambda \Xi \Delta \Theta o/\Pi \Theta \Omega \Lambda \Lambda  i\Xi  \Theta  and o/\Pi \Theta \Omega \Lambda  satisfies the \Theta \Phi \Pi \Theta \Lambda \Xi  invariant.

78
o/ ' $ ^ !fl `\Phi  !ffi If o/ ^ !fl\Upsilon  !ffi *\Delta  $ and for every oe \Sigma  oe\Omega o/\Theta $\Lambda  it is the case

that !\Pi \Theta oe\Lambda  (\Lambda  \Delta \Lambda flffi\Pi '\Omega  ' *_\Pi  , such that flffi \Xi  \Theta  and , satisfies the
\Theta \Phi \Pi \Theta \Lambda \Xi  invariant.

`fl `\Phi  `ffi ' * If there exist o/ , o/fl, and o/ffi plus terms `\Sigma fl (\Lambda  `\Sigma ffi such that o/ ^

o/fl `\Phi  o/ffi, and o/ ^ `\Sigma \Pi  ' * and `\Pi  \Delta  o/\Pi \Theta `\Sigma \Pi \Lambda  and each `\Sigma \Pi  satisfies the
\Theta \Phi \Pi \Theta \Lambda \Xi  invariant.

OEfl `\Phi  OEffi If for all \Sigma ff \Sigma  oe\Omega o/\Theta OEfl\Lambda  OE oe\Omega o/\Theta OEffi\Lambda , \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda  \Xi  \Theta  implies that

\Sigma ff \Sigma  oe\Omega o/\Theta OEfl\Lambda  O/ oe\Omega o/\Theta OEffi\Lambda  and OEfl\Theta \Sigma ff\Lambda  `\Phi  OEffi\Theta \Sigma ff\Lambda  ' *.

Finally, we can put all of these requirements together to define the \Theta -equivalence of
two machine configurations, which also gives us the invariant for the noninterferenceproof.

Definition 4.4.5 (Noninterference Invariant) The noninterference invariant is a predicate on machine configurations, written o/ ' $ ^ \Lambda OEfl\Upsilon  flffifl\Upsilon  ,fl\Pi  `\Phi  \Lambda OEffi\Upsilon  flffiffi\Upsilon  ,ffi\Pi , that
holds if there exist substitutions o/fl\Upsilon  o/ffi\Upsilon  !fl\Upsilon  !ffi and terms ,\Sigma fl and ,\Sigma ffi such that the following
conditions are all met:(i) ,

fl \Delta  o/fl\Theta !fl\Theta ,\Sigma fl\Lambda \Lambda  and ,ffi \Delta  o/ffi\Theta !ffi\Theta ,\Sigma ffi\Lambda \Lambda .(ii)
o/ % $ ssflffiflae ^ ,\Sigma fl and o/ % $ ssflffiffiae ^ ,\Sigma ffi(iii)

Either \Theta ffi\Lambda  flffifl \Delta  flffiffi \Xi  \Theta  *'oe ,\Sigma fl (\Lambda  ,\Sigma ffi \Omega _

\Theta ffl\Lambda  flffifl i\Xi  \Theta  *'oe flffiffi i\Xi  \Theta \Pi (iv)
o/ ^ o/fl `\Phi  o/ffi and o/ ' $ ^ !fl `\Phi  !ffi(v)
\Sigma i\Theta ,fl\Lambda  ffl oe\Omega o/\Theta OEfl\Lambda  and \Sigma i\Theta ,ffi\Lambda  ffl oe\Omega o/\Theta OEffi\Lambda 
and OEfl `\Phi  OEffi.(vi)
Both ,\Sigma fl and ,\Sigma ffi satisfy the \Theta \Phi \Pi \Theta \Lambda \Xi  invariant.

The main technical work of the noninterference proof is a preservation argumentshowing that the Noninterference Invariant holds after each transition. When the

flffi is
low, equivalent configurations execute in lock step (modulo high-security data). Afterthe program branches on high-security information (or jumps to a high-security continuation), the two programs may temporarily get out of sync, but during that time they
may affect only high-security data. If the program counter drops low again (via a linearcontinuation), both computations return to lock-step execution.

We first show that \Theta -equivalent configuration evaluate in lock step as long as the
program counter has low security.

Lemma 4.4.1 (Low-flffi Step) Suppose

" o/ ' $ ^ \Lambda OEfl\Upsilon  flffifl\Upsilon  ,fl\Pi  `\Phi  \Lambda OEffi\Upsilon  flffiffi\Upsilon  ,ffi\Pi 
" flffifl \Xi  \Theta  and flffiffi \Xi  \Theta 

79
" \Lambda OEfl\Upsilon  flffifl\Upsilon  ,fl\Pi  _ \Lambda OE \Sigma fl\Upsilon  flffi\Sigma fl\Upsilon  ,\Sigma fl\Pi 
then \Lambda OEffi\Upsilon  flffiffi\Upsilon  ,ffi\Pi  _ \Lambda OE \Sigma ffi\Upsilon  flffi\Sigma ffi\Upsilon  ,\Sigma ffi\Pi  and there exist o/ \Sigma  and $\Sigma  such that:

o/ \Sigma  ' $\Sigma  ^ \Lambda OE \Sigma fl\Upsilon  flffi\Sigma fl\Upsilon  ,\Sigma fl\Pi  `\Phi  \Lambda OE \Sigma ffi\Upsilon  flffi\Sigma ffi\Upsilon  ,\Sigma ffi\Pi 
Proof: Let ,fl \Delta  o/fl\Theta !fl\Theta ,\Sigma \Sigma fl\Lambda \Lambda  and ,ffi \Delta  o/ffi\Theta !ffi\Theta ,\Sigma \Sigma ffi\Lambda \Lambda  where the substitutions are as de-scribed by the conditions of the Noninterference Invariant. Because

flffi\Pi  \Xi  \Theta , clause (iii)implies that
,\Sigma \Sigma fl and ,\Sigma \Sigma ffi must be ss-equivalent expressions and flffifl \Delta  flffiffi \Delta  flffi. Hence
the only difference in their behavior arises due to the substitutions or the different mem-ories. We proceed by cases on the transition step taken by the first program. The main

technique is to reason by cases on the security level of the value used in the step--if
it's low-security, by ss-equivalence, both programs compute the same values, otherwisewe extend the substitutions

o/fl and o/ffi to contain the high-security data. We show a few
representative cases in detail to give the flavor of the argument, the remainder follow ina similar fashion.

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LETPRIM

\Lambda OE\Upsilon  flffi\Upsilon  fl#\Xi O/\Pi  * `
\Lambda OE\Upsilon  flffi\Upsilon  \Theta \Phi \Pi  \Omega  \Delta  fl#\Xi O/ \Lambda \Xi  ,\Pi  _ \Lambda OE\Upsilon  flffi\Upsilon  ,fl`ae\Omega ffi\Pi 

In this case, ,\Sigma \Sigma fl and ,\Sigma \Sigma ffi must be of the form \Theta \Phi \Pi  \Omega  \Delta  fl#\Xi O/ \Lambda \Xi  ,, consequently ,ffimust also transition via rule

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LETPRIM. Because OEfl \Delta  OE \Sigma fl and OEffi \Delta 
OE \Sigma ffi, and the locations found in terms ,\Sigma fl and ,\Sigma ffi are found in ,fl and ,ffi respectively,
condition (v) of the Noninterference Invariant holds after the transition.

It suffices to find an ,\Sigma  and o/\Sigma \Pi  such that ,\Sigma fl \Delta  o/\Sigma fl\Theta !fl\Theta ,\Sigma \Lambda \Lambda  and ,\Sigma ffi \Delta  o/\Sigma ffi\Theta !ffi\Theta ,\Sigma \Lambda \Lambda .If

fl#\Xi O/ is a value, then take o/\Sigma \Pi  \Delta  o/\Pi  and let ,\Sigma  \Delta  ,flfl#\Xi O/ae\Omega ffi. These choicessatisfy the conditions. Otherwise,

fl#\Xi O/ is not a value. Consider the evaluation
\Lambda OEfl\Upsilon  flffi\Upsilon  o/fl\Theta fl#\Xi O/\Lambda \Pi  * ffl`\Theta . There are two cases.

If \Psi  \Xi  \Theta  then fl#\Xi O/ cannot contain any free variables, for otherwise condition (iv)would be violated--evaluation rules

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-PRIM and \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-BINOP
imply that the label of the resulting value be higher than the label of any con-stituent, and all the values of

o/fl have label higher than \Theta . Thus, o/fl\Theta fl#\Xi O/\Lambda  \Delta 
fl#\Xi O/ \Delta  o/ffi\Theta fl#\Xi O/\Lambda . \Lambda OEffi\Upsilon  flffi\Upsilon  o/ffi\Theta fl#\Xi O/\Lambda \Pi  * ffl`\Sigma \Theta \Delta  and because OEfl `\Phi  OEffi we
have ffl`\Theta  `\Phi  ffl`\Sigma \Theta \Delta  ' *. Thus, there exist o/ \Sigma \Sigma , o/\Sigma \Sigma fl , o/\Sigma \Sigma ffi and values `fl (\Lambda  `ffi such that
o/ \Sigma \Sigma  ^ o/\Sigma \Sigma fl `\Phi  o/\Sigma \Sigma ffi and ffl`\Theta  \Delta  o/\Sigma \Sigma fl \Theta `fl\Lambda  and ffl`\Sigma \Theta \Delta  \Delta  o/\Sigma \Sigma ffi \Theta `ffi\Lambda . Thus, we take o/\Sigma fl \Delta  o/fl OE o/\Sigma \Sigma fl ,
o/\Sigma ffi \Delta  o/ffi OE o/\Sigma \Sigma ffi and ,\Sigma \Sigma \Pi  \Delta  ,fl`\Pi ae\Omega ffi. Conditions (iv), (v), and (vi) hold trivially;
conditions (i), (ii), and (iii) are easily verified based on the operational semanticsand the fact that

flffifl \Delta  flffiffi \Delta  flffi.

If \Psi  i\Xi  \Theta  then \Lambda OEffi\Upsilon  flffi\Upsilon  o/ffi\Theta fl#\Xi O/\Lambda \Pi  * ffl`\Sigma \Theta \Delta  where it is also the case that \Psi \Sigma  i\Xi  \Theta .
(fl#\Xi O/ either contains a variable, which forces \Psi \Sigma  to be high, or fl#\Xi O/ contains a

80
value explicitly labeled with a high-label.) It follows that ffl`\Theta  `\Phi  ffl`\Sigma \Theta \Delta  ' * and we
take o/\Sigma fl \Delta  o/flfl\Omega  %_ ffl`\Theta ffi and o/\Sigma ffi \Delta  o/ffifl\Omega  %_ ffl`\Sigma \Theta \Delta  ffi, and ,\Sigma \Sigma \Pi  \Delta  ,, which are easilyseen to satisfy the conditions.

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LETREF

\Psi  \Phi  flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda  \Sigma ff i\Sigma  oe\Omega o/\Theta OE \Lambda 
\Lambda OE\Upsilon  flffi\Upsilon  \Theta \Phi \Pi  \Omega  \Delta  \Omega \Phi `ffffl`\Theta  \Lambda \Xi  ,\Pi 

_ \Lambda OE ss\Sigma ff %_ ffl`\Theta \Pi \Phi \Psi ae\Upsilon  flffi\Upsilon  ,fl\Sigma ff\Phi \Psi ae\Omega ffi\Pi 

In this case, ,\Sigma \Sigma fl and ,\Sigma \Sigma ffi must be of the form \Theta \Phi \Pi  \Omega  \Delta  \Omega \Phi `ff` \Lambda \Xi  , where ` \Delta  ffl`\Theta .Note that

o/fl\Theta `\Lambda  `\Phi  o/ffi\Theta `\Lambda  ' * so it follows that OE \Sigma fl \Delta  OEflss\Sigma ff %_ o/fl\Theta `\Lambda  \Phi  flffiae is
\Theta -equivalent to OE \Sigma ffi \Delta  OEffiss\Sigma ff %_ o/ffi\Theta `\Lambda  \Phi  flffiae, satisfying invariant (v). Now wesimply take

o/\Sigma \Pi  \Delta  o/\Pi , and note that ,\Sigma fl \Delta  o/fl\Theta ,fl\Sigma ff\Phi \Psi ae\Omega ffi\Lambda  and ,\Sigma ffi \Delta  o/ffi\Theta ,fl\Sigma ff\Phi \Psi ae\Omega ffi\Lambda satisfy the required invariants.

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LETLIN

\Lambda OE\Upsilon  flffi\Upsilon  \Theta \Phi \Pi \Theta \Lambda \Xi  oe\Sigma  \Delta  _` \Lambda \Xi  ,\Pi  _ \Lambda OE\Upsilon  flffi\Upsilon  ,fl_`aeoe\Sigma ffi\Pi 

If _` \Delta  \Delta \Theta \Pi ff , then the Noninterference Invariant holds trivially after the transi-tion. Otherwise,

_` \Delta  \Delta \Lambda flffi\Sigma \Pi '\Omega  ' *_\Pi  ,\Sigma . In this case, ,\Sigma \Sigma fl and ,\Sigma \Sigma ffi are \Theta \Phi \Pi \Theta \Lambda \Xi  oe\Sigma  \Delta 
\Delta \Lambda flffi\Sigma \Pi '\Omega  ' *_\Pi  ,\Sigma  \Lambda \Xi  ,. If flffi\Sigma  \Xi  \Theta , simply take $\Sigma  \Delta  $\Upsilon  oe\Sigma  ' * _ * and choose
!\Sigma \Pi  \Delta  !\Pi  OE floe\Sigma  %_ \Delta \Lambda flffi\Sigma \Pi '\Omega  ' *_\Pi  ,\Sigma ffi, which satisfies invariant (iv) because !fl `\Phi  !ffiand the terms

,\Sigma \Sigma fl and ,\Sigma \Sigma ffi are well-typed. In the case that flffi\Sigma  i\Xi  \Theta , we take !\Sigma \Pi  \Delta  !\Pi 
and choose each ,\Sigma \Pi  to be ,fl\Delta \Lambda flffi\Sigma \Pi '\Omega  ' *_\Pi  ,\Sigma aeoe\Sigma ffi which again satisfies invariant (iv)and the

\Theta \Phi \Pi \Theta \Lambda \Xi -invariant, (vi). The remaining invariants are easily seen to holdbecause the memories and ordinary value substitutions do not change.

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-COND1

\Lambda OE\Upsilon  flffi\Upsilon  \Lambda ` \Pi \Theta  \Pi \Delta \Phi \Xi  ,\Sigma \Psi  \Phi \Theta ,\Phi  ,\Sigma \Omega \Pi  _ \Lambda OE\Upsilon  flffi \Phi  \Psi \Upsilon  ,\Sigma \Psi \Pi 
In this case, ,\Sigma \Sigma fl and ,\Sigma \Sigma ffi must be of the form \Lambda ` ` \Pi \Delta \Phi \Xi  ,\Psi  \Phi \Theta ,\Phi  ,\Omega . If ` is not a vari-able, then by

ss-equivalence, ,ffi must also transition via rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-COND1.
Because OEfl and OEffi don't change, it is easy to establish that all of the invariantshold. When

` is a variable, o/fl\Theta `\Lambda  \Delta  \Pi \Theta  for \Psi  i\Xi  \Theta . Similarly, o/ffi\Theta `\Lambda  \Delta  ffl\Theta \Delta  for \Psi \Sigma  i\Xi  \Theta .Because
ffl could be either \Pi  or `, we don't know whether the second program
transitions via \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-COND1 or \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-COND2, but in either case itis easy to establish that the resulting configurations are

`\Phi  . Clause (i) holds viathe original substitutions; clause (ii) follows from the fact that the configurations

are well-typed; clause (iii) holds because part (b) lets us relate any high-securityprograms; clauses (iv) through (vi) are a simple consequence of

\Theta -equivalence of
,fl and ,ffi.

81
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-GOTO

flffi \Xi  flffi\Sigma  ` \Delta  \Theta \Delta ssflffi\Sigma ae AE '\Omega  ' *_\Pi  oe ' ",\Lambda \Theta 
\Lambda OE\Upsilon  flffi\Upsilon  ssae\Pi ae ` `\Sigma  _`\Pi  _ \Lambda OE\Upsilon  flffi\Sigma  \Phi  \Psi \Upsilon  ,fl`aeAE ffifl`\Sigma  \Phi  flffiae\Omega ffifl_`aeoeffi\Pi 

In this case, each ,\Sigma \Sigma \Pi  \Delta  ssae\Pi ae ` `\Sigma  _`. It must be the case that o/fl\Theta `\Lambda  \Delta  \Theta \Delta ssflffi\Sigma aeAE'\Omega  '
*\Upsilon  oe ' "_\Pi  ,\Lambda \Theta . If \Psi  \Xi  \Theta , then ` \Delta  \Theta \Delta ssflffi\Sigma aeAE'\Omega  ' *\Upsilon  oe ' "_\Pi  ,\Sigma \Lambda \Theta  where ,\Sigma  \Delta  o/fl\Theta ,\Lambda because, by invariant (iii), the continuation could not be found in

o/fl. Note that
o/fl\Theta `\Sigma \Lambda  `\Phi  o/ffi\Theta `\Sigma \Lambda  ' *. There are two sub-cases, depending on whether o/fl\Theta `\Sigma \Lambda  haslabel

\Xi  \Theta . If so, it suffices to take o/ \Sigma  \Delta  o/ , $\Sigma  \Delta  $, and leave the substitutionsunchanged, for we have

,\Sigma \Pi  \Delta  o/\Pi \Theta !\Pi \Theta ,fl`aeAE ffiflo/\Pi \Theta `\Sigma \Lambda  \Phi  flffiae\Omega ffifl_`aeoeffi\Lambda \Lambda . Otherwise,
if the label of o/fl\Theta `\Sigma \Lambda  i\Xi  \Theta , we take o/ \Sigma  \Delta  o/ \Upsilon  \Omega  ' * and o/\Sigma \Pi  \Delta  o/\Pi fl\Omega  %_ o/\Pi \Theta `\Sigma \Lambda  \Phi  flffiffi.The necessary constraints are then met by

,\Sigma \Pi  \Delta  o/\Sigma \Pi \Theta !\Pi \Theta ,fl`aeAE ffifl_`aeoeffi\Lambda \Lambda .

The other case is that \Psi  i\Xi  \Theta , and hence the label of o/ffi\Theta `\Lambda  is also i\Xi  \Theta . Thus,
flffi\Sigma fl \Delta  flffi \Phi  \Psi  i\Xi  \Theta  and flffi\Sigma ffi i\Xi  \Theta . The resulting configurations satisfy part (b) ofclause (iii). The bodies of the continuations are irrelevant, as long as the other

invariants are satisfied, but this follows if we build the new value substitutions as
in the previous paragraph

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LGOTO This follows analogously to the previous case, except that thestronger constraints that relate linear contexts imply that the continuations being

invoked are actually ss-equivalent.

\Delta 
Next, we prove that linear continuations do indeed get called in the order describedby the linear context. The proof follows directly from Subject Reduction and the linearity built into the type system.
Lemma 4.4.2 (Linear Continuation Ordering) Assume $ \Delta  oe\Delta  ' "\Delta \Upsilon  \Pi  \Pi  \Pi  \Upsilon  oefl ' "fl for
some ' ) AE, each "\Pi  is a linear continuation type, and !% $ ssflffiae ^ ,. If ! ^ ! *\Delta  $,
then in the evaluation starting from any well-formed configuration \Lambda OE\Upsilon  flffi\Upsilon  !\Theta ,\Lambda \Pi , the
continuation !\Theta oefl\Lambda  will be invoked before any other !\Theta oe\Pi \Lambda .

Proof: The operational semantics and Subject Reduction are valid for open terms.Progress, however, does not hold for open terms. Consider the evaluation of the open

term , in the configuration \Lambda OE\Upsilon  flffi\Upsilon  ,\Pi . If the computation diverges, none of the oe\Pi 'sever reach an active position, and hence are not invoked. Otherwise, the computation
must get stuck (it can't halt because Subject Reduction implies that all configurations
are well-typed; the \Delta \Theta \Pi  expression requires an empty linear context). The stuck termmust be of the form

\Theta ssae\Pi ae oe\Pi  `, and because it is well-typed, rules \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LVAR and
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LGOTO together imply that oe\Pi  \Delta  oefl. \Delta 

82
We use the stack ordering property of linear continuations, as made explicit in the
Progress Lemma, to prove that equivalent high-security configurations eventually returnto equivalent low-security configurations.

Lemma 4.4.3 (High-flffi Step) Suppose

" o/ ' $ ^ \Lambda OEfl\Upsilon  flffifl\Upsilon  ,fl\Pi  `\Phi  \Lambda OEffi\Upsilon  flffiffi\Upsilon  ,ffi\Pi 

" flffifl i\Xi  \Theta  and flffiffi i\Xi  \Theta 
" \Lambda OEfl\Upsilon  flffifl\Upsilon  ,fl\Pi  _ \Lambda OE \Sigma fl\Upsilon  flffi\Sigma fl\Upsilon  ,\Sigma fl\Pi 
then either ,ffi diverges or \Lambda OEffi\Upsilon  flffiffi\Upsilon  ,ffi\Pi  %oe_\Phi  \Lambda OE \Sigma ffi\Upsilon  flffi\Sigma ffi\Upsilon  ,\Sigma ffi\Pi  and there exist o/ \Sigma  and $\Sigma 
such that o/ \Sigma  ' $\Sigma  ^ \Lambda OE \Sigma fl\Upsilon  flffi\Sigma fl\Upsilon  ,\Sigma fl\Pi  `\Phi  \Lambda OE \Sigma ffi\Upsilon  flffi\Sigma ffi\Upsilon  ,ffi\Pi .

Proof: By cases on the transition step of the first configuration. Because flffifl i\Xi  \Theta 
and all rules except \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LGOTO increase the program-counter label, we maychoose zero steps for

,ffi and still show that `\Phi  is preserved. Condition (iii) holds via
part (b). The other invariants follow because all values computed and memory locationswritten to must have labels higher than

flffifl (and hence i\Xi  \Theta ). Thus, the only memorylocations affected are high-security:
OE \Sigma fl `\Phi  OEffi \Delta  OE \Sigma ffi. Similarly, \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LETLIN forces
linear continuations introduced by ,fl to have flffi i\Xi  \Theta . Substituting them in ,fl maintainsclause (v) of the invariant.

Now consider \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LGOTO. Let ,fl \Delta  o/fl\Theta !fl\Theta ,\Sigma \Sigma fl\Lambda \Lambda , then ,\Sigma \Sigma fl \Delta  \Theta ssae\Pi ae _` `fl
for some _`. If _` is not a variable, clause (vi) ensures that the program counter in _`'sbody is

i\Xi  \Theta . Pick 0 steps for the second configuration as above, and it easily follows
that the resulting configurations are `\Phi  under o/ and $. Otherwise, _` is the variable oe.By assumption,

!fl\Theta oe\Lambda  \Delta  \Delta \Lambda flffi\Pi '\Omega  ' *_\Pi  ,, where flffi \Xi  \Theta . Assume ,ffi does not diverge. Bythe Progress Lemma

\Lambda OEffi\Upsilon  flffiffi\Upsilon  ,ffi\Pi  %oe_\Phi  \Lambda OE \Sigma ffi\Upsilon  flffi\Sigma ffi\Upsilon  \Theta ssae\Pi ae !ffi\Theta oe\Lambda  `ffi\Pi  (by assumption,
it can't diverge). Simple induction on the length of this transition sequence shows that
OEffi `\Phi  OE \Sigma ffi, because the program counter may not become \Xi  \Theta . Thus, OE \Sigma fl \Delta  OEfl `\Phi 
OEffi `\Phi  OE \Sigma ffi. By invariant (iv), !ffi\Theta oe\Lambda  (\Lambda  !fl\Theta oe\Lambda . Furthermore, \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -LGOTO requires that
\Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda  i\Xi  \Theta . Let o/ \Sigma  \Delta  o/ \Upsilon  \Omega  ' *, o/\Sigma fl \Delta  o/flfl\Omega  %_ o/fl\Theta `fl\Lambda \Phi flffiflffi, o/\Sigma ffi \Delta  o/ffifl\Omega  %_ o/ffi\Theta `ffi\Lambda \Phi flffiffiffi;take

!\Sigma fl and !\Sigma ffi to be the restrictions of !fl and !ffi to the domain of the tail of $, which
we choose for $\Sigma . Finally, let ,\Sigma fl \Delta  o/\Sigma fl\Theta !\Sigma fl\Theta ,\Lambda \Lambda  and ,\Sigma ffi \Delta  o/\Sigma ffi\Theta !\Sigma ffi\Theta ,\Lambda \Lambda . All of the necessaryconditions are satisfied as is easily verified via the operational semantics.

\Delta 

Finally, we use the above lemmas to prove noninterference. Assume a program thatcomputes a low-security Boolean has access to high-security data. Arbitrarily changing

the high-security data does not affect the program's result.First, some convenient notation for the initial linear continuation: Let

**fl\Theta *\Lambda  fflij\Delta  \Delta \Lambda ff\Pi '\Omega  ' *_\Pi  \Delta \Theta \Pi ff \Omega 
It has type "ffijfl`ff' \Delta  * _ *.

83
Theorem 4.4.1 (Noninterference) Suppose

" \Omega  ' *% oe ' fflaeae\Theta \Phi  _ * ssffae ^ , for some initial program ,.
" \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda  i\Xi  \Theta 
" ! ^ `fl\Upsilon  `ffi ' *
Then \Lambda o/\Upsilon  ff\Upsilon  ,fl`flae\Omega ffifl**fl\Theta fflaeae\Theta \Phi  \Lambda aeoeffi\Pi  %oe_\Phi  \Lambda OEfl\Upsilon  \Theta \Upsilon  \Delta \Theta \Pi \Delta \Theta \Theta \Lambda \Theta  '\Theta \Delta  \Pi  and
\Lambda o/\Upsilon  ff\Upsilon  ,fl`ffiae\Omega ffifl**fl\Theta fflaeae\Theta \Phi  \Lambda aeoeffi\Pi  %oe_\Phi  \Lambda OEffi\Upsilon  \Theta \Upsilon  \Delta \Theta \Pi \Delta \Theta \Theta \Lambda \Theta  O/\Theta \Theta  \Pi 
imply that OEfl `\Phi  OEffi and ' \Delta  O/.

Proof: Let ,fl be the term ,fl`flae\Omega ffi and let ,ffi be the term ,fl`ffiae\Omega ffi. It is easy to verifythat

\Omega  ' * ' oe ' fflaeae\Theta \Phi  _ * ^ \Lambda o/\Upsilon  ff\Upsilon  ,fl\Pi  `\Phi  \Lambda o/\Upsilon  ff\Upsilon  ,ffi\Pi 
by letting o/fl \Delta  fl\Omega  %_ `flffi, o/ffi \Delta  fl\Omega  %_ `ffiffi, and !fl \Delta  !ffi \Delta  floe %_ oeffi. Induction on thelength of the first expression's evaluation sequence, using the Low- and Highflffi Step
lemmas plus the fact that the second evaluation sequence terminates, implies that

o/ ' $ ^ \Lambda OEfl\Upsilon  \Theta \Upsilon  \Delta \Theta \Pi \Delta \Theta \Theta \Lambda \Theta  '\Theta \Delta \Pi  `\Phi  \Lambda OEffi\Upsilon  \Theta \Upsilon  \Delta \Theta \Pi \Delta \Theta \Theta \Lambda \Theta  O/\Theta \Theta  \Pi 
Clause (v) of the Noninterference Invariant implies that OEfl `\Phi  OEffi. Soundness implies
that \Psi fl \Xi  \Theta  and \Psi ffi \Xi  \Theta . This means, because of clause (iv), that neither '\Theta \Delta  nor O/\Theta \Theta  arein the range of

o/\Sigma \Pi . Thus, the Booleans present in the \Delta \Theta \Pi  expressions do not arise from
substitution. Because \Theta  \Xi  \Theta , clause (iii) implies that \Delta \Theta \Pi \Delta \Theta \Theta \Lambda \Theta  '\Theta \Delta  (\Lambda  \Delta \Theta \Pi \Delta \Theta \Theta \Lambda \Theta  O/\Theta \Theta  ,from which we obtain

' \Delta  O/ as desired.

\Delta 

4.5 Translation
The source types of \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  are like those of \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda , except that instead of continuations,
\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  has functions. The type translation from \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  types to \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  types, following
previous work on typed CPS conversion [HL93], is given in terms of three mutuallyrecursive functions:

\Theta oe\Lambda \Phi , for base types, \Theta oe\Lambda ^ for security types, and \Theta oe\Lambda \Upsilon  to linearcontinuation types:

ffi\Xi \Lambda \Pi \Phi  \Delta  ffi\Xi \Lambda \Pi 
fflaeae\Theta \Phi  \Delta  fflaeae\Theta 
\Theta * \Omega \Phi `\Lambda \Phi  \Delta  *^ \Omega \Phi `
\Theta ss\Psi ae*fl _ *ffi\Lambda \Phi  \Delta  ss\Psi ae\Theta *^fl \Upsilon  *\Upsilon ffi \Lambda  _ *

*^\Theta  \Delta  \Theta *\Phi \Lambda \Theta 
*\Upsilon  \Delta  *^ _ *

84
\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -VAL

o/ ^ ` ' * flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 

sssso/ ssflffiae ^ ` ' *aeaeoe

\Delta 
\Theta ssae\Pi ae oe ssss`aeae

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -APP

o/ ssflffiae ^ , ' \Theta ssflffi\Sigma ae*\Sigma  _ *\Lambda \Theta  o/ ssflffiae ^ ,\Sigma  ' *\Sigma  flffi \Xi  flffi\Sigma 

sssso/ ssflffiae ^ , ,\Sigma  ' * \Phi  \Psi aeaeoe

\Delta 
\Theta \Phi \Pi \Theta \Lambda \Xi  !fl j \Delta \Lambda flffi\Pi 'AE ' \Theta ssflffi\Sigma ae*\Sigma  _ *\Lambda ^\Theta  _\Pi 

\Theta \Phi \Pi \Theta \Lambda \Xi  !ffi j \Delta \Lambda flffi\Pi '\Omega  ' *\Sigma ^_\Pi  ssae\Pi ae AE \Omega  oe
\Lambda \Xi  sssso/ ssflffiae ^ ,\Sigma  ' *\Sigma aeae!ffi
\Lambda \Xi  sssso/ ssflffiae ^ , ' \Theta ssflffi\Sigma ae*\Sigma  _ *\Lambda \Theta aeae!fl

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -PRIM

o/ ssflffiae ^ ,fl ' fflaeae\Theta \Theta  o/ ssflffiae ^ ,ffi ' fflaeae\Theta \Theta 

sssso/ ssflffiae ^ ,fl , ,ffi ' fflaeae\Theta \Theta aeaeoe

\Delta 
\Theta \Phi \Pi \Theta \Lambda \Xi  !fl j \Delta \Lambda flffi\Pi '\Omega fl ' fflaeae\Theta ^\Theta  _\Pi 

\Theta \Phi \Pi \Theta \Lambda \Xi  !ffi j \Delta \Lambda flffi\Pi '\Omega ffi ' fflaeae\Theta ^\Theta  _\Pi 

\Theta \Phi \Pi  \Omega  j \Omega fl , \Omega ffi \Lambda \Xi  \Theta ssae\Pi ae oe \Omega 
\Lambda \Xi  sssso/ ssflffiae ^ ,ffi ' fflaeae\Theta \Theta aeae!ffi
\Lambda \Xi  sssso/ ssflffiae ^ ,fl ' fflaeae\Theta \Theta aeae!fl

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -REF

o/ ssflffiae ^ , ' *

sssso/ ssflffiae ^ \Omega \Phi `ff, ' * \Omega \Phi `\Phi \Psi aeaeoe

\Delta 
\Theta \Phi \Pi \Theta \Lambda \Xi  ! j \Delta \Lambda flffi\Pi '\Omega  ' *^_\Pi 

\Theta \Phi \Pi  # j \Omega \Phi `ff \Omega  \Lambda \Xi  \Theta ssae\Pi ae oe #
\Lambda \Xi  sssso/ ssflffiae ^ , ' *aeae!

Figure 4.11: CPS translation

85
\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -DEREF

o/ ssflffiae ^ , ' * \Omega \Phi `\Theta 

sssso/ ssflffiae ^ ", ' * \Phi  \Psi aeaeoe

\Delta 
\Theta \Phi \Pi \Theta \Lambda \Xi  ! j \Delta \Lambda flffi\Pi '# ' * \Omega \Phi `^\Theta  _\Pi 

\Theta \Phi \Pi  \Omega  j "# \Lambda \Xi  \Theta ssae\Pi ae oe \Omega 
\Lambda \Xi  sssso/ ssflffiae ^ , ' * \Omega \Phi `\Theta aeae!

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -ASSN

o/ ssflffiae ^ ,fl ' * \Omega \Phi `\Theta  o/ ^ ,ffi ' * \Psi  \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 

sssso/ ssflffiae ^ ,fl '\Delta  ,ffi ' ffi\Xi \Lambda \Pi \Phi \Psi aeaeoe

\Delta 
\Theta \Phi \Pi \Theta \Lambda \Xi  !fl j \Delta \Lambda flffi\Pi '\Omega fl ' * \Omega \Phi `^\Theta  _\Pi 

\Theta \Phi \Pi \Theta \Lambda \Xi  !ffi j \Delta \Lambda flffi\Pi '\Omega ffi ' *^_\Pi 

\Theta \Phi \Pi  \Omega fl '\Delta  \Omega ffi \Lambda \Xi  \Theta ssae\Pi ae oe \Lambda \Pi \Phi \Psi 
\Lambda \Xi  sssso/ ^ ,ffi ' *aeae!ffi
\Lambda \Xi  sssso/ ssflffiae ^ ,fl ' * \Omega \Phi `\Theta aeae!fl

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -COND

o/ ssflffiae ^ , ' fflaeae\Theta \Theta  o/ ssflffi \Phi  \Psi ae ^ ,\Pi  ' * \Xi  \Sigma  flAE\Upsilon  OEffi

sssso/ ssflffiae ^ \Lambda ` , \Pi \Delta \Phi \Xi  ,fl \Phi \Theta ,\Phi  ,ffi ' *aeaeoe

\Delta 
\Theta \Phi \Pi \Theta \Lambda \Xi  ! j \Delta \Lambda flffi\Pi '\Omega  ' fflaeae\Theta ^\Theta  _\Pi 

\Lambda ` \Omega  \Pi \Delta \Phi \Xi  sssso/ ssflffi \Phi  \Psi ae ^ ,fl ' *aeaeoe

\Phi \Theta ,\Phi  sssso/ ssflffi \Phi  \Psi ae ^ ,fl ' *aeaeoe
\Lambda \Xi  sssso/ ssflffiae ^ , ' fflaeae\Theta \Theta aeae!

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -EXPRSUB

o/ ssflffiae ^ , ' * ^ *  *\Sigma 

sssso/ ssflffiae ^ , ' *\Sigma aeaeoe

\Delta 
sssso/ ssflffiae ^ , ' *aeaeoe

Figure 4.12: CPS translation (continued)

86
Figures 4.11 and 4.12 show the term translation as a type-directed map from source
typing derivations to target terms. The rules are of the form:

fifl \Pi  \Pi  \Pi  fi\Delta 
sssso/ ssflffiae ^ ,ffj`'^* ' *aeaeoe

\Delta 
,i\Psi '_*i

Here, the fi\Pi 's represent premises of the inference rule in the source type system. Thesemantic brackets around the conclusion of the inference rule indicate the typing context

and the source expression to be translated, assuming that the result of the computation
is to be passed to the continuation stored in the \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -variable oe. The translation of
,ffj`'^* is the term ,i\Psi '_*i, which may mention the translations of types appearing in theinference rule. Recursive translation of a subexpressions of

,ffj`'^*, as directed by the
premise fi of the inference rule, are indicated in ,i\Psi '_*i as ssssfiaeae\Pi  For instance, the rule fortranslating

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  -PRIM depends on translating the two subexpressions.
Because \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  and \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  agree on the values for ffi\Xi \Lambda \Pi  and fflaeae\Theta , the translation of
those values or variables is just the identity. Functions are the only values whose trans-lation is not the identity, their translation is mutually recursive with the translation for

program expressions:

ssss\Omega aeae \Delta  \Omega 
ssss\Lambda \Pi \Theta aeae \Delta  \Lambda \Pi \Theta 

ssssffl\Theta aeae \Delta  ffl\Theta  \Theta ffl \Sigma  fl\Pi \Upsilon  `ffi\Lambda 
ssss\Sigma ffaeae \Delta  \Sigma ff

\Lambda 

ssss\Theta \Delta ssflffiae AE '\Omega  ' *_\Pi  ,\Lambda \Theta aeae \Delta  \Theta \Delta ssflffiaeAE'\Omega  ' *^fl \Upsilon  oe ' *\Upsilon ffi _\Pi  sssso/ \Upsilon  AE ' *\Sigma \Upsilon  \Omega  ' *fl ssflffiae ^ , ' *ffiaeaeoe\Lambda \Theta 

where *\Sigma  \Delta  \Theta ssflffiae*fl _ *ffi\Lambda \Theta 

For simplicity, we present an un-optimizing CPS translation, although we expectthat first-class linear continuations will support more sophisticated translations, such as

tail-call optimization [DF92]. To obtain the full translation of a closed term , of type *,
we pass in the initial continuation instantiated at the correct type:

ssss,aeae \Delta  \Theta \Phi \Pi \Theta \Lambda \Xi  oe j **fl\Theta *^\Lambda  \Lambda \Xi  ssss!ssflffiae ^ , ' *aeaeoe
As expected, linear continuations are introduced by the translation at points thatcorrespond (via the structure of the source program) to pushing an activation record
on to the stack, and \Theta ssae\Pi aes are introduced where pops occur. The linear variable oe
represents the current "top of stack" continuation; invoking it will cause the activationstack to be popped, after executing the body of the continuation

oe. Note that all of the
implicit control flow of the source language is expressed by ordered linear continuations;

87
ordinary continuations are used only to express source-level functions, which, because
they might be copied or never invoked, are inherently nonlinear. However, the uniquereturn continuation of a function is represented by a linear continuation.

The basic lemma for establishing type correctness of the translation is proved by
induction on the typing derivation of the source term. This result also shows that theCPS language is at least as precise as the source.

Lemma 4.5.1 (Type Translation)
If o/ ssflffiae ^ , ' * then o/ ^% oe ' *\Upsilon  ssflffiae ^ sssso/ ssflffiae ^ , ' *aeaeoe.

Proof: Straightforward. The necessary lattice inequalities to give a target derivationare established by simply following the source derivation.

\Delta 

To show that this CPS translation is operationally correct, we would like to estab-lish the following lemma. Giving a complete proof is beyond the scope of this thesis.

However, the result should follow by a simulation argument similar to those used byDanvy and Filinski [DF92]. There are some subtleties with the simulation that arise because of the presence of mutable state. Because this is an unoptimizing version of CPS
translation, it is also necessary to allow administrative redexes to remain in the resultingterms [DF92]. Doing so complicates the exact strengthening of the simulation relations,

but it can be done [Plo75, Rie89].
Lemma 4.5.2 (Operational Correctness) Suppose , is a \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  term such that o/ ssffae ^
, ' * and that OE is a \Delta \Xi \Theta \Pi \Delta \Theta \Lambda  memory such that \Sigma i\Theta ,\Lambda  ffl *OE *. Then

\Lambda OE\Upsilon  ff\Upsilon  ,\Pi  * \Lambda OE \Sigma \Upsilon  `\Pi  ' \Lambda ssssOE aeae\Upsilon  ff\Upsilon  ssss,aeae\Pi  %oe_\Phi  \Lambda ssssOE \Sigma aeae\Upsilon  ff\Upsilon  \Delta \Theta \Pi ff

\Lambda  ssss`aeae\Pi 

Proof (sketch): The proof goes by strengthening the induction hypothesis to handlethe case where the linear continuation isn't known to be

**fl\Theta *\Phi \Lambda , the program counter
may be different from ff, and the programs are related up to administrative redexes.Additional interesting points include:

1. Binary operations are compatible in both languages.
2. There is a caveat that the memory allocation must be somehow coherent--that is,

the locations that are created "fresh" in the source can be mapped isomorphicallyonto those created "fresh" in the target.

3. It's important that the target can take multiple evaluation steps to simulate asource evaluation rule, because there can be multiple

\Theta ssae\Pi ae operations involved
in threading the control through the target.

\Delta 

88
4.6 Related work
Pottier and Simonet [PS02] give a proof technique for proving noninterference in asecurity-typed version of core ML, which is similar to

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  . Their approach differs
from the one presented here by using a nonstandard operational semantics in which twoprogram evaluations can be represented simultaneously. Their construction reduces the

noninterference result for the source language to the subject-reduction theorem for the
nonstandard language.The constraints imposed by linearity can be seen as a form of resource management [Gir87], in this case limiting the set of possible future computations.

There are many similarities between the stack-like nature of ordered linear contin-uations and other type systems for regulating resource consumption. For example, the

capabilities calculus uses linearity constraints to manage regions of memory [CWM99];the regions obey a stack discipline. Linearity has been widely used in the context of
memory management [Abr93, CWM99, Wad90, Wad93].

Linear continuations have been studied in terms of their category-theoretic seman-tics [Fil92] and for their role in a computational interpretation of classical logic [Bie99].

Polakow and Pfenning have investigated the connections between ordered linear-logic,
stack-based abstract machines, and CPS [PP00]. Berdine, et al., have also studied anumber of situations in which continuations are used linearly [BORT01].

CPS translation has been studied in the context of program analysis [FB93, Nie82].Sabry and Felleisen observed that increased precision in some CPS data flow analyses
is due to duplication of analysis along different execution paths [SF94]. They also note
that some analyses "confuse continuations" when applied to CPS programs. Our typesystem distinguishes linear from nonlinear continuations to avoid confusing "calls" with

"returns." More recently, Damian and Danvy showed that CPS translation can improvebinding-time analysis in the

\Delta -calculus [DD00], suggesting that the connection betweenbinding-time analysis and security [ABHR99] warrants more investigation.

Linear continuations appear to be a higher-order analog to post-dominators in acontrol-flow graph. Algorithms for determining post-dominators in control-flow graphs
(see Muchnick's text [Muc97]) might yield inference techniques for linear continuation
types. Conversely, linear continuations might yield a type-theoretic basis for correctnessproofs of optimizations based on post-dominators.

Linearity also plays a role in security types for concurrent process calculi such asthe
(-calculus [HVY00, HY02]. Because the usual translation of the \Delta -calculus into the
(-calculus can be seen as a form of CPS translation, it is enlightening to investigate the
connections between security in process calculi and low-level code. These connectionsare made more explicit in the next chapter.

Chapter 5
Secure Concurrent Programs
This chapter considers the problem of protecting information security in concurrent pro-grams. Concurrent programming techniques are useful for systems that must react to or
control ongoing activities in their environments [Sch97]. Typical examples of concurrent programs include operating systems, databases, web servers, and user interfaces.

Languages for concurrent programming vary widely in the details of the featuresthey provide, but they share some essential traits: support for multiple threads of execution and the ability to describe interthread communication.

Operational models of concurrent languages differ from those of sequential lan-guages because they are

nondeterministic: a single machine configuration O/ may transition to two different machine configurations O/fl and O/ffi, reflecting a choice of whichof multiple threads of execution to run.

For multithreaded programming on a sequential computer, an implementation of a
concurrent language uses a thread scheduler to resolve the nondeterminism inherent inthe operational semantics.

The nondeterminism in the operational semantics keeps the thread scheduler implementation abstract. Leaving the thread scheduler implementation unspecified in thelanguage semantics is desirable because the behavior of the implementation may depend

on details of run-time context that are not under the programmer's control, for instance
the operating system, the available resources, or the presence of other threads managedby the scheduler. However, the nondeterministic behavior of concurrent programs can

also permit multiple threads to interact in unwanted (and often unpredictable) ways.Practical languages for concurrent programs provide synchronization mechanisms to
help avoid this problem.

Concurrency adds several new difficulties for regulating information flows:

1. How nondeterminism is resolved in an implementation of the language plays an

important role in the information flows of a concurrent program. An observer

89

90
with knowledge of the scheduler implementation might be able to deduce more
information from the behavior of the program.

2. Communication between concurrently running threads also creates informationflows. More problematically, race conditions can arise that might leak information

if the outcome of a race is influenced by high-security data.
3. Synchronization itself exchanges information between threads and hence createsinformation flows. However, synchronization may also eliminate race conditions

and other forms of resource contention--thereby preventing potentially insecureinformation flows.

This chapter introduces the language \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  that extends \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  with mechanismsfor concurrent evaluation, message passing, and synchronization.
Despite their importance for practical concurrent programming and their impact on
information-flow properties, synchronization mechanisms have only recently been stud-ied in the context of information security [Sab01, HY02, Pot02].

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  incorporates
a controlled form of synchronization that uses linearity constraints similar to those onthe linear continuations of Chapter 4. Linear synchronization provides structure that

allows the type system to more accurately describe information flows that arise due to
synchronization. Although not complete--there are secure synchronization behaviorsthat are not expressible in this framework--

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  provides the ability to write pro-grams with useful synchronization behavior.

In contrast to many previous security-typed language approaches for concurrentprograms [SV98, SV00, VS00, Smi01, Sab01, HY02, Pot02, BC02], the definition of
information-flow presented here permits high-security information to affect the termi-nation behavior and external timing behavior of the program. Instead, the proposal here
controls information flows by eliminating certain race conditions between threads. This
definition of noninterference requires that the sequence of values stored in each memorylocation is deterministic.

The next section discusses the issues of information-flow, concurrency, and synchro-nization more thoroughly, motivating the design of

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  and informally introducingits syntax. Section 5.2 presents the concrete language, its type operational semantics and

type system. Section 5.3 gives a proof of subject reduction. Section 5.4 formally definesnoninterference and race freedom and proves that the

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  type system providesnoninterference. This chapter concludes with further comparison to related work.

5.1 Thread communication, races, and synchronization
This section describes information flows that arise in concurrent languages and informally introduces the syntax for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  .

91
The syntax for running two processes concurrently is fifl 5 fiffi. A process1 itself
may consist of multiple concurrent subprocesses. For example, fifl might be the process
)fl 5 )ffi. The order in which the threads are written is unimportant: the program
fifl 5 fiffi is equivalent to the program fiffi 5 fifl. Similarly, the 5 operator is associative,
so the programs \Theta fifl 5 fiffi\Lambda  5 fi* and fifl 5 \Theta fiffi 5 fi*\Lambda  are equivalent.

The operational semantics for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  allow any possible interleaving of the evaluations of two parallel processes. Informally2, there are two rules for evaluating fifl 5 fiffi:

fifl _ fi \Sigma fl
fifl 5 fiffi _ fi \Sigma fl 5 fiffi

fiffi _ fi \Sigma ffi
fifl 5 fiffi _ fifl 5 fi \Sigma ffi

These two rules directly exhibit the nondeterminism of the operational semantics.

5.1.1 Shared memory and races
One basic means by which threads can communicate is shared memory. In shared memory models, one thread can write to a shared location and a second thread can read fromit, thereby transferring information from the first thread to the second.

Due to concurrency, two threads might try to write to the same location simultane-ously or one thread might attempt to write to a location concurrently with a read by a
second thread, as illustrated below in examples (1) and (2) below:

\Theta AE\Lambda  '\Theta  ij \Pi _ 5 '\Theta  ij `_
\Theta OE\Lambda  '\Theta  ij \Pi _ 5 'o/ ij oe\Theta _

Both programs might behave nondeterministically. In example (1), the final valuestored in location

\Theta  depends on the order in which the two threads are executed. Similarly, in example (2), the final contents of o/ might depend on whether the read of location
\Theta  is scheduled before the write.

These write-write and write-read races can be used to leak confidential informationdue to the relative timing behavior of the two threads. For example, the following program sets up a race to assign to location \Theta . The amount of time it takes the first thread
to reach the assignment depends on high-security data \Delta . As an example, consider thefollowing program that might leak information about

\Delta  via a write-read race:

\Theta fi\Lambda  AE ij \Pi fi

'\Lambda ` \Delta  \Pi \Delta \Phi \Xi  O/\Phi \Theta o/'***_ \Phi \Theta ,\Phi  ,.\Lambda &fi AE ij `_
5 'O/\Phi \Theta o/'6*_fi \Theta  ij AEfi (((_ \Theta  i\Upsilon AE\Xi i, fl\Theta  \Xi OE\Pi \Omega i \Delta 

1The terms thread and process are used interchangeably.
2The actual operational semantics of \Omega \Pi \Upsilon \Phi \Pi \Psi \Delta 

\Xi \Theta \Pi  is given in Figures 5.4 and 5.5

92
This program initializes variable AE to be true and then spawns two threads. The first
thread assigns AE the value false either immediately or after a long delay. The secondthread waits long enough so that the assignment to

AE is likely to have occurred when
\Delta  is false; this second thread then assigns \Theta  the value of AE. Depending on the threadscheduler implementation, this program can reliably copy the contents of \Delta  into thevariable

\Theta --a potentially insecure information leak.
Termination behavior also plays a role in the information flows possible in concur-rent programs. For example, the following program copies the value of

\Delta  to \Theta , assumingthat
788fl'_ is a function that diverges:

\Theta fl\Lambda  '\Lambda ` \Delta  \Pi \Delta \Phi \Xi  788fl'_ \Phi \Theta ,\Phi  ,.\Lambda &fi \Theta  ij `_

5 '\Lambda ` '\Xi ae\Pi  \Delta _ \Pi \Delta \Phi \Xi  788fl'_ \Phi \Theta ,\Phi  ,.\Lambda &fi \Theta  ij \Pi _

In this example, exactly one of the threads will terminate and only one assignment to
\Theta  will take place. Some third thread that can read from \Theta  could poll its value to learnthe contents of

\Delta . This example also depends on the assumption of a fair scheduler--an unfair scheduler could run the

788fl'_ code forever, never giving the other thread a
chance to make its assignment.Suppose that the variable

\Delta  used in the examples contains high-security data and \Theta 
is a low-security variable. Whether to consider these programs secure is dependent onwhat the low-security observer knows about the thread scheduler implementation. We

have already observed that if the scheduler is fair, meaning that each thread is given
eventually given a chance to run, then example (4) is not secure--it copies the contentsof

\Delta  into \Theta .

Similarly, if it is known that the thread scheduler alternates between threads (startingwith the first) and runs each for exactly 200 operational steps before switching, example

(3) has deterministic behavior with respect to the variable \Theta --by the time the second
thread tests AE it is always false. In this case, the program should be considered secure.In contrast, if the scheduler runs each thread for fewer than 100 steps before switching,

example 3 does leak \Delta  to \Theta  and should be considered insecure.

As these examples have shown, whether a concurrent program is secure depends onwhat information about the thread scheduler is available to the low-level observer of the

program. Examples (1) and (2) could be considered insecure if the low-level observerknows that the schedule chosen depends on high-security information--even though
neither example mentions high-security data.

It might be reasonable to assume some characteristics about the thread scheduler, forinstance, that it is fair, or that it schedules processes uniformly at random. However, it is

still difficult to rule out programs that are insecure due to races. The existing type systems that follow this approach lead to extremely restrictive models of programming. Forexample, Smith and Volpano consider only a fixed number of threads [SV98, Smi01].

Both their definition of noninterference and most other definitions [SS01, MS01, Sab01,

93
BC02, HY02, Pot02, SM02] forbid low-security computation from depending on the
timing or termination behavior that is influenced by high-security data. These ap-proaches correctly rule out examples (3) and (4) as insecure while permitting programs

(1) and (2). However, due to the restrictions on high-security data, those type systems
also rule out the following single-threaded programs because the assignment to \Theta  se-quentially follows computation whose

external timing or termination behavior depends
on high-security data.

\Theta (\Lambda  /\Delta \Lambda \Theta \Phi  '\Delta  ! ***_ O/ae \Sigma  \Delta  ij \Delta  " * fffi \Theta  ij *fi
\Theta )\Lambda  \Lambda ` \Delta  \Pi \Delta \Phi \Xi  788fl'_ \Phi \Theta ,\Phi  ,.\Lambda &fi \Theta  ij *fi

Type systems that rule out these programs implicitly assume that there may be otherunknown threads running concurrently with the program being analyzed and that those
other threads have access to the memory locations used in the program in question. Thismakes the noninterference analysis very compositional, but quite restrictive--examples
(5) and (6) are considered insecure.

A different approach is to observe that examples (1)-(4) share a simple common
feature: there is a race on a low-security variable.3 As we have seen, whether such racesleak high-security information depends both on the threads that are running and on what

the low-security observer knows about the thread scheduler. Therefore, a natural way
to eliminate the information flows that arise from concurrency is to eliminate races tolow-security memory locations. Such race freedom requires that the sequence of values

stored in every memory location is deterministic. The definition of noninterference in
concurrent languages used here is based on low-security observational determinism. Asimilar proposal has been made by Roscoe in the context of a labeled-transition semantics for CSP [Ros95]. One benefit of this approach is that, under the caveat that thevariable

\Theta  is local to the program being analyzed, examples (5) and (6) are consideredsecure. As with previous work, examples (3) and (4) are considered insecure. However, with this definition of noninterference examples (1) and (2) are not consideredsecure. Another benefit of this approach is that it yields a very strong kind of schedulerindependence: determinism of the low-security memory writes implies that the samesequence of reads and writes will be seen regardless of what decisions are made by the
thread scheduler.

We have seen that noninterference in the presence of concurrency relies cruciallyon the absence of races. Of course, eliminating race conditions can itself be difficult,

3Whether there is a race in example (4) is debatable because we know ahead of time that at most one
assignment to fi will ever take place. Because detecting races is, in general, undecidable (replace # withan undecidable predicate), any static analysis sophisticated enough to determine that there is no race in

programs like this one could detect the information flow from # to fi and hence rule this program out asinsecure.

94
particularly due to aliasing. For instance, we must reject the following program that has
a write-write race on the memory location aliased by \Theta  and \Theta 9:

\Theta \Phi \Pi  \Theta 9 j \Theta  \Lambda \Xi 

'\Theta 9 ij *_ 5 '\Theta  ij *_

The simplest way to rule out race conditions on shared memory is to eliminate shared
memory altogether. A less severe, yet sufficient, approach is to restrict the memoryshared between two threads to be read-only, thereby eliminating write-write and write-

read races. This strategy does not prohibit writable memory locations; it requires thatmutable state be local to a single thread.

Alias analysis plays a crucial role in establishing thread locality of memory resources, and hence whether a program is race free. However, developing such an analy-sis is beyond the scope of this thesis. Instead, we assume the existence of such an analysis for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  programs. The abstract requirements of a race-freedom analysis and
some potential implementations in terms of alias analysis are described in Section 5.2.3.

Because we do not make any assumptions about the thread scheduler, the conditionof race-freedom and the lack of synchronization together rule out interthread communication via shared memory. However, for concurrency to be useful, the threads still needsome means of exchanging data. Therefore

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  allows a form of message passing
to compensate for the lack of general shared memory. The message-passing constructshave a built-in synchronization mechanism that can be used to prevent race conditions

and to encode secure forms of shared-memory communication.

5.1.2 Message passing
In message-passing models (see Schneider's text [Sch97] for an overview), one thread
may send a message on a channel; a second thread may then receive the message fromthe channel.

Synchronous message passing requires that the sending thread block untilthe receiving thread has received the message, and, symmetrically, the receiving thread

must block until a message is sent.

Asynchronous message passing allows the sender of the message to continue beforethe message has necessarily been received; a symmetric construct allows the receiver

to accept a message if one has been sent, or continue processing otherwise. \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda provides asynchronous message passing; synchronous message passing can be encoding
using the synchronization mechanisms, as shown below.

The \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  notation for sending a value ` on a channel \Psi  is \Psi '`_. Messages maycontain no data, in which case the send is written

\Psi '_, or they may contain multiple
values, in which case the send is written \Psi '`fl:(((:`\Delta _.

95
The way a \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  process reacts when it receives a message on a channel is described by a message handler (or simply handler). The syntax for a handler is illustratedbelow:

\Psi '\Omega _ \Theta  \Theta  ij \Omega 
This handler waits for a message on channel \Psi . When it receives such a message thehandler creates a new thread that executes the program

\Theta  ij \Omega  with the contents of the
message bound to the variable \Omega . For example, when the handler receives the message
\Psi '\Pi _, it creates a new thread that performs the assignment \Theta  ij \Pi . The message isconsumed by the handler.

Handlers definitions are introduced via \Theta \Phi \Pi -syntax, just as the continuations of \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda or the functions of

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  are introduced. The channel name defined in the handler is inscope within the body of the let. As an example, a

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  program that sends the
message as described above is:

\Theta \Phi \Pi  \Psi '\Omega _ \Theta  \Theta  ij \Omega  \Lambda \Xi 

\Psi '\Pi _

In full generality, multiple threads might attempt to send messages on a channelconcurrently. This situation is similar to the write-write race condition possible with

shared memory; information implicit in the thread scheduler might affect the outcomeof the communication. Such

send contention occurs when multiple threads try to sendconcurrently on the same channel, as illustrated in this example:

\Theta \Phi \Pi  \Psi '\Omega _ \Theta  \Theta  ij \Omega  \Lambda \Xi 

\Psi '\Pi _ 5 \Psi '`_

This example also shows how send contention can lead to a race condition. The handlerabove will react to the two messages by spawning a new thread to handle each; therefore

this example effectively evaluates to this program, which clearly exhibits a race:

\Theta \Phi \Pi  \Psi '\Omega _ \Theta  \Theta  ij \Omega  \Lambda \Xi 

'\Theta  ij \Pi _ 5 '\Theta  ij `_

Handlers like the ones above remain permanently in the program environment once
declared. They are thus able to react to any number of messages sent on the channelsthey define. Note that lexical scoping of channel names makes it impossible to introduce

read contention, which multiple handlers vie for a message. In the program below, thesecond handler definition for the channel

\Psi  shadows the first:

\Theta \Phi \Pi  \Psi '\Omega _ \Theta  \Theta  ij \Omega  \Lambda \Xi 
\Theta \Phi \Pi  \Psi '\Omega _ \Theta  \Theta  ij \Pi  \Lambda \Xi 

\Psi '`_

96
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  permits channels to be used in a first-class way. This means that they may
be passed as values in the messages sent on other channels. For example, the channel
O/aeffiffl\Theta \Phi  sends two (empty) messages on any channel it is given as an argument:

\Theta \Phi \Pi  O/aeffiffl\Theta \Phi '\Psi _ \Theta  \Psi '_ 5 \Psi '_ \Lambda \Xi 
\Theta \Phi \Pi  O/'_ \Theta  fi \Lambda \Xi 

O/aeffiffl\Theta \Phi 'O/_

Just as recursive functions may mention the name of the function inside its body,handler definitions may mention the channels they define. This makes it possible for
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  handler definitions to encode recursive functions. For example, the following
program creates an infinite loop:

\Theta \Phi \Pi  \Psi 'AE_ \Theta  \Psi 'AE_ \Lambda \Xi 

\Psi '\Pi _

To further illustrate the connection between handlers and functions, compare the handlerdefinition to a similar recursive function written in

\Delta \Xi \Theta \Pi \Delta \Theta \Lambda  :

\Delta ssffae AE '\Omega  ' *_\Pi  AE \Omega 
The handler for a channel is like a continuation: both accept a value and then performsome computation based on that value. The ordered linear continuations of Chapter 4
imposes enough structure on sequential programs to establish a noninterference result.Similarly,

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  provides linear channels, on which exactly one message must besent. The symbol

\Theta  is used in place of \Theta  to indicate that a message handler is linear.
For example, the following program declares a linear channel . that must be usedexactly once along each execution path:

\Theta \Phi \Pi  .'\Omega _ \Theta  \Theta  ij \Omega  \Lambda \Xi 

\Lambda ` \Lambda  \Pi \Delta \Phi \Xi  .'\Pi _ \Phi \Theta ,\Phi  .'`_

The following programs are ill-formed, because they violate linearity of the channel
.. The first uses . in two separate threads, the second discards . in the second branch
of the conditional:

\Theta \Phi \Pi  .'\Omega _ \Theta  \Theta  ij \Omega  \Lambda \Xi 

.'\Pi _ 5 .'`_

\Theta \Phi \Pi  .'\Omega _ \Theta  \Theta  ij \Omega  \Lambda \Xi 

\Lambda ` \Lambda  \Pi \Delta \Phi \Xi  .'\Pi _ \Phi \Theta ,\Phi  '\Theta  ij `_

97
Importantly, linear handlers can never be used to create nondeterminism because, in
contrast to nonlinear handlers, there is never any send contention. This observation justi-fies a weaker program-counter label constraint for using linear channels in the

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda type system, just as the
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  rules for linear continuations introduce weaker constraints
than the rules for nonlinear continuations.

Channels may be seen as generalizing the abstraction of memory locations. A mem-ory location is a channel that accepts messages that are pairs of the form

',\Phi \Pi : `_ or
'ss\Phi \Pi : i_ where ` is the value assigned by a ,\Phi \Pi  operation and i is itself the name of achannel on which to return the contents of the memory cell.

Channels fundamentally exhibit the same difficulties that shared references do, sowhy consider adding both to a concurrent language? Including both mechanisms provides a separation of concerns: references are used to structure the data of a compu-tation, whereas channels (and message passing) are used to structure the behavior of a
computation.

5.1.3 Synchronization
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  provides a synchronization mechanism that allows a single handler definitionto block waiting for messages on multiple channels.

A handler definition defines a set of channels that all share the same continuation.
As a simple example, consider this handler definition:

\Lambda \Xi &ffi\Pi fl'\Omega _ 5 \Lambda \Xi &ffi\Pi ffi'oe_ \Theta  \Theta \Phi \Pi  ' j \Omega  ss oe \Lambda \Xi  aeffi\Pi &ffi\Pi ''_
It declares two channel names \Lambda \Xi &ffi\Pi fl and \Lambda \Xi &ffi\Pi ffi that block, each waiting to receivea message. After both messages have been received, the handler triggers. In this case,
the data in the message received on \Lambda \Xi &ffi\Pi fl is bound to the variable \Omega  and the data in
the message received on \Lambda \Xi &ffi\Pi ffi is bound to the variable oe. The body of this handlercomputes

\Omega  ss oe and then sends the result on a third channel, aeffi\Pi &ffi\Pi .
As another example, the handler definition below declares two channels \Psi  and O/.Channel

\Psi  accepts messages containing a single value and channel O/ accepts messages
that contain no data:

\Theta \Phi \Pi  \Psi '\Omega _ 5 O/'_ \Theta  fi \Theta \Omega \Lambda  \Lambda \Xi  )
If the process ) sends messages on both channels \Psi  and O/, the handler will react bycreating a new thread

fi in which the value sent on \Psi  is bound to the variable \Omega . If )never sends a message on one of the two channels, the handler will never be triggered.

For example, the following program sends memory location \Theta  on channel \Psi , but only
sends a message on channel O/ if the value of \Lambda  is true:

98
\Theta \Phi \Pi  \Theta  j \Omega \Phi ` ` \Lambda \Xi 
\Theta \Phi \Pi  \Psi '\Omega _ 5 O/'_ \Theta  \Omega  ij \Pi  \Lambda \Xi 

\Psi '\Theta _ 5 '\Lambda ` \Delta  \Pi \Delta \Phi \Xi  O/'_ \Phi \Theta ,\Phi  *_

This construct provides synchronous message passing between two threads. Suppose thread fifl wants to send the message OE synchronously to thread )fl after whichit continues as

fiffi. Thread )fl blocks waiting for the message OE and then continuesas thread
)ffi\Theta OE\Lambda . In a traditional message-passing notation, this situation might be expressed by the following program:

\Psi aeffl\Phi ss\Lambda \Xi  'fiflfi,\Phi \Xi O/^'OE_fififfi_ 5 ')flfi\Omega \Phi \Psi )^'\Omega _fi)ffi\Theta \Omega \Lambda _ \Psi ae\Phi \Xi O/
Here, ,\Phi \Xi O/^'OE_ sends the message OE on channel \Psi , blocking until the message has been
received. Symmetrically, \Omega \Phi \Psi )^'\Omega _ blocks until channel \Psi  has been sent the message OE,which it binds to variable

\Omega .
Using the syntactic sugar fifl% fiffi to denote sequential composition of (sequential)processes

fifl and fiffi, this example can be written using \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  's synchronizationmechanisms:

\Theta \Phi \Pi  ,\Phi \Xi O/^'\Omega _ 5 \Omega \Phi \Psi )^'_ \Theta  fiffi 5 )ffi\Theta \Omega \Lambda 
\Lambda \Xi 

fiflfi,\Phi \Xi O/^'OE_ 5 )flfi\Omega \Phi \Psi )^'_

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  also allows synchronization on linear channels. For example, the programbelow declares a handler for two linear channels

._ and .fl:

\Theta \Phi \Pi  ._'_ 5 .fl'\Omega _ \Theta  fi \Lambda \Xi  )
As with the linear continuations of \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda , channels ._ and .fl must be used exactly oncein each possible execution path of the process

).
The channel synchronization mechanism in \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  provides a flexible way ofstructuring inter-thread communication.

The left half of Figure 5.1 illustrates a nested synchronization structure possible
for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  programs. The wavy arrows in this picture denote sequential threads ofexecution. Forks in the computation are indicated by two solid arrows leaving a thread;

synchronization between threads is indicated by two solid arrows joining together--the
lines are labeled with the (linear) channels on which the synchronization takes place .The corresponding program is:

\Theta \Phi \Pi  ._'_ 5 .fl'_ \Theta  * \Lambda \Xi 

fi fi' )flfi'\Theta \Phi \Pi  .ffi'_ 5 .*'_ \Theta  .fl'_ \Lambda \Xi 

'+flfi .*'_ 5 +ffifi .ffi'___
5 )ffifi ._'_ _

99
!

*\Upsilon \Upsilon \Delta \Theta !

\Phi \Phi \Pi \Pi \Pi \Pi 

\Pi 

\Psi \Psi \Sigma \Sigma \Sigma 
\Sigma \Sigma 

!
,\Delta  \Upsilon \Upsilon \Delta \Theta  !

,\Theta 

\Upsilon \Upsilon \Delta \Theta 

\Delta \Theta \Delta \Theta 
\Delta \Theta \Delta \Theta 
\Delta \Theta \Delta \Theta 
\Delta \Theta \Delta \Theta 
\Delta \Theta \Delta \Theta !

\Phi \Phi \Pi \Pi \Pi \Pi 

\Pi 

\Psi \Psi \Sigma \Sigma \Sigma 
\Sigma \Sigma 

!
ss\Delta  \Upsilon \Upsilon \Delta \Theta  ! ss\Theta \Upsilon \Upsilon \Delta \Theta 

!

\Phi \Xi  \Psi \Psi \Sigma \Sigma \Sigma 

\Sigma \Sigma  !

\Phi \Theta \Phi \Phi \Pi \Pi \Pi \Pi 

\Pi 

!

\Phi \Delta  \Psi \Psi \Sigma \Sigma \Sigma 

\Sigma \Sigma  !

\Phi \Pi \Phi \Phi \Pi \Pi \Pi \Pi 

\Pi 

!

\Xi \Upsilon \Upsilon \Delta \Theta !

!

*\Upsilon \Upsilon \Delta \Theta !

\Phi \Phi \Pi \Pi \Pi \Pi 

\Pi 

\Omega \Omega \Upsilon \Upsilon \Upsilon \Upsilon 
\Upsilon \Upsilon \Upsilon \Upsilon \Upsilon 

!
,\Delta  \Upsilon \Upsilon \Delta \Theta  !

,\Theta 

\Upsilon \Upsilon \Delta \Theta 

\Delta \Theta \Delta \Theta 
\Delta \Theta \Delta \Theta 
\Delta \Theta \Delta \Theta 
\Delta \Theta 
!
\Phi \Phi \Pi \Pi \Pi \Pi 

\Pi 

\Psi \Psi \Sigma \Sigma \Sigma 
\Sigma \Sigma 

!

ss\Delta 

\Upsilon \Upsilon \Delta \Theta 

\Delta \Theta \Delta \Theta 
\Delta \Theta \Delta \Theta 
\Delta \Theta \Delta \Theta 
\Delta \Theta  !ss\Theta  \Upsilon \Upsilon \Delta \Theta 

!

\Phi \Xi  \Psi \Psi \Sigma \Sigma \Sigma 

\Sigma \Sigma  !

\Phi \Theta \Phi \Phi \Pi \Pi \Pi \Pi 

\Pi 

!

\Xi \Upsilon \Upsilon \Delta \Theta !

\Phi \Delta  \Omega \Omega \Upsilon \Upsilon \Upsilon \Upsilon \Upsilon 

\Upsilon \Upsilon \Upsilon \Upsilon  !

\Phi \Pi \Phi \Phi \Pi \Pi \Pi \Pi 

\Pi 

!

ae\Upsilon \Upsilon \Delta \Theta !

Figure 5.1: Synchronization structures

100
More complex synchronization behavior is also possible. For instance, the following
program has the synchronization structure pictured in the right part of Figure 5.1.

\Theta \Phi \Pi  ._'_ 5 .fl'_ \Theta  , \Lambda \Xi 
\Theta \Phi \Pi  .ffi'_ 5 .*'_ \Theta  *fi ._'_ \Lambda \Xi 

fi fi' )flfi' +flfi .fl'_

5 +ffifi .*'__
5 )ffifi .ffi'__

Note that this program uses channel .* inside the body of the handler defining channels
.4 and .-.

5.2 \Delta `*+`,ij` : a secure concurrent calculus
This section introduces the formal semantics for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  , including its syntax, opera-tional semantics. and type system.

5.2.1 Syntax and operational semantics
Figure 5.2 shows the syntax for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  programs.

Base values in \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  are channel names i, memory locations \Sigma , or Booleans \Pi and

`. The metavariable AE ranges over channels and variables that have channel or linearchannel type. Primitive operations are defined exactly as in

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda .
A process4, fi consists of a sequence of \Theta \Phi \Pi -declarations and primitive operationsfollowed by either

*, the terminal process, an \Lambda ` expression, or the concurrent composition of two processes, written fifl 5 fiffi. The terminal process * is analogous to the \Delta \Theta \Pi instruction of

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda , except that it does not "return" any final output.
If \Psi  is a channel, then the syntax \Psi '-`_ denotes a message with contents '-`_ sent on
channel \Psi . Message sends are asynchronous; but message handlers are blocking.

A join pattern . \Delta  AEfl' -\Omega fl_ 5 \Pi  \Pi  \Pi  5 AE\Delta ' -\Omega \Delta _is a generalization of the binding construct
\Delta AE \Theta \Omega \Lambda  found in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda 5. A join pattern declares a set of channels (or channel variables)
AEfl \Pi  \Pi  \Pi  AE\Delta . Each channel AE\Pi  accepts a vector of arguments that will be bound to the vectorvariables

-\Omega \Pi .
There are two kinds of join patterns. Nonlinear join patterns may bind linear vari-ables

oe (although they are not required to), and thus can include channel declarations

4The words thread and process are used interchangeably Because \Omega  \Pi \Upsilon \Phi \Pi \Psi \Delta 

\Xi \Theta \Pi  does not have explicitthread (or process) identifiers, the concept is somewhat nebulous.

5The word "join" here comes from "fork" and "join" terminology of multithreading, not the "join" of
the security lattice.

101
\Omega \Upsilon  AE \Sigma  * Variable names

ffl` ''\Delta  i Channel value

* \Sigma  Reference value
* \Pi  * ` Boolean values

` ''\Delta  \Omega  Variables

* ffl`\Theta  Secure values

_` ''\Delta  oe * i Linear values
fl#\Xi O/ ''\Delta  ` Values

* ` , ` Boolean operations
* "` Dereference

AE ''\Delta  \Omega  * oe * i Variables or channels
. ''\Delta  AE'-\Omega \Upsilon  oe_ Nonlinear channel

* AE'-\Omega _ Linear channel
* . 5 . Join pattern

fi ''\Delta  \Theta \Phi \Pi  \Omega  \Delta  fl#\Xi O/ \Lambda \Xi  fi Primitive operation

* \Theta \Phi \Pi  \Omega  \Delta  \Omega \Phi ` ` \Lambda \Xi  fi Reference creation
* ,\Phi \Pi  ` '\Delta  ` \Lambda \Xi  fi Assignment
* \Theta \Phi \Pi  . \Theta  fi \Lambda \Xi  fi Handler definition
* \Theta \Phi \Pi  . \Theta  fi \Lambda \Xi  fi Linear handler definition
* ` '-`\Upsilon  _`\Sigma \Phi \Omega _ Message send
* _` '-`_ Linear message send
* \Lambda ` ` \Pi \Delta \Phi \Xi  fi \Phi \Theta ,\Phi  fi Conditional
* \Theta fi 5 fi \Lambda  Parallel processes
* * Inert process

Figure 5.2: Process syntax

102
of the form AE'-\Omega \Upsilon  oe_. Linear join patterns never bind linear variables--they contain only
channel declarations of the form AE'-\Omega _.The restriction that linear channels are not permitted to carry other linear channels

prevents sequencing problems like the ones encountered for continuations in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda . For
example, the \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  program '2_ of Figure 4.1 can be encoded straightforwardly into
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  . Join patterns introduce another means by which deterministic ordering of
linear continuations can be violated. For example, if linear channels were permitted tocarry other linear channels, the following program would contain an information flow

from \Delta  to \Theta  because the two assignments to \Theta  occur in different orders depending on the
value of \Delta .

\Theta \Phi \Pi \Theta \Lambda \Xi  ._'_ \Theta  * \Lambda \Xi 
\Theta \Phi \Pi \Theta \Lambda \Xi  .fl'oefl_ \Theta  ,\Phi \Pi  \Theta  ij \Pi  \Lambda \Xi  oefl'_ \Lambda \Xi 
\Theta \Phi \Pi \Theta \Lambda \Xi  .ffi'oeffi_ \Theta  ,\Phi \Pi  \Theta  ij ` \Lambda \Xi  oeffi'_ \Lambda \Xi 
\Theta \Phi \Pi \Theta \Lambda \Xi  .*'oe*_ 5 .*'oe*_ \Theta 

'\Theta \Phi \Pi \Theta \Lambda \Xi  .'_ \Theta  oe*'.__ \Lambda \Xi  oe*'.__
\Lambda \Xi 

\Lambda ` \Lambda  \Pi \Delta \Phi \Xi  .*'.fl_ 5 .*'.ffi_

\Phi \Theta ,\Phi  .*'.ffi_ 5 .*'.fl_

Although it would be possible to generalize the ordering constraints on the linear continuations of \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  to the linear channels of \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  , doing so complicates the type systemsubstantially. Instead, the race-freedom requirement implies an appropriate ordering on

the usage of linear channels.

As described informally in the previous section, a handler definition is the \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda generalization of a continuation. Formally, it consists of a join pattern and a process

fi
called the body of the handler. The syntax for nonlinear handlers is . \Theta  fi . The syntaxfor linear handlers is

. \Theta  fi .Just like nonlinear continuations, nonlinear channels may be duplicated and freely

used; however to prevent race conditions from arising, nonlinear handlers must be re-entrant in a sense described below. Each linear channel must be used exactly once in all
possible future paths of computation.

It is helpful for writing examples to define a sequential subset of \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  .

Definition 5.2.1 (Sequential processes) A \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  process fi is sequential if it does
not contain the 5 symbol.

If fi \Theta oe\Lambda  is a sequential process that contains one free linear channel variable oe, the
process fi fi ) is defined as: \Theta \Phi \Pi  oe'_ \Theta  ) \Lambda \Xi  fi \Theta oe\Lambda .

Note that if fi and ) are both sequential processes, then fi fi ) is also a sequentialprocess. Also observe that the sequential sublanguage of

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  is the same (modulo
syntax) as the language \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda .

103
OE ''\Delta  OE ss\Sigma  %_ `ae Memory location \Sigma  storing `

* OE ssflffi ' . \Theta  fi ae Message handler
* !

* ''\Delta  *ssflffi ' . \Theta  fi ae Linear handler

* !

/ ''\Delta  ! * / 5 ssflffi ' fi ae Network

O/ \Delta  \Lambda OE\Upsilon  *\Upsilon  / \Pi  Machine configuration

Figure 5.3: Dynamic state syntax

Figure 5.3 shows the syntax for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  memories, synchronization environments,networks and machine configurations. These structures make up the dynamic state of a
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  program.

Unlike \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda , the memories of \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  contain channel handler definitions in addi-tion to the ordinary mapping between locations and their values. The new syntax for a

memory OE is the binding ssflffi ' . \Theta  fi ae. We generalize the domain of a memory OE toinclude the join patterns

. it provides definitions to.

The memory OE of the \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  abstract machine consists of a collection of bindingsof the form

ss\Sigma  %_ `ae and ssflffi ' . \Theta  fi ae, as shown in Figure 5.2. The domain of OE , written
oe\Omega o/\Theta OE \Lambda , is the set of locations \Sigma  and join patterns . that appear in OE . If \Sigma  \Sigma  oe\Omega o/\Theta OE \Lambda 
then we write OE \Theta \Sigma \Lambda  for the value ` such that ss\Sigma  %_ `ae \Sigma  OE . Similarly, if . \Sigma  oe\Omega o/\Theta OE \Lambda ,we write

OE \Theta . \Lambda  for the (open) process fi .
A synchronization environment, denoted by *, stores the linear handler definitions
that have been declared by the program. Notation similar to that of memories is used todescribe the domain of a synchronization environment.

In order to track the information flows through a concurrent program, each threadmust have its own

flffi label. \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  associates a process fi with its flffi label using thesyntax
ssflffi ' fi ae. A collection of such threads running concurrently is called a network.
This terminology is chosen in anticipation of the developments of Chapter 7, wherethreads may be running on distinct hosts--for

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  , a network can be thought of asa pool of threads running on a single host. The syntax for a network

/ is shown near
the bottom of Figure 5.2.

In \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  , a machine configuration O/ is a triple \Lambda OE\Upsilon  *\Upsilon  / \Pi , where OE is a memory, * is a synchronization environment, and / is a network.

104
OE\Upsilon  flffi *\Delta  fl#\Xi O/ * ` \Lambda OEfl\Upsilon  *fl\Upsilon  /fl\Pi  _ \Lambda OEffi\Upsilon  *ffi\Upsilon  /ffi\Pi 

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-PRIM \Xi \Pi  \Delta \Theta  i\Sigma  \Upsilon  \Delta  \Upsilon  \Psi  \Delta \Theta 
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-BINOP \Xi \Pi  \Delta \Theta  i\Sigma  \Phi \Theta  \Pi  \Phi \Sigma \Theta \Delta  \Delta  \Delta \Phi \Xi \Xi \Pi \Pi \Pi \Phi \Sigma \Lambda \Theta \Pi \Theta \Delta  \Psi  \Delta \Theta 

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-DEREF

\Xi  \Delta \Psi \Lambda  \Sigma  \Upsilon 
\Xi \Pi  \Delta \Theta  i\Sigma  \Upsilon \Psi  \Delta  \Upsilon  \Psi  \Delta \Theta 

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-LETPRIM

\Xi \Pi  \Delta \Theta  i\Sigma  \Omega fffifl \Delta  \Upsilon 

\Lambda \Xi \Pi  *\Pi  \Delta , * \Xi \Delta \Theta  \Theta  \Xi \Phi \Sigma  \Theta  \Sigma  \Omega fffifl \Pi \Psi  ffi\Pi \Lambda \Xi  \Sigma  \Lambda \Xi \Pi  *\Pi  \Delta , * \Xi \Delta \Theta  \Theta  ffi\Upsilon \Upsilon ffl\Theta \Phi \Pi \Lambda \Xi 

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-LETREF

\Lambda \Xi \Pi  *\Pi  \Delta , * \Xi \Delta \Theta  \Theta  \Xi \Phi \Sigma  \Theta  \Sigma  ff\Phi \Delta  \Upsilon  \Pi \Psi  ss \Pi \Lambda \Xi 
\Sigma  \Lambda \Xi  \Xi \Psi  fl\Sigma  \Upsilon \Pi \Pi  *\Pi  \Delta , * \Xi \Delta \Theta  \Theta  ss \Upsilon \Psi \Phi \Psi ffl\Theta \Phi \Pi \Lambda \Xi  \Delta \Psi  fresh\Lambda 

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-SET

\Lambda \Xi \Pi  *\Pi  \Delta , * \Xi \Delta \Theta  \Theta  \Omega \Phi \Sigma  \Psi  _ ae \Theta \Sigma  \Upsilon \Sigma  \Pi \Psi  ss \Pi \Lambda \Xi 
\Sigma  \Lambda \Xi  \Xi \Psi  fl\Sigma  \Upsilon \Sigma  \Psi  i \Psi  \Delta \Theta \Pi \Pi  *\Pi  \Delta , * \Xi \Delta \Theta  \Theta  ss \Pi \Lambda \Xi 

Figure 5.4: \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  operational semantics
Figures 5.4 and 5.5 contain the operational semantics for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  . The rules definea transition relation

O/fl _ O/ffi between machine configurations. Evaluation of primitiveoperations, reference creation, assignment, and conditionals is essentially the same as

in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda ; such evaluation is defined by the relation OE\Upsilon  flffi *\Delta  fl#\Xi O/ * `. The descriptionbelow concentrates on the new features of

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  , shown in Figure 5.5.
The rules \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-HANDLER and \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-LINHANDLER allocatefresh channel names for each variable

AE\Pi  in the join pattern of the handler. The channels
declared in nonlinear handlers may be used recursively (inside the body of the handler),so the fresh channel names are substituted in the body. Nonlinear handlers are placed

in the memory of the machine configuration. Linear handlers are put into the synchronization environment. Both kinds of handlers capture the flffi label of the introductioncontext and record it in the machine state.

Rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-SEND describes how a nonlinear handler is invoked. It uses
the syntactic abbreviation 5\Pi  fi\Pi  fflij\Delta  * 5 fifl 5 \Pi  \Pi  \Pi  5 fi\Delta . Suppose the handler

ssflffi ' ifl' -\Omega fl_ 5 \Pi  \Pi  \Pi  5 i\Delta ' -\Omega \Delta _\Theta  fi ae

105
\Lambda OEfl\Upsilon  *fl\Upsilon  /fl\Pi  _ \Lambda OEffi\Upsilon  *ffi\Upsilon  /ffi\Pi 

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-HANDLER

\Lambda \Xi \Pi  *\Pi  \Delta , * \Xi \Delta \Theta  \Theta  \Xi \Phi \Sigma  ^flfioe\Theta flfl * \Lambda  \Lambda  \Lambda  * ^\Delta fioe\Theta \Delta fl\Delta  ssfl \Pi \Psi  ssffi\Pi \Lambda \Xi 
\Sigma  \Lambda \Xi  \Xi o/flfioe\Theta flfl * \Lambda  \Lambda  \Lambda  * o/\Delta fioe\Theta \Delta fl\Delta  ssfl\Upsilon \Delta o/\Pi \Lambda \Phi \Psi ffl^\Pi \Phi \Pi \Pi  *\Pi  \Delta , * \Xi \Delta \Theta  \Theta  ssffi\Upsilon \Delta o/\Pi \Lambda \Phi \Psi ffl^\Pi \Phi \Pi \Lambda \Xi 

where the o/\Pi  are fresh

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-LINHANDLER

\Lambda \Xi \Pi  *\Pi  \Delta , * \Xi \Delta \Theta  \Theta  \Xi \Phi \Sigma  ^flfioe\Theta flfl * \Lambda  \Lambda  \Lambda  * ^\Delta fioe\Theta \Delta fl \Delta  ssfl \Pi \Psi  ssffi\Pi \Lambda \Xi 
\Sigma  \Lambda \Xi \Pi  *\Xi \Delta \Theta  \Theta  o/flfioe\Theta flfl * \Lambda  \Lambda  \Lambda  * o/\Delta fioe\Theta \Delta fl \Delta  ssfl\Pi \Pi  \Delta , * \Xi \Delta \Theta  \Theta  ssffi\Upsilon o/\Pi ffl^\Pi \Phi \Pi \Lambda \Xi 

where the o/\Pi  are fresh

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-COND1

\Lambda \Xi \Pi  *\Pi  \Delta , * \Xi \Delta \Theta  \Theta  \Pi \Delta  \Sigma \Theta  \Sigma \Upsilon \Phi \Psi  ssfl \Phi \Xi \Omega \Phi  ssffi\Pi \Lambda \Xi 
\Sigma  \Lambda \Xi \Pi  *\Pi  \Delta , * \Xi \Delta \Theta  \Psi  i \Theta  ssfl\Pi \Lambda \Xi 

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-COND2

\Lambda \Xi \Pi  *\Pi  \Delta , * \Xi \Delta \Theta  \Theta  \Pi \Delta  \Delta \Theta  \Sigma \Upsilon \Phi \Psi  ssfl \Phi \Xi \Omega \Phi  ssffi\Pi \Lambda \Xi 
\Sigma  \Lambda \Xi \Pi  *\Pi  \Delta , * \Xi \Delta \Theta  \Psi  i \Theta  ssffi\Pi \Lambda \Xi 

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-SEND

\Lambda \Xi  \Xi o/flfioe\Theta fl\Pi  `\Sigma \Phi \Omega fl fl *\Lambda  \Lambda  \Lambda * o/\Delta fioe\Theta \Delta \Pi  `\Sigma \Phi \Omega \Delta  fl\Delta  ss \Pi \Pi  *\Pi  \Delta , *\Pi  \Xi \Delta \Theta \Pi  \Theta  o/\Pi \Theta \Lambda fioe\Upsilon \Pi \Pi  '\Upsilon \Sigma \Phi \Omega \Pi  fl\Pi \Lambda \Xi 
\Sigma  \Lambda \Xi  \Xi o/flfioe\Theta fl\Pi  `\Sigma \Phi \Omega fl fl *\Lambda  \Lambda  \Lambda * o/\Delta fioe\Theta \Delta \Pi  `\Sigma \Phi \Omega \Delta  fl\Delta  ss \Pi \Pi  *\Pi  \Delta , * \Xi i \Theta  ss \Upsilon oe\Upsilon \Pi  \Psi  \Delta \Theta \Pi ffloe\Theta \Pi \Phi \Upsilon '\Upsilon \Pi ffl`\Pi \Phi \Sigma \Phi \Omega \Pi \Lambda \Xi 

ij`'` i \Sigma  \Pi \Delta \Theta \Pi  \Psi  i\Pi 

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-LINSEND

\Lambda \Xi \Pi  *\Xi \Delta \Theta  \Theta  o/flfioe\Theta flfl * \Lambda  \Lambda  \Lambda  * o/\Delta fioe\Theta \Delta fl \Delta  ss \Pi \Pi  \Delta , *\Pi  \Xi \Delta \Theta \Pi  \Theta  o/\Pi fioe\Upsilon \Pi fl\Pi \Lambda \Xi 
\Sigma  \Lambda \Xi \Pi  *\Pi  \Delta , * \Xi \Delta \Theta  \Theta  ss \Upsilon oe\Upsilon \Pi  \Psi  \Delta \Theta \Pi ffloe\Theta \Pi \Phi \Pi \Lambda \Xi 

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-FORK

\Lambda \Xi \Pi  *\Pi  \Delta , * \Xi \Delta \Theta  \Theta  ss * AE\Pi \Lambda \Xi 
\Sigma  \Lambda \Xi \Pi  *\Pi  \Delta , * \Xi \Delta \Theta  \Theta  ss \Pi  * \Xi \Delta \Theta  \Theta  AE\Pi \Lambda \Xi 

Figure 5.5: \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  operational semantics (continued)

106
PROCUNIT fi 5 * ( fiP

ROCCOMM fifl 5 fiffi ( fiffi 5 fifl
PROCASSOC \Theta fifl 5 fiffi\Lambda  5 fi* ( fifl 5 \Theta fiffi 5 fi*\Lambda 

Figure 5.6: Process structural equivalence

is in the memory. If there are messages i\Pi '-`\Pi _ waiting at each of the channels i\Pi , thehandler triggers, causing process

fi to execute with the message contents substituted
for the formal parameters. The program counter label of the new process is the join ofthe

flffi labels that were present when the messages were sent. Joining the flffi's preventsimplicit flows due to synchronization. Importantly, the nonlinear handler remains in the

memory after being triggered--it can be invoked many times (or never).The rule for invoking linear handlers,

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-LINSEND, is similar to therule for nonlinear handlers, except for two differences. First, the program counter label

of the new process is the same as the one when the handler was declared. This rule isanalogous to one used for linear continuations in

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda --see rule \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -EVAL-LGOTO of
Figure 4.3. Second, the linear handler is removed from the synchronization environmentafter it is used, so no further invocations of it are possible.

The last rule, \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-FORK, says that a forked process inherits the flffi label
of the point at which it was spawned.The operational semantics in the figure are too rigid: they require the right-most processes to take part in the computational step. Because thread scheduling should ignore
the syntactic ordering of networks and processes running concurrently, we introduce thenotion of structural equivalence. The process

structural equivalence relation says that
the syntactic order of concurrent processes is irrelevant. Network structural equivalencesays that the syntactic order of the processes in a network is irrelevant and that there is

no distinction between the syntax for a halted process, *, and an empty network.

Structural equivalence is an instance of a congruence relation on program terms.Congruence relations respect the structure of the syntax of the language--if two terms

are congruent, then placing them in identical program contexts yields two congruentterms.

Let \Phi \Psi \Omega ffi be the set of all process terms. Let ffl\Xi i be the set of all network terms.
Definition 5.2.2 (Network congruence) A relation + ffl ffl\Xi i , ffl\Xi i is a congruenceon networks

if it contains the \Delta \Lambda  relation, and, furthermore, /fl+/ffi implies that for
any / \Sigma  ffl\Xi i it is the case that

\Theta /fl 5 / \Lambda +\Theta /ffi 5 / \Lambda  and \Theta / 5 /fl\Lambda +\Theta / 5 /ffi\Lambda 

107
NETUNIT / 5 ! ( /N

ETCOMM /fl 5 /ffi ( /ffi 5 /fl
NETASSOC \Theta /fl 5 /ffi\Lambda  5 /* ( /fl 5 \Theta /ffi 5 /*\Lambda N

ETPROC ssflffi ' fiflae ( ssflffi ' fiffiae (if fifl ( fiffi)
NETZERO ssflffi ' *ae ( !

Figure 5.7: Network structural equivalence

Definition 5.2.3 (Process congruence) Let *ss!ae be a term with a single `hole' in it obtained from the grammar in Figure 5.2 by extending the set of processes to include
fi ''\Delta  \Pi  \Pi  \Pi  * ss!ae. For any process fi , let *ssfi ae be the ordinary process term obtained
from *ss!ae by filling the single instance of a hole in *ss!ae with the process fi . A relation
+ ffl \Phi \Psi \Omega ffi , \Phi \Psi \Omega ffi is a congruence on processes if it contains the \Delta \Lambda  relation, and,
furthermore, fifl+fiffi implies that for any *ss!ae it is the case that \Theta *ssfiflae\Lambda +\Theta *ssfiffiae\Lambda .

Definition 5.2.4 (Structural equivalence) Structural equivalence on processes, written (, is the least symmetric, transitive process congruence satisfying the axioms given
in Figure 5.6. Structural equivalence on networks, also written (, is the least symmetric,
transitive network congruence satisfying the axioms given in Figure 5.7.

The structural equivalence on networks extends to a structural equivalence on machine configurations. In addition, we allow machine configurations in which the namesof locations or channels are systematically changed to be considered equivalent.

Definition 5.2.5 (Configuration structural equivalence) Two machine configurations
\Lambda OEfl\Upsilon  *fl\Upsilon  /fl\Pi  and \Lambda OEffi\Upsilon  *ffi\Upsilon  /ffi\Pi  are structurally equivalent, written \Lambda OEfl\Upsilon  *fl\Upsilon  /fl\Pi  (
\Lambda OEffi\Upsilon  *ffi\Upsilon  /ffi\Pi , if they are ss-equivalent (where locations and channel definitions in a
memory or synchronization environment are considered binding occurrences of locations and channels) and /fl ( /ffi .

The syntax-independent operational semantics is given by the transition relation \Lambda 
defined from the _ relation and structural equivalence as shown in the following rule.

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EQSTEP

\Lambda OEfl\Upsilon  *fl\Upsilon  /fl\Pi  ( \Lambda OE \Sigma fl\Upsilon  *\Sigma fl\Upsilon  / \Sigma fl\Pi 
\Lambda OE \Sigma fl\Upsilon  *\Sigma fl\Upsilon  / \Sigma fl\Pi  _ \Lambda OE \Sigma ffi\Upsilon  *\Sigma ffi\Upsilon  / \Sigma ffi\Pi 
\Lambda OE \Sigma ffi\Upsilon  *\Sigma ffi\Upsilon  / \Sigma ffi\Pi  ( \Lambda OEffi\Upsilon  *ffi\Upsilon  /ffi\Pi 

\Lambda OEfl\Upsilon  *fl\Upsilon  /fl\Pi  \Lambda  \Lambda OEffi\Upsilon  *ffi\Upsilon  /ffi\Pi 

108
5.2.2 \Delta \Upsilon \Omega ff\Upsilon fi\Phi \Pi \Sigma \Upsilon  type system
Figure 5.8 shows the types for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  programs. As with \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda , types are divided into
nonlinear security types and linear types. Base types, *, consist of Booleans, channeltypes, and references.

The channel type ssflffiae\Theta -*\Upsilon  !\Sigma \Phi \Omega \Lambda  has any number of nonlinear arguments and at mostone linear argument. The

ssflffiae component of a channel type is, as in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda , a lower boundon the security level of memory locations that might be written to if a message is sent on

this channel. Note that the channel type ssflffiae\Theta *\Upsilon  !\Lambda  corresponds precisely to the nonlinearcontinuation type

ssflffiae\Theta *\Upsilon  !\Lambda  _ * used in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda .The linear types are channels

\Theta -*\Lambda  that accept some number of nonlinear arguments.
Sending a message on a linear channel does not itself reveal information about the send-ing context (although the message contents might), so linear channel types do not require

the ssflffiae component. The linear channel type \Theta *\Lambda  corresponds precisely to the linear con-tinuation type

\Theta *\Lambda  _ *. The security lattice is lifted to a subtyping relation on \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda types, as shown in Figure 5.9.

A type context o/ is a finite map from nonlinear variables to their types. If o/fl and
o/ffi are type contexts, the notation o/fl\Upsilon  o/ffi forms there disjoint union: o/fl\Upsilon  o/ffi \Delta  o/fl OE o/ffiwhenever

oe\Omega o/\Theta o/fl\Lambda  O/ oe\Omega o/\Theta o/ffi\Lambda  \Delta  o/. Linear type contexts $ are finite maps from linear
variables to linear types. Disjoint union of linear contexts $fl\Upsilon  $ffi is defined similarly tothe case for nonlinear type contexts.

A memory type, 0 (for heap), is a mapping from locations and channels to theirtypes. Memory types were implicit in

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  because each location value was tagged withits associated type. For
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  , because memories also store handler definitions, it is
syntactically less cumbersome to factor the type information for locations and channelsinto these explicit memory types. A synchronization state type

, similarly maps linear
channels to their linear types.The type system for

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  is shown in Figure 5.13. These judgments make useof auxiliary judgments that ensure values and linear values are well-typed (Figures 5.10

and 5.11), primitive operations are well-typed (Figure 5.12), and that memories andsynchronization environments are well-formed (Figures 5.16 and 5.17).

The type system is designed to guarantee the following properties:
1. Explicit and implicit insecure information flows are ruled out.

2. Channel names introduced in a linear handler are used linearly.

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  typing judgments have the form 0% o/ % , % $ ssflffiae ^ fi . This judgmentasserts that process

fi is well-typed. The contexts 0 and o/ map locations, nonlinear
channels, and nonlinear variables to their types as described above. , is a linear contextthat maps linear channels to their types and

$ maps linear variables to their types. Unlike \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  the linear contexts are unordered--the necessary ordering on linear channels

109
flffi\Upsilon  \Psi  \Sigma  \Theta  Security labels

* ''\Delta  *\Theta  Security types

* ''\Delta  fflaeae\Theta  Booleans

* ssflffiae\Theta -*\Upsilon  !\Sigma \Phi \Omega \Lambda  Channel types
* * \Omega \Phi ` Reference types

! ''\Delta  \Theta -*\Lambda  Linear channel types
o/ ''\Delta  ! * o/ \Upsilon  \Omega  ' * Type contexts
0 ''\Delta  ! Empty memory type

* 0\Upsilon  ss\Sigma  ' *ae Location type
* 0\Upsilon  ssi ' *ae Channel definition type

$ ''\Delta  ! * $\Upsilon  oe ' ! Linear type contexts

, ''\Delta  ! * ,\Upsilon  i ' ! Synchronization state types

Figure 5.8: Process types

110
^ *fl  *ffi ^ *fl  *ffi ^ !fl  !ffi

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -TREFL ^ *  *

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -TTRANS

^ *  *\Sigma  ^ *\Sigma   *\Sigma \Sigma 

^ *  *\Sigma \Sigma 

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -TCHANSUB

flffi\Sigma  \Xi  flffi ^ *\Sigma \Pi   *\Pi  \Theta ^ "\Sigma   "\Lambda \Sigma \Phi \Omega 

^ ssflffiae\Theta -*\Upsilon  "\Sigma \Phi \Omega \Lambda   ssflffi\Sigma ae\Theta -*\Sigma \Upsilon  "\Sigma \Sigma \Phi \Omega \Lambda 

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -SLAB

^ *  *\Sigma  \Psi  \Xi  \Psi \Sigma 

^ *\Theta   *\Sigma \Theta \Delta 

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -TLINSUB

^ *\Sigma \Pi   *\Pi 
^ \Theta -*\Lambda   \Theta -*\Sigma \Lambda 

Figure 5.9: \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  subtyping

0% o/ ^ ` ' *

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -VAR 0% o/ ^ \Omega  ' o/ \Theta \Omega \Lambda 
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -TRUE 0% o/ ^ \Pi \Theta  ' fflaeae\Theta \Theta 
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -FALSE 0% o/ ^ `\Theta  ' fflaeae\Theta \Theta 
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -LOC 0% o/ ^ \Sigma \Theta  ' 0\Theta \Sigma \Lambda  \Phi  \Psi 
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -CHAN 0% o/ ^ i\Theta  ' 0\Theta i\Lambda  \Phi  \Psi 

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -SUB

^ *fl  *ffi 0% o/ ^ ` ' *fl

0% o/ ^ ` ' *ffi

Figure 5.10: \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  value typing

111
, % $ ^ _` ' !

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -LINVAR !% oe ' ! ^ oe ' !
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -LINCHAN i ' !% ! ^ i ' !

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -LINSUB

^ !fl  !ffi , % $ ^ _` ' !fl

, % $ ^ _` ' !ffi

Figure 5.11: \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  linear value types

0% o/ ssflffiae ^ fl#\Xi O/ ' *

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -VAL

0% o/ ^ ` ' * flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 

0% o/ ssflffiae ^ ` ' *

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -BINOP

0% o/ ^ ` ' fflaeae\Theta \Theta  0% o/ ^ `\Sigma  ' fflaeae\Theta \Theta  flffi \Xi  \Psi 

0% o/ ssflffiae ^ ` , `\Sigma  ' fflaeae\Theta \Theta 

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -DEREF

0% o/ ^ ` ' * \Omega \Phi `\Theta  flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta * \Phi  \Psi \Lambda 

0% o/ ssflffiae ^ "` ' * \Phi  \Psi 

Figure 5.12: \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  primitive operation types

112
0% o/ % , % $ ssflffiae ^ fi

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -PRIM

0% o/ ssflffiae ^ fl#\Xi O/ ' *0%

o/ \Upsilon  \Omega  ' *% , % $ ssflffiae ^ fi

0% o/ % , % $ ssflffiae ^ \Theta \Phi \Pi  \Omega  \Delta  fl#\Xi O/ \Lambda \Xi  fi

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -REF

0% o/ ^ ` ' * flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 
0% o/ \Upsilon  \Omega  ' * \Omega \Phi `\Phi \Psi % , % $ ssflffiae ^ fi

0% o/ % , % $ ssflffiae ^ \Theta \Phi \Pi  \Omega  \Delta  \Omega \Phi `` \Lambda \Xi  fi

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -ASSN

0% o/ ^ ` ' * \Omega \Phi `\Theta  0% o/ % , % $ ssflffiae ^ fi

0% o/ ^ `\Sigma  ' * flffi \Phi  \Psi  \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 

0% o/ % , % $ ssflffiae ^ ,\Phi \Pi  ` '\Delta  `\Sigma  \Lambda \Xi  fi

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -IF

0% o/ ssflffiae ^ ` ' fflaeae\Theta \Theta 
0% o/ % , % $ ssflffi \Phi  \Psi ae ^ fi\Pi  \Theta \Xi  \Sigma  flAE\Upsilon  OEffi\Lambda 

0% o/ % , % $ ssflffiae ^ \Lambda ` ` \Pi \Delta \Phi \Xi  fifl \Phi \Theta ,\Phi  fiffi

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -ZERO 0% o/ % !\Upsilon  ! ssflffiae ^ *

Figure 5.13: Process typing

is induced by the race-freedom assumption. As in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda , nonlinear contexts o/ permitweakening and contraction, whereas linear contexts

$ do not.

The type system, like that of \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda , uses the flffi label to approximate the informationthat can learned by seeing that the program execution has reached a particular point.

The ssflffiae component is the program counter security label that is a lower bound on thelabel of memory locations that may be written to by the process

fi . The critical rule is
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -IF, which checks that after the program has branched on \Psi -level data there are
no writes to memory locations lower than \Psi .

The typing rules \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -PRIM, \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -REF, and \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -ASSN introduce the
same label constraints that primitive operations and references do in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda . These con-straints are sufficient to prevent unwanted information flows due to reference creation

or assignment, and they approximate the information flows due to binary operations.

Rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -IF propagates the label of the conditional into the flffi labels for check-ing the branches. Because the linear resources must be used no matter which branch is

taken, both branches have access to all of the linear context.

113
0% o/ % , % $ ssflffiae ^ fi

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -PAR

0% o/ % ,\Pi % $\Pi  ssflffiae ^ fi\Pi  \Theta \Xi  \Sigma  flAE\Upsilon  OEffi\Lambda 

0% o/ % ,fl\Upsilon  ,ffi% $fl\Upsilon  $ffi ssflffiae ^ fifl 5 fiffi

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -LET

. \Lambda \Phi \Psi  \Lambda o/oe % o/\Psi '_ff% $\Psi '_ff\Pi 
0% o/ \Upsilon  o/oe \Upsilon  o/\Psi '_ff% !\Upsilon  $\Psi '_ff ssflffiae ^ fifl
0% o/ \Upsilon  o/oe % ,\Upsilon  $ ssflffiae ^ fiffi

0% o/ % , % $ ssflffiae ^ \Theta \Phi \Pi  . \Theta  fifl \Lambda \Xi  fiffi

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -LETLIN

. \Lambda  \Lambda $oe % o/\Psi '_ff\Pi 
0% o/ \Upsilon  o/\Psi '_ff% ,fl% $ffi ssflffiae ^ fifl
0% o/ % ,ffi% $fl\Upsilon  $oe ssflffiae ^ fiffi

0% o/ % ,fl\Upsilon  ,ffi% $fl\Upsilon  $ffi ssflffiae ^ \Theta \Phi \Pi  . \Theta  fifl \Lambda \Xi  fiffi

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -SEND

0% o/ ^ ` ' ssflffi\Sigma ae\Theta -*\Upsilon  !\Sigma \Phi \Omega \Lambda \Theta 
0% o/ ssflffiae ^ `\Pi  ' *\Pi 
, % $ ^ _`\Sigma \Phi \Omega  ' !\Sigma \Phi \Omega 
flffi \Phi  \Psi  \Xi  flffi\Sigma 

0% o/ % , % $ ssflffiae ^ `'-`\Upsilon  _`\Sigma \Phi \Omega _

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -LINSEND

, % $ ^ _` ' \Theta -*\Lambda 
0% o/ ssflffiae ^ `\Pi  ' *\Pi 

0% o/ % , % $ ssflffiae ^ _`'-`_

Figure 5.14: Process typing (continued)

114
. \Lambda \Phi \Psi  \Lambda o/oe % o/\Psi '_ff% $\Pi  . \Lambda  \Lambda $% o/\Psi '_ff\Pi 

AE'-\Omega _ \Lambda \Phi \Psi  \Lambda AE ' ssflffiae\Theta -*\Lambda \Upsilon  -\Omega  '-*\Upsilon  o/\Pi 
AE'-\Omega \Upsilon  oe_ \Lambda \Phi \Psi  \Lambda AE ' ssflffiae\Theta -*\Upsilon  !\Lambda \Upsilon  -\Omega  '-*\Upsilon  oe ' !\Pi 

.fl \Lambda \Phi \Psi  \Lambda o/oefl% o/\Psi '_fffl% $fl\Pi 
.ffi \Lambda \Phi \Psi  \Lambda o/oeffi% o/\Psi '_ffffi% $ffi\Pi 

.fl 5 .ffi \Lambda \Phi \Psi  \Lambda o/oefl\Upsilon o/oeffi% o/\Psi '_fffl\Upsilon o/\Psi '_ffffi% $fl\Upsilon $ffi\Pi 

AE'-\Omega _ \Lambda  \Lambda AE ' \Theta -*\Lambda \Upsilon  -\Omega  '-*\Pi 
.fl \Lambda  \Lambda $fl% o/\Psi '_fffl\Pi  .ffi \Lambda  \Lambda $ffi% o/\Psi '_ffffi\Pi 

.fl 5 .ffi \Lambda  \Lambda $fl\Upsilon $ffi% o/\Psi '_fffl\Upsilon o/\Psi '_ffffi\Pi 

Figure 5.15: Join pattern bindings

Rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -ZERO says that the null process type-checks only if all of the linearresources have been used.
Concurrent processes fifl 5 fiffi are checked using the program-counter label of theparent process, as shown in rule

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -PAR of Figure 5.14. The two processes have
access to the same nonlinear resources, but the linear resources must be partitionedbetween them.

The typing rules \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -LET and \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -LETLIN make use of auxiliary oper-ations that extract variable binding information from handler definitions. A join pattern
. yields a collection o/oe of channels it defines and a set of variables bound in the body of
the handler definition o/\Psi '_ff. For nonlinear join patterns, the linear variables form a syn-chronization context

$. The operation . \Lambda \Phi \Psi  \Lambda o/oe % o/\Psi '_ff% $\Pi , defined in Figure 5.15collects these channel names and variables for nonlinear join patterns and assigns them

types. A similar operation . \Lambda  \Lambda $% o/\Psi '_ff\Pi  defined for linear join patterns extracts thesynchronization point

$ and the context for the handler body, o/\Psi '_ff.
Rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -LET is analogous to \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda -CONT from \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  (see Figure 4.5). Itchecks the body of the handler under the assumption that the arguments bound by the

join pattern have the appropriate types. Nonlinear handlers cannot capture free linear
values or channels, because that would potentially violate their linearity. Consequently,the only linear resources available inside the body

fifl are those explicitly passed to
the handler: $\Psi '_ff. Note that the channels defined by the nonlinear handler (o/oe ) are

115
0 ^ OE

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -HEAP-EMPTY 0 ^ !

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -HEAP-LOC

0 ^ OE 0% ! ^ ` ' 0\Theta \Sigma \Lambda 

0 ^ OE ss\Sigma  %_ `ae

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -HEAP-HANDLER

0 ^ OE
0\Theta i\Pi \Lambda  \Delta  ssflffiae\Theta -*\Pi \Upsilon  !\Sigma \Phi \Omega \Pi  \Lambda 
0% -\Omega fl ' -*fl \Pi  \Pi  \Pi  -\Omega \Delta  ' -*\Delta % oe\Sigma \Phi \Omega fl ' !\Sigma \Phi \Omega fl \Pi  \Pi  \Pi  oe\Sigma \Phi \Omega \Delta  ' !\Sigma \Phi \Omega \Delta  ssflffiae ^ fi

0 ^ OE ssifl' -\Omega fl\Upsilon  oe\Sigma \Phi \Omega fl _ 5 \Pi  \Pi  \Pi  5 i\Delta ' -\Omega \Delta \Upsilon  oe\Sigma \Phi \Omega \Delta  _\Theta  fi ae

Figure 5.16: \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  heap types

available inside the handler body, which allows recursion. The process fiffi has access to
the newly defined channels (in o/oe ) and to the previously available resources.

Rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -LETLIN shows how linear resources are manipulated when a linear
handler is declared. The join pattern . defines a collection of linear channels $oe andarguments

o/\Psi '_ff. The arguments (o/\Psi '_ff), as well as some of previously defined linear
channels (,fl and $fl), are available in the linear handler's body (fifl). The rest of thelinear resources (

,ffi and $ffi), plus the newly defined linear channels, are available in theprocess
fiffi.
The rule for type-checking messages sends on nonlinear channels requires that thechannel type and the types of the values passed in the message agree. Also, the program

counter at the point of the send must be protected by the label of message handler; thisconstraint rules out implicit information flows. Rule

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -SEND shows how these
constraints are required.

Sending a message on a linear channel does not impose any constraints on the flffi
label at the point of the send, reflecting that fact that there is no information revealedby the fact that a message is sent on a linear channel. Note that the contents of the

messages are labeled with the flffi label--the message sent on a linear channel might
contain information about the program counter.

A memory OE is a well-formed with heap type 0 when 0 ^ OE can be derivedaccording to the rules in Figure 5.16. Furthermore, no channel name should be defined

in more than one handler definition appearing in OE : for all distinct join patterns .fl and
.ffi in oe\Omega o/\Theta OE \Lambda  if .fl \Lambda \Phi \Psi  \Lambda o/oe\Delta % oe% oe\Pi  and .ffi \Lambda \Phi \Psi  \Lambda o/oe\Theta  % oe% oe\Pi , then

oe\Omega o/\Theta o/oe\Delta \Lambda  O/ oe\Omega o/\Theta o/oe\Theta  \Lambda  \Delta  o/

116
0% ,fl ^ *% ,ffi

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -S-EMPTY 0% , ^ !% !

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -S-HANDLER

0% , ^ *% ,fl
, \Theta i\Pi \Lambda  \Delta  \Theta -*\Pi \Lambda  ,ffi ffl ,
0% -\Omega fl ' -*fl \Pi  \Pi  \Pi  -\Omega \Delta  ' -*\Delta % ,ffi\Upsilon  ! ssflffiae ^ fi

0% , ^ *ssflffi ' ifl\Theta  -\Omega fl\Lambda  5 \Pi  \Pi  \Pi  i\Delta \Theta  -\Omega \Delta \Lambda  \Theta  fi ae% ,fl\Upsilon  ,ffi

Figure 5.17: \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  synchronization environment types
0% o/ % , % $ ^ /

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -NET-EMPTY 0% o/ % !% ! ^ !

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -NET-PROC

0% o/ % ,fl% $fl ^ /
0% o/ % ,ffi% $ffi ssflffiae ^ fi

0% o/ % ,fl\Upsilon  ,ffi% $fl\Upsilon  $ffi ^ / 5 ssflffi ' fi ae

Figure 5.18: Network typing rules

Note that the heap type 0 may contain more bindings than are present in OE .

A synchronization environment * has type , when no channel name in , is definedin more than one handler,

oe\Omega o/\Theta *\Lambda  \Delta  oe\Omega o/\Theta , \Lambda , and 0% , ^ *% , \Sigma  can be derived ac-cording to the rules in Figure 5.17. Any linear channel in

, must be used in at most
one of the handlers present in the synchronization environment. The type , \Sigma  recordswhich channels have been used in

*. The channels in , AE , \Sigma  must be used within
the program accompanying the synchronization environment, as required by the rule
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -CONFIG (given below).

A network of processes is well-typed whenever each of the processes in the networkis well-typed and the linear resources are completely used, as shown in Figure 5.18.

Finally, a configuration \Lambda OE\Upsilon  *\Upsilon  / \Pi  is well-typed if its components are and all of the
linear channels defined in * are used exactly once in either * or / :

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -CONFIG

0 ^ OE 0% ,fl\Upsilon  ,ffi ^ *% ,fl 0% !% ,ffi% ! ^ /

0% ,fl\Upsilon  ,ffi ^ \Lambda OE\Upsilon  *\Upsilon  / \Pi 

117
5.2.3 Race prevention and alias analysis
As we have seen, two concurrently running threads might leak confidential informationif they have write-write or read-write races. This section discusses how to formalize

race freedom and how program analysis techniques can potentially be used to establishthat a program is race free.

Consider example (1) from Section 5.1.1. In the \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  syntax, it can be written
as the program fifl:

fifl fflij\Delta  ',\Phi \Pi  \Sigma fl ij \Pi  \Lambda \Xi  *_ 5 ',\Phi \Pi  \Sigma fl ij ` \Lambda \Xi  *_
The possible evaluation sequences of this program, starting from the memory ss\Sigma fl %_ \Pi aeare shown in the next diagram.

6

\Lambda \Xi \Psi fl fl\Sigma  \Sigma \Pi \Pi  j\Pi  \Omega \Phi \Sigma  \Psi fl `i \Delta  \Pi \Psi  *\Xi  \Theta  \Lambda \Xi \Psi fl fl\Sigma  \Delta \Pi \Pi  j\Pi  *\Xi 
\Lambda \Xi \Psi fl fl\Sigma  \Sigma \Pi \Pi  j\Pi  ssfl\Xi 

\Theta 

\Theta  \Lambda \Xi \Psi fl fl\Sigma  \Delta \Pi \Pi  j\Pi  \Omega \Phi \Sigma  \Psi fl `i \Sigma  \Pi \Psi  *\Xi  \Theta  \Lambda \Xi \Psi fl fl\Sigma  \Sigma \Pi \Pi  j\Pi  *\Xi 
The evaluation is nondeterministic because of the concurrency. Once the choice ofwhich thread to run first is made, the evaluations become distinct --the nondeterministic

choice becomes apparent from the program state. Importantly, the nondeterminism isvisible solely by watching the contents of location

\Sigma fl. Example (2) from Section 5.1.1exhibits similar properties.

Contrast those programs with the following race-free program, fiffi:

fiffi fflij\Delta  ',\Phi \Pi  \Sigma fl ij \Pi  \Lambda \Xi  *_ 5 ',\Phi \Pi  \Sigma ffi ij ` \Lambda \Xi  *_
The possible evaluation sequences of this program starting from the memory OEfl \Delta 
ss\Sigma fl %_ `aess\Sigma ffi %_ `ae are shown below:

\Lambda \Xi fl\Xi \Psi fl fl\Sigma  \Sigma \Pi \Pi  j\Pi  \Omega \Phi \Sigma  \Psi ffi `i \Delta  \Pi \Psi  *\Xi  \Theta 
\Lambda \Xi fl\Pi  j\Pi  ssfl\Xi 

\Theta 

\Theta 

\Lambda \Xi \Psi fl fl\Sigma  \Sigma \Pi \Xi \Psi ffi fl\Sigma  \Delta \Pi \Pi  j\Pi  *\Xi 

\Lambda \Xi fl\Xi \Psi ffi fl\Sigma  \Delta \Pi \Pi  j\Pi  \Omega \Phi \Sigma  \Psi fl `i \Sigma  \Pi \Psi  *\Xi  \Theta 

In this case, even though there is still nondeterminism in the evaluation, the evaluation
of one thread does not disrupt the computation of the other thread. Evaluation of the twothreads

commutes, which implies that the scheduler is free to choose any ordering--the
eventual outcome of the program is unaffected.These observations lead to the following definition of race freedom, which requires

that any configuration reachable from the starting configuration satisfy the commutativity property.

6For the sake of clarity, the network syntax fl\Delta \Theta  ffi ff\Omega ffl has been omitted from this description, because
the program counter label is irrelevant.

118
Definition 5.2.6 A configuration O/ is race free whenever O/ \Lambda \Phi  O/\Sigma  and O/\Sigma  \Lambda  O/fl
and O/\Sigma  \Lambda  O/ffi and O/fl i( O/ffi imply that there exists an O/\Sigma \Sigma  such that O/fl \Lambda  O/\Sigma \Sigma  and
O/ffi \Lambda  O/\Sigma \Sigma . Pictorially, this can be seen as:

O/fl

\Lambda 
i(O/ \Lambda \Phi  O/\Sigma 
\Lambda 

\Lambda 

O/\Sigma \Sigma 

O/ffi

\Lambda 

An open term is race free whenever all of its closed instances are race free. Formally,
/ is race free if !% o/ % !% ! ^ / and for every substitution o/ such that ! *\Delta  o/ ' o/ the
configuration \Lambda !\Upsilon  !\Upsilon  o/\Theta / \Lambda \Pi  is race free.

This is a strong notion of race freedom. For example, under this definition the fol-lowing program has a race:

\Theta \Phi \Pi  \Delta 'AE_ 5 ss'_ j \Theta \Phi \Pi   j AE \Lambda \Xi  * \Lambda \Xi 

\Delta '\Pi _ 5 \Delta '`_ 5 ss'_

Here, the program evolves into one of two distinct possible configurations that have networks containing either the (unhandled) message send \Delta '\Pi _ or the (unhandled) messagesend

\Delta '`_ --such nondeterminism corresponds to send contention.
This definition of race freedom is certainly sufficient to rule out the timing leaks that
may occur between threads. However, it is stronger than necessary if the only externallyobservable aspect of the machine configuration is the memory (and not the program

counter or channel states). It is possible to weaken the definition of race freedom toconsider harmful only nondeterminism apparent from the memory, in which case sideeffect free programs (like the one above) are permitted to exhibit nondeterminism.

However, even with a weakened definition of race freedom, the nondeterminism onnonlinear channels can cause races. For example, the following program nondeterministically stores either \Pi  or ` into the reference \Theta  because there is a race between the twosends on channel

\Delta .

\Theta \Phi \Pi  \Delta 'AE_ 5 ss'_ j ,\Phi \Pi  \Theta  ij AE \Lambda \Xi  * \Lambda \Xi 

\Delta '\Pi _ 5 \Delta '`_ 5 ss'_

The channels involved in the race need not carry values (as in the program above). In-stead, the handler itself may contain state that introduces the nondeterminism, as shown

here:

119
\Theta \Phi \Pi  \Delta '_ \Theta  \Theta \Phi \Pi  ' j oe \Lambda \Xi  ,\Phi \Pi   ij &' \Lambda \Xi  * \Lambda \Xi 

\Delta '_ 5 \Delta '_

As a last example, the following program exhibits a race to the assignment of thelocation

. It shows a slightly more subtle way to create a race to the send on channel \Delta :

\Theta \Phi \Pi  \Delta 'AE_ \Theta  ,\Phi \Pi   ij AE \Lambda \Xi  * \Lambda \Xi 
\Theta \Phi \Pi  ss'\Delta fl: \Delta ffi_ \Theta  \Delta fl'\Pi _ 5 \Delta ffi'`_ \Lambda \Xi 

ss'\Delta : \Delta _

Observe that all of the examples of races involve two aliases of either a reference or
a channel used concurrently. Consequently, preventing races relies on detecting possi-ble aliasing of references and channels and disallowing aliases to be used by multiple

threads. Rather than formulate a specific alias analysis for fine-grained control over
the resources available to each thread, this thesis instead assumes that the concurrentprogram is race-free.

There are a number of ways that race freedom can be established. One useful approach is to use alias analysis to (soundly) approximate the set of locations and channelswritten to (or sent messages) by a thread. Call this set by

j\Psi `i\Xi \Theta fi \Lambda . By determining
which locations are potentially read by fi (a set \Psi \Xi \Theta '\Theta fi \Lambda ), an analysis can prevent racesby requiring that, for any subprograms

fifl and fiffi that might occur during evaluation:

j\Psi `i\Xi \Theta fifl\Lambda  O/ \Theta \Psi \Xi \Theta '\Theta fiffi\Lambda  OE j\Psi `i\Xi \Theta fiffi\Lambda \Lambda  \Delta  o/
ss j\Psi `i\Xi \Theta fiffi\Lambda  O/ \Theta \Psi \Xi \Theta '\Theta fifl\Lambda  OE j\Psi `i\Xi \Theta fifl\Lambda \Lambda  \Delta  o/

Alias analyses construct finite models of the dynamic behavior of a program so thatwhich references are dynamically instantiated with which memory locations can be statically approximated. The more closely the abstract model agrees with the true behaviorof the system, the more accurate the aliasing information can be. An abstract interpretation is sound if it faithfully models the behavior of the system--it does not give answersthat disagree with the actual behavior of the system. Here, the alias analysis can be used
to approximate the sets \Psi \Xi \Theta '\Theta oe\Lambda  and j\Psi `i\Xi \Theta oe\Lambda  sufficient to establish race freedom.7

As an extreme, one sound analysis is to simply assume that any process might reador write any reference. Such a rough approximation to the actual aliasing would require

that the program be sequential. Another possibility is to approximate alias information
using types: a reference of type fflaeae\Theta  \Omega \Phi ` can never alias a reference of type \Lambda \Xi \Pi  \Omega \Phi `,for example. This scheme would allow concurrent threads to mutate parts of the heap

that contain different types of data.A second possibility is to ensure that references and nonlinear channels do not cause
races is to require them to be used sequentially. Simple syntactic constraints similar to

7Although it is beyond the scope of this thesis, it should be possible to prove that this application of
alias analysis implies the semantic definition of race freedom.

120
linearity that can force a handler to be used sequentially. (See, for example, Reynolds'
original work on syntactic control of interference [Rey78].) Consider the handler dec-laration

\Theta \Phi \Pi  ; \Theta  fl \Lambda \Xi  !. If the channel names defined in . are used affinely (at mostonce statically) in

fi and affinely in ), then the body of the handler (fi ) will never
execute concurrently with another instance of itself--the handler must be used sequen-tially. One can formulate sequentiality in the type system (as shown by Honda et al.

[HVY00, HY02]), but doing so is rather complex.

Another possibility is to track aliasing directly in the type system [SWM00, WM00].
Such an approach would potentially permit very fine-grained control of concurrency.More generally, pointer or shape analysis can be used to approximate the

\Psi \Xi \Theta '\Theta oe\Lambda  and
j\Psi `i\Xi \Theta oe\Lambda  sets. Most relevant to this thesis are interprocedural analyses [LR92, Deu94],
analyses that deal with function pointers [EGH94], and the work on pointer analysis formultithreaded programs [RR99].

There are also a number of type systems that regulate locking protocols to preventrace conditions [FA99b, FA99a, FF00]. Instead of using aliasing information directly,
these analyses ensure that an appropriate lock is held before a memory location is ac-cessed; they introduce ordering constraints on locks to serialize the memory accesses.
Although not intended to guarantee the strong race-freedom requirement needed here
(these analyses still permit nondeterministic ordering of memory writes), it might bepossible to use them as a starting point.

It is worth noting that linear channels may never be aliased because they cannot beduplicated or stored in the memory. Linear type information can therefore be used by the
alias analysis. However, we have not yet addressed the connection between the orderedlinear continuations of

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  and the linear channels of \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  .
The type system presented in Figures 5.13 and 5.14 does not explicitly enforce anyordering constraints on the use linear channels. Instead, the ordering is induced by the

race-freedom requirement because it restricts how linear channels may be mentioned inthe program.

To see how linear channels, sequentiality, and race prevention are related, considerthe following program.

\Theta \Phi \Pi  \Delta 'AE_ \Theta  fi \Lambda \Xi 

\Delta '\Pi _ 5 \Delta '`_

The channel \Delta  itself is nonlinear and hence can be used multiple times. It may step toa configuration containing the process

fi fl-aeAEffi or fi fl=aeAEffi nondeterministically. Anysequencing between invocations of
\Delta  must be encoded explicitly using linear channels;
the linear message acknowledges that the channel has received one message and is wait-ing for another. To ensure that the message

\Delta '`_ is consumed before \Delta '\Pi _, the above
example would be changed to:

121
\Theta \Phi \Pi  \Delta 'AE:._ \Theta  fi fi.'_ \Lambda \Xi 
\Theta \Phi \Pi  .fl'_ \Theta  \Delta '\Pi : .__ \Lambda \Xi 

\Delta '`: .fl_

Here, the linear channel .fl expresses the causal connection between the send of ` on
\Delta  and the send of \Pi  on \Delta . Note that ._ is unspecified: It expresses the causal relation
between the send of ` on \Delta  and any future sends. Importantly, ._ is free in the body ofthe handler for

.fl.The linearity of the acknowledgment channels is crucial: duplicating the acknowledgment messages allows multiple "futures" to take place, destroying sequentiality:

\Theta \Phi \Pi  \Delta 'AE:._ \Theta  fi fi.'_ \Lambda \Xi 
\Theta \Phi \Pi  .fl'_ \Theta  \Delta '\Pi : .__ \Lambda \Xi 

\Delta '`: .fl_ 5 \Delta '\Pi : .fl_

Note that because of synchronization between linear channels, the causal ordering
can be more complex. Consider the following example.

\Theta \Phi \Pi  .fl'_ 5 .ffi'_ \Theta  fi \Lambda \Xi 
\Theta \Phi \Pi  .*'_ \Theta  )fi.fl'_ \Lambda \Xi 

.ffi'_ 5 +fi.*'_

In this program, threads +, ), and fi must be evaluated in that order, even though
there is a message sent on channel .ffi (potentially) before the send on channel .*. Thesequentiality is guaranteed because the handler body for

.* sends the message on .fl--the message on
.* must take place before the synchronization on .fl and .ffi.
Race freedom rules out the following program because there is no causal orderingbetween the handlers for

.fl and .ffi, even though they are used linearly:

\Theta \Phi \Pi  .fl'_ \Theta  ,\Phi \Pi   ij \Pi  \Lambda \Xi  * \Lambda \Xi 
\Theta \Phi \Pi  .ffi'_ \Theta  ,\Phi \Pi   ij ` \Lambda \Xi  * \Lambda \Xi 

.fl'_ 5 .ffi'_

The following similar program does establish a total ordering between .fl and .ffi, soit is permitted by the race-freedom condition.

\Theta \Phi \Pi  .fl'_ \Theta  ,\Phi \Pi   ij \Pi  \Lambda \Xi  * \Lambda \Xi 
\Theta \Phi \Pi  .ffi'_ \Theta  ,\Phi \Pi   ij ` \Lambda \Xi  .fl'_ \Lambda \Xi 

.ffi'_

Race freedom implies that there is a causal ordering relationship between the linear
synchronization handlers and that any two handlers that interfere are totally ordered.This constraint ensures that interfering linear handlers are used sequentially, which implies that updates to memory locations mentioned in them are deterministic.

122
5.3 Subject reduction for \Delta `*+`,ij`
This section establishes a subject reduction theorem for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  . It follows the same
general outline as the subject reduction proof for \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda . As with \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  the subject reduc-tion property is key to establishing noninterference for

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  .
We first establish the standard lemmas.

Lemma 5.3.1 (Substitution 1) Suppose 0% o/ \Upsilon  \Omega  ' *% ,\Upsilon  $ ssflffiae ^ fi and 0% ! ^ ` ' *
then 0% o/ % ,\Upsilon  $ ssflffiae ^ fi fl`ae\Omega ffi.

Proof (sketch): The proof first strengthens the hypothesis to allow substitution in all ofthe syntactic classes of

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  . The result then follows from mutual induction on thestructure of the typing derivation. The argument is similar to the proof of Lemma 4.3.1.

\Delta 

Lemma 5.3.2 (Substitution 2) Suppose 0% o/ % ,fl\Upsilon  $fl\Upsilon  oe ' ! ssflffiae ^ fi and ,ffi% $ffi ^ _` '
! then 0% o/ % ,fl\Upsilon  ,ffi\Upsilon  $fl\Upsilon  $ffi ssflffiae ^ fi fl_`aeoeffi.

Proof (sketch): The proof first strengthens the hypothesis to allow substitution in allof the syntactic classes of

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  . The result then follows from mutual induction on
the structure of the derivation that fi is well-typed. The base cases follow directly fromthe rules in Figure 5.11.

\Delta 

Lemma 5.3.3 (Program counter variance) If 0% o/ % ,\Upsilon  $ ssflffiae ^ fi and flffi\Sigma  \Xi  flffi then
0% o/ % ,\Upsilon  $ ssflffi\Sigma ae ^ fi .

Proof: By induction on the derivation that fi is well-typed under ssflffiae. Note that all
lattice inequalities involving the program counter appear to the left of \Xi . Thus, replacing
flffi by flffi\Sigma  in a typing derivation will still yield a valid derivation. \Delta 

Lemma 5.3.4 (Primitive evaluation) If 0% ! ssflffiae ^ fl#\Xi O/ ' * and OE\Upsilon  flffi *\Delta  fl#\Xi O/ * `
then 0% ! ^ ` ' *.

Proof (sketch): The proof is nearly identical to that of Lemma 4.3.5. \Delta 

Lemma 5.3.5 (Heap weakening) If 0\Sigma  extends 0 and 0 appears to the left of ^ in
the conclusion of a typing derivation, then replacing 0 by 0 \Sigma  in the conclusion yields a
valid typing judgment.

123
Proof (sketch): By induction on the typing derivations. The base case follows from
the fact that 0\Sigma  extends 0 (and hence agrees with 0 on their common domain), so rules
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -HEAP-LOC and \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -HEAP-HANDLER hold with 0 \Sigma  instead of 0.
\Delta 

Because \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  has a more complicated operational semantics, we also need to
show that the additional components of the machine configuration are well-typed.

Lemma 5.3.6 (Synchronization environment weakening) If 0% ,fl ^ *% ,ffi and , \Sigma  is
any synchronization state type such that oe\Omega o/\Theta , \Sigma \Lambda  O/ oe\Omega o/\Theta ,fl\Lambda  \Delta  o/ then 0% ,fl\Upsilon  , \Sigma  ^ *% ,ffi

Proof: By induction on the typing derivation. The base case follows immediatelyfrom the rule

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -S-EMPTY. \Delta 

The structural equivalence of machine configurations allows us to disregard the syn-tactic order of processes in a program. The following lemma establishes, as expected,

that reordering the processes in a configuration does not affect its typing properties.
Lemma 5.3.7 (Equivalence preserves typing) If 0% , ^ \Lambda OE\Upsilon  *\Upsilon  / \Pi  and configuration \Lambda OE\Upsilon  *\Upsilon  / \Pi  ( \Lambda OE \Sigma \Upsilon  *\Sigma \Upsilon  / \Sigma \Pi  then there exists a renaming 0 \Sigma  of 0 and a renaming
, \Sigma  of , such that 0 \Sigma % , \Sigma  ^ \Lambda OE \Sigma \Upsilon  *\Sigma \Upsilon  / \Sigma \Pi .

Proof (sketch): This lemma follows from several observations:

1. The rules \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -NET-EMPTY and \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -ZERO agree on the linear portionof the context.

2. Partitioning of linear contexts is commutative and associative (and hence agreeswith the requirements of rules

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -NET-PROC and \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -PAR).

3. Consistent renaming of memory locations or channel names does not change their

associated types.

\Delta 
Using the above lemmas, we prove the following lemma.

Lemma 5.3.8 (Subject reduction) Suppose 0% , ^ \Lambda OE\Upsilon  *\Upsilon  / \Pi  and

\Lambda OE\Upsilon  *\Upsilon  / \Pi  \Lambda  \Lambda OE \Sigma \Upsilon  *\Sigma \Upsilon  / \Sigma \Pi 
Then there exists 0 \Sigma  and , \Sigma  such that 0 \Sigma % , \Sigma  ^ \Lambda OE \Sigma \Upsilon  *\Sigma \Upsilon  / \Sigma \Pi .
Proof: This proof follows as a corollary of the strengthened version below, using
Lemma 5.3.7 twice to recover the result for \Lambda  from the case for _ and the structuralevaluation rule

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EQSTEP . \Delta 

124
Lemma 5.3.9 (Strengthened subject reduction) Suppose 0% , ^ \Lambda OE\Upsilon  *\Upsilon  / \Pi  and

\Lambda OE\Upsilon  *\Upsilon  / \Pi  _ \Lambda OE \Sigma \Upsilon  *\Sigma \Upsilon  / \Sigma \Pi 
Then there exists 0 \Sigma  and , \Sigma  such that 0 \Sigma % , \Sigma  ^ \Lambda OE \Sigma \Upsilon  *\Sigma \Upsilon  / \Sigma \Pi . Furthermore, 0 \Sigma  extends
0 and , and , \Sigma  agree on the channels in their intersection.

Proof: The proof is by cases on the evaluation step used.
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-LETPRIM This case follows immediately from Lemmas 5.3.4 and5.3.1. Note that neither the memory nor the synchronization environment change.

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-LETREF It must be that / \Delta  / \Sigma \Sigma  5 ssflffi ' \Theta \Phi \Pi  \Omega  \Delta  \Omega \Phi ` ` \Lambda \Xi  fi ae and

/ \Sigma  \Delta  / \Sigma \Sigma  5 ssflffi ' fi fl\Sigma ae\Omega ffiae and OE \Sigma  \Delta  OE ss\Sigma  %_ `ae. Let 0\Sigma  \Delta  0ss\Sigma  ' * \Omega \Phi `ae. Bythe rule's side condition, the location

\Sigma  does not occur in the domain of 0 or OE .Therefore,
0\Sigma  extends 0. Because / is well-typed, it follows that 0% !% ,fl% ! ^ / \Sigma \Sigma 
and 0% \Omega  ' * \Omega \Phi `\Phi \Psi % ,ffi\Upsilon  ! ssflffiae ^ fi where , \Delta  ,fl\Upsilon  ,ffi. Furthermore, it must be thecase that

0% ! ^ ` ' *. By Lemma 5.3.5, we then have 0 \Sigma % !% ,fl% ! ^ / \Sigma \Sigma  and
0\Sigma % \Omega  ' * \Omega \Phi `% ,ffi\Upsilon  ! ssflffiae ^ fi and 0\Sigma % ! ^ ` ' *. Note that 0 \Sigma  ^ OE \Sigma  follows from
Lemma 5.3.5 and \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -HEAP-LOC. The fact that / \Sigma  is well-typed followsfrom Lemma 5.3.1 and rule

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -NET-PROC .

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-SET This case follows almost exactly as the previous one.
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-HANDLER This case is like the one for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-LETREF except that weakening (Lemma 5.3.5) and rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -HEAP-HANDLER are usedto establish that substitution applies. Note that substitution must be performed on

the handler body. This case also relies on the operation \Lambda \Phi \Psi  agreeing with the
requirements of rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -HEAP-HANDLER. The freshness of the channelnames is needed to establish that

0 \Sigma  extends 0.

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-LINHANDLER It must be the case that / \Delta  / \Sigma \Sigma  5 fi where fi \Delta 

ssflffi ' \Theta \Phi \Pi  . \Theta  fifl \Lambda \Xi  fiffiae and . \Lambda  \Lambda $oe % o/\Psi '_ff\Pi . Suppose that

$oe \Delta  flAEfl ' \Theta  -*fl\Lambda \Upsilon  \Pi  \Pi  \Pi  \Upsilon  AE\Delta  ' \Theta  -*\Delta \Lambda ffi
Because the configuration is well-typed under 0 and , , we also have 0 ^ OEand

0% , ^ *% ,fl and 0% !% ,ffi% ! ^ / , where , \Delta  ,fl\Upsilon  ,ffi. Inversion of rule
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -NET-PROC yields 0% !% ,*% ! ^ / \Sigma \Sigma  and 0% !% ,*\Upsilon  ! ssflffiae ^ fi , where ,ffi \Delta 
,*\Upsilon  ,*. Inversion of rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -LETLIN yields 0% o/\Psi '_ff% ,,\Upsilon  ! ssflffiae ^ fifl and
0% !% ,ss\Upsilon  $oe ssflffiae ^ fiffi where ,* \Delta  ,,\Upsilon  ,ss. Let , \Sigma \Pi  \Delta  fli\Pi  ' $oe \Theta AE\Pi \Lambda ffi for AE  \Xi   '
and the i\Pi  chosen according to the transition rule and let ,ae \Delta  \Delta \Delta \Pi  , \Sigma \Pi  . Then

125
by rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -LINCHAN we have , \Sigma \Pi  % ! ^ i\Pi  ' $oe \Theta AE\Pi \Lambda . By ' applications of
Lemma 5.3.2 we obtain 0% !% ,ss\Upsilon  ,ae\Upsilon  ! ssflffiae ^ fiffifl-i\Pi aeAE\Pi ffi.

Applying rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -NET-PROC to the antecedents

0% !% ,*% ! ^ / \Sigma \Sigma  *'oe 0% !% ,ss\Upsilon  ,ae\Upsilon  ! ssflffiae ^ fiffifl-i\Pi aeAE\Pi ffi
we obtain

0% !% ,*\Upsilon  ,ss\Upsilon  ,ae% ! ^ / \Sigma \Sigma  5 ssflffi ' fiffifl-i\Pi aeAE\Pi ffiae

We have already shown that 0% o/\Psi '_ff% ,,\Upsilon  ! ssflffiae ^ fifl and 0% , ^ *% ,fl hold. By
weakening (Lemma 5.3.6) it follows that 0% ,\Upsilon  ,ae ^ *% ,fl. Note that ,, ffl ,* ffl
,ffi ffl , ffl ,\Upsilon  ,ae and that, by construction \Theta ,\Upsilon  ,ae\Lambda \Theta i\Pi \Lambda  \Delta  $oe \Theta \Omega \Pi \Lambda . Therefore, we
may apply rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -S-HANDLER to obtain

0% ,\Upsilon  ,ae ^ *ssflffi ' . \Theta  fiflae% ,fl\Upsilon  ,,

Now we must account for the linearity of the channels:

,\Upsilon  ,ae \Delta  ,fl\Upsilon  ,ffi\Upsilon  ,ae \Delta  ,fl\Upsilon  ,*\Upsilon  ,*\Upsilon  ,ae \Delta  ,fl\Upsilon  ,*\Upsilon  ,,\Upsilon  ,ss\Upsilon  ,ae
Resources ,fl and ,, are used in *\Sigma  \Delta  *ssflffi ' . \Theta  fiflae and resources ,*, ,ss, and
,ae are used in / \Sigma  \Delta  / \Sigma \Sigma  5 ssflffi ' fiffifl-i\Pi aeAE\Pi ffiae, so we may apply \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -CONFIG
to conclude 0% ,\Upsilon  ,ae ^ \Lambda OE\Upsilon  *\Sigma \Upsilon  / \Sigma \Pi , as required.

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-COND1 We have / \Delta  / \Sigma \Sigma  5 ssflffi ' \Lambda ` \Pi \Theta  \Pi \Delta \Phi \Xi  fifl \Phi \Theta ,\Phi  fiffiae. Be-cause the configuration is well-typed under

0 and , , we also have 0 ^ OEand
0% , ^ *% ,fl and 0% !% ,ffi% ! ^ / , where , \Delta  ,fl\Upsilon  ,ffi. Inversion of rule
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -NET-PROC yields 0% !% ,*% ! ^ / \Sigma \Sigma  and

0% !% ,*\Upsilon  ! ssflffiae ^ \Lambda ` \Pi \Theta  \Pi \Delta \Phi \Xi  fifl \Phi \Theta ,\Phi  fiffi
where ,ffi \Delta  ,*\Upsilon  ,*. From \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -IF, it follows that 0% ! ^ \Pi \Theta  ' fflaeae\Theta \Theta \Delta 
where \Psi  \Xi  \Psi \Sigma  and that 0% !% ,*\Upsilon  ! ssflffi \Phi  \Psi \Sigma ae ^ fifl. By program counter vari-ance (Lemma 5.3.3) it follows that

0% !% ,*\Upsilon  ! ssflffi \Phi  \Psi ae ^ fifl. Applying rule
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -NET-PROC yields 0% !% ,*\Upsilon  ,*% ! ^ / \Sigma \Sigma  5 ssflffi \Phi  \Psi  ' fiflae, from which
we can use \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -CONFIG to conclude 0% ,fl\Upsilon  ,*\Upsilon  ,* ^ \Lambda OE\Upsilon  *\Upsilon  / \Sigma \Pi , where
/ \Sigma  \Delta  / \Sigma \Sigma  5 ssflffi \Phi  \Psi  ' fiflae. Recall that ,*\Upsilon  ,* \Delta  ,ffi and that ,fl\Upsilon  ,ffi \Delta  , , so we have
the desired result.

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-COND2 This case is nearly identical to the previous case.

126
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-SEND We have / \Delta  / \Sigma \Sigma  5\Pi  ssflffi\Pi  ' i\Pi \Theta \Lambda '-`\Pi \Upsilon  _`\Sigma \Phi \Omega \Pi  _ae and it is also the

case that OE \Delta  OE \Sigma \Sigma ssifl'-\Omega fl\Upsilon  oe\Sigma \Phi \Omega fl _ 5 \Pi  \Pi  \Pi  5 i\Delta '-\Omega \Delta \Upsilon  oe\Sigma \Phi \Omega \Delta  _ \Theta  fi ae. Because the configu-ration is well-typed under

0 and , , we also have 0 ^ OE and 0% , ^ *% ,fland
0% !% ,ffi% ! ^ / , where , \Delta  ,fl\Upsilon  ,ffi. Inversion of rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -NET-PROC '
times yields 0% !% ,*% ! ^ / \Sigma \Sigma  and 0% !% , \Sigma \Pi  \Upsilon  ! ssflffi\Pi ae ^ i\Pi \Theta \Lambda '-`\Pi \Upsilon  _`\Sigma \Phi \Omega \Pi  _where ,ffi \Delta  ,*\Upsilon  ,*and

,* \Delta  , \Sigma fl\Upsilon  \Pi  \Pi  \Pi  \Upsilon  , \Sigma \Delta . For each \Xi  \Sigma  flAE\Upsilon  \Pi  \Pi  \Pi  \Upsilon  'ffi the rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -SEND yields
0% ! ^ i\Pi \Theta \Lambda  ' ssflffi\Sigma \Pi ae\Theta -*\Pi \Upsilon  !\Pi \Sigma \Phi \Omega \Lambda \Theta \Delta \Lambda  where flffi\Pi  \Phi  \Psi \Sigma \Pi  \Xi  flffi\Sigma \Pi  and \Psi \Pi  \Xi  \Psi \Sigma \Pi . Furthermore, we
also have 0% ! ^ `\Pi o/ ' *\Pi o/ where flffi\Pi  \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Pi o/\Lambda  and , \Sigma \Pi  % ! ^ _`\Sigma \Phi \Omega \Pi  ' !\Sigma \Phi \Omega \Pi  .

Because flffi\Pi  \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Pi o/\Lambda , we have 0% ! ^ `\Pi o/ \Phi  flffi\Pi  ' *\Pi o/.
From 0 ^ OE and rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -HEAP-HANDLER we have

0% -\Omega fl ' -*fl\Upsilon  \Pi  \Pi  \Pi  \Upsilon  -\Omega \Delta  ' -*\Delta % !% oe\Sigma \Phi \Omega fl ' !\Sigma \Phi \Omega fl \Upsilon  \Pi  \Pi  \Pi  \Upsilon  oe\Sigma \Phi \Omega \Delta  ' !\Sigma \Phi \Omega \Delta  ssflffiae ^ fi
Applying the substitution Lemmas 5.3.1 and 5.3.2 we obtain

0% !% ,*\Upsilon  ! ssflffiae ^ fi fl-`\Pi  \Phi  flffi\Pi ae -\Omega \Pi ffifl_`\Pi aeoe\Pi ffi\Sigma \Phi \Omega 
Note that rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -SEND requires that flffi\Sigma \Pi  \Xi  flffi and because flffi\Pi  \Phi  \Psi \Pi  \Xi  flffi\Sigma \Pi we have

\Psi  \Delta  \Delta \Pi  \Theta flffi\Pi  \Phi  \Psi \Pi \Lambda  \Xi  \Delta \Pi  flffi\Sigma \Pi  \Xi  flffi
By Lemma 5.3.3 it follows that 0% !% ,*\Upsilon  ! ss\Psi ae ^ fi fl-`\Pi  \Phi  flffi\Pi ae -\Omega \Pi ffifl_`\Pi aeoe\Pi ffi\Sigma \Phi \Omega .
Applying \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -NET-PROC , we obtain

0% !% ,*\Upsilon  ,*% ! ^ / \Sigma \Sigma  5 ss\Psi  ' fi fl-`\Pi  \Phi  flffi\Pi ae -\Omega \Pi ffifl_`\Pi aeoe\Pi ffi\Sigma \Phi \Omega ae
Lastly, we observe that ,ffi \Delta  ,*\Upsilon  ,* so rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -CONFIG yields the desiredresult.

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-LINSEND This case is similar to the previous case, except that wenote that the

, \Sigma  is , minus the linear channels used in the step.

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-FORK This case follows straightforwardly from the two typing rules

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -NET-PROC and \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -PAR and the fact that set union (for linear
contexts) is associative.

\Delta 
Note that progress, as it is usually stated, does not hold for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  . A nonlinear
channel may never be sent a message, causing the corresponding handler to block for-ever waiting. For example, the following program either runs the subprocess

fi or gets
stuck, depending on the value of \Theta , but it should be typable:

127
\Theta \Phi \Pi  \Delta '_ 5 ss'_ \Theta  fi \Lambda \Xi 

\Delta '_ 5 '\Lambda ` \Theta  \Pi \Delta \Phi \Xi  * \Phi \Theta ,\Phi  ss'__

There is a weaker analog to progress in this setting. A program may not get stuckif there are still outstanding linear channels that have not yet received communication.
One could formulate type-soundness without using a progress lemma, for instance, by
adding an explicit bad state and then showing that the type system prevents a well-typedprogram from stepping to the bad state. Such a result is unimportant for the discussion

of noninterference in the next section; subject reduction is the key lemma.

5.4 Noninterference for \Delta `*+`,ij`
This section establishes that \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  programs that are well typed and satisfy a race-freedom condition obey noninterference. Recall that the ultimate goal of the noninterference result is to establish that altering the high-security parts of the program doesnot affect the deterministic behavior of the low-security parts of the store. Because this
definition of noninterference ignores external timing channels and internal timing channels are prevented by eliminating races, it suffices to show that the low-security memoryaccess behavior of the program can be simulated by another deterministic program that

differs in its high-security parts.

A program meets race-freedom requirement if all of its low-security simulations arerace free. Intuitively, a low-security simulation of a

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  program fi is another
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  program that differs from fi in high-security values; the low-security simu-lation also forces high-security computation to terminate in exactly one step. A lowsecurity simulation of fi reflects the possible behavior of fi as seen by a low-security
observer. Because high-security computation in the simulation terminates after one step,the resulting security condition is timing and termination insensitive.

Importantly, because the simulation of a program fi is itself a \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  program,
establishing that the simulation is race free is no harder than establishing that a \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda program is race free. Any of the techniques discussed in Section 5.2.3 can be used to

ensure the race-freedom requirement. Also, because the simulations of a program can be
treated as abstract interpretations of the program, it is plausible that all of the simulationsof a program can be determined to be race free simultaneously.

In order to state the determinism property formally, we must first build some addi-tional technical machinery. For now, we state the noninterference result informally.

Theorem 5.4.1 ((Informal) Noninterference for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  ) If / is well-typed and \Theta -
equivalent simulations are race free, then for any low-security memory location \Sigma  and
any two high-security values `fl and `ffi the sequence of values stored in memory location

128
\Sigma  during the evaluation of \Lambda !\Upsilon  !\Upsilon  / fl`flae\Omega ffi\Pi  is a prefix of the sequence of values stored
in \Sigma  by \Lambda !\Upsilon  !\Upsilon  / fl`ffiae\Omega ffi\Pi  (or vice-versa).

At a high level, the proof strategy is similar to that used in \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda . We first establish anappropriate notion of

\Theta -equivalence that equates values that should not be distinguish-able to an observer with security clearance less-than

\Theta . We then use this equivalence to
construct a faithful low-security simulation of the process; the relevant lemmas are the
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  analog of 4.4.1 and 4.4.3. Using these results, it we establish the noninterference result by induction on the evaluation sequence of the original program, using thefact that secure programs are race free.

5.4.1 \Theta  -equivalence for \Delta \Upsilon \Omega ff\Upsilon fi\Phi \Pi \Sigma \Upsilon 
We first define \Theta -equivalence, which indicates when two values (or substitutions) lookthe same to a

\Theta -level observer.

Definition 5.4.1 (\Theta -equivalence) Let \Theta -equivalence (written `\Phi  ) be the family of symmetric binary relations inductively defined as follows.

" For values:

0% o/ *\Delta  `fl `\Phi  `ffi ' *\Theta  ' 0% o/ ^ `\Pi  ' *\Theta  ss \Theta \Psi  \Xi  \Theta  \Upsilon  `fl \Delta  `ffi\Lambda 

" For linear values:

, *\Delta  ifl `\Phi  iffi ' ! ' , \Theta i\Pi \Lambda  \Delta  ! ss ifl \Delta  iffi

" For nonlinear substitutions: 0 *\Delta  o/fl `\Phi  o/ffi ' o/ iff

0% ! ^ o/\Pi  *\Delta  o/ ss j\Omega  \Sigma  oe\Omega o/\Theta o/ \Lambda \Pi  0% ! *\Delta  o/fl\Theta \Omega \Lambda  `\Phi  o/ffi\Theta \Omega \Lambda  ' o/ \Theta \Omega \Lambda 

" For linear substitutions: , *\Delta  1fl `\Phi  1ffi ' $ iff

, ^ 1\Pi  *\Delta  $ ss joe \Sigma  oe\Omega o/\Theta $\Lambda \Pi  , *\Delta  1fl\Theta oe\Lambda  `\Phi  1ffi\Theta oe\Lambda  ' $\Theta oe\Lambda 

Generalizing \Theta -equivalence to processes is more involved for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  than for
\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda . The problem is that because of concurrency, there can be both high-securityand low-security computations running simultaneously, so relating corresponding parts

of subprograms is more complicated. In particular, the approach used for \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda , whichrequired lock-step bisimulation for low transitions, is no longer appropriate in a concurrent setting. Rather than giving a bisimulation directly, we instead give a simulation \Xi  \Phi 

129
relation. Two programs are then \Theta -equivalent if they can both be simulated by the same
machine.The simulation relation is induced by the typing structure of a source machine configuration. Intuitively, if 0% , ^ O/ \Xi \Phi  O/\Sigma  then configuration O/\Sigma  can simulate the lowsecurity behavior of O/ while ignoring both the timing and termination behavior of thehigh-security computation in

O/.

Definition 5.4.2 (\Theta -simulation) Let \Theta -approximation, written \Xi \Phi  , be the relation (mutually) inductively defined as shown in Figures 5.19,5.20, 5.21, 5.22 and in the rules
below.

For configurations:

SIM-CONFIG

0 ^ OEfl \Xi \Phi  OEffi
0% ,fl\Upsilon  ,ffi ^ *fl \Xi \Phi  *ffi\Upsilon  ,ffi
0% !% ,ffi% ! ^ /fl \Xi \Phi  /ffi

0% ,fl\Upsilon  ,ffi ^ \Lambda OEfl\Upsilon  *fl\Upsilon  /fl\Pi  \Xi \Phi  \Lambda OEffi\Upsilon  *ffi\Upsilon  /ffi\Pi 

For processes with flffi i\Xi  \Theta :

SIM-HIGH-PROC

flffi i\Xi  \Theta  , \Theta i\Pi \Lambda  \Delta  '-*\Pi _ 0% o/ ^ -`\Pi  ' -*\Pi 

0% o/ % , % ! ssflffiae ^ fi \Xi \Phi  5\Pi  i\Pi '-`\Pi _

For processes that are well-typed with a program counter \Xi  \Theta , the \Xi \Phi  relationship
acts homomorphically on the typing rule of the term, replacing the judgment 0% o/ ^
` ' * with the equivalence rule 0% o/ ^ `fl `\Phi  `ffi ' * (and similarly for primitive
operations). For example, the simulation for conditionals is derived from the typing rule
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -IF:

SIM-IF

flffi \Xi  \Theta 
0% o/ ssflffiae ^ `fl \Xi \Phi  `ffi ' fflaeae\Theta \Theta 
0% o/ % , % ! ssflffi \Phi  \Psi ae ^ fifl\Pi  \Xi \Phi  fiffi\Pi  \Xi  \Sigma  flAE\Upsilon  OEffi

0% o/ % , % ! ssflffiae ^ \Lambda ` `fl \Pi \Delta \Phi \Xi  fiflfl \Phi \Theta ,\Phi  fiflffi \Xi \Phi  \Lambda ` `ffi \Pi \Delta \Phi \Xi  fiffifl \Phi \Theta ,\Phi  fiffiffi

The most important part of the \Xi \Phi  relation is rule SIM-HIGH-PROC . This rule saysthat any process that is well typed with a

flffi label not protected by \Theta  can be simulatedby the process that just sends a response on each of the linear channels. Intuitively,

this simulation bypasses all of the potential high-security computation performed in fiand simply returns via the linear-channel invocations. Importantly, for a high-security
process fi such that fi \Xi \Phi  fi \Sigma  the simulation fi \Sigma  always terminates, even if fi does not.
The simulation ignores the termination behavior of fi .Observe that all of the values returned from a high-security context via linear channels must themselves be high-security. (See the premise of rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -LINSEND

130
0% o/ ssflffiae ^ fl#\Xi O/fl \Xi \Phi  fl#\Xi O/ffi ' *

SIM-VAL

0% o/ *\Delta  `fl `\Phi  `ffi ' * flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda 

0% o/ ssflffiae ^ `fl \Xi \Phi  `ffi ' *

SIM-BINOP

0% o/ *\Delta  `flfl `\Phi  `flffi ' fflaeae\Theta \Theta  0% o/ *\Delta  `ffifl `\Phi  `ffiffi ' fflaeae\Theta \Theta  flffi \Xi  \Psi 

0% o/ ssflffiae ^ `flfl , `flffi \Xi \Phi  `ffifl , `ffiffi ' fflaeae\Theta \Theta 

SIM-DEREF

0% o/ *\Delta  `fl `\Phi  `ffi ' * \Omega \Phi `\Theta  flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta * \Phi  \Psi \Lambda 

0% o/ ssflffiae ^ "`fl \Xi \Phi  "`ffi ' * \Phi  \Psi 

Figure 5.19: Primitive operation simulation relation

in Figure 5.14, which uses the value rule from Figure 5.12. \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -VAL requires alower bound of

flffi for the label of the value.) Therefore, it does not matter what valuesare returned in the

\Theta -simulation because these values are not observable anyway.
Also note that if there are no linear channels in the context, SIM-HIGH-PROC says
that fi \Xi \Phi  *--the high-security process fi has no way of affecting low-security memorylocations, so from the low-security view,

fi may as well not exist.
In this setting the \Xi \Phi  relation is more fundamental and easier to work with than `\Phi  .However, two machine configurations are

\Theta -equivalent if they are both simulated by the
same configuration.

Definition 5.4.3 (\Theta -equivalence for configurations) Configurations O/fl and O/ffi are \Theta -
equivalent, written 0% , *\Delta  O/fl `\Phi  O/ffi, if and only if there exists a configuration O/
such that 0% , ^ O/fl \Xi \Phi  O/ and 0% , ^ O/ffi \Xi \Phi  O/.

To prove that \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  satisfies noninterference, we follow a similar strategy to the
proof for \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda . We first establish some basic properties of the simulation relations andshow that the simulations are faithful. Next, we prove the analogs of Lemmas 4.4.1 and

4.4.3, which show that the low-security parts of the computation are simulated correctly.
Lastly, we combine these lemmas to show that altering the high-security inputs to theprogram does not affect its low-security deterministic behavior.

Lemma 5.4.1 (Simulation preserves typing) If 0% , ^ O/ and 0% , ^ O/ \Xi \Phi  O/\Sigma 
then 0% , ^ O/\Sigma .

Proof: By induction on the derivation of 0% , ^ O/; the inductive hypothesis must
be extended to the other judgment forms. The one interesting case is SIM-HIGH-PROC,

131
0 ^ OEfl \Xi \Phi  OEffi

SIM-HEAP-EMPTY

0 ^ OE
j\Sigma  \Sigma  oe\Omega o/\Theta OE \Lambda \Pi \Delta \Theta \Lambda \Xi \Delta \Theta 0\Theta \Sigma \Lambda \Lambda  i\Xi  \Theta 
ji \Sigma  oe\Omega o/\Theta OE \Lambda \Pi \Delta \Theta \Lambda \Xi \Delta \Theta 0\Theta i\Lambda \Lambda  i\Xi  \Theta 

0 ^ OE \Xi \Phi  !

SIM-HEAP-LOC

0 ^ OEfl \Xi \Phi  OEffi 0 *\Delta  `fl `\Phi  `ffi ' 0\Theta \Sigma \Lambda 

0 ^ OEflss\Sigma  %_ `flae \Xi \Phi  OEffiss\Sigma  %_ `ffiae

SIM-HEAP-HANDLER

0 ^ OEfl \Xi \Phi  OEffi
. \Lambda \Phi \Psi  \Lambda fli\Pi  ' 0\Theta i\Pi \Lambda ffi% fl -\Omega \Pi  ' -*\Pi ffi% floe\Sigma \Phi \Omega \Pi  ' !\Sigma \Phi \Omega \Pi  ffi\Pi 
0\Theta i\Pi \Lambda  \Delta  ssflffiae\Theta -*\Pi \Upsilon  !\Sigma \Phi \Omega \Pi  \Lambda 
0% -\Omega \Pi  ' -*\Pi % !% floe\Sigma \Phi \Omega \Pi  ' !\Sigma \Phi \Omega \Pi  ffi ssflffiae ^ fifl \Xi \Phi  fiffi

0 ^ OEflss. \Theta  fiflae \Xi \Phi  OEffiss. \Theta  fiffiae

Figure 5.20: Memory simulation relation

0% ,fl ^ *fl \Xi \Phi  *ffi\Upsilon  ,ffi

SIM-S-EMPTY

0% , ^ *% , \Sigma 
jssflffi ' . \Theta  fi ae \Sigma  *\Pi flffi i\Xi  \Theta 

0% , ^ * \Xi \Phi  !\Upsilon  , \Sigma 

SIM-S-HANDLER

0% , ^ *fl \Xi \Phi  *ffi\Upsilon  ,fl
. \Lambda  \Lambda fli\Pi  ' , \Theta i\Pi \Lambda ffi% fl -\Omega \Pi  ' -*\Pi ffi\Pi 
, \Theta i\Pi \Lambda  \Delta  \Theta -*\Pi \Lambda  ,ffi ffl ,
0% -\Omega \Pi  ' -*\Pi % ,ffi% ! ssflffiae ^ fifl \Xi \Phi  fiffi

0% , ^ *flssflffi ' . \Theta  fiflae \Xi \Phi  *ffissflffi ' . \Theta  fiffiae\Upsilon  ,fl\Upsilon  ,ffi

Figure 5.21: Synchronization environment simulation relation

132
0% o/ % , % $ ^ /fl \Xi \Phi  /ffi

SIM-NET-EMPTY 0% o/ % !% ! ^ ! \Xi \Phi  !

SIM-NET-PROC

0% o/ % ,fl% $fl ^ / \Xi \Phi  / \Sigma  0% o/ % ,ffi% $ffi ssflffiae ^ fi \Xi \Phi  fi \Sigma 

0% o/ % ,fl\Upsilon  ,ffi% $fl\Upsilon  $ffi ^ / 5 ssflffi ' fi ae \Xi \Phi  / \Sigma  5 ssflffi ' fi \Sigma ae

SIM-NET-EQUIV

/fl ( /ffi 0% o/ % , % $ ^ /ffi \Xi \Phi  /* /* ( /*

0% o/ % , % $ ^ /fl \Xi \Phi  /*

Figure 5.22: Network simulation relation

which holds because each free linear channel i\Pi  mentioned in fi is used exactly once in
the simulation 5\Pi  i\Pi '-`\Pi _. \Delta 

The following lemmas show that substitution of \Theta -equivalent values preserves thesimulation relation.

Lemma 5.4.2 (\Xi \Phi  -Substitution) If 0% o/ % , % $ ssflffiae ^ fifl \Xi \Phi  fiffi and 0 *\Delta  o/fl `\Phi  o/ffi '
o/ then 0% !% , % $ ssflffiae ^ o/fl\Theta fifl\Lambda  \Xi \Phi  o/ffi\Theta fiffi\Lambda .

Proof: Easy induction on the derivation of the simulation relation. \Delta 

Lemma 5.4.3 (\Xi \Phi  -Linear-Substitution) Suppose that

0% o/ % ,fl% $ ssflffiae ^ fifl \Xi \Phi  fiffi \Omega \Phi \Lambda  0% ,ffi *\Delta  1fl `\Phi  1ffi ' $
Then it is the case that 0% o/ % ,fl\Upsilon  ,ffi% ! ssflffiae ^ 1fl\Theta fifl\Lambda  \Xi \Phi  1ffi\Theta fiffi\Lambda .
Proof: Easy induction on the derivation of the simulation relation. \Delta 

The next lemma shows that evaluation of a primitive operation in two related con-figurations yields related results.

Lemma 5.4.4 (Primitive Simulation) Suppose that

0 ^ OEfl \Xi \Phi  OEffi \Omega \Phi \Lambda  0% !ssflffiae ^ fl#\Xi O/fl \Xi \Phi  fl#\Xi O/ffi ' * \Omega \Phi \Lambda  OE\Pi \Upsilon  flffi *\Delta  fl#\Xi O/\Pi  * `\Pi 
Then it is the case that 0% !ssflffiae ^ `fl \Xi \Phi  `ffi ' *
Proof: By cases on the primitive operations involved. \Delta 

Now we establish that the simulation respects the operational semantics.

133
Lemma 5.4.5 (\Lambda -Simulation) Suppose that 0% , *\Delta  O/fl \Xi \Phi  O/ffi and O/fl \Lambda  O/\Sigma fl. Then
either O/\Sigma fl \Xi \Phi  O/ffi or there exists 0 \Sigma , , \Sigma , and O/\Sigma ffi such that O/ffi \Lambda  O/\Sigma ffi and, furthermore,
0\Sigma \Upsilon  , \Sigma  *\Delta  O/\Sigma fl \Xi \Phi  O/\Sigma ffi.

Proof: This result follows directly from the _-Simulation lemma below and the rule

SIM-NET-EQUIV. \Delta 

Because we want to show that high-security computation does not affect the lowsecurity behavior, we need a way of distinguishing the high-security transition stepsfrom the low-security ones.

Definition 5.4.4 (\Theta -low and \Theta -high evaluation steps) Let configuration O/ _ O/\Sigma  and
let ssflffi\Pi  ' fi\Pi ae be the processes reduced during the single step, i.e.

O/ ( \Lambda OE\Upsilon  *\Upsilon  / 5 5\Pi ssflffi\Pi  ' fi\Pi ae\Pi 
where / and the ssflffi\Pi  ' fi\Pi ae processes define a redex according to Figure 5.4 or Figure 5.5.

Then O/ is said to take a \Theta -low evaluation step if \Theta  \Pi flffi\Pi \Lambda  \Xi  \Theta . Otherwise, O/ is said
to take a \Theta - high evaluation step.

We next prove the analog of Lemma 4.4.1. It says that any \Theta -low evaluation stepperformed by one configuration can also be performed by its simulation.

Lemma 5.4.6 (\Theta -low simulation) If 0% , *\Delta  O/fl \Xi \Phi  O/ffi and O/fl _ O/\Sigma fl via a \Theta -low
evaluation step then there exists 0 \Sigma , , \Sigma , and O/\Sigma ffi such that O/ffi _ O/\Sigma ffi and, furthermore,
0\Sigma \Upsilon  , \Sigma  *\Delta  O/\Sigma fl \Xi \Phi  O/\Sigma ffi. Pictorially, this requirement is:

O/fl ffff

\Delta \Theta 

O/\Sigma fl

\Delta \Theta 
O/ffi ffff O/\Sigma ffi

Proof: By cases on the evaluation step taken by O/fl. Because the flffi of each processinvolved in the redex is

\Xi  \Theta , the reduced processes in O/fl are homomorphic to some
process in O/ffi. Therefore, most of the cases follow from straightforwardly unwindingthe definitions and applying either primitive simulation (Lemma 5.4.4) or one of the

substitution lemmas (Lemma 5.4.2 or 5.4.3).

The interesting cases are when the process resulting from the redex has flffi i\Xi  \Theta ,
which can occur when evaluating a conditional or invoking a nonlinear handler. A rep-resentative case considered in detail below; similar arguments holds for evaluation via

rules \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-COND2 or \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-SEND.

134
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-COND1 Then O/fl \Delta  \Lambda OEfl\Upsilon  *fl\Upsilon  /fl 5 ssflffi ' \Lambda ` \Pi \Theta  \Pi \Delta \Phi \Xi  fiflfl \Phi \Theta ,\Phi  fiflffiae\Pi .

Because flffi \Xi  \Theta , and 0% , ^ O/fl \Xi \Phi  O/ffi, we must have

O/ffi \Delta  \Lambda OEffi\Upsilon  *ffi\Upsilon  /ffi 5 ssflffi ' \Lambda ` ` \Pi \Delta \Phi \Xi  fiffifl \Phi \Theta ,\Phi  fiffiffiae\Pi 

Furthermore, O/\Sigma fl \Delta  \Lambda OEfl\Upsilon  *fl\Upsilon  /fl 5 ssflffi \Phi  \Psi  ' fiflflae\Pi . If \Psi  \Xi  \Theta , then 0% !ssflffiae ^ \Pi \Theta  \Xi \Phi 
` ' fflaeae\Theta \Theta  implies that ` \Delta  \Pi \Theta \Delta  for some \Psi \Sigma  \Xi  \Theta , but then O/ffi transitions via rule
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-COND1 to \Lambda OEffi\Upsilon  *ffi\Upsilon  /ffi 5 ssflffi \Phi  \Psi  ' fiffiflae\Pi . Because flffi \Phi  \Psi  \Xi  \Theta ,
the definition of \Xi \Phi  yields 0% !% ,fl% ! ssflffi \Phi  \Psi ae ^ fiflfl \Xi \Phi  fiffifl, so the result followsfrom S

IM-NET-PROC and SIM-CONFIG.

The other case is when \Psi  i\Xi  \Theta . It follows from SIM-IF and SIM-HIGH-PROC that

0% !% ,fl% ! ssflffi \Phi  \Psi ae ^ fio/ \Xi \Phi  5\Pi  i\Pi \Theta -`\Pi \Lambda 
for 2 \Sigma  flAE\Upsilon  OEffi. Therefore even though O/ffi may transition either via the rule
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-COND1 or via the rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-COND2, both transitionsyield the same configuration

O/\Sigma ffi \Delta  \Lambda OEffi\Upsilon  *ffi\Upsilon  /ffi 5 ssflffi \Phi  \Psi  ' 5\Pi  i\Pi '-`\Pi _ae\Pi 
In both cases, the resulting configurations satisfy 0% , ^ O/\Sigma fl \Xi \Phi  O/\Sigma ffi as required.

\Delta 
The analog of Lemma 4.4.3 says that if a configuration transitions by a \Theta -high step,then the transition can be simulated by zero or one steps. Rather than using some analog

of the linear continuation ordering lemma, the SIM-HIGH-PROC rule builds the appro-priate linear channel invocation into the simulation.

Lemma 5.4.7 (\Theta -high simulation) If 0% , *\Delta  O/fl \Xi \Phi  O/ffi and O/fl _ O/\Sigma fl via a \Theta -high
evaluation step then either O/\Sigma fl \Xi \Phi  O/ffi or there exists 0 \Sigma , , \Sigma , and O/\Sigma ffi such that O/ffi _ O/\Sigma ffi
and 0 \Sigma \Upsilon  , \Sigma  *\Delta  O/\Sigma fl \Xi \Phi  O/\Sigma ffi. Pictorially, these requirements are:

O/fl ffff

\Delta \Theta 

O/\Sigma fl

O/ffi

\Delta \Theta 

\Omega _ O/fl ffff

\Delta \Theta 

O/\Sigma fl

\Delta \Theta 
O/ffi ffff O/\Sigma ffi

Proof: By cases on the transition step. In all cases except \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-SEND
and \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-LINSEND there is only one process involved in the redex. In thosecases,

O/fl \Delta  \Lambda OEfl\Upsilon  *fl\Upsilon  /fl 5 ssflffi ' fi ae\Pi  and from the definition of SIM-NET-PROC we
have that O/ffi ( \Lambda OEfl\Upsilon  *fl\Upsilon  /ffi 5 ssflffi ' 5\Pi  i\Pi '-`\Pi _ae\Pi  where the i\Pi  are the free linear channels

135
occurring in fi . It must be the case that O/\Sigma fl \Delta  \Lambda OE \Sigma fl\Upsilon  *\Sigma fl\Upsilon  /fl 5 ssflffi ' fi \Sigma ae\Pi  for fi \Sigma  defined
according to the transition relation. Observe that because the configuration is well-typed,

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-REF and \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-ASSN imply that OE \Sigma fl and OEfl differin only locations that have label

i\Xi  \Theta . Similarly, * \Sigma fl may differ from *fl only on linear
handlers with flffi i\Xi  \Theta . Therefore, it is easy to establish that there is a 0 \Sigma  and , \Sigma  suchthat

0 \Sigma  ^ OEfl \Xi \Phi  OE \Sigma fl and 0\Sigma % , \Sigma  ^ *fl \Xi \Phi  *\Sigma fl\Upsilon  \Pi  Furthermore, subject reduction
implies that the free linear channels of fi \Sigma  are the same as the free linear channels of fi ,so

0\Sigma % !% , \Sigma % ! ssflffiae ^ fi \Sigma  \Xi \Phi  5\Pi  i\Pi '-`\Pi _ by SIM-HIGH-PROC. This is enough to establishthat

0 \Sigma % , \Sigma  ^ O/\Sigma fl \Xi \Phi  O/ffi, as required.
The case for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-SEND follows because the body of the handler is well-typed with

flffi i\Xi  \Theta . Lemma 5.4.3 implies that the body is simulated by the correspondingsends on the linear channels. Thus, as above, we have

0% , ^ O/\Sigma fl \Xi \Phi  O/ffi as needed.
Finally, consider the case for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-LINSEND. If the flffi label of the targethandler is

i\Xi  \Theta , then the result follows exactly as above. Otherwise, it is the case that
the program counter is being reset to some label \Xi  \Theta . Note that because the synchro-nization environments satisfy

0% , ^ *fl \Xi \Phi  *ffi\Upsilon  , \Sigma  it is possible for O/ffi to step via
\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-LINSEND. The resulting configuration O/\Sigma ffi satisfies 0% , \Sigma  ^ O/\Sigma fl \Xi \Phi 
O/\Sigma ffi by construction of the \Xi \Phi  relation and an application of Lemma 5.4.2. \Delta 

Lemma 5.4.8 (_-simulation) If 0% , *\Delta  O/fl \Xi \Phi  O/ffi and O/fl _ O/\Sigma fl then either O/\Sigma fl \Xi \Phi 
O/ffi or there exists 0 \Sigma , , \Sigma , and O/\Sigma ffi such that O/ffi _ O/\Sigma ffi and 0\Sigma \Upsilon  , \Sigma  *\Delta  O/\Sigma fl \Xi \Phi  O/\Sigma ffi.

Proof: Follows immediately from the \Theta -low and \Theta -high simulation lemmas. \Delta 

Next, we formally specify the determinism condition. Intuitively, we are interested
in establishing that during the evaluation of a secure program, the sequence of updatesto a particular memory location

\Sigma  is deterministic.
First we define some useful notation that makes it easier to isolate memory updates to
particular locations. For any configuration O/ \Delta  \Lambda OE\Upsilon  *\Upsilon  / \Pi  and location \Sigma  \Sigma  oe\Omega o/\Theta OE \Lambda let

O/\Theta \Sigma \Lambda  \Delta  OE \Theta \Sigma \Lambda . Two configurations that are well-typed under memory type 0 are

\Theta -equivalent at \Sigma , written O/fl \Upsilon -\Phi  O/ffi, if they agree on the value stored at location \Sigma :

O/fl \Upsilon -\Phi  O/ffi ' 0% ! ^ O/fl\Theta \Sigma \Lambda  `\Phi  O/ffi\Theta \Sigma \Lambda  ' 0\Theta \Sigma \Lambda 
Because we are interested in the determinism of writes to the low-security memorylocations, it is helpful to separate the transition relations into those that affect a particular location and those that do not. Therefore we partition the \Lambda  relation into two cases:
transition O/

\Upsilon \Lambda 

\Phi  O/\Sigma  informally says that configuration O/ writes to location \Sigma ; a transition O/

\Upsilon \Lambda 

\Phi  O/\Sigma  says that the transition does not affect location \Sigma . Formally, we define

136
these transition relations using the `\Phi  relation. Treating these relations as sets of pairs,
we have:

\Upsilon \Lambda 

\Phi 

fflij\Delta  \Lambda  O/ \Upsilon i-

\Phi 
\Upsilon \Lambda 

\Phi 

fflij\Delta  \Theta \Lambda  O/ \Upsilon -

\Phi  \Lambda OE (

Now we establish some properties relating the

\Upsilon \Lambda 

\Phi  relation to race conditions.

Lemma 5.4.9 (\Sigma -transitions write to \Sigma ) If O/fl

\Upsilon \Lambda 

\Phi  O/ffi then O/fl ( \Lambda OE\Upsilon  *\Upsilon  / 5 ssflffi '
,\Phi \Pi  \Sigma  '\Delta  ` \Lambda \Xi  fi ae\Pi .

Proof: By definition, the memory location \Sigma  must change. By inspection of theoperational semantics, we see that

O/fl must contain an assignment to location \Sigma . \Delta 

Lemma 5.4.10 (Two writes) If O/fl

\Upsilon \Lambda 

\Phi  O/ffi and O/fl

\Upsilon \Lambda 

\Phi  O/* and O/ffi

\Upsilon i-

\Phi  O/* then

O/fl ( \Lambda OE\Upsilon  *\Upsilon  / 5 ssflffi ' ,\Phi \Pi  \Sigma  '\Delta  ` \Lambda \Xi  fi ae 5 ssflffi ' ,\Phi \Pi  \Sigma  '\Delta  `\Sigma  \Lambda \Xi  fi \Sigma ae\Pi 

where 0% ! ^ ` i`\Phi  `\Sigma .
Proof: By two applications of the lemma above, we see that O/fl must contain twodistinct assignments. By inspection of the syntax and the definition of

(, the only waythis may occur is if
O/fl has the form required. \Delta 

The following lemma says that race freedom implies that there are no write-writeconflicts--the next update of any location

\Sigma  is deterministic.

Lemma 5.4.11 (Write-write race) If O/ is race free then it is not the case that there
exists O/\Sigma \Upsilon  O/fl\Upsilon  O/ffi such that O/ \Lambda \Phi  O/\Sigma  and O/\Sigma  \Lambda  O/fl and O/\Sigma  \Lambda  O/ffi and O/fl

\Upsilon i-

\Phi  O/ffi.

Proof: Note that because O/fl

\Upsilon i-

\Phi  O/ffi it must be the case that O/fl i( O/ffi. Hence thedefinition of race free implies that there exists O/

* such that O/fl \Lambda  O/* and O/ffi \Lambda  O/*.

Observe that because O/* \Upsilon -\Phi  O/* it must be the case that the transitions from O/fl and O/ffiboth assign

\Theta -equivalent values to \Sigma . Therefore, there exist `fl `\Phi  `ffi such that:

O/fl ( \Lambda OEfl\Upsilon  *fl\Upsilon  /fl 5 ssflffifl ' ,\Phi \Pi  \Sigma  '\Delta  `fl \Lambda \Xi  fiflae\Pi 
O/ffi ( \Lambda OEffi\Upsilon  *ffi\Upsilon  /ffi 5 ssflffiffi ' ,\Phi \Pi  \Sigma  '\Delta  `ffi \Lambda \Xi  fiffiae\Pi 

By applying Lemma 5.4.10 to configuration O/\Sigma , we also have that there exist `\Sigma fl i`\Phi  `\Sigma ffisuch that:

O/\Sigma  ( \Lambda OE \Sigma \Upsilon  *\Sigma \Upsilon  / \Sigma  5 ssflffi ' ,\Phi \Pi  \Sigma  '\Delta  `\Sigma fl \Lambda \Xi  )flae 5 ssflffi ' ,\Phi \Pi  \Sigma  '\Delta  `\Sigma ffi \Lambda \Xi  )ffiae\Pi 

137
Because the evaluation rule \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  -EVAL-SET involves the reduction of only one
network term, it must be the case that /fl contains the assignment ,\Phi \Pi  \Sigma  '\Delta  `\Sigma ffi \Lambda \Xi  )ffiand

/ffi contains the assignment ,\Phi \Pi  \Sigma  '\Delta  `\Sigma fl \Lambda \Xi  )fl. It follows that /fl i( /ffi becausethey both evolved from the same configuration. But this yields a contradiction, because

O/* ( \Lambda OE*\Upsilon  **\Upsilon  /fl 5 fifl\Pi  and O/* ( \Lambda OE*\Upsilon  **\Upsilon  /ffi 5 fiffi\Pi , which is impossible when
/fl i( /ffi (even if fifl ( fiffi). \Delta 

Next we establish two key technical lemmas that show how

\Upsilon \Lambda 

\Phi  and

\Upsilon \Lambda 

\Phi  transitionsinteract.

Lemma 5.4.12 (\Sigma -\Sigma  square) Suppose that O/

\Upsilon \Lambda 

\Phi  O/fl and O/

\Upsilon \Lambda 

\Phi  O/ffi with O/fl i( O/ffi.

If there exists O/* such that O/fl \Lambda  O/* and O/ffi \Lambda  O/* then O/fl

\Upsilon \Lambda 

\Phi  O/* and O/ffi

\Upsilon \Lambda 

\Phi  O/*.Pictorially, this situation is:

O/

\Xi \Theta 

\Theta 

\Xi \Theta 

\Theta  O/fl

\Theta \Psi \Omega 

O/ffi \Theta  O/*

\Upsilon 

O/

\Xi \Theta 

\Theta 

\Xi \Theta 

\Theta  O/fl

\Xi \Theta 

\Theta 

O/ffi \Xi \Theta \Theta  O/*

Proof: Because O/fl i( O/ffi, the configurations must differ in some respect. Note that
since O/ \Upsilon -\Phi  O/ and O/fl and O/ffi are reached from O/ by a transition that does not affect
location \Sigma , it must be the case that O/ \Upsilon -\Phi  O/fl and O/ \Upsilon -\Phi  O/ffi. It is not possible that

O/fl

\Upsilon \Lambda 

\Phi  O/* and O/ffi

\Upsilon \Lambda 

\Phi  O/* because then, by definition of

\Upsilon \Lambda 

\Phi  and

\Upsilon \Lambda 

\Phi  , we would havethis contradiction:

O/ \Upsilon -\Phi  O/fl

\Upsilon i-

\Phi  O/*

\Upsilon -

\Phi  O/ffi

\Upsilon -

\Phi  O/

Similarly, it is not possible that O/fl

\Upsilon \Lambda 

\Phi  O/* and O/ffi

\Upsilon \Lambda 

\Phi  O/*. Finally, reasoning similar

to that used in Lemma 5.4.11 shows that O/fl

\Upsilon \Lambda 

\Phi  O/\Sigma * and O/ffi

\Upsilon \Lambda 

\Phi  O/\Sigma \Sigma * implies O/\Sigma * i( O/\Sigma \Sigma *.

Therefore, the only remaining possibility is for O/fl

\Upsilon \Lambda 

\Phi  O/* and O/ffi

\Upsilon \Lambda 

\Phi  O/*, as required.

\Delta 

Lemma 5.4.13 (\Sigma -\Sigma  square) Suppose that O/

\Upsilon \Lambda 

\Phi  O/fl and O/

\Upsilon \Lambda 

\Phi  O/ffi with O/fl i( O/ffi.

If there exists O/* such that O/fl \Lambda  O/* and O/ffi \Lambda  O/* then O/fl

\Upsilon \Lambda 

\Phi  O/* and O/ffi

\Upsilon \Lambda 

\Phi  O/*.Pictorially, this situation is:

O/

\Xi \Theta 

\Theta 

\Xi \Theta 

\Theta  O/fl

\Theta \Psi \Omega 

O/ffi \Theta  O/*

\Upsilon 

O/

\Xi \Theta 

\Theta 

\Xi \Theta 

\Theta  O/fl

\Xi \Theta 

\Theta 

O/ffi \Xi \Theta \Theta  O/*

138
Proof: This proof is similar to that of 5.4.12, so we sketch it only briefly. Note that
by definition O/

\Upsilon i-

\Phi  O/fl and O/

\Upsilon -

\Phi  O/ffi. Therefore, to reach a common O/*, at least oneof

O/fl and O/ffi must perform a write to \Sigma . It can't be O/fl because then reasoning similarto that in 5.4.11 yields a contradiction. Therefore

O/ffi must perform a write to \Sigma . \Delta 

Lemma 5.4.14 If O/`_AE_' is race free and

O/`_AE_' \Theta 

\Upsilon \Lambda 

\Phi  \Lambda \Pi  O/`\Pi AE_'

\Upsilon \Lambda 

\Phi  O/`\Pi ^flAE_'

and O/`_AE_'

\Upsilon \Lambda 

\Phi  O/`_AEfl' then there exists a sequence of configurations O/`o/AEfl' for &  2 

\Xi  ffi AE such that for all &  ! 3 \Xi  either O/`OEAEfl' ( O/`OE^flAEfl' or O/`OEAEfl'

\Upsilon \Lambda 

\Phi  O/`OE^flAEfl' and

O/`\Pi AEfl'

\Upsilon \Lambda 

\Phi  O/`\Pi ^flAEfl', where O/`\Pi ^flAEfl'

\Upsilon -

\Phi  O/\Theta \Xi  ffi AE\Upsilon  &\Lambda . Pictorially, this lemma says that thefollowing diagram:

O/`_AE_'

\Xi \Theta 

\Theta 

\Xi \Theta 

\Theta  O/`flAE_' `

\Xi \Theta 

\Theta '\Sigma \Lambda 

\Lambda \Delta \Upsilon  O/`\Pi AE_' \Xi \Theta \Theta  O/`\Pi ^flAE_'

O/`_AEfl'
can be completed to a diagram or the form:

O/`_AE_'

\Xi \Theta 

\Theta 

\Xi \Theta 

\Theta  O/`flAE_' `

\Xi \Theta 

\Theta '\Sigma \Lambda 

\Lambda \Delta \Upsilon 

\Xi \Theta 

\Theta 

O/`\Pi AE_' \Xi \Theta 

\Theta 

\Xi \Theta 

\Theta 

O/`\Pi ^flAE_'

\Xi \Theta 

\Theta 

O/`_AEfl' \Xi \Theta 

\Theta  O/`flAEfl' `

\Xi \Theta 

\Theta '\Sigma \Lambda 

\Lambda \Delta \Upsilon  O/`\Pi AEfl' \Xi \Theta \Theta  O/`\Pi ^flAEfl'

Proof: By induction on \Xi . The base case, for \Xi  \Delta  & follows directly from Lemma 5.4.13.
The induction step follows because O/`_AE_' is race free, using Lemma 5.4.12 to complete
the first square in the diagram. \Delta 

The following lemma is crucial to establishing the determinism of secure programs.
Lemma 5.4.15 (Race freedom implies determinism) Suppose that both

O/`_AE_' \Theta 

\Upsilon \Lambda 

\Phi  \Lambda \Pi  O/`\Pi AE_'

\Upsilon \Lambda 

\Phi  O/`\Pi ^flAE_'

and

O/`_AE_' \Theta 

\Upsilon \Lambda 

\Phi  \Lambda o/ O/`_AEo/'

\Upsilon \Lambda 

\Phi  O/`_AEo/^fl'

then O/`\Pi ^flAE_' \Upsilon -\Phi  O/`_AEo/^fl'.

139
Proof: By induction on \Theta \Xi \Upsilon  2\Lambda . For the base case, \Theta \Xi \Upsilon  2\Lambda  \Delta  \Theta &\Upsilon  &\Lambda  we have the following
diagram:

O/`_AE_'

\Xi \Theta 

\Theta 

\Xi \Theta 

\Theta  O/`flAE_'

O/`_AEfl'
Applying Lemma 5.4.11, we obtain O/`flAE_' \Upsilon -\Phi  O/`_AEfl' as desired.

For the induction step, we have \Xi  4 & or 2 4 &. Without loss of generality, assume
that \Xi  4 & (the case for 2 4 & is symmetric). In the case that 2 \Delta  & we have the followingdiagram:

O/`_AE_'

\Xi \Theta 

\Theta 

\Xi \Theta 

\Theta  O/`flAE_' `

\Xi \Theta 

\Theta '\Sigma \Lambda 

\Lambda \Delta \Upsilon  O/`\Pi AE_' \Xi \Theta \Theta  O/`\Pi ^flAE_'

O/`_AEfl'
It must be the case that O/`flAE_'

\Upsilon i-

\Phi  O/`_AEfl', which implies that O/`flAE_' i( O/`_AEfl'. Therefore,because O/
`_AE_' is race free, there must exist a configuration O/`flAEfl' such that O/`flAE_' \Lambda 
O/`flAEfl' and O/`_AEfl' \Lambda  O/`AE\Upsilon  AE\Lambda . So, by Lemma 5.4.13 we can complete the diagram above

to:

O/`_AE_'

\Xi \Theta 

\Theta 

\Xi \Theta 

\Theta  O/`flAE_' `

\Xi \Theta 

\Theta '\Sigma \Lambda 

\Lambda \Delta \Upsilon 

\Xi \Theta 

\Theta 

O/`\Pi AE_' \Xi \Theta \Theta  O/`\Pi ^flAE_'

O/`_AEfl' \Xi \Theta 

\Theta  O/`flAEfl'

Note that O/`_AEfl' \Upsilon -\Phi  O/`flAEfl'. Finally, the induction hypothesis applies to the configuration
O/`flAE_' because it is race free. Therefore, we obtain O/`_AEfl' \Upsilon -\Phi  O/`flAEfl' \Upsilon -\Phi  O/`\Pi ^flAE_' asrequired.

Now suppose that 2 4 &. Then we have the following diagram:

O/`_AE_'

\Xi \Theta 

\Theta 

\Xi \Theta 

\Theta  O/`flAE_' `

\Xi \Theta 

\Theta '\Sigma \Lambda 

\Lambda \Delta \Upsilon  O/`\Pi AE_' \Xi \Theta \Theta  O/`\Pi ^flAE_'

O/`_AEfl'
`

\Xi \Theta 

\Theta '\Sigma \Pi 

\Lambda \Delta \Upsilon 

O/`_AEo/'

\Xi \Theta 

\Theta 

O/`_AEo/^fl'

140
By Lemma 5.4.14 we can complete the diagram above to:

O/`_AE_'

\Xi \Theta 

\Theta 

\Xi \Theta 

\Theta  O/`flAE_' `

\Xi \Theta 

\Theta '\Sigma \Lambda 

\Lambda \Delta \Upsilon 

\Xi \Theta 

\Theta 

O/`\Pi AE_' \Xi \Theta 

\Theta  O/`\Pi ^flAE_'

O/`_AEfl'
`

\Xi \Theta 

\Theta '\Sigma \Pi 

\Lambda \Delta \Upsilon 

\Xi \Theta 

\Theta  O/`flAEfl'

`

\Xi \Theta 

\Theta '\Sigma \Pi 

\Lambda \Delta \Upsilon 

O/`_AEo/'

\Xi \Theta 

\Theta 

\Xi \Theta 

\Theta  O/`flAEo/'

\Xi \Theta 

\Theta 

O/`_AEo/^fl' \Xi \Theta 

\Theta  O/`flAEo/^fl'

Note that O/`_AEo/^fl' \Upsilon -\Phi  O/`flAEo/^fl' and that O/`flAE_' is race free. Therefore, we use the induction hypothesis applied to O/`flAE_' to obtain that O/`flAEo/^fl' \Upsilon -\Phi  O/`\Pi ^flAE_' from which we
conclude O/`_AEo/^fl' \Upsilon -\Phi  O/`\Pi ^flAE_' as needed.

\Delta 

The following lemma says that starting from a configuration with an open network
and closing the network under similar substitutions yields `\Phi  configurations. It lets usestablish that two programs that differ only in their high-security inputs can be simulated

by the same low-simulation. The noninterference theorem, proved next, uses the shared
simulation, together with the race-freedom requirement to show that related programsupdate memory deterministically and identically.

Lemma 5.4.16 (Simulations and High-substitution) Suppose the following:

" 0 ^ OE
" 0% ,fl\Upsilon  ,ffi ^ *% ,fl
" 0% o/ % ,ffi% ! ^ /
" 0 *\Delta  o/fl `\Phi  o/ffi ' o/
" j\Omega  \Sigma  oe\Omega o/\Theta o/ \Lambda \Pi  \Delta \Theta \Lambda \Xi \Delta \Theta o/ \Theta \Omega \Lambda \Lambda  i\Xi  \Theta 
then for any configuration O/, 0% , *\Delta  \Lambda OE\Upsilon  *\Upsilon  o/fl\Theta / \Lambda \Pi  \Xi \Phi  O/ implies that 0% , *\Delta 
\Lambda OE\Upsilon  *\Upsilon  o/ffi\Theta / \Lambda \Pi  \Xi \Phi  O/.

Proof: By an easy induction on the typing derivation for network / . The base case forvalues follows from rule S

IM-VAL and the requirement that \Delta \Theta \Lambda \Xi \Delta \Theta o/ \Theta \Omega \Lambda \Lambda  i\Xi  \Theta . The case
for primitive operations follows from the fact that if the primitive operation involves a

141
variable in o/ , then its result is i\Xi  \Theta . The inductive cases follow from the construction of
the \Xi \Phi  relation. \Delta 

Finally, we can prove noninterference for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  .

Theorem 5.4.2 (Noninterference for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  ) Let \Theta  be an arbitrary label in the security lattice. Suppose that 0% \Omega  ' *% !% ! ^ / is derivable. Let an initial memory OE be
given such that 0 ^ OE and suppose that whenever 0% ! ^ \Lambda OE\Upsilon  !\Upsilon  / \Pi  \Xi \Phi  O/ the simulation O/ is race free. Let location \Sigma  \Sigma  oe\Omega o/\Theta 0\Lambda  be given such that \Delta \Theta \Lambda \Xi \Delta \Theta 0\Theta \Sigma \Lambda \Lambda  \Xi  \Theta .
Further suppose that \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda  i\Xi  \Theta . Then for any two values `fl and `ffi such that
0% ! ^ `\Pi  ' * the sequence of values stored in memory location \Sigma  during the evaluation of
\Lambda OE\Upsilon  !\Upsilon  / fl`flae\Omega ffi\Pi  is a prefix of the sequence of values stored in \Sigma  by \Lambda OE\Upsilon  !\Upsilon  / fl`ffiae\Omega ffi\Pi 
(or vice-versa).

Proof: Let O/`flAE_' \Delta  \Lambda OE\Upsilon  !\Upsilon  / fl`flae\Omega ffi\Pi  and O/`ffiAE_' \Delta  \Lambda OE\Upsilon  !\Upsilon  / fl`ffiae\Omega ffi\Pi . Note thatby Lemma 5.4.16 there exists a configuration

O/\Sigma  such that 0% ! ^ O/fl \Xi \Phi  O/\Sigma  and
0% ! ^ O/ffi \Xi \Phi  O/\Sigma . Furthermore, note that O/\Sigma  must be race free. Suppose, for the sakeof contradiction, that the evaluations disagree on the

' ffi AEffi update to the location \Sigma .
We derive a contradiction by induction on '. For the base case, ' \Delta  & and theremust exist evaluation sequences:

O/`flAE_' \Theta 

\Upsilon \Lambda 

\Phi  \Lambda \Pi  O/`flAE\Pi '

\Upsilon \Lambda 

\Phi  O/`flAE\Pi ^fl'

O/`ffiAE_' \Theta 

\Upsilon \Lambda 

\Phi  \Lambda o/ O/`ffiAE\Pi '

\Upsilon \Lambda 

\Phi  O/`ffiAEo/^fl'

where O/`flAE\Pi ^fl'

\Upsilon i-

\Phi  O/`ffiAEo/^fl'. However, by induction on the lengths of these sequencesapplying Lemma 5.4.5, we obtain the following simulations:

O/\Sigma  ( O/\Sigma `flAE_' \Theta 

\Upsilon \Lambda 

\Phi  \Lambda \Pi  O/\Sigma `flAE\Pi '

\Upsilon \Lambda 

\Phi  O/\Sigma `flAE\Pi ^fl'

O/\Sigma  ( O/\Sigma `ffiAE_' \Theta 

\Upsilon \Lambda 

\Phi  \Lambda o/ O/\Sigma `ffiAE\Pi '

\Upsilon \Lambda 

\Phi  O/\Sigma `ffiAEo/^fl'

Because the location \Sigma  is visible at \Theta , it must be that O/`flAE\Pi ^fl' \Upsilon -\Phi  O/\Sigma `flAE\Pi ^fl' and
O/`ffiAEo/^fl' \Upsilon -\Phi  O/\Sigma `ffiAEo/^fl'. We may also apply Lemma 5.4.15 to conclude that O/\Sigma `flAE\Pi ^fl' \Upsilon -\Phi 
O/\Sigma `ffiAEo/^fl', but that is a contradiction.

The inductive step follows similarly to the inductive step of Lemma 5.4.5. \Delta 

142
5.5 Related work
A few researchers have investigated noninterference-based type systems for concurrentlanguages and process calculi. Smith and Volpano have studied multithreaded programs, although they assumed a fixed number of threads and a uniform thread scheduler
[SV98]. Their subsequent work refines the original type system to account for prob-abilistic thread scheduling and to relax the constraints due to timing channels [SV00,

VS00, Smi01].

Roscoe [Ros95] was the first to propose a determinism-based definition of noninter-ference for labeled-transition systems. This approach has not been used previously in

type systems for programming languages.

Focardi and Gorrieri [FG97] have implemented a flow-checker for a variant of Mil-ner's calculus of concurrent systems (CCS). Honda, Vasoncelos, and Yoshida have proposed a similar system for the (-calculus in which they can faithfully encode Smith and
Volpano's language [HVY00, HY02]. Their work relies on a sophisticated type sys-tem that distinguishes between linear channels, affine channels, and nonlinear channels

while also tracking information about stateful computations. Both of these approachesuse techniques of bisimulation to prove noninterference properties. A similar approach
is taken by Abadi and Gordon to prove the correctness of cryptographic protocols in the
Secure Pi Calculus [AG99], but the security policies they enforce are not information-flow policies.

Hennessy and Riely consider information-flow properties in the asynchronous picalculus [Hen00, HR00]. Their may-testing definition of noninterference is quite sim-ilar to the definition used here, because it is timing and termination insensitive. However, their language does not support synchronous communication or refinement of the
information-flow analysis via linearity constraints.

Pottier [Pot02] gives an elementary proof of noninterference for a variant of thepi-calculus, but its type system is quite restrictive because it does not make a distinction between linear and nonlinear channel usage. Pottier observes that bisimulation-based definitions of noninterference give stronger security guarantees than those based
on may-testing (i.e. [Hen00]) in the presence of race conditions. However, as describedin this thesis, it is not clear that permitting races is desirable, so the additional constraints
imposed by a type system that permits races may not be warranted.

Sabelfeld and Sands have considered concurrent languages in a probabilistic setting[SS00]. They use a novel probabilistic bisimulation approach to specify noninterference

properties, and have used the techniques to prove correct Agat's program transformation
for eliminating timing channels [Aga00]. Mantel and Sabelfeld have also consideredtype systems for multithreaded secure languages [MS01].

Reitman was among the earliest to consider message-passing primitives and their
impact on information flows [Rei78]. However, there were no correctness proofs es143
tablished for his security logic. Ban^atre, Bryce, and Le Met'ayer [BBL84] give a static
analysis for discovering information flows in a nondeterministic language, but their ap-proach appears to be unsound (see the discussion in [VSI96]).

The design of \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  was inspired by concurrent process calculi such as the pi
calculus [MPW92] and especially the join calculus [FG96].Chapter 6

Downgrading
Security properties based on information flow, such as the noninterference policy considered to this point in this thesis, provide strong guarantees that confidentiality andintegrity are maintained. However, programs often need to leak some amount of confidential information in order to serve their intended purpose. Consider these examples:

" A secure e-mail reader might release encrypted confidential mail.
" The password-checking function of an operating system operates on confidentialpasswords, but granting or denying access leaks some information about the correct password.
" An on-line auction program might release the value of the winning bid after all

secret bids have been made.

Similarly, programs often need to assert the integrity of a piece of data. For instance,
after verifying a check sum or a digital signature a program might wish to consider apiece of data to be more trustworthy.

Consequently, realistic systems include a means of downgrading--allowing the se-curity label of the data to be shifted downwards in the security lattice. For confidentiality, this process is called declassification; for integrity, it is called endorsement. Theability to escape from the strict confines of noninterference is both essential and dangerous: unregulated use of downgrading can easily result in unexpected release of con-fidential information or in corruption of supposedly trustworthy data.

To see the problem, first consider the simplest way to add a declassification operationto a security-typed language. We extend the syntax:

, ''\Delta  \Pi  \Pi  \Pi  * \Theta \Phi \Pi  \Omega  \Delta  O/\Phi \Psi \Theta ,,\Lambda `o/'`\Upsilon  \Psi _\Lambda \Xi  ,

144

145
and add the following typing judgment

BAD-DECLASSIFY

O/ ^ ` ' *\Theta \Delta  o/ \Upsilon  \Omega  ' *\Theta  ssflffiae ^ ,
o/ ssflffiae ^ \Theta \Phi \Pi  \Omega  \Delta  O/\Phi \Psi \Theta ,,\Lambda `o/'`\Upsilon  \Psi _\Lambda \Xi  ,

This judgment says that a value ` with an arbitrary label can be given any other arbitrarylabel by declassification. This clearly breaks noninterference because high-security data

can now be made low-security. Declassification is intended for this purpose, but this
rule is too permissive--it can be used at any point to release confidential information.Consequently, adding such a rule to the languages studied in this thesis completely invalidates their noninterference theorems. We get no guarantees about the security of
programs that use declassification, and the program may as well have been written with-out security types.

Because it is potentially dangerous, downgrading should only be used in certain,well-defined ways. One could imagine generalizing information-flow security policies
to include specifications of exactly under what circumstances declassification or endorsement may occur. The problem with such an approach is that establishing that agiven program meets the specifications of the security policy can be extremely difficult:

It is the problem of proving that a program meets an arbitrary specification. Moreover,even stating these formal specifications of security policies is hard.

The noninterference policies specified using the lattice model for labels approximate
the information flows in the program to avoid the difficulty of doing full-scale programverification. The next section describes Myers' and Liskov's

decentralized label model,a particular security lattice designed to help govern the use of declassification operations. It avoids the full verification problem by introducing the notion of authority,which allows coarse-grained control over where declassifications may be used.

There is still a problem with regulating downgrading, even with the authority model.The last section of this chapter describes the problem and proposes a solution in which
downgrading operations tie together integrity and confidentiality constraints.

6.1 The decentralized label model
The decentralized label model (DLM) proposed by Myers and Liskov [ML00] addsadditional structure to the security lattice in order to regulate how declassification is
used by a program.Central to the model is the notion of a

principal, which is an entity (e.g., user, pro-cess, party) that can have a confidentiality or integrity concern with respect to data.

Principals can be named in information-flow policies and are also used to define the
authority possessed by the running program. The authority & at a point in the program
is a set of principals that are assumed to authorize any action taken by the program at

146
that point--in particular, principals may authorize declassifications of data. Different
program points may have different authority, which must be explicitly granted by theprincipals in question.

A simple confidentiality label in this model is written \Sigma aei\Omega fl:\Omega ffi:(((:\Omega \Delta ff, meaning
that the labeled data is owned by principal ae, and that ae permits the data to be read byprincipals

\Omega fl through \Omega \Delta  (and, implicitly, ae).
Data may have multiple owners, each controlling a different component of its label.For example, the label

\Sigma aefli\Omega fl:\Omega ffifi aeffii\Omega fl:\Omega *ff, contains two components and says that
owner aefl allows readers \Omega fl and \Omega ffi and owner aeffi allows readers \Omega fl and \Omega *. The interpre-tation is that

all of the policies described by a label must be obeyed, only \Omega fl will be able
to read data with this annotation. Such composite labels arise naturally in collaborativecomputations: for example, if

AE has label \Sigma aefli\Omega fl:\Omega ffiff and o/ has label \Sigma aeffii\Omega fl:\Omega *ff, thenthe sum
AE " o/ has the composite label \Lambda \Xi \Pi \Sigma aefli\Omega fl:\Omega ffifi aeffii\Omega fl:\Omega *ff, which expresses the
conservative requirement that the sum is subject to both the policy on AE and the policyon

o/.

In the lattice, \Psi fl \Xi  \Psi ffi if the label \Psi fl is less restrictive than the label \Psi ffi. Intuitively, data
with label \Psi fl is less confidential than data with label \Psi ffi--more principals are permittedto see the data, and, consequently, there are fewer restrictions on how data with label

\Psi flmay be used. For example,
\Sigma aei\Omega ff \Xi  \Sigma aeiff holds because the left label allows both ae
and \Omega  to read the data, whereas the right label admits only ae as a reader.

The formal definition of \Xi  for the decentralized label model is given in Myers' the-sis [Mye99]. His thesis also shows that the relation

\Xi  is a pre-order whose equivalence
classes form a distributive lattice. The label join operation combines the restrictionson how data may be used. As an example, if

AE has label \Sigma aei\Omega fl:\Omega ffiff and o/ has label
\Sigma aei\Omega fl:\Omega *ff, the sum AE " o/ has label \Sigma aei\Omega flff, which includes the restrictions of both.

In this thesis, the decentralized label model is extended with label components thatspecify simple integrity constraints. The label

\Sigma ?i&fl:(((:&\Delta ff specifies that principals
&fl through &\Delta  trust the data--they believe the data to be computed by the program as
written. (Because integrity policies have no owner, a question mark is used in its place.)Note that the integrity label

\Sigma ?iff specifies a piece of data trusted by no principals; it is
the label of completely untrusted data.

This is a weak notion of trust; its purpose is to protect security-critical informa-tion from damage by subverted hosts. Labels combining integrity and confidentiality

components also arise naturally.

For any DLM label \Psi , the functions 5\Theta \Psi \Lambda  and 6\Theta \Psi \Lambda  extract the confidentiality andintegrity parts of

7, respectively. Because confidentiality and integrity are duals (see thediscussion in Section 2.1), if

\Psi fl \Xi  \Psi ffi, then \Psi ffi must specify at least as much confidentiality and at most as much integrity as \Psi fl. This interpretation is consistent with the ideathat labels represent restrictions on how data may be used; data with higher integrity has

fewer restrictions on its use.

147
To emphasize that security labels are drawn from the decentralized label model, as
opposed to some unspecified lattice, we shall sometimes refer to them as DLM labels.

We can now consider how the concept of authority helps control declassification in
the decentralized label model. Consider the expression O/\Phi \Psi \Theta ,,\Lambda `o/'\Phi : \Psi _. It allowsa program acting with sufficient authority to declassify the expression

\Phi  to label \Psi . Aprincipal
&'s authority is needed to perform declassifications of data owned by &. For
example, owner ae can add a reader \Omega  to a piece of data AE by declassifying its label from
\Sigma aeiff to \Sigma aei\Omega ff using the expression O/\Phi \Psi \Theta ,,\Lambda `o/'AE: \Sigma aei\Omega ff_.

The rule for declassification in the decentralized label model is:

DLM-DECLASSIFY

&\Upsilon  O/ ^ ` ' *\Theta \Delta  &\Upsilon  o/ \Upsilon  \Omega  ' *\Theta  ssflffiae ^ , \Theta \Sigma i^\Theta \Psi \Upsilon  \Psi \Sigma \Lambda  ffl &

&\Upsilon  o/ ssflffiae ^ \Theta \Phi \Pi  \Omega  \Delta  O/\Phi \Psi \Theta ,,\Lambda `o/'`\Upsilon  \Psi _\Lambda \Xi  ,

Here, the function \Theta \Sigma i^\Theta \Psi \Upsilon  \Psi \Sigma \Lambda  returns the set of principals whose policies are weakenedby moving from label

\Psi \Sigma  down to label \Psi  in the lattice. For example:

\Theta \Sigma i^\Theta \Sigma aeiff\Upsilon  \Sigma aei\Omega ff\Lambda  \Delta  flaeffi
The authority & is a set of principals associated with this point of the program, and isintroduced at function boundaries. Therefore, the typing rule for functions is:

DLM-FUN

&\Sigma \Upsilon  o/ \Upsilon  \Omega  ' *\Sigma  ssflffi\Sigma ae ^ , ' *
&\Upsilon  o/ ssflffiae ^ \Delta ss&\Sigma \Upsilon  flffi\Sigma ae\Theta \Omega  ' *\Sigma \Lambda \Pi  , ' ss&\Sigma \Upsilon  flffi\Sigma ae*\Sigma  _ *

The function type ss&\Upsilon  flffi\Sigma ae*\Sigma  _ * indicates that the function has authority & and so mayperform declassifications on behalf of the principals in

&. The programmer can delimit
where declassifications may take place by constraining the authority available to a givenfunction.

The caller of a function must establish that it has the authority necessary to carry outany of the declassifications that might occur inside the function call. This requirement
is reflected in the function application rule:

DLM-APP

&\Upsilon  o/ ssflffiae ^ , ' ss&\Sigma \Upsilon  flffi\Sigma ae*\Sigma  _ *
&\Upsilon  o/ \Upsilon  ssflffiae ^ ,\Sigma  ' *\Sigma 
&\Sigma  ffl & flffi \Xi  flffi\Sigma 

&\Sigma \Upsilon  o/ ssflffiae ^ , ,\Sigma  ' *

6.2 Robust declassification
Despite the increased control of downgrading offered by the decentralized label model,there is a weakness in its simple, authority-based approach. The problem is illustrated
in Figure 6.1.

148
\Lambda \Xi \Pi \Sigma \Omega aeae\Pi iff ,\Phi \Psi \Omega \Phi \Pi  j (((fi ?? \Psi aeOE&ffi\Pi \Phi  \Pi \Delta \Phi  ,\Phi \Psi \Omega \Phi \Pi 
\Theta \Phi \Pi  \Psi \Delta \Phi \Psi . j \Delta *\Sigma \Omega aeae\Pi ff:ff+'AEi\Lambda \Xi \Pi \Sigma ?iff_(

\Lambda ` AE \Pi \Delta \Phi \Xi  &\Omega \Lambda \Xi \Pi 'O/\Phi \Psi \Theta ,,\Lambda `o/',\Phi \Psi \Omega \Phi \Pi : \Sigma ff__fi

\Phi \Theta ,\Phi  ,.\Lambda &fi
\Lambda \Xi \Pi  AE\Sigma ?iff j @\Phi \Pi /ae\Omega .(\Omega \Phi O/'_fi

\Psi \Delta \Phi \Psi .'AE_

Figure 6.1: The need for robust declassification

The program in the figure contains a function named \Psi \Delta \Phi \Psi . that tests its argument AE
and uses its value to decide whether to release the secret, using the authority of the prin-cipal

\Omega aeae\Pi . Note that the privacy component of the label is declassified from \Sigma \Omega aeae\Pi iff
to \Sigma ff--the most public DLM label. The problem is that the value AE, used to regulatethe declassification, is completely untrusted by the

\Omega aeae\Pi  principal. This situation isexacerbated in the distributed setting discussed in the next section, because the computation that determines whether declassification should take place (the \Lambda ` AE part) canpotentially reside on a different host than the actual declassification itself.

Rather than give authority to the entire function body, it seems more natural to associate the required authority with the decision to perform the declassification. Theprogram counter at the point of a

O/\Phi \Psi \Theta ,,\Lambda `o/ expression is already a model of the in-formation used to reach the declassification. Therefore, to enforce that the decision to

do the declassification is sufficiently trusted, we simply require that the program counterhave high enough integrity.

These intuitions are captured in the following rule for declassification:

ROBUST-DECLASSIFY

O/ ^ ` ' *\Theta \Delta  o/ \Upsilon  \Omega  ' *\Theta  ssflffiae ^ , 6\Theta flffi\Lambda  \Xi  \Sigma ?i\Theta \Sigma i^\Theta \Psi \Upsilon  \Psi \Sigma \Lambda ff

o/ ssflffiae ^ \Theta \Phi \Pi  \Omega  \Delta  O/\Phi \Psi \Theta ,,\Lambda `o/'`\Upsilon  \Psi _\Lambda \Xi  ,

This approach equates the authority of a piece of code with the integrity of the pro-gram counter at the start of the code, simultaneously simplifying the typing rules--no
authority context & is needed--and strengthening the restrictions on where declassification is permitted. This version of declassification rules out the program in Figure 6.1.

The benefit of tying downgrading to integrity is that the noninterference proofs givenfor the security-typed language say something meaningful for programs that include

declassification. Note that the declassification operation does not change the integrityof the data being declassified. Projecting the noninterference result onto the integrity
sublattice yields the following lemma as a corollary.

149
Lemma 6.2.1 (Robust Declassification) Suppose that \Omega  ' *ssffae ^ , ' *\Sigma  and the integrity
labels satisfy 6\Theta \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda \Lambda  i\Xi  6\Theta \Delta \Theta \Lambda \Xi \Delta \Theta *\Sigma \Lambda \Lambda . Then for any values `fl and `ffi such that ^ `\Pi  ' *
it is the case that ,fl`flae\Omega ffi * ` ' ,fl`ffiae\Omega ffi * `.

This lemma holds regardless of whether , contains declassification operations. Itis a weak guarantee: Intuitively, low-integrity data cannot interfere with what data is

declassified. This lemma does not say anything about what high-security information
might be declassified. Nevertheless, it is better than giving up all security propertieswhen declassifications are used.

One could generalize robust declassification by associating with each distinct declas-sification expression in the program a separate principal

j and requiring that 6\Theta flffi\Lambda  \Xi 
\Sigma ?iO/ff in the declassification typing judgment. This constraint allows the programmer
to name particular declassifications in security policies so that, for instance a value withintegrity label

\Sigma ?iO/fl: O/ffiff could possibly be declassified at points O/fl and O/ffi but not ata declassification associated with point

O/* in the program.
Whether such a generalization would be useful in practice, and how to preciselycharacterize the confidentiality properties of the resulting programs remains for future

work.

6.3 Related work
The simplest and most standard approach to declassification is to restrict its uses tothose performed by a trusted subject, similar to the DLM requirement that a function
possess the proper authority. This approach does not address the question of whetheran information channel is created. Many systems have incorporated a more limited
form of declassification. Ferrari et. al [FSBJ97] augment information flow controls in
an object-oriented system with a form of dynamically-checked declassification called
waivers. However, these efforts provide only limited characterization of the safety ofthe declassification process.

The interplay between authority and declassification is similar to Java's stack in-spection security model [WF98, WAF00, FG02]. In Java, privileged operations (like
declassification) can require that they be invoked only in the context of some authoriza-tion clause, and, that, dynamically, no untrusted methods are between the authorization
and the use of the privileged operation on the call stack. These constraints on the runtime stack are similar to the authority constraints used in the decentralized label model,but weaker than the robust declassification mechanism proposed here. The difference

is that the stack-inspection approach does not track the integrity of data returned by an
untrusted piece of code, so untrusted data might still influence privileged operations.Using untrusted data to regulate privileged operations is related to an extremely common bug found in the C libraries. The string formatting utilities assume that strings are

150
properly delimited and do not check their bounds. Programs that use the libraries without the appropriate checks are vulnerable to attacks that occur when strings are read froman untrusted source such as the network. The analysis that is able to find such format

string vulnerabilities in C [STFW01] is quite similar to an integrity-only informationflow analysis.

Intransitive noninterference policies [Rus92, Pin95, RG99] generalize noninterference to describe systems that contain restricted downgrading mechanisms. The work byBevier et al. on

controlled interference [BCY95] is most similar to this work in allowingthe specification of policies for information released to a set of

agents. The idea of robust declassification has been formalized in an abstract, state-machine model [ZM01a].

Chapter 7
Distribution and Heterogeneous Trust
So far, the security-typed languages in this thesis have addressed information-flow se-curity in systems executed on a single, trusted host. This assumption is unrealistic,
particularly in scenarios for which information-flow policies are most desirable--when
multiple principals need to cooperate but do not entirely trust one another. Simple exam-ples of such scenarios abound: email services, web-based shopping and financial planning, business-to-business transactions, and joint military information systems. Such
sophisticated, collaborative, inter-organizational computation is becoming increasinglycommon; some way is needed to ensure that data confidentiality is protected.

The general problem with these collaborative computations is ensuring that the security policies of all the participants are enforced. When participants do not fully trust eachothers' hosts, it is necessary to distribute the data and computational work among the

hosts. This distribution creates a new threat to security: the hosts used for computation
might cause security violations--either directly, by leaking information, or indirectly,by carrying out computations in a way that causes other hosts to leak information.

Of course, the program itself might also cause security violations. Because the ex-isting single-host techniques developed in this thesis address this problem, this chapter
focuses on the new threat, untrusted hosts.

The goal of this chapter is to extend \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  to account for the problem of infor-mation-flow security in distributed systems with mutually untrusting hosts.

\Delta  \Omega ff\Delta fi\Delta \Theta \Lambda  is acore language for studying information-flow security properties in distributed systems.

As with \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  , it abstracts away from many of the details of actual computation andinstead focuses on the key aspects of distributed computing: message passing, synchronization, and the notion of hosts with distinct identities levels of trust.

The defining characteristic of a distributed system is the absence of shared memory [Sch97]. In \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  , the requirements imposed by information-flow considerationshave already restricted interthread communication to a message-passing style similar to

that needed in a distributed setting. However, there are still a number of differences

151

152
between a the universally trusted, single-platform setting and a heterogeneously trusted,
distributed setting:

" The lack of shared memory in a distributed setting implies that reading from aremote memory location involves sending a message to the host that is storing the

data. The distributed computing model must make all interhost communication
explicit, which, in contrast to a single-platform model, introduces read channels:implicit flows that arise due to the additional communication necessary to read a

remote location.
" The failure mode in a heterogeneously-trusted system is different from that of a

single trusted platform. In the universally-trusted host setting, once the platformhas been compromised or subverted, the confidentiality or integrity of any data in

the system might be endangered. In the heterogeneous setting, the failure of onehost should affect only those principals who have declared some degree of trust in
that host.
" Confidential information can be leaked based on which of two hosts sends a message to a receiver, even if the message contents are otherwise identical.

" There are more abstraction-violation attacks in a distributed setting. For example,an attacker might learn some information by watching the network traffic generated by a distributed program. Such an attack is an external channel according to
the classification of information flows in the introduction of this thesis because theglobal state of the links on a network is not available at the programming language

level of abstraction.
The next section describes the heterogeneous trust model for the distributed setting;
it is based on the decentralized labels presented in the previous chapter and permitsan appropriate strengthening of noninterference. The following section sketches the

modifications to the type system of \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  needed to achieve such security.

7.1 Heterogeneous trust model
This section presents one model network environment and shows how the decentralizedlabel model can describe the trust relationship between principals and hosts. There
are many plausible models for network communication and its security properties; this
model was chosen because it fits well with the operational semantics of \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  , itseems reasonable to implement, and it is sufficient to describe additional information

flows that might arise in a distributed setting.

153
Let 0 be a set of known hosts, among which the system is to be distributed. Pairwise
communication between two members of 0 is assumed to be reliable: messages cannotbe lost. Communication is assumed to be asynchronous: sending hosts do not block

waiting for the destination host to receive the message, nor is there a bound on the
amount of time it takes for a message to be delivered.This model also assumes that messages cannot be intercepted by hosts outside

0 or
by the other members of 0. Protection against interception can be achieved efficientlythrough well-known encryption techniques (e.g, [SNS88, Ylo96]); for example, each

pair of hosts can use symmetric encryption to exchange information, with key exchange
via public-key encryption. that the same encryption mechanisms permit each memberof

0 to authenticate messages sent and received by one another.In addition to the underlying communication model, for security purposes, it is necessary to relate the available hosts to the principals on whose behalf the system is sup-posed to run. This relation is called a

trust configuration, and it consists of two labels
associated with each host.

" A confidentiality label %O/ that is an upper bound on the confidentiality of information that can be sent securely (either explicitly or implicitly) to host \Lambda .

" An integrity label AO/ describing an upper bound on the integrity of data that maybe received from

\Lambda .

Intuitively, the confidentiality label specifies which principals trust host \Lambda  not to leaktheir confidential data, and the integrity label specifies which principals trust

\Lambda  not tocorrupt their data.

As an example, consider a host & owned by Alice but untrusted by Bob, and a host
7 owned by Bob and untrusted by Alice. A reasonable trust configuration might be:

% \Delta  \Sigma 0\Theta \Lambda \Psi \Phi iff A \Delta  \Sigma ?i0\Theta \Lambda \Psi \Phi ff
%! \Delta  \Sigma 1aeffliff A! \Delta  \Sigma ?i1aefflff

Because 1aeffl does not appear as an owner in the label %, this description acknowledges that Bob is unwilling to send his private data to host &. Similarly, Bob does nottrust information received from

& because 1aeffl does not appear in A. The situation is
symmetric with respect to Alice and Bob's host.Next, consider hosts

, and * that are partially trusted by Alice and Bob:

%ae \Delta  \Sigma 0\Theta \Lambda \Psi \Phi ifi1aeffliff Aae \Delta  \Sigma ?i0\Theta \Lambda \Psi \Phi ff
%\Xi  \Delta  \Sigma 0\Theta \Lambda \Psi \Phi ifi1aeffliff A\Xi  \Delta  \Sigma ?iff

Alice and Bob both trust , not to divulge their data incorrectly; on the other hand,
Bob believes that , might corrupt data--he does not trust the integrity of data received

154
from , . Host * is also trusted with confidential data, but neither Alice nor Bob trust
data generated by *.These trust declarations are public knowledge--that is, they are available on all

known hosts--and are signed by the principals involved. Consequently, this heterogeneous trust model assumes the existence of a public-key infrastructure that makessuch digital signatures feasible. (See for example, the work on public-key encryption [SNS88] and certification authorities [Zho01, ZSv00].)

The goal is to ensure that the threats to a principal's confidential data are not in-creased by the failure or subversion of an untrusted host.

The security of a principal is endangered only if one or more of the hosts that theprincipal trusts is bad. Suppose the host

\Lambda  is bad and let 7* be the label of an expres-sion in the program. The confidentiality of the expression's value is endangered only if

5\Theta 7*\Lambda  \Xi  %O/; correspondingly, the expression's integrity may have been corrupted onlyif

AO/ \Xi  6\Theta 7*\Lambda .

If Alice's machine & from above is compromised, only data owned by Alice maybe leaked, and only data she trusts may be corrupted. Bob's privacy and integrity are

protected. By contrast, if the semi-trusted machine , malfunctions or is subverted, both
Alice and Bob's data may be leaked, but only Alice's data may be corrupted becauseonly she trusts the integrity of the machine.

When there are multiple bad machines, they might cooperate to leak or corrupt more
data. The type system described in the next section enforces the following property inaddition to the standard noninterference:

Definition 7.1.1 (Distributed Security Assurance) The confidentiality of a program
expression , is not threatened by a set 0\Omega \Psi " of bad hosts unless 5\Theta 7*\Lambda  \Xi  O/ff\Sigma \Sigma \Upsilon \Phi %O/; its
integrity is not threatened unless O/ffO/\Sigma \Upsilon \Phi AO/ \Xi  6\Theta 7*\Lambda .

Note that in the case that there are no compromised hosts (0\Omega \Psi " \Delta  o/), this definition
degenerates to standard noninterference.Providing this level of assurance involves two challenges: (1) Data with a confidentiality label (strictly) higher than %O/ should never be sent (explicitly or implicitly) to \Lambda ,
and data with an integrity label lower than AO/ should never be accepted from \Lambda . (2) Badhosts should not be able to exploit the downgrading abilities of more privileged hosts,

causing them to violate the security policy of the source program.

7.2 \Delta -.i/ij` : a secure distributed calculus
The \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  language guarantees noninterference for concurrent processes running ona single, universally trusted platform. This section describes an extension to

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  ,
called \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  , that enforces the distributed security assurance property.

155
7.2.1 Syntax
Programs in \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  consist of a collection of \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  processes, each process executingat a particular host. To describe this situation, we need to make only a few modifications

to the \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  syntax. A \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  network is:

/ ''\Delta  ! * / 5 \Lambda *flffi ' fi +
Here, the syntax \Lambda *flffi ' fi + denotes a host \Lambda  running a process fi whose current programcounter label is

flffi.
Processes, fi are identical to those of \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  , but \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  must also keep trackof the host that allocates each memory location or synchronization handler definition.

Consequently, locations and channel values are tagged with the host that created them:

ffl` ''\Delta  \Pi  * ` * i B \Lambda  * \Sigma  B \Lambda 
In \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  , each host has a local store. The global state of the distributed system
is therefore defined just like the memories used in \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  , except that the memorycontents are tagged by their hosts:

OE ''\Delta  OE\Upsilon  \Lambda *\Sigma  %_ `+ * OE\Upsilon  \Lambda *flffi ' . \Theta  fi + * !
7.2.2 Operational semantics
The operational semantics of \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  is given in Figures 7.1 and 7.2. It is, for the mostpart, identical to the semantics for

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda . Primitive operations must take place on a specific host, as indicated by the B \Lambda  to the left of the symbol *\Delta  . Rule \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -EVAL-DEREFrequires that the host performing the dereference be the same as the host that allocated

the reference--hosts have local state.Whenever data leaves a host

\Lambda  its security label is stamped with the integrity label AO/,reflecting the fact that only those principals that trust

\Lambda  not to corrupt data are willing to
trust any value \Lambda  generates. The rules \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -EVAL-SEND and \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -EVAL-LINSENDshow this behavior.

7.2.3 Type system
The type system for \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  modifies the type system for \Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  to add additionalconstraints reflecting the hosts' levels of trust.

The intuition is that whenever data leaves a host \Lambda , it is constrained so that its in-tegrity is no more than

AO/. Similarly, when data arrives at a host \Lambda , it must have confidentiality no higher than %O/.

156
\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -EVAL-PRIM \Xi \Pi  \Delta \Theta  _ ae i\Sigma  \Upsilon  \Delta  \Upsilon  \Psi  \Delta \Theta 
\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -EVAL-BINOP \Xi \Pi  \Delta \Theta  _ ae i\Sigma  \Phi \Theta  \Pi  \Phi \Sigma \Theta \Delta  \Delta  \Delta \Phi \Xi \Xi \Pi \Pi \Pi \Phi \Sigma \Lambda \Theta \Pi \Theta \Delta  \Psi  \Delta \Theta 

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -EVAL-DEREF

\Xi  \Sigma  \Xi  \Sigma \Pi  ae,\Psi  fl\Sigma  \Upsilon ss
\Xi \Pi  \Delta \Theta  _ ae i\Sigma  \Upsilon \Psi  _ ae \Delta  \Upsilon  \Psi  \Delta \Theta 

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -EVAL-LETPRIM

\Xi \Pi  \Delta \Theta  _ ae i\Sigma  \Omega fffifl \Delta  \Upsilon 

\Lambda \Xi \Pi  *\Pi  \Delta , * ae,\Delta \Theta  \Theta  \Xi \Phi \Sigma  \Theta  \Sigma  \Omega fffifl \Pi \Psi  ffiss\Lambda \Xi  \Sigma  \Lambda \Xi \Pi  *\Pi  \Delta , * ae,\Delta \Theta  \Theta  ffi\Upsilon \Upsilon ffl\Theta \Phi ss\Lambda \Xi 

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -EVAL-LETREF

\Lambda \Xi \Pi  *\Pi  \Delta , * ae,\Delta \Theta  \Theta  \Xi \Phi \Sigma  \Theta  \Sigma  ff\Phi \Delta  \Upsilon  \Pi \Psi  ss ss\Lambda \Xi 
\Sigma  \Lambda \Xi \Pi  ae,\Psi  fl\Sigma  \Upsilon ss\Pi  *\Pi  \Delta , * ae,\Delta \Theta  \Theta  ss \Upsilon \Psi \Phi \Psi  _ aeffl\Theta \Phi ss\Lambda \Xi  \Delta \Psi  fresh\Lambda 

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -EVAL-SET

\Lambda \Xi \Pi  ae,\Psi  fl\Sigma  \Upsilon ss\Pi  *\Pi  \Delta , * ae,\Delta \Theta  \Theta  \Omega \Phi \Sigma  \Psi \Theta  _ ae \Theta \Sigma  \Upsilon \Sigma  \Pi \Psi  ss ss\Lambda \Xi 
\Sigma  \Lambda \Xi \Pi  ae,\Psi  fl\Sigma  \Upsilon \Sigma  \Psi  i \Psi  \Delta \Theta ss\Pi  *\Pi  \Delta , * ae,\Delta \Theta  \Theta  ss ss\Lambda \Xi 

Figure 7.1: \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  operational semantics

157
\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -EVAL-HANDLER

\Lambda \Xi \Pi  *\Pi  \Delta , * ae,\Delta \Theta  \Theta  \Xi \Phi \Sigma  ^flfioe\Theta flfl * \Lambda  \Lambda  \Lambda  * ^\Delta fioe\Theta \Delta fl\Delta  ssfl \Pi \Psi  ssffiss\Lambda \Xi 
\Sigma  \Lambda \Xi \Pi  ae,\Delta \Theta  \Theta  o/flfioe\Theta flfl * \Lambda  \Lambda  \Lambda  * o/\Delta fioe\Theta \Delta fl\Delta  ssfl\Upsilon \Delta o/\Pi \Lambda \Phi \Psi ffl^\Pi \Phi ss\Pi  *\Pi 

\Delta , * ae,\Delta \Theta  \Theta  ssffi\Upsilon \Delta o/\Pi \Lambda \Phi \Psi ffl^\Pi \Phi ss\Lambda \Xi 
where the o/\Pi  are fresh

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -EVAL-LINHANDLER

\Lambda \Xi \Pi  *\Pi  \Delta , * ae,\Delta \Theta  \Theta  \Xi \Phi \Sigma  ^flfioe\Theta flfl * \Lambda  \Lambda  \Lambda  * ^\Delta fioe\Theta \Delta fl \Delta  ssfl \Pi \Psi  ssffiss\Lambda \Xi 
\Sigma  \Lambda \Xi \Pi  *\Pi  ae,\Delta \Theta  \Theta  o/flfioe\Theta flfl * \Lambda  \Lambda  \Lambda  * o/\Delta fioe\Theta \Delta fl\Delta  ssflss\Pi  \Delta , * ae,\Delta \Theta  \Theta  ssffi\Upsilon o/\Pi ffl^\Pi \Phi ss\Lambda \Xi 

where the o/\Pi  are fresh

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -EVAL-COND1

\Lambda \Xi \Pi  *\Pi  \Delta , * ae,\Delta \Theta  \Theta  \Pi \Delta  \Sigma \Theta  \Sigma \Upsilon \Phi \Psi  ssfl \Phi \Xi \Omega \Phi  ssffiss\Lambda \Xi 
\Sigma  \Lambda \Xi \Pi  *\Pi  \Delta , * ae,\Delta \Theta  \Psi  i \Theta  ssflss\Lambda \Xi 

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -EVAL-COND2

\Lambda \Xi \Pi  *\Pi  \Delta , * ae,\Delta \Theta  \Theta  \Pi \Delta  \Delta \Theta  \Sigma \Upsilon \Phi \Psi  ssfl \Phi \Xi \Omega \Phi  ssffiss\Lambda \Xi 
\Sigma  \Lambda \Xi \Pi  *\Pi  \Delta , * ae,\Delta \Theta  \Psi  i \Theta  ssffiss\Lambda \Xi 

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -EVAL-SEND

\Lambda \Xi \Pi  ae,\Delta \Theta  \Theta  o/flfioe\Theta fl\Pi  `\Sigma \Phi \Omega fl fl *\Lambda \Lambda \Lambda * o/\Delta fioe\Theta \Delta \Pi  `\Sigma \Phi \Omega \Delta  fl\Delta  ss ss\Pi  *\Pi  \Delta , *\Pi  ae\Pi ,\Delta \Theta \Pi  \Theta  o/\Pi \Theta \Lambda fioe\Upsilon \Pi \Pi  '\Upsilon \Sigma \Phi \Omega \Pi  flss\Lambda \Xi 
\Sigma  \Lambda \Xi \Pi  ae,\Delta \Theta  \Theta  o/flfioe\Theta fl\Pi  `\Sigma \Phi \Omega fl fl *\Lambda \Lambda \Lambda * o/\Delta fioe\Theta \Delta \Pi  `\Sigma \Phi \Omega \Delta  fl\Delta  ss ss\Pi  *\Pi 

\Delta , * ae,i \Theta  ss \Upsilon oe\Upsilon \Pi  \Psi  \Delta \Theta \Pi  \Psi  aeO/\Lambda ffloe\Theta \Pi \Phi \Upsilon '\Upsilon \Pi ffl`\Pi \Phi \Sigma \Phi \Omega ss\Lambda \Xi 
ij`'` i \Sigma  \Pi \Delta \Theta \Pi  \Psi  i\Pi 

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -EVAL-LINSEND

\Lambda \Xi \Pi  *\Pi  ae,\Delta \Theta  \Theta  o/flfioe\Theta flfl * \Lambda  \Lambda  \Lambda  * o/\Delta fioe\Theta \Delta fl\Delta  ss ss\Pi  \Delta , *\Pi  ae\Pi ,\Delta \Theta \Pi  \Theta  o/\Pi fioe\Upsilon \Pi flss\Lambda \Xi 
\Sigma  \Lambda \Xi \Pi  *\Pi  \Delta , * ae,\Delta \Theta  \Theta  ss \Upsilon oe\Upsilon \Pi  \Psi  \Delta \Theta \Pi  \Psi  aeO/\Lambda ffloe\Theta \Pi \Phi ss\Lambda \Xi 

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -EVAL-FORK

\Lambda \Xi \Pi  *\Pi  \Delta , * ae,\Delta \Theta  \Theta  ss * AEss\Lambda \Xi  \Sigma  \Lambda \Xi \Pi  *\Pi  \Delta , * ae,\Delta \Theta  \Theta  ss ss * ae,\Delta \Theta  \Theta  AEss\Lambda \Xi 

Figure 7.2: \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  operational semantics continued

158
\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -SEND

0% o/ ^O/ ` ' ssflffi\Sigma ae\Theta -*\Upsilon  !\Sigma \Phi \Omega \Lambda 
0% o/ ^O/ `\Pi  ' *\Pi 
, % $ ^O/ _`\Sigma \Phi \Omega  ' !\Sigma \Phi \Omega 
AO/ \Phi  flffi \Xi  flffi\Sigma  AO/ \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Pi \Lambda 

0% o/ % , % $ ssflffiae ^O/ `'-`\Upsilon  _`\Sigma \Phi \Omega _

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -LET

. \Lambda \Phi \Psi \Delta  \Lambda o/oe % o/\Psi '_ff% $\Pi 
0% o/ \Upsilon  o/oe \Upsilon  o/\Psi '_ff% !\Upsilon  $ ssflffi\Sigma ae ^O/ fifl
0% o/ \Upsilon  o/oe % ,\Upsilon  $ ssflffiae ^O/ fiffi
flffi\Sigma  \Xi  %O/ j\Omega  \Sigma  oe\Omega o/\Theta o/\Psi '_ff\Lambda \Pi  o/\Psi '_ff\Theta \Omega \Lambda  \Xi  %O/

0% o/ % ,\Upsilon  $ ssflffiae ^O/ \Theta \Phi \Pi  . \Theta  fifl \Lambda \Xi  fiffi

Figure 7.3: \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  typing rules for message passing

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -VAL

0% o/ ^ ` ' * flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta *\Lambda  \Xi  %O/

0% o/ ssflffiae ^O/ ` ' *

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -BINOP

0% o/ ^ ` ' fflaeae\Theta \Theta  0% o/ ^ `\Sigma  ' fflaeae\Theta \Theta  flffi \Xi  \Psi  \Xi  %O/

0% o/ ssflffiae ^O/ ` , `\Sigma  ' fflaeae\Theta \Theta 

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  -DEREF

0% o/ ^ ` ' * \Omega \Phi `\Theta  flffi \Xi  \Delta \Theta \Lambda \Xi \Delta \Theta * \Phi  \Psi \Lambda  \Xi  %O/

0% o/ ssflffiae ^O/ "` ' * \Phi  \Psi 

Figure 7.4: \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  typing rules for primitive operations

159
The rules for sending messages and declaring message handlers are shown in Figure 7.3. (The rule for linear handlers is modified analogously.)It is also necessary to rule out high-security data from being explicitly located at

a low-security host. Accordingly, the rules for typechecking primitive operations require that the host can handle the confidentiality of the data. These rules are shown inFigure 7.4.

The type system for \Delta \Omega ff\Delta fi\Delta \Theta \Lambda  satisfies subject reduction; the proof is a straightforwardmodification of the one given for lemma 5.3.8. Although a proof is beyond the scope of
this thesis, the type system given here is also intended to provide the distributed security
assurance property.

7.3 Related Work
The distributed trust model presented in this chapter, was originally developed in a tech-nical report [ZM00]. This model was further refined for the program-partitioning work
described in the next chapter [ZZNM02].

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  's notion of explicit hosts is similar to those in the D( calculus of Riely andHennessy [RH99]. More sophisticated ambient calculi [CG00] have a dynamic notion

of host and also permit mobile computing. Some security considerations have beenstudied in the ambient scenarios [MH02], but information-flow policies have not yet
been considered.

Mantel and Sabelfeld [MS01, SM02] consider a distributed model in which multi-threaded programs communicate via synchronous and asynchronous message passing.

They propose a definition of information security based on Mantel's security frame-work [Man00] and show how a type system can establish noninterference. Their definition of noninterference is both external-timing and termination sensitive, and hence
rules out single-threaded programs like examples (5) and (6) of Section 5.1.In addition to high- and low-security channels, the Mantel and Sabelfeld language

provides encrypted channels. An encrypted channel reveals to a low-security observer
only the number of messages that have been sent on it. Consequently, high-security datais not permitted to influence the number of messages sent on an encrypted channel--this

restriction is quite similar to the linearity constraints considered here (where it is stati-cally known that exactly one message will be sent on the channel). Further investigation
of this possible connection is warranted.

Chapter 8
Jif/split
This chapter presents secure program partitioning, a way to protect the confidentialityof data for computations that manipulate data with differing confidentiality needs in
the heterogeneously trusted hosts model of the previous chapter. Figure 8.1 illustratesthe key insight: The security policy can be used to guide the automatic splitting of a
security-typed program into communicating subprograms, each running on a differenthost. Collectively, the subprograms perform the same computation as the original; in
addition, they satisfy all the participants' security policies without requiring a single
universally trusted host.The prototype implementation, called Jif/split, is primarily designed to enforce confidentiality policies, but due to declassification, the system must also enforce simple
integrity policies as well (see Chapter 6).As Figure 8.1 shows, Jif/split receives two inputs: the program, including its confidentiality and integrity policy annotations, and also a set of signed trust declarationsstating each principal's trust in hosts and other principals, in accordance with the heterogeneous trust model presented in the last chapter. The goal of secure program partitioning is to ensure that if a host \Lambda  is subverted, the only data whose confidentiality orintegrity is threatened is data owned by principals that have declared they trust

\Lambda . Also,
note that to avoid the need for undue trust in the splitting process itself, the productionof the subprogram for host

\Lambda  can be performed on any host that is at least as trustworthyas
\Lambda --such as \Lambda  itself.

It is useful to contrast this approach with the usual development of secure distributedsystems, which involves the careful design of protocols for exchanging data among hosts

in the system. By contrast, the splitting approach provides the following benefits:

" Stronger security: Secure program partitioning can be applied to informationflow policies; most distributed systems make no attempt to control informationflow. It can also be applied to access control policies, which are comparatively

simple to enforce with this technique.

160

161
,&\Theta \Lambda \Pi ?,&\Theta \Lambda \Pi \Pi \Phi \Omega 4(&,

Figure 8.1: Secure program partitioning
" Decentralization: Collaborative computations can be carried out despite incom-plete trust. In addition, for many computations, there is no need for a universally

trusted host. Each participant can independently ensure that its security policiesare enforced.

" Automation: Large computing systems with many participating parties containcomplex, interacting security policies that evolve over time; automated enforcement is becoming a necessity. Secure program partitioning permits a computation
to be described as a single program independent of its distributed implementation.The partitioning process then

automatically generates a secure protocol for data
exchange among the hosts.

Secure program partitioning has the most value when strong protection of confiden-tiality is needed by one or more principals, the computing platform consists of differently trusted hosts, there is a generally agreed-upon computation to be performed, and
security, performance, or functionality considerations prevent the entire computationfrom being executed on a single host. One example of a possible application is an integrated medical information system that stores patient and physician records, raw testdata, and employee records, and supports information exchange with other medical institutions. Another example is an automated business-to-business procurement system,
in which profitable negotiation by the buyer and supplier depends on keeping some dataconfidential.

The goal of Jif/split is to enforce the distributed security assurance discussed in Section 7.1. It ensures that the threats to a principal's confidential data are not increasedby the failure or subversion of an untrusted host that is being used for execution. Bad

hosts--hosts that fail or are subverted--have full access to the part of the program ex162
ecuting on them, can freely fabricate apparently authentic messages from bad hosts,
and can share information with other bad hosts. Bad hosts may execute concurrentlywith good hosts, whereas good hosts preserve the sequential execution of the source

language--there is only one good host executing at a time. However, we assume that
bad hosts are not able to forge messages from good hosts, nor can they generate certaincapabilities to be described later.

The rest of this chapter describes Jif/split, an implementation of secure programpartitioning, which includes a static checker, program splitter, and run-time support for
the distributed subprograms. It also presents simple examples of applying this approach
and some performance results that indicate its practicality.As with the other security-typed languages in this thesis, Jif/split does not attempt to

control certain classes of information flows: external timing and termination channels,
or attacks based on network traffic analysis.

8.1 Jif: a security-typed variant of Java
The Jif/split program splitter extends the compiler for Jif [Mye99, MNZZ01], a security-typed extension to Java [GJS96] that uses labels from the decentralized label model (as
described in 6.1).

Types in Jif are labeled, allowing the programmer to declare variables and fields thatinclude security annotations. For example, a value with type

\Lambda \Xi \Pi \Sigma aei\Omega ff is an integer
owned by principal ae and readable by \Omega . When unlabeled Java types are written in aprogram, the label component is automatically inferred.

As with the other security-typed languages described in this thesis, every Jif program
expression has a labeled type that indicates an upper bound (with respect to the \Xi  order)of the security of the data represented by the expression. Jif also uses a program counter

label to track the side-effects that may be created by a method or other piece of code.Using the labels provided by the programmer and the inferred

flffi label, the Jif compileris able to statically verify that all of the information flows apparent in the program text

satisfy the label constraints that prevent illegal information flows from occurring. If theprogram does not satisfy the security policy, it is rejected.

In addition to these changes to the Java type system, Jif adds a number of constructs
for creating secure programs. The following are germane to this dissertation:

" Declassification and endorse expressions, that follow the robust-declassification

rule as described in Section 8.2.3.

" An optional ffi\Pi \Delta ae\Omega \Lambda \Pi o/ clause on method declarations describes the authorityavailable in the body of the method. Code containing such a clause can be added

to the system only with the permission of the principals named in it.

163
" Optional label bounds on the initial flffi label of a method.

For example, the method signature

\Lambda \Xi \Pi \Sigma \Psi flff OE\Sigma &\Psi ff'\Lambda \Xi \Pi \Sigma \Psi ffiff AE_ /\Delta \Phi \Omega \Phi  ffi\Pi \Delta ae\Omega \Lambda \Pi o/ \Sigma 0\Theta \Lambda \Psi \Phi ff
is translated into the notation used in this thesis as

ssfl0\Theta \Lambda \Psi \Phi ffi\Upsilon  flffiae\Lambda \Xi \Pi \Theta \Theta  _ \Lambda \Xi \Pi \Theta \Delta 
This type indicates that the method OE can only be called when the program counterlabel is

\Xi  flffi. It takes an integer AE with label \Psi ffi and returns an integer labeled \Psi fl. The
initial label bound plays exactly the same role for Jif methods as the ss&\Upsilon  flffiae componenton function types presented in Chapter 6.

Jif also introduces some limitations to Java, which apply to Jif/split as well. The
most important is that programs are assumed to be sequential: the #\Delta \Omega \Phi O/ class is notavailable. The current implementation of Jif does not support threaded computation as

proposed in Chapter 5, partially because Java's model of threads and synchronizationis significantly more complex than that of

\Delta \Lambda \Upsilon \Phi \Lambda \Psi \Xi \Delta \Theta \Lambda  . Determining how to integrate theresults of Chapter 5 into Jif is left for future work.

8.1.1 Oblivious Transfer Example
Figure 8.2 shows a sample program that is used as a running example. It is based on thewell-known Oblivious Transfer Problem [EGL83, Rab81], in which the principal Alice

has two values (here represented by fields OE* and OE4), and Bob may request exactly one
of the two values. However, Bob does not want Alice to learn which of the two valueswas requested.

Even this short example has interesting security issues. For instance, it is well-known that a trusted third party is needed for a secure distributed implementation under
the assumptions of perfect security (no information leakage) [DKS99].1

Alice's secret data is represented by integer fields OE* and OE4, with security label
\Sigma 0\Theta \Lambda \Psi \Phi ifi ?i0\Theta \Lambda \Psi \Phi ff. This type indicates that these fields are owned by Alice, that she
lets no one else read them, and that she trusts their contents. The boolean \Lambda ,0\Psi \Psi \Phi ,,\Phi O/records whether Bob has requested a value yet.

Lines 6 through 18 define a method \Pi \Omega \Xi ,`\Phi \Omega  that encapsulates the oblivious trans-fer protocol. It takes a request,

\Xi , owned by Bob, and returns either OE* or OE4 depending

1Probabilistic solutions using two hosts exist, but these algorithms leak small amounts of information.
Because Jif's type system is geared to possibilistic information flows, these probabilistic algorithms arerejected as potentially insecure. Ongoing research [GS92, VS00, SS00] attempts to address probabilistic

security.

164
* &ffiffl\Theta \Lambda \Psi  \Psi \Theta ,, 8#3AEOE&\Theta \Phi  \Sigma 
4 \Lambda \Xi \Pi \Sigma 0\Theta \Lambda \Psi \Phi ifi ?i0\Theta \Lambda \Psi \Phi ff OE*fi
- \Lambda \Xi \Pi \Sigma 0\Theta \Lambda \Psi \Phi ifi ?i0\Theta \Lambda \Psi \Phi ff OE4fi
= fflaeae\Theta \Phi \Xi \Sigma 0\Theta \Lambda \Psi \Phi ifi ?i0\Theta \Lambda \Psi \Phi ff \Lambda ,0\Psi \Psi \Phi ,,\Phi O/fi
6
C \Lambda \Xi \Pi \Sigma 1aeffliff \Pi \Omega \Xi ,`\Phi \Omega \Sigma ?i0\Theta \Lambda \Psi \Phi ff '\Lambda \Xi \Pi \Sigma 1aeffliff \Xi _
D /\Delta \Phi \Omega \Phi  ffi\Pi \Delta ae\Omega \Lambda \Pi o/'0\Theta \Lambda \Psi \Phi _ \Sigma 
E \Lambda \Xi \Pi  \Pi OE&* j OE*fi
F \Lambda \Xi \Pi  \Pi OE&4 j OE4fi
** \Lambda ` 'oe\Lambda ,0\Psi \Psi \Phi ,,\Phi O/_ \Sigma 
** \Lambda ,0\Psi \Psi \Phi ,,\Phi O/ j \Pi \Omega ffi\Phi fi
*4 \Lambda ` '\Phi \Xi O/ae\Omega ,\Phi '\Xi : \Sigma ?i0\Theta \Lambda \Psi \Phi ff_ jj *_
*- \Omega \Phi \Pi ffi\Omega \Xi  O/\Phi \Psi \Theta ,,\Lambda `o/'\Pi OE&*: \Sigma 1aeffliff_fi
*= \Phi \Theta ,\Phi 
*6 \Omega \Phi \Pi ffi\Omega \Xi  O/\Phi \Psi \Theta ,,\Lambda `o/'\Pi OE&4: \Sigma 1aeffliff_fi
*C ff
*D \Phi \Theta ,\Phi  \Omega \Phi \Pi ffi\Omega \Xi  *fi
*E ff
*F ff

Figure 8.2: Oblivious transfer example in Jif

on \Xi 's value. Note that because Alice owns OE* and OE4, releasing the data requires de-classification (lines 13 and 15). Her authority, needed to perform this declassification,
is granted by the ffi\Pi \Delta ae\Omega \Lambda \Pi o/ clause on line 7.

Ignoring for now the temporary variables \Pi OE&* and \Pi OE&4 and the \Phi \Xi O/ae\Omega ,\Phi  statement,
the body of the \Pi \Omega \Xi ,`\Phi \Omega  method is straightforward: Line 10 checks whether Bob hasmade a request already. If not, line 11 records the request, and lines 12 through 15 return

the appropriate field after declassifying them to be visible by Bob. If Bob has alreadymade a request,

\Pi \Omega \Xi ,`\Phi \Omega  simply returns *.

The simplicity of this program is deceptive. For example, the flffi label at the start ofthe

\Pi \Omega \Xi ,`\Phi \Omega  method must be bounded above by the label \Sigma ?i0\Theta \Lambda \Psi \Phi ff, as indicated on
line 6. The reason is that line 11 assigns \Pi \Omega ffi\Phi  into the field \Lambda ,0\Psi \Psi \Phi ,,\Phi O/, which requiresAlice's integrity. If the program counter at the point of assignment does not also have

Alice's trust, the integrity of \Lambda ,0\Psi \Psi \Phi ,,\Phi O/ is compromised.

165
These observations illustrate one benefit of programming in a security-typed language: the compiler can catch many subtle security holes even though the code is writtenin a style that contains no specification of how the code is to be distributed.

The interactions between confidentiality, integrity, and declassifications described in
Chapter 6 explain the need for the temporary variables and endorsement. The detailsof this example are described in the rest of this chapter, as we consider its security in a

distributed environment.

8.2 Static Security Constraints
Jif/split uses the model for heterogeneously trusted distributed systems given in Chapter 7. To securely partition a program for such an environment, the splitter must knowthe trust relationships between the participating principals and the hosts

0. Recall thatthese trust configurations are provided by a confidentiality and integrity label for each

host \Lambda . These labels are %O/ and AO/, respectively.At a high level, the partitioning process can be seen as a constraint satisfaction problem. Given a source program and the trust relationships between principals and hosts,
the splitter must assign a host in 0 to each field, method, and program statement inthe program. This fine-grained partitioning of the code is important so that a single

method may access data of differing confidentiality and integrity. The primary concernwhen assigning hosts is to enforce the confidentiality and integrity requirements on data;
efficiency, discussed in Section 8.5, is secondary.

This section describes the static constraints on host selection, they derive from theconsiderations of

\Delta \Omega ff\Delta fi\Delta \Theta \Lambda  .

8.2.1 Field and Statement Host Selection
Consider the field OE* of the oblivious transfer example. It has label \Sigma 0\Theta \Lambda \Psi \Phi ifi?i0\Theta \Lambda \Psi \Phi ff,which says that Alice owns and trusts this data. Only certain hosts are suitable to store

this field: hosts that Alice trusts to protect both her confidentiality and integrity. If the
field were stored elsewhere, the untrusted host could violate Alice's policy, contradictingthe security assurance of Section 7.1. The host requirements can be expressed using

labels: \Sigma 0\Theta \Lambda \Psi \Phi iff \Xi  %O/ and AO/ \Xi  \Sigma ?i0\Theta \Lambda \Psi \Phi ff. The first inequality says that Alice
allows her data to flow to \Lambda , and the second says that Alice trusts the data she receivesfrom

\Lambda . In general, for a field AE with label 7oe we require

5\Theta 7oe \Lambda  \Xi  %O/ *'oe AO/ \Xi  6\Theta 7oe \Lambda \Pi 
This same reasoning further generalizes to the constraints for locating an arbitrary
program statement, *. Let 8 \Theta *\Lambda  be the set of values used in the computation of * and

166
let 9\Theta *\Lambda  be the set of locations * defines. Suppose that the label of the value ` is 7# and
that the label of a location _ is 7ffi. Let

7\Pi \Delta  \Delta  #ff$`\Xi '7# *'oe 7j`i \Delta  ffiff%`\Xi '7ffi
A host \Lambda  can execute the statement * securely, subject to constraints similar to those forfields.

5\Theta 7\Pi \Delta \Lambda  \Xi  %O/ *'oe AO/ \Xi  6\Theta 7j`i\Lambda 

8.2.2 Preventing Read Channels
The rules for host selection for fields in the previous section are necessary but not suf-ficient in the distributed environment. Because bad hosts in the running system may

be able to observe read requests from good hosts, a new kind of implicit flow is intro-duced: a

read channel in which the request to read a field from a remote host itself
communicates information.For example, a naive implementation of the oblivious transfer example of Figure 8.2

exhibits a read channel. Suppose that in implementing the method \Pi \Omega \Xi ,`\Phi \Omega , the
O/\Phi \Psi \Theta ,,\Lambda `o/ expressions on lines 13 and 15 directly declassified the fields OE* and OE4,respectively, instead of the variables

\Pi OE&* and \Pi OE&4. According to Bob, the value of thevariable
\Xi  is private and not to be revealed to Alice. However, if OE* and OE4 are stored on
Alice's machine, Alice can improperly learn the value of \Xi  from the read request.The problem is that Alice can use read requests to reason about the location of the

program counter. Therefore, the program counter at the point of a read operation mustnot contain information that the field's host is not allowed to see. With each field

AE , thestatic checker associates a confidentiality label
7ae\Psi oe that bounds the security level of
implicit flows at each point where AE is read. For each read of the field AE , the label 7ae\Psi oemust satisfy the constraint

5\Theta flffi\Lambda  \Xi  7ae\Psi oe . Using this label 7ae\Psi oe , the confidentiality
constraint on host selection for the field is:

5\Theta 7oe \Lambda  \Phi  7ae\Psi oe \Xi  %O/
To eliminate the read channel in the example while preventing Bob from seeing both
OE* and OE4, a trusted third party is needed. The programmer discovers this problemduring development when the naive approach fails to split in a configuration with just

the hosts & and 7 as described in Section 4.2. The error pinpoints the read channelintroduced: arriving at line 13 depends on the value of

\Xi , so performing a request for
OE* there leaks \Xi  to Alice. The splitter automatically detects this problem when the field
constraint above is checked.If the more trusted host

, is added to the set of known hosts, the splitter is able
to solve the problem, even with the naive code, by allocating OE* and OE4 on , , which

167
prevents Alice from observing the read request. If * is used in place of , , the naive
code again fails to split--even though * has enough privacy to hold Alice's data, fields
OE* and OE4 can't be located there because Alice doesn't trust * not to corrupt her data.Again, the programmer is warned of the read channel, but this time a different solution

is possible: adding \Pi OE&* and \Pi OE&4 as in the example code give the splitter enoughflexibility to

copy the data to * rather than locating the fields there. Whether * or , is
the right model for the trusted host depends on the scenario; what is important is thatthe security policy is automatically verified in each case.

8.2.3 Declassification Constraints
Consider the oblivious transfer example from Alice's point of view. She has two privatepieces of data, and she is willing to release exactly one of the two to Bob. Her decision

to declassify the data is dependent on Bob not having requested the data previously.
In the example program, this policy is made explicit in two ways. First, the method
\Pi \Omega \Xi ,`\Phi \Omega  explicitly declares that it uses her authority, which is needed to perform thedeclassification. Second, the program itself tests (in line 10) whether

\Pi \Omega \Xi ,`\Phi \Omega  has
been invoked previously--presumably Alice would not have given her authority to thisprogram without this check to enforce her policy.

This example shows that it is not enough simply to require that any O/\Phi \Psi \Theta ,,\Lambda `o/performed on Alice's behalf executes on a host she trusts to hold the data. Alice also
must be confident that the decision to perform the declassification, that is, the program
execution leading to the O/\Phi \Psi \Theta ,,\Lambda `o/, is performed correctly.

The program counter label summarizes the information dependencies of the decision
to arrive at the corresponding program point. Thus, a O/\Phi \Psi \Theta ,,\Lambda `o/ operation using theauthority of a set of principals

fi introduces the integrity constraint: 6\Theta flffi\Lambda  \Xi  A* where
A* is the label \Sigma ?i&fl\Upsilon  \Pi  \Pi  \Pi  \Upsilon  &\Delta ff for &\Pi  \Sigma  fi . This constraint says that each principal &whose authority is needed to perform the declassification must trust that the program

has reached the O/\Phi \Psi \Theta ,,\Lambda `o/ correctly.

Returning to the oblivious transfer example, we can now explain the need to use the
\Phi \Xi O/ae\Omega ,\Phi  operation. Alice's authority is needed for the declassification, but, as described
above, she must also be sure of the integrity of the program counter when the programdoes the declassification. Omitting the

\Phi \Xi O/ae\Omega ,\Phi  when testing \Xi  on line 12 would lowerthe integrity of the program counter within the branches--Alice doesn't trust that

\Xi  was
computed correctly, as indicated by its (lack of an) integrity label on line 6. She mustadd her endorsement to

\Xi , making explicit her agreement with Bob that she doesn't need
to know \Xi  to enforce her security policy.

Using the static constraints just described, the splitter finds a set of possible hosts
for each field and statement. This process may yield many solutions, or none at all--for

168
G\Theta  ss\Phi \Pi H\Lambda \Phi \Theta O/'Iae,\Pi A2 \Delta : 8fflJ ae: H\Lambda \Phi \Theta O/A2 `_
G\Theta  ,\Phi \Pi H\Lambda \Phi \Theta O/'Iae,\Pi A2 \Delta : 8fflJ ae: H\Lambda \Phi \Theta O/A2 `: G\Theta  )_
)ae\Lambda O/ `ae\Omega /\Omega O/'Iae,\Pi A2 \Delta : H\Omega OE\Phi A2 `: G\Omega A2 )\Omega : G\Theta  )_
)ae\Lambda O/ \Omega ssae\Pi ae'Iae,\Pi A2 \Delta : H\Omega OE\Phi A2 `: 3\Xi \Pi \Omega o/fl\Pi  \Phi : #ae.\Phi \Xi  \Pi _
)ae\Lambda O/ \Theta ssae\Pi ae'#ae.\Phi \Xi  \Pi _
#ae.\Phi \Xi  ,o/\Xi \Psi 'Iae,\Pi A2 \Delta : H\Omega OE\Phi A2 `: 3\Xi \Pi \Omega o/fl\Pi  \Phi : #ae.\Phi \Xi  \Pi _

Figure 8.3: Run-time interface
instance, if the program manipulates data too confidential for any known host. Whenno solution exists, the splitter gives an error indicating which constraint is not satisfiable. We have found that the static program analysis is remarkably useful in identifying
problems with apparently secure programs. When more than one solution exists, thesplitter chooses hosts to optimize performance of the distributed system, as described in

Section 8.5.

8.3 Dynamic Enforcement
In the possible presence of bad hosts that can fabricate messages, run-time checks are
required to ensure security. For example, access to an object field on a remote host mustbe authenticated to prevent illegal data transfers from occurring. Thus, the informationflow policy is enforced by a combination of static constraints (controlling how the program is split) and dynamic checks to ensure that running program obeys the static con-straints.

When a program is partitioned, the resulting partitions contain both ordinary code
to perform local computation and calls to a special run-time interface that supports hostcommunication. Figure 8.3 shows the interface to the distributed run-time system.

2

There are three operations that transfer data between hosts: ss\Phi \Pi H\Lambda \Phi \Theta O/, ,\Phi \Pi H\Lambda \Phi \Theta O/, and
`ae\Omega /\Omega O/; and three operations that transfer control between hosts: \Omega ssae\Pi ae, \Theta ssae\Pi ae, and
,o/\Xi \Psi . These operations define building blocks for a protocol that exchanges informationamong the hosts running partitions.

The \Omega ssae\Pi ae and \Theta ssae\Pi ae control operations are primitive constructs for transferring
control from one program point to another that is located on a different host. In generala program partition comprises a set of code fragments that offer entry points to which

\Omega ssae\Pi ae and \Theta ssae\Pi ae transfer control. These two kinds of goto operations are taken directlyfrom the work on

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  in Chapter 4.

2This interface is simplified for clarity; for instance, the actual implementation provides direct support
for array manipulation.

169
The run-time interface describes all the ways that hosts can interact. To show that
bad hosts cannot violate the security assurance provided by the system, it is thereforenecessary to consider each of the run-time operations in turn and determine what checks

are needed to enforce the assurance condition given in Section 7.1.

8.3.1 Access Control
The simplest operations provided by the run-time interface are ss\Phi \Pi H\Lambda \Phi \Theta O/ and ,\Phi \Pi H\Lambda \Phi \Theta O/,which perform remote field reads and writes. Both operations take a handle to the remote host, the object that contains the field, and an identifier for the field itself. The
,\Phi \Pi H\Lambda \Phi \Theta O/ operation also takes the value to be written.

These requests are dispatched by the run-time system to the appropriate host. Suppose \Lambda fl sends a field access request to \Lambda ffi. Host \Lambda ffi must perform an access control checkto determine whether to satisfy the request or simply ignore it, while perhaps logging

any improper request for auditing purposes. A read request for a field AE labeled 7oe is
legal only if 5\Theta 7oe \Lambda  \Xi  %O/\Delta  , which says that \Lambda fl is trusted enough to hold the data stored in
AE . Similarly, when \Lambda fl tries to update a field labeled 7oe , \Lambda ffi checks the integrity constraint
AO/\Delta  \Xi  6\Theta 7oe \Lambda , which says that the principals who trust AE also trust \Lambda fl. These requirementsare the dynamic counterpart to those used for host selection (see Section 8.2.1).

Note that because field and host labels are known at compile time, an access controllist can be generated for each field, and thus label comparisons can be optimized into a
single lookup per request. There is no need to manipulate labels at run time.

8.3.2 Data Forwarding
Another difficulty with moving to a distributed setting is that the run-time system must
provide a mechanism to pass data between hosts without violating any of the confiden-tiality policies attached to the data. The problem is most easily seen when there are three

hosts and the control flow \Lambda fl oe_ _ oe_ \Lambda ffi: execution starts on \Lambda fl, transfers to _, andthen completes on

\Lambda ffi. Hosts \Lambda fl and \Lambda ffi must access confidential data j (and are trustedto do so), whereas

_ is not allowed to see j. The question is how to make j securely
available to \Lambda ffi. Clearly it is not secure to transfer j in plaintext between the trustedhosts via

_.
There are essentially two solutions to this problem: pass j via _ in encrypted form, orforward

j directly to \Lambda ffi. Jif/split implements the second solution. After hosts have beenassigned, the splitter infers statically where the data forwarding should occur, using a

standard definition-use dataflow analysis. The run-time interface provides an operation
`ae\Omega /\Omega O/ that permits a local variable to be forwarded to a particular stack frame on
a remote host. The same mechanism is used to transmit a return value to a remote

170
host. Data forwarding requires that the recipient validate the sender's integrity, as with
,\Phi \Pi H\Lambda \Phi \Theta O/.

8.3.3 Control Transfer Integrity
So far, Jif/split has not addressed concurrency, which is inherently a concern for securityin distributed systems. While it would be possible to make use of the structured synchronization mechanisms presented in Chapter 5, the Jif/split prototype was not beendesigned to take advantage of concurrency in the source program--this is a limitation
inherited from Jif. Instead, Jif/split takes advantage of the single-threaded nature of the
source program by using simpler ordered linear continuations of Chapter refch:cps.Consider a scenario with three hosts:

\Lambda fl and \Lambda ffi have high integrity, and _ has relatively lower integrity (that is, its integrity is not equal to or greater than that of \Lambda fl or \Lambda ffi).Because the program has been partitioned into code fragments, each host is prepared to

accept control transfers at multiple entry points, each of which begins a different codefragment. Some of the code fragments on

\Lambda fl and \Lambda ffi make use of the greater privilegeavailable due to higher integrity (e.g., the ability to declassify certain data).

Suppose the source program control flow indicates control transfer in the sequence
\Lambda fl oe_ _ oe_ \Lambda ffi. A potential attack is for _ to improperly invoke a privileged code
fragment residing on \Lambda ffi, therefore violating the behavior of the original program andpossibly corrupting or leaking some data. Hosts

\Lambda fl and \Lambda ffi can prevent these attacks by
simply denying _ the right to invoke entry points that correspond to privileged code, butthis strategy prevents

\Lambda ffi from using its higher privileges after control has passed through
_--even if this control transfer was supposed to occur according to the source program.

The mechanism to prevent these illegal control transfers is based on a stack disciplinefor manipulating capabilities. Each capability represents a linear continuation, and the

stack keeps track of the ordering between them.The intuition is that the block structure and sequential behavior of the source program, which are embodied at run-time by the stack of activation records, induce a similarLIFO property on linear continuations (and the

flffiintegrity). The deeper the stack, the
more data the program counter depends on, and consequently, the lower its integrity.In Jif, the correspondence between stack frames and linear continuations is not perfect because the flffi label need not decrease in lock step with every stack frame. A singlestack frame may be used by a block of code that is partitioned across several hosts of
differing integrity, for example. To distinguish between the stack of activation records
(whose elements are represented by H\Omega OE\Phi A2 objects) and the stack of continuation to-kens, the latter is called the ICS--integrity control stack. The ICS can be thought of as

an implementation of the linear context $ used in the typechecking rules for \Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda .Informally, in the scenario above, the first control transfer (from

\Lambda fl to _) pushes a
capability (a continuation) for return to \Lambda ffi onto the ICS, after which computation is more

171
,&\Theta \Lambda \Pi ?8#K,&\Theta \Lambda \Pi (&,

Figure 8.4: Control flow graph of the oblivious transfer program
restricted (and hence may reside on a less trusted machine). The second control transfer(from

_ to \Lambda ffi) consumes the capability and pops it off the ICS, allowing \Lambda ffi to regain
its full privileges. The idea is that before transferring control to _, trusted machines
\Lambda fl and \Lambda ffi agree that the only valid, privileged entry point between them is the one on
\Lambda ffi. Together, they generate a capability for the entry point that \Lambda fl passes to _ on the
first control transfer. Host _ must present this capability before being granted access tothe more privileged code. Illegal attempts to transfer control from

_ to \Lambda fl or to \Lambda ffi are
rejected because \Lambda fl and \Lambda ffi can validate the (unique) capability.

8.3.4 Example Control Flow Graph
Figure 8.3 shows the signatures for the three control transfer facilities: \Omega ssae\Pi ae (for "regular" control transfers that do not affect the ICS), \Theta ssae\Pi ae (for "linear" transfers--ICSpops), and

,o/\Xi \Psi  (for generating capabilities--ICS pushes; these correspond to \Theta \Phi \Pi \Theta \Lambda \Xi ).
The continuation capabilities are represented as #ae.\Phi \Xi  objects. In addition to the codefragment to be jumped to (given by the

3\Xi \Pi \Omega o/fl\Pi  argument), control transfer is to aspecific stack frame (given by
H\Omega OE\Phi A2) on a particular host.
The next section describes in detail the operation of these mechanisms, but first it is
helpful to see an example of their use.

172
Figure 8.4 shows the control-flow graph of a possible splitting of the oblivious transfer example in a host environment that contains Alice's machine &, Bob's machine 7and the partially trusted server,

, from Section 4.2. For completeness, the followingdescribes the unoptimized behavior; optimizations that affect the partitioning process

and run-time performance are discussed in Sections 8.5 and 8.6.The figure shows only a fragment of the

OE\Lambda \Xi 3 method. Host , initially has control
and possesses a single capability \Pi *, which is on top of the ICS. Bob's host is neededto initialize

\Xi --his choice of Alice's two fields. Recall that \Sigma ?i1aefflff i\Xi  \Sigma ?i0\Theta \Lambda \Psi \Phi ff,which means that

7 is relatively less trusted than , . Before transferring control to 7, ,
,o/\Xi \Psi 's to a suitable return point (entry \Phi 4), which pushes a new capability, \Pi *, onto theICS (hiding

\Pi *). The ,o/\Xi \Psi  operation then returns this fresh capability token, \Pi *, to \Phi *.Next,
, passes \Pi * to entry point \Phi 6 on 7 via \Omega ssae\Pi ae. There, Bob's host computes the
value of \Xi  and returns control to , via \Theta ssae\Pi ae, which requires the capability \Pi * to returnto a host with relatively higher integrity. Upon receiving this valid capability,

, pops
\Pi *, restoring \Pi * as the top of the ICS. If instead 7 maliciously attempts to invoke anyentry point on either

, or & via \Omega ssae\Pi ae, the access control checks deny the operation.The only valid way to transfer control back to

, is by invoking \Theta ssae\Pi ae with one-time
capability \Pi *. Note that this prevents Bob from initiating a race to the assignment online

** of the example, which might allow two of his transfer requests (one for OE* and
one for OE4) to be granted and thus violate Alice's declassification policy.Alice's machine must check the

\Lambda ,0\Psi \Psi \Phi ,,\Phi O/ field, so after 7 returns control, , next
,o/\Xi \Psi s with the return point of \Pi \Omega \Xi ,`\Phi \Omega  (the entry point \Phi =), which again pushes new
token \Pi 4 onto the ICS. , then transfers control to \Phi C on &, passing \Pi 4. The entry point
\Phi C corresponds to the beginning of the \Pi \Omega \Xi ,`\Phi \Omega  method.Alice's machine performs the comparison, and either denies access to Bob by returning to \Phi = with \Theta ssae\Pi ae using \Pi 4, or forwards the values of OE* and OE4 to , and hands backcontrol via

\Omega ssae\Pi ae to \Phi -, passing the token \Pi 4. If Bob has not already made a request,
, is able to check \Xi  and assign the appropriate value of \Pi OE&* and \Pi OE&4 to \Omega \Phi \Pi )\Theta ,then jump to

\Phi = via \Pi 4. The final block shows , exiting the program by invoking thecapability
\Pi *.

8.3.5 Control Transfer Mechanisms
This section describes how \Omega ssae\Pi ae, \Theta ssae\Pi ae, and ,o/\Xi \Psi  manipulate the ICS, which is itselfdistributed among the hosts, and defines the dynamic checks that must occur to maintain

the desired integrity invariant. The implementation details given here are one way ofimplementing the ordered synchronization handlers described in Chapters 5 and 7.

3The ssfl`o/ method and constructors are omitted from Figure 8.2 to simplify the presentation; they
contain simple initialization code. This description also omits the details of &oeflss\Xi '( objects, which areunimportant for this example.

173
,&\Theta \Lambda \Pi ?,\Pi \Psi .(&,
Figure 8.5: Distributed implementation of the global stack
A capability token \Pi  is a tuple fl\Lambda \Upsilon  AE\Upsilon  ,ffiOE\Psi  containing a Iae,\Pi A2, a H\Omega OE\Phi A2, and
an 3\Xi \Pi \Omega o/fl\Pi . It represents a linear continuation--or, equivalently, a synchronizationchannel--that expects no arguments and whose body contains the code

,. To preventforgery and ensure uniqueness, the tuple is appended to its hash with
\Lambda 's private key and
a nonce.

The global ICS is represented by a collection of local stacks, as shown in Figure 8.5.Host

\Lambda 's local stack, *O/, contains pairs of tokens \Theta \Pi \Upsilon  \Pi \Sigma \Lambda  as shown. The intended invariant
is that when the top of \Lambda 's stack, \Pi ae&'*O/_, is \Theta \Pi \Upsilon  \Pi \Sigma \Lambda , then \Pi  is the token most recentlyissued by

\Lambda . Furthermore, the only valid \Theta ssae\Pi ae request that \Lambda  will serve must presentthe capability

\Pi . The other token, \Pi \Sigma , represents the capability for the next item on the
global stack; it is effectively a pointer to the tail of the global ICS.

To show that these distributed stacks enforce a global stack ordering on the capa-bilities, the proof, given in Section 8.4, establishes a stronger invariant of the protocol

operations. Whenever control is transferred to low-integrity hosts, there is a unique re-entry point on high-security hosts that permits high-integrity computation. This uniqueness ensures that if a low-integrity host is bad, it can only jeopardize the security oflow-integrity computation.

The recipients of control transfer requests enforce the ordering protocol. Assumethe recipient is the host

\Lambda , and the initiator of the request is \Xi . The table in Figure 8.6
specifies \Lambda 's action for each type of request. The notation ,\Theta AE\Upsilon  \Pi \Lambda  is a local invocation ofthe code identified by entry point

, in stack frame AE , passing the token \Pi  as an additional
argument.

This approach forces a stack discipline on the integrity of the control flow: \Omega ssae\Pi aemay be used to transfer control to an entry point that requires lesser or equal integrity;

\Theta ssae\Pi ae may transfer control to a higher-integrity entry point--provided that the higherintegrity host previously published a capability to that entry point. These capabilitiescan be used at most once: upon receiving an

\Theta ssae\Pi ae request using the valid capability
\Pi , \Lambda  pops its local capability stack, thereby invalidating \Pi  for future uses. Calls to ,o/\Xi \Psi 

174
and \Theta ssae\Pi ae thus come in pairs, with each \Theta ssae\Pi ae consuming the capability produced by
the corresponding ,o/\Xi \Psi .

Just as the run-time system must dynamically prevent malicious hosts from improperly accessing remote fields, it also must ensure that bad hosts cannot improperly invokeremote code. Otherwise, malicious hosts could indirectly violate the integrity of data affected by the code. Each entry point , has an associated dynamic access control label A*
that regulates the integrity of machines that may remotely invoke ,. The receiver of an
\Omega ssae\Pi ae or ,o/\Xi \Psi  request checks the integrity of the requesting host against A* as shown in
Figure 8.6. The label A* is given by \Theta  #ff%`*'7#\Lambda  \Psi  A* , where 9\Theta ,\Lambda  is the set of variablesand fields written to by the code in

, and A* is the integrity label of the principals, fi ,whose authority is needed to perform any declassifications in

,.
The translation phase described in the next section inserts control transfers into thesource program. To prevent confidentiality and integrity policies from being violated

by the communications of the transfer mechanisms themselves, there are constraints onwhere

\Omega ssae\Pi ae and ,o/\Xi \Psi  may be added.
Suppose a source program entry point , is assigned to host \Xi , but doing so requiresinserting an

\Omega ssae\Pi ae or ,o/\Xi \Psi  to another entry point ,\Sigma  on host \Lambda . The necessary constraints
are:

5\Theta flffi\Lambda  \Xi  %O/ A\Pi  \Xi  A*\Delta  A* \Xi  A*\Delta \Pi 

The first inequality says that \Xi  cannot leak information to \Lambda  by performing this opera-tion. The second inequality says that host

\Xi  has enough integrity to request this control
transfer. This constraint implies that the dynamic integrity checks performed by \Lambda  areguaranteed to succeed for this legal transfer--the dynamic checks are there to catch

malicious machines, not well-behaved ones. Finally, the third constraint says that the
code of the entry point , itself has enough integrity to transfer the control to ,\Sigma . Further-more, because

,o/\Xi \Psi  passes a capability to \Lambda , it requires the additional constraint that
6O/ \Xi  6\Theta flffi\Lambda , which limits the damage \Lambda  can do by invoking the capability too early, thusbypassing the intervening computation.

These enforcement mechanisms do not attempt to prevent denial of service attacks,as such attacks do not affect confidentiality or integrity. These measures

are sufficient toprevent a bad low-integrity host from launching race-condition attacks against the higher

integrity ones: hosts process requests sequentially, and each capability offers one-shotaccess to the higher integrity hosts.

While our restrictive stack-based control transfer mechanism is sufficient to providethe security property of Section 7.1, it is not

necessary; there exist secure systems thatlie outside the behaviors expressible by the ICS. However, following the stack discipline

is sufficient to express many interesting protocols that move the thread of control fromtrusted hosts to untrusted hosts and back. Moreover, the splitter determines when a
source program can obey the stack ordering and generates the protocol automatically.

175
Request for \Lambda  Description \Lambda 's Action
\Omega ssae\Pi ae'\Lambda \Upsilon  AE\Upsilon  ,\Upsilon  *_ Transfers control to the entrypoint

, in frame AE on the host
\Lambda . Host \Xi 's current capability
\Pi  is passed to \Lambda .

\Lambda ` 'A\Pi  \Xi  A*_ \Sigma 

,\Theta AE\Upsilon  *\Lambda 
ff \Phi \Theta ,\Phi  \Lambda ss\Xi ae\Omega \Phi 

\Theta ssae\Pi ae'*_
where(

* \Delta  fl\Lambda \Upsilon  AE\Upsilon  ,ffiOE\Psi )

Pops \Lambda 's local control stackafter verifying the capability
*; control moves to entrypoint

, in frame AE on host \Lambda ,restoring privileges.

\Lambda ` 'top\Theta *O/\Lambda  j '*:*\Sigma __ \Sigma pop

\Theta *O/\Lambda %
,\Theta AE\Upsilon  *\Sigma \Lambda %
ff \Phi \Theta ,\Phi  \Lambda ss\Xi ae\Omega \Phi 

,o/\Xi \Psi '\Lambda \Upsilon  AE\Upsilon  ,\Upsilon  *_ Host \Lambda  checks \Xi 's integrity; ifsufficient,

\Lambda  returns to \Xi  a new
capability ('*) for entry point
, in frame AE .

\Lambda ` 'A\Pi  \Xi  A*_ \Sigma 

'* \Delta  fl\Lambda \Upsilon  AE\Upsilon  ,ffiOE\Psi %push

\Theta *O/\Upsilon  \Theta '*\Upsilon  *\Lambda \Lambda %send
\Theta \Lambda \Lambda \Pi \Theta AE\Upsilon  '*\Lambda %
ff \Phi \Theta ,\Phi  \Lambda ss\Xi ae\Omega \Phi 

Figure 8.6: Host \Lambda 's reaction to transfer requests from host \Xi 

8.4 Proof of Protocol Correctness
This section proves that the control-transfer protocols generated by Jif/split protect theintegrity of the program counter. The purpose of these protocols is to ensure that at
any point in time, the set of (relatively) low-integrity hosts has access to at most onecapability that grants access to high-integrity (more privileged) code. This prevents the
low-integrity hosts from having a choice about how privileges are restored to the com-putation, which means that they cannot inappropriately invoke declassifications that reside on more trusted machines. Thus, untrusted hosts can jeopardize only low-integrity
computation--the control behavior of the high-integrity parts of the split code is thesame as in the original, single-host source program. The

Stack Integrity Theorem, described below, proves that the distributed systems generated by Jif/split satisfy this se-curity invariant.

To arrive at this result, we need to first model the behavior of the system at anappropriate level of detail. There are two parts to this model: First, Jif/split statically
produces code fragments to distribute among the hosts. These code fragments obeystatic constraints imposed by the compiler and splitter, but they also have a run-time
effect on the behavior of the system--for instance, a code fragment may terminate in a

176
control transfer to a different host. Second, the run-time system of each host manipulates
stacks of capability tokens that are used for dynamic checking. The combination of staticconstraints on the partitions created by the splitter and dynamic checks performed by the

run-time system protects the control-transfer integrity.

8.4.1 Hosts
Let 0 be a set of known hosts fl\Lambda fl\Upsilon  \Pi  \Pi  \Pi  \Upsilon  \Lambda \Delta ffi. We assume that each host \Lambda  has an as-sociated integrity label

AO/. Fix an integrity label :, used to define the relative trust
levels between hosts. Let 0& \Delta  fl\Lambda  * AO/ \Xi  :ffi be the set of good hosts, and let
0! \Delta  fl\Lambda  * AO/ i\Xi  :ffi be the set of bad hosts. For example, with respect to a single
principal, &, we might choose : \Delta  fl?i&ffi. In this case, 0& is the set of hosts trusted by
& and 0! is the set of hosts not trusted by &. Note that 0& OE 0! \Delta  0. Throughout thissection, we call objects with label

i\Xi  : bad and objects with label \Xi  : good. 4

We assume that good hosts follow the protocols and that bad hosts might not. Inparticular, bad hosts may attempt to duplicate or otherwise misuse the capability tokens;

they may also generate spurious messages that contain tokens previously seen by anybad host.

The run-time system provided also ensures that good hosts execute requests atomi-cally. In particular, a host

\Lambda  that is executing the sequential code fragment correspondingto an entry point
,O/ will not be executing code for any other entry point ,\Sigma O/ on \Lambda . This
assumption justifies the state-transition approach described below, because we show thatthe local processing on each host, if performed atomically, preserves a global invariant.

One subtle point is that despite the distinction between good and bad hosts, not alllow-integrity computation takes place at bad hosts. Intuitively, running low-integrity
computation on high-integrity hosts is allowed because the integrity constraints inferredfor the source program are lower bounds on the integrity required by the hosts. It is
therefore safe to use a more secure host than necessary. Consequently, high-integrity
hosts may accept requests to run low-integrity parts of the program from bad hosts. Ingeneral, several good hosts may be executing concurrently--perhaps because they are

responding to low-integrity requests generated by bad hosts. However, the intendedeffect is that such concurrency does not affect high-integrity computation. The Stack
Integrity Theorem establishes that high-integrity computation is still single-threaded,
despite this possible concurrency introduced by bad hosts.

4Recall that in the integrity lattice, labels representing more integrity are lower in the \Pi  order.

177
8.4.2 Modeling Code Partitions
To capture the static constraints on the behavior of good hosts, we define the notion of an
entry point: an entry point , is the name of a code partition generated by the splitter--itcan be thought of as a remote reference to a single-threaded piece of program that resides

entirely on one host. An entry point names a program point to which control may be
transferred from a remote host. Each entry point , has an associated integrity label A*as described in Section 8.3. Note that a low-integrity entry point may be located at a

high-integrity machine. Let ; be the set of entry points generated by a given program,
and let ;O/ be the set of entry points located on host \Lambda .

Because our proof is concerned with the control transfers between hosts, we canignore the details of the sequential code named by an entry point. Consequently, an

entry point , on a good host \Lambda  \Sigma  0& can be thought of as a function that takes a frame AE
and a token * and produces an action, which is a pair \Theta \Lambda \Upsilon  #\Lambda  of the host \Lambda  and an operationrequest

#, in one of the following forms:

1. ,\Theta AE\Upsilon  *\Lambda  \Delta  \Theta \Lambda \Upsilon  \Omega ssae\Pi ae\Theta \Lambda \Sigma \Upsilon  AE \Sigma \Upsilon  ,\Sigma \Upsilon  *\Lambda \Lambda : Host \Lambda  transfers control to entry ,\Sigma  on \Lambda \Sigma  inframe

AE \Sigma .

2. ,\Theta AE\Upsilon  *\Lambda  \Delta  \Theta \Lambda \Upsilon  ,o/\Xi \Psi \Theta \Lambda \Sigma \Upsilon  AE \Sigma \Upsilon  ,\Sigma \Upsilon  *\Lambda \Lambda : Host \Lambda  requests a sync with entry ,\Sigma  on \Lambda \Sigma  and

frame AE \Sigma ; \Lambda  blocks until it receives a reply.

3. ,\Theta AE\Upsilon  *\Lambda  \Delta  \Theta \Lambda \Upsilon  \Theta ssae\Pi ae\Theta *\Lambda \Lambda : Host \Lambda  transfers control to entry ,\Sigma  on \Lambda \Sigma  in frame AE \Sigma  if

* \Delta  fl\Lambda \Sigma \Upsilon  AE \Sigma \Upsilon  ,\Sigma ffiOE\Psi \Delta  .

The recipient, or destination host of an action is the host \Lambda \Sigma  in the requests describedabove. If

# is a request, the notation \Lambda \Xi \Sigma fl \Theta #\Lambda  indicates the destination host.
The metavariable * indicates a capability token, which is a tuple fl\Lambda \Upsilon  AE\Upsilon  ,ffiOE\Psi  consisting of a host identifier, a frame identifier, and an entry point identifier. To preventforgery and ensure uniqueness of such tokens, the tuple is appended to its hash with

\Lambda 'sprivate key and a nonce. Thus a token of this form can be generated only by host
\Lambda , but
its validity can be checked by any host with \Lambda 's public key. (In the text below, we use
*\Upsilon  *\Sigma \Upsilon  !\Upsilon  !\Sigma , etc., to range over tokens.)

The ,o/\Xi \Psi  operation is the only control transfer mechanism that involves an exchangeof messages between hosts. (Both

\Omega ssae\Pi ae and \Theta ssae\Pi ae unconditionally transfer control to
the recipient.) Because the initiator (host \Lambda  in the above description) of a ,o/\Xi \Psi  requestexpects the recipient (

\Lambda \Sigma ) to respond with a freshly generated token, \Lambda  blocks until itgets
\Lambda \Sigma 's reply. For the purposes of analysis, we treat \Lambda 's behavior after issuing a ,o/\Xi \Psi 
request to \Lambda \Sigma  as an entry point send\Theta \Lambda \Sigma \Lambda O/ on \Lambda  to which \Lambda \Sigma  may return control. Theintegrity of the entry point send

\Theta \Lambda \Sigma \Lambda O/ is the integrity A* of the entry point containing the
,o/\Xi \Psi  operation.

178
Just like any other entry point, send\Theta \Lambda \Sigma \Lambda O/ is a function that takes a frame and token
and returns an action. In the case that \Lambda \Sigma  is also a good host, and hence follows theappropriate protocol,

\Lambda \Sigma  will generate a fresh token *\Sigma  and return control to \Lambda  causing theentry point send
\Theta \Lambda \Sigma \Lambda O/\Theta AE\Upsilon  *\Sigma \Lambda  to be invoked.
For example, the code fragment below, located on a host \Lambda , includes two entry points,
, and send\Theta \Lambda \Sigma \Lambda O/:

, ' AE j AE"*fi

' j AEK4fi
,o/\Xi \Psi \Theta \Lambda \Sigma \Upsilon  AE \Sigma \Upsilon  ,\Sigma \Upsilon  *\Lambda fisend
\Theta \Lambda \Sigma \Lambda O/ ' o/ j o/ "4fi

\Omega ssae\Pi ae\Theta \Lambda \Sigma \Sigma \Upsilon  AE \Sigma \Sigma \Upsilon  ,\Sigma \Sigma \Upsilon  *\Sigma \Lambda fi

These entry points are modeled as functions

,\Theta AE\Upsilon  *\Lambda  \Delta  ,o/\Xi \Psi \Theta \Lambda \Sigma \Upsilon  AE \Sigma \Upsilon  ,\Sigma \Upsilon  *\Lambda 
and

send\Theta \Lambda \Sigma \Lambda O/\Theta AE\Upsilon  *\Sigma \Lambda  \Delta  \Omega ssae\Pi ae\Theta \Lambda \Sigma \Sigma \Upsilon  AE \Sigma \Sigma \Upsilon  ,\Sigma \Sigma \Upsilon  *\Sigma \Lambda 

When , is invoked, the local computations are performed and then host \Lambda  sends a ,o/\Xi \Psi 
request to \Lambda \Sigma , causing \Lambda \Sigma  to block (waiting for the response to be sent by \Lambda \Sigma  to the entrypoint send

\Theta \Lambda \Sigma \Lambda O/).
Note that this description of entry points is valid only for good hosts--bad hosts maydo anything they like with the tokens they receive. For good hosts, the code generated

by our splitter satisfies the above abstract specification by construction. For instance, the
splitter always terminates the thread of control on a host by inserting a single \Omega ssae\Pi ae oran

\Theta ssae\Pi ae--the splitter never generates several control transfers in a row from the same
host (which would cause multiple remote hosts to start executing concurrently). Asdiscussed in Section 8.3, the splitter also follows some constraints about where

\Omega ssae\Pi aeand
,o/\Xi \Psi  can be inserted. In order for host \Lambda  to perform an \Omega ssae\Pi ae or ,o/\Xi \Psi  at an entry
point , to entry point ,\Sigma  on host \Lambda \Sigma , the following static constraint must be satisfied:
AO/ \Phi  A* \Xi  A*\Delta . The ,o/\Xi \Psi  operation requires an additional constraint AO/\Delta  \Xi  6\Theta flffi\Lambda ,which limits the damage

\Lambda \Sigma  can do by invoking the capability too early, bypassing the
intervening computation. Since we assume good hosts are not compromised, ,o/\Xi \Psi s or
\Omega ssae\Pi aes issued by good hosts satisfy these label inequalities.

8.4.3 Modeling the Run-time Behavior
To capture the dynamic behavior of the hosts, we need to model the state manipulatedby the run-time system. Let

, be the set of all possible tokens. For the purposes of
this proof, we assume that a host may generate a fresh, unforgeable token not yet used

179
anywhere in the system. In practice, this is accomplished by using nonces. The run-time
system's local state on a host \Lambda  includes a token stack, which is a list of pairs of tokens

\Theta *fl\Upsilon  *\Sigma fl\Lambda  ' \Theta *ffi\Upsilon  *\Sigma ffi\Lambda  ' \Pi  \Pi  \Pi  ' \Theta *\Delta \Upsilon  *\Sigma \Delta \Lambda \Pi 
Stacks grow to the left, so pushing a new pair \Theta *_\Upsilon  *\Sigma _\Lambda  onto this stack yields:

\Theta *_\Upsilon  *\Sigma _\Lambda  ' \Theta *fl\Upsilon  *\Sigma fl\Lambda  ' \Theta *ffi\Upsilon  *\Sigma ffi\Lambda  ' \Pi  \Pi  \Pi  ' \Theta *\Delta \Upsilon  *\Sigma \Delta \Lambda \Pi 
Because only good hosts are trusted to follow the protocol, only good hosts necessar-ily have token stacks. For each

\Lambda  \Sigma  0& we write *O/ for the local token stack associated
with the good host \Lambda .Let

*O/ be the stack \Theta *fl\Upsilon  *\Sigma fl\Lambda  ' \Pi  \Pi  \Pi  ' \Theta *\Delta \Upsilon  *\Sigma \Delta \Lambda . We use the notation top\Theta *O/\Lambda  to denotethe top of the stack

*O/: the pair \Theta *fl\Upsilon  *\Sigma fl\Lambda . If *O/ is empty (that is, ' \Delta  &), then top\Theta *O/\Lambda  is
undefined. For the pair \Theta *\Upsilon  *\Sigma \Lambda , let fst\Theta *\Upsilon  *\Sigma \Lambda  \Delta  * be the first projection and snd\Theta *\Upsilon  *\Sigma \Lambda  \Delta  *\Sigma  bethe second projection. We overload the meaning of fst and snd to include entire stacks:

fst\Theta *O/\Lambda  \Delta  fl*fl\Upsilon  *ffi\Upsilon  \Pi  \Pi  \Pi  \Upsilon  *\Delta ffi and snd\Theta *O/\Lambda  \Delta  fl*\Sigma fl\Upsilon  *\Sigma ffi\Upsilon  \Pi  \Pi  \Pi  \Upsilon  *\Sigma \Delta ffi.

When a good host \Lambda  receives a request from initiator \Xi , \Lambda  reacts to the messageaccording to the table in Figure 8.6. (We can't say anything about what a bad host does

upon receiving a message, except observe that the bad host may gain access to newtokens.) The pop and push operations manipulate

\Lambda 's local stack.Note that
\Lambda  will react to a \Theta ssae\Pi ae request only if the token used to generate the request
is on top of its local stack. The point of our protocol is to protect against any bad host(or set of bad hosts) causing more than one these "active tokens" to be used at time.

The global state of the system at any point in time is captured by a configuration,which is a tuple

\Lambda *\Upsilon  +\Upsilon  ,ss\Pi . Here, * is the mapping from good hosts to their local stacks,
+ is a predicate on ; indicating which entry points are running, and ,ss ffl , is the setof tokens released to bad hosts or generated by them. The intention is that

,ss contains
all tokens that have been passed to the bad hosts or to low integrity entry points beforereaching this system configuration during the computation.

As always, we cannot assume anything about what code a bad host is running. Thus,
we use the predicate + only for those entry points located on good hosts. The notation
+ss, %_ \Omega ae for \Omega  \Sigma  fl\Pi \Upsilon  `ffi stands for the predicate on entry points that agrees with +everywhere except

,, for which +ss, %_ \Omega ae\Theta ,\Lambda  \Delta  \Omega .
The behavior of a Jif/split system can now be seen as a labeled transition system inwhich the states are system configurations and the transitions are actions. The notation

\Lambda *\Upsilon  +\Upsilon  ,ss\Pi  `

O/AE''oe_ \Lambda *\Sigma \Upsilon  +\Sigma \Upsilon  , \Sigma 

ss\Pi 

indicates that the left configuration transitions via the action \Theta \Lambda \Upsilon  #\Lambda  to yield the right
configuration. The effects of the transition on the configuration depend on the action.

180
For example, a successful \Theta ssae\Pi ae request will cause a good host \Lambda  to pop its local token
stack. Thus, for that transition *\Sigma O/ \Delta  pop\Theta *O/\Lambda . Other effects, such as passing a token to abad host, relate

,ss and , \Sigma ss. The proof cases in Section 8.4.5 describe the effects of eachtransition.

Not every transition sequence is possible--some are ruled out by the static con-straints, while some are ruled out by the dynamic checks of good hosts. Thus, we must
make some further modeling assumptions about the valid transition systems.

" If, during a computation, the configuration * transitions to a configuration * \Sigma 

via an action performed by a good host, then that action is actually the result ofevaluating an entry point on that host:

\Lambda *\Upsilon  +\Upsilon  ,ss\Pi  `

O/AE''oe_ \Lambda *\Sigma \Upsilon  +\Sigma \Upsilon  , \Sigma 

ss\Pi ss\Lambda  \Sigma  0& \Upsilon  ., \Sigma  ;O/\Upsilon  AE\Upsilon  * \Pi  \Theta ,\Theta AE\Upsilon  *\Lambda  \Delta  \Theta \Lambda \Upsilon  #\Lambda \Lambda ss+\Theta ,\Lambda 

" If the initiator of an action is a bad host or an entry point in ;!, then any tokens

appearing in the action are available to the bad hosts (they are in the set ,ss).

" Communication between bad hosts does not change the relevant parts of the globalstate:

\Lambda *\Upsilon  +\Upsilon  ,ss\Pi  `

O/AE''oe_ \Lambda *\Sigma \Upsilon  +\Sigma \Upsilon  , \Sigma 

ss\Pi  ss \Lambda  \Sigma  0! ss \Lambda \Xi \Sigma fl \Theta #\Lambda  \Sigma  0!\Upsilon 

\Theta * \Delta  *\Sigma \Upsilon  + \Delta  +\Sigma \Upsilon  ,ss \Delta  , \Sigma ss\Lambda 

8.4.4 The stack integrity invariant
This section defines the stack integrity invariant, which will establish the correctnessof control-transfer protocol. First, we define some useful notation for describing the

relevant properties of the system configurations.Each token

* \Delta  fl\Lambda \Upsilon  AE\Upsilon  ,ffiOE\Psi  generated by a good host \Lambda  corresponds to the entry point
,. Because tokens are hashed with a private key, it is possible to distinguish tokens gen-erated by good hosts from tokens generated by bad hosts. For any token

*, let creator\Theta *\Lambda be the host that signed the token (in this case, host
\Lambda ). Using these pieces of information,
we can define the integrity level of a token as:

Ai \Delta  \Theta  A* \Lambda  \Delta  creator\Theta *\Lambda  \Sigma  0&A

O/ \Lambda  \Delta  creator\Theta *\Lambda  \Sigma  0!

Define a good token to be any token * for which Ai \Xi  :. Let ,& be the set of all good
tokens and ,! \Delta  , AE ,& be the set of bad tokens.Just as we have partitioned hosts and tokens into good and bad sets, we define

good
entry points and bad entry points. The set of low integrity entry points can be defined

181
as ;& \Delta  fl, * , \Sigma  ; ss A* i\Xi  :ffi. Correspondingly, let ;! \Delta  ; AE ;& be the set of
high-integrity entry points.Recall from Section 8.3 that the local stacks are intended to simulate a global integrity control stack (ICS) that corresponds to the program counter of the source pro-gram. Due to the presence of bad hosts, which may request

,o/\Xi \Psi  operations with low-integrity entry points located at good hosts, the global structure described by the composition of the local stacks may not be a stack. To see why, consider a bad host thatobtains a good token

* and then uses the good token in ,o/\Xi \Psi  requests to bad entry pointson two different good hosts,

\Lambda fl and \Lambda ffi. The resulting configuration of local stacks contains *O/\Delta  \Delta  \Pi  \Pi  \Pi  ' \Theta *fl\Upsilon  *\Lambda  and *O/\Theta  \Delta  \Pi  \Pi  \Pi  ' \Theta *ffi\Upsilon  *\Lambda . Thus the global ICS isn't a stack, but adirected, acyclic graph. However, the crucial part of the invariant is that the global ICS

is a stack with respect to good tokens.The key to defining the invariant is to relax the notion of "stack" with respect to bad
tokens. Observe that the global structure on , induced by the local stacks is captured bythe directed graph whose nodes are tokens in

, and whose edges are given by fl\Theta *\Upsilon  *\Sigma \Lambda  *
.\Lambda  \Sigma  0&\Pi \Theta *\Upsilon  *\Sigma \Lambda  \Sigma  *O/ffi. If this structure truly described a stack there would be a single
component:

*fl _ *ffi _ \Pi  \Pi  \Pi  *\Delta \Upsilon fl _ *\Delta 

with no other edges present. (Here *\Delta  is the bottom of the stack.) Instead, we show thatthe graph looks like:

7 _ *fl _ *ffi _ \Pi  \Pi  \Pi  *\Delta \Upsilon fl _ *\Delta 
where 7 is an arbitrary dag whose nodes are only bad tokens and *fl through *\Delta  are goodtokens.

We formalize the `7' part of the graph by observing that the edges in 7 and theones between

7 and *fl originate from a bad token. Because the good hosts' local stacks
change during a run of the system, it is convenient to define some notation that letsus talk about this property in a given configuration. Let

* be a system configuration,
\Lambda *\Upsilon  +\Upsilon  ,ss\Pi . Define:

* /\Xi  *\Sigma  ' .\Lambda  \Sigma  0&\Pi \Theta *\Upsilon  *\Sigma \Lambda  \Sigma  *O/ ss * \Sigma  ,!
The relation * /\Xi  *\Sigma  says that the bad token * appears immediately before the token
*\Sigma  in the graph above. Its transitive closure * /\Phi \Xi  *\Sigma  says that there are bad tokens !fl
through !\Delta  such that

* _ !fl _ \Pi  \Pi  \Pi  _ !\Delta  _ *\Sigma 

appears as part of the ICS--these bad tokens are a subgraph of the dag 7. Note that *\Sigma 
may be either a good or a bad token. Property (iv) of the invariant (see below) says thatthere is at most one good token reachable through the relation

/\Phi \Xi --that is, at most one
good token can be a successor of 7, the bad portion of the ICS.

182
If we conservatively assume that all bad tokens are available to the bad hosts, then
* /\Phi \Xi  *\Sigma  says that the bad hosts can "get to" the token *\Sigma  by doing an appropriate series of
\Theta ssae\Pi ae operations (each of which will pop a *\Pi  off the ICS).We next define some auxiliary concepts needed to state the stack invariant:

Tok\Xi  \Delta  fl* * .\Lambda  \Sigma  0&\Pi * \Sigma  fst\Theta *O/\Lambda ffiTok

\Xi \Theta \Lambda \Lambda  \Delta  fst\Theta *O/\Lambda  whenever \Lambda  \Sigma  0&Active

\Xi \Theta *\Lambda  ' * \Sigma  Tok\Xi  ss .*\Sigma  \Sigma  ,ss\Pi \Theta * \Delta  *\Sigma \Lambda  ae \Theta *\Sigma  /\Phi \Xi  *\Lambda 

The set Tok\Xi  is just the set of tokens appearing in the left part of any good host's localstack--this is a set of tokens for which some good host might grant an

\Theta ssae\Pi ae request
(it is conservative because it includes all the left-hand-side tokens of the stack, not justthe top of the stack). The set Tok

\Xi \Theta \Lambda \Lambda  is the restriction of Tok\Xi  to a particular good host
\Lambda . Tok\Xi \Theta \Lambda \Lambda  is exactly the set of tokens issued by \Lambda  that have not been consumed by

a valid \Theta ssae\Pi ae request. Finally, the predicate Active\Xi \Theta *\Lambda  determines the subset of Tok\Xi "reachable" from the tokens available to bad hosts.

Definition 8.4.1 A configuration * satisfies the Stack Integrity Invariant (SII) if and
only if:

(i) j*\Upsilon  *\Sigma  \Sigma  ,&\Pi Active\Xi \Theta *\Lambda  ss Active\Xi \Theta *\Sigma \Lambda  \Upsilon  * \Delta  *\Sigma 

Uniqueness of exposed, good tokens.

(ii) ., \Sigma  ;&\Pi  +\Theta ,\Lambda  \Upsilon  &.* \Sigma  ,&\Pi Active\Xi \Theta *\Lambda 

When good code has control, there are no good, active tokens.

(iii) j,\Upsilon  ,\Sigma  \Sigma  ;&\Pi  +\Theta ,\Lambda  ss +\Theta ,\Sigma \Lambda  \Upsilon  , \Delta  ,\Sigma 

Good code is single threaded.

(iv) j*fl\Upsilon  *\Sigma fl\Upsilon  *ffi\Upsilon  *\Sigma ffi\Pi  \Theta *fl /\Phi \Xi  *\Sigma fl\Lambda  ss \Theta *ffi /\Phi \Xi  *\Sigma ffi\Lambda  ss \Theta *\Sigma fl\Upsilon  *\Sigma ffi \Sigma  ,&\Lambda  \Upsilon  *\Sigma fl \Delta  *\Sigma ffi

Unique good successor token.

(v) j\Lambda fl\Upsilon  \Lambda ffi \Sigma  0&\Pi  \Lambda fl i\Delta  \Lambda ffi \Upsilon  Tok\Xi \Theta \Lambda fl\Lambda  O/ Tok\Xi \Theta \Lambda ffi\Lambda  \Delta  o/.

No two good hosts generate identical tokens.

(vi) j\Lambda  \Sigma  0&\Pi  *O/ \Delta  \Theta *fl\Upsilon  *\Sigma fl\Lambda  ' \Pi  \Pi  \Pi  \Theta *\Delta \Upsilon  *\Sigma \Delta \Lambda  \Upsilon  *fl through *\Delta  are pairwise distinct.
Stack Integrity Theorem If * is a configuration satisfying the SII and * transitions to
*\Sigma , then *\Sigma  satisfies the SII.

Note that condition (i) of the SII implies that if * is a good token on the top of
some good host's local stack and * has been handed out as a capability to the bad hosts

183
(* \Sigma  ,ss), then * is unique--there are no other such capabilities available to the bad hosts.
Because only good hosts can create such tokens, and they do so only by following thesource program's control flow, the bad hosts cannot subvert the control-flow of highintegrity computation.

8.4.5 Proof of the stack integrity theorem
Suppose * \Delta  \Lambda *\Upsilon  +\Upsilon  ,ss\Pi  is a configuration satisfying the Stack Integrity Invariant (SII).
To show that our system preserves the SII, we reason by cases on all the possible actionsin the system. In other words, we want to show that after any possible action, the resulting system configuration * \Sigma  \Delta  \Lambda *\Sigma \Upsilon  +\Sigma \Upsilon  , \Sigma ss\Pi  still satisfies SII. Note that, by assumption,any communication between bad hosts does not change the state of the configuration, so
we may safely eliminate those cases. We first make a few observations:

1. If *\Sigma  \Delta  * then invariants (iv), (v), and (vi) hold trivially because they depend onlyon the state of the local stacks.

2. If *\Sigma  \Delta  * and , \Sigma ss \Delta  ,ss then Active\Xi \Delta  \Delta  Active\Xi  and invariant (i) is satisfied

trivially.

3. Changing the running predicate of a bad entry point does not affect invariants (ii)or (iii)--changing the running predicate on good entries, or changing Active

\Xi  mayaffect (ii) and (iii).

Case I. * transitions via \Theta \Lambda fl\Upsilon  \Omega ssae\Pi ae\Theta \Lambda ffi\Upsilon  AEffi\Upsilon  ,ffi\Upsilon  *\Lambda \Lambda .

(a) \Lambda fl \Sigma  0!, \Lambda ffi \Sigma  0&, and 6O/\Delta  i\Xi  6*\Theta  .

In this case, because \Lambda ffi is a good host, the dynamic check on \Omega ssae\Pi ae prevents
the system configuration from changing. Thus * \Sigma  \Delta  *, and the invariant isimmediate.

(b) \Lambda fl \Sigma  0!, \Lambda ffi \Sigma  0&, and 6O/\Delta  \Xi  6*\Theta  .

Because \Lambda fl \Sigma  0!, we have 6O/\Delta  i\Xi  : and thus 6*\Theta  i\Xi  :. Consequently, ,ffi \Sigma 
;!. Thus , \Sigma ss \Delta  ,ss OE fl*ffi \Delta  ,ss, +\Sigma  \Delta  +ss,ffi %_ \Pi ae, and *\Sigma  \Delta  *. Observations1, 2, and 3 show that all of the invariants but (ii) hold for

* \Sigma . Invariant (ii)
follows from the fact that Active\Xi \Delta  \Delta  Active\Xi  and the fact that invariant (ii)holds in

*.

(c) \Lambda fl \Sigma  0& and \Lambda ffi \Sigma  0!.

By the modeling assumptions, there exists an ,fl \Sigma  ;O/\Delta  such that

,fl\Theta AEfl\Upsilon  *\Lambda  \Delta  \Theta \Lambda fl\Upsilon  \Omega ssae\Pi ae\Theta \Lambda ffi\Upsilon  AEffi\Upsilon  ,ffi\Upsilon  *\Lambda \Lambda 

184
for some AEfl and, furthermore, +\Theta ,fl\Lambda  holds. In the new configuration, , \Sigma ss \Delta 
,ss OE fl*ffi, +\Sigma  \Delta  +ss,fl %_ `ae, and *\Sigma  \Delta  *. Observation 1 shows that invariants(iv), (v) and (vi) hold trivially because

*\Sigma  \Delta  *. Note that we also have
/\Phi \Xi \Delta /\Phi \Xi \Delta .

If ,fl \Sigma  ;! then * \Sigma  ,ss, so , \Sigma ss \Delta  ,ss and observations 2 and 3 imply that * \Sigma 
satisfies the SII.

Otherwise ,fl \Sigma  ;& and by invariant (iii) of state * no other good entrypoints are running. Thus, in

* \Sigma  we have j, \Sigma  ;&\Pi &+\Theta ,\Lambda  and it follows that
invariants (ii) and (iii) hold in * \Sigma . Now we must show that invariant (i) holds.Consider an arbitrary good token

! \Sigma  ,&. Because , \Sigma ss \Delta  ,ss OE fl*ffi we have

Active\Xi \Delta \Theta !\Lambda  ' ! \Sigma  Tok\Xi \Delta  ss .!\Sigma  \Sigma  , \Sigma ss\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi \Delta  !\Lambda 

' ! \Sigma  Tok\Xi  ss .!\Sigma  \Sigma  ,ss OE fl*ffi\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi  !\Lambda 
' ss* \Sigma  Tok\Xi  ss \Theta ! \Delta  * ae * /\Phi \Xi  !\Lambda ae ae Active\Xi \Theta !\Lambda 

By invariant (ii) of configuration *, we have ! \Sigma  ,& \Upsilon  &Active\Xi \Theta !\Lambda and so

! \Sigma  ,& ss Active\Xi \Delta \Theta !\Lambda  implies * \Sigma  Tok\Xi  ss \Theta ! \Delta  * ae * /\Phi \Xi  !\Lambda . If
* \Sigma  ,& then by the definition of /\Phi \Xi  we have &.!\Pi * /\Phi \Xi  ! and consequently
! \Sigma  ,& ss Active\Xi \Delta \Theta !\Lambda  \Upsilon  ! \Delta  *, from which invariant (i) follows immediately. Otherwise, * \Sigma  ,! and we have that !fl\Upsilon  !ffi \Sigma  ,& ss Active\Xi \Delta \Theta !fl\Lambda  ssActive

\Xi \Delta \Theta !ffi\Lambda  \Upsilon  * /\Phi \Xi  !fl ss * /\Phi \Xi  !ffi, but now invariant (iv) of configuration
* implies that !fl \Delta  !ffi as needed. Thus invariant (i) holds in * \Sigma .

(d) \Lambda fl \Sigma  0& and \Lambda ffi \Sigma  0& and AO/\Delta  i\Xi  A*\Theta .

By the modeling assumptions, there exists an ,fl \Sigma  ;O/\Delta  such that

,fl\Theta AEfl\Upsilon  *\Lambda  \Delta  \Theta \Lambda fl\Upsilon  \Omega ssae\Pi ae\Theta \Lambda ffi\Upsilon  AEffi\Upsilon  ,ffi\Upsilon  *\Lambda \Lambda 
for some frame AEfl and, furthermore, +\Theta ,fl\Lambda  holds. After the transition, we
have +\Sigma  \Delta  +ss,fl %_ `ae, and, due to the run-time check performed by \Lambda ffi,we also have

, \Sigma ss \Delta  ,ss, and *\Sigma  \Delta  *. Invariants (i), (iv), (v) and (vi) followimmediately from observations 1 and 2. If

,fl \Sigma  ;! then invariants (ii) and
(iii) are a direct consequence of the assumption that they hold in * \Sigma . Tosee that (ii) and (iii) hold when

,fl \Sigma  ;&, note that because +\Theta ,fl\Lambda  we have
j, \Sigma  ;&\Pi +\Theta ,\Lambda  \Upsilon  , \Delta  ,fl (from invariant (iii)). Because +\Sigma  agrees with +
everywhere but ,fl, (iii) holds of +\Sigma  too. The same reasoning shows that (ii)holds.

(e) \Lambda fl \Sigma  0& and \Lambda ffi \Sigma  0& and AO/\Delta  \Xi  A*\Theta .

By the modeling assumptions, there exists an ,fl \Sigma  ;O/\Delta  such that

,fl\Theta AEfl\Upsilon  *\Lambda  \Delta  \Theta \Lambda fl\Upsilon  \Omega ssae\Pi ae\Theta \Lambda ffi\Upsilon  AEffi\Upsilon  ,ffi\Upsilon  *\Lambda \Lambda 

185
for some frame AEfl and, furthermore, +\Theta ,fl\Lambda  holds. After the transition, we
have

+\Sigma  \Delta  +ss,fl %_ `aess,ffi %_ \Pi ae

and *\Sigma  \Delta  *. This latter fact and observation 1 implies that invariants (iv), (v),and (vi) hold in

*\Sigma . Note also that /\Phi \Xi \Delta \Delta /\Phi \Xi .

If ,fl \Sigma  ;!, the modeling assumption tells us that , \Sigma ss \Delta  ,ss OE fl*ffi \Delta  ,ssbecause

* \Sigma  ,ss. Note that because \Lambda fl is a good host, the static constraint on
\Omega ssae\Pi ae implies that A*\Delta  \Xi  A*\Theta , which in turn implies that A*\Theta  i\Xi  : and thus
,ffi \Sigma  ;!. Invariants (i), (ii), and (iii) follow immediately from observations2 and 3, plus the fact that

+\Sigma  agrees with + on all good entry points.

Otherwise, ,ffi \Sigma  ;&. If ,fl \Sigma  ;& then , \Sigma ss \Delta  ,ss because * is not passed
to a bad entry point. Consequently, Active\Xi \Delta  \Delta  Active\Xi  and invariant (i)follows immediately. Because

+\Theta ,fl\Lambda  ss ,fl \Sigma  ;&, invariant (iii) of * impliesthat no other good entry points are running in predicate

+. Thus, because
+\Sigma  \Delta  +ss,fl %_ `aess,ffi %_ \Pi ae it is trivial to show that +\Sigma \Theta ,\Lambda  ss , \Sigma  ;& \Upsilon  , \Delta  ,ffi,as required. Furthermore,

+\Theta ,fl\Lambda  implies that &.* \Sigma  ,&\Pi Active\Xi \Theta *\Lambda  and so
invariant (ii) holds in configuration * \Sigma  too.

The last case is when ,fl \Sigma  ;& and ,ffi \Sigma  ;!, but this case follows exactly as
in the last paragraph of case I(c).

Case II. * transitions via \Theta \Lambda fl\Upsilon  \Theta ssae\Pi ae\Theta *\Lambda \Lambda  where * \Delta  fl\Lambda ffi\Upsilon  AEffi\Upsilon  ,ffiffiOE\Psi \Theta  .

(a) \Lambda fl \Sigma  0!\Upsilon  \Lambda ffi \Sigma  0& and top\Theta *O/\Theta \Lambda  i\Delta  \Theta *\Upsilon  *\Sigma \Lambda .

In this case, because \Lambda ffi is a good host, the dynamic check on \Theta ssae\Pi ae prevents thesystem configuration from changing. Thus

* \Sigma  \Delta  *, and the invariant is immediate.

(b) \Lambda fl \Sigma  0!\Upsilon  \Lambda ffi \Sigma  0& and top\Theta *O/\Theta \Lambda  \Delta  \Theta *\Upsilon  *\Sigma \Lambda  for some token *\Sigma .

Note that * \Sigma  Tok\Xi , and by the modeling assumption, * \Sigma  ,ss and, consequently,
we have Active\Xi \Theta *\Lambda . Because \Lambda ffi pops its local stack, invariants (v) and (vi) ofconfiguration

* imply that Tok\Xi \Delta \Theta \Lambda ffi\Lambda  \Delta  Tok\Xi \Theta \Lambda ffi\Lambda  AE fl*ffi and thus Tok\Xi \Delta  \Delta  Tok\Xi  AE
fl*ffi. Also note that because of the stack pop /\Phi \Xi \Delta ffl/\Phi \Xi , which implies that SII(iv)
holds in configurations * \Sigma . Invariants (v) and (vi) hold in *\Sigma  directly because theyhold in

*. There are two final cases to consider:

1. * \Sigma  ,&

186
It follows that ,ffi \Sigma  ;&, and thus , \Sigma ss \Delta  ,ss. Furthermore, +\Sigma  \Delta  +ss,ffi %_ \Pi ae.
We now show that Active\Xi \Delta \Theta !\Lambda  \Upsilon  Active\Xi \Theta !\Lambda :

Active\Xi \Delta  \Theta !\Lambda  ' ! \Sigma  Tok\Xi \Delta  ss .!\Sigma  \Sigma  , \Sigma ss\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi \Delta  !\Lambda 

' ! \Sigma  \Theta Tok\Xi  AE fl*ffi\Lambda  ss .!\Sigma  \Sigma  ,ss\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi \Delta  !\Lambda 
\Upsilon  ! \Sigma  Tok\Xi  ss .!\Sigma  \Sigma  ,ss\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi  !\Lambda 
' Active\Xi \Theta !\Lambda 

We show that in *\Sigma  it is the case that j! \Sigma  ,&\Pi &Active\Xi \Delta \Theta !\Lambda , from whichinvariants (i) and (ii) follow directly. Suppose for the sake of contradiction

that Active\Xi \Delta \Theta !\Lambda  for some ! \Sigma  ,&. Then, by the implication above, we haveActive

\Xi \Theta !\Lambda . Recall that Active\Xi \Theta *\Lambda , and so by invariant (ii) of the configura-tion
*, we have ! \Delta  *. But, Active\Xi \Delta \Theta !\Lambda  \Upsilon  ! \Sigma  Tok\Xi \Delta  \Delta  Tok\Xi  AE fl*ffi, which

implies that ! i\Delta  *, a contradiction.

Lastly, we must show that SII(iii) holds in configuration * \Sigma . We know that
+\Sigma \Theta ,ffi\Lambda  \Delta  \Pi . Suppose , \Sigma  ;& and assume , i\Delta  ,ffi. We must show that
&+\Sigma \Theta ,\Lambda . But, +\Sigma \Theta ,\Lambda  \Delta  +ss,ffi %_ \Pi ae\Theta ,\Lambda  \Delta  +\Theta ,\Lambda . Recalling once more thatActive

\Xi \Theta *\Lambda  ss * \Sigma  ,&, the contrapositive of SII(ii) for configuration * impliesthat
&+\Theta ,\Lambda  as desired.

2. * \Sigma  ,!

It follows that ,ffi \Sigma  ;!, and thus , \Sigma ss \Delta  ,ss OE fl*\Sigma ffi. Furthermore, +\Sigma  \Delta 
+ss,ffi %_ \Pi ae and we immediately obtain invariant (iii) via observation 3. First
note that * /\Xi  *\Sigma  because \Theta *\Upsilon  *\Sigma \Lambda  \Sigma  *O/\Theta , and, consequently, if *\Sigma  \Sigma  ,! we have
* /\Phi \Xi  ! ss ! i\Delta  *\Sigma  \Upsilon  *\Sigma  /\Phi \Xi  ! for any !. We need this fact to derive theimplication marked

= below:

Active\Xi \Delta \Theta !\Lambda  ' ! \Sigma  Tok\Xi \Delta  ss .!\Sigma  \Sigma  , \Sigma ss\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi \Delta  !\Lambda 

' ! \Sigma  \Theta Tok\Xi  AEfl*ffi\Lambda  ss .!\Sigma  \Sigma  ,ss OE fl*\Sigma ffi\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi \Delta  !\Lambda 
= \Upsilon  ! \Sigma  Tok\Xi  ss \Theta \Theta ! \Delta  *\Sigma \Lambda  ae .!\Sigma  \Sigma  ,ss\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi \Delta  !\Lambda \Lambda 

' \Theta ! \Sigma  Tok\Xi  ss ! \Delta  *\Sigma \Lambda  ae Active\Xi \Theta !\Lambda 

If *\Sigma  \Sigma  Tok\Xi , then by definition, we have Active\Xi \Theta *\Sigma \Lambda ; otherwise in the left
conjunct above we have \Theta ! \Sigma  Tok\Xi  ss ! \Delta  *\Sigma  ss *\Sigma  i\Sigma  Tok\Xi \Lambda  \Delta  `. Thus, in eithercase, the expression above reduces to Active

\Xi \Theta !\Lambda  and we have Active\Xi \Delta \Theta !\Lambda  \Upsilon Active
\Xi \Theta !\Lambda . Invariant (i) in *\Sigma  follows directly from invariant (i) of *; simi-larly because

+\Sigma  agrees with + on good entry points, invariant (ii) in * \Sigma  fol-lows directly from invariant (ii) of

*.

(c) \Lambda fl \Sigma  0& and \Lambda ffi \Sigma  0&, and top\Theta *O/\Theta \Lambda  i\Delta  \Theta *\Upsilon  *\Sigma \Lambda .

By the modeling assumptions, there exists an ,fl \Sigma  ;O/\Delta  such that

,fl\Theta AEfl\Upsilon  *\Lambda  \Delta  \Theta \Lambda fl\Upsilon  \Theta ssae\Pi ae\Theta *\Lambda \Lambda 

187
for some AEfl and, furthermore, +\Theta ,fl\Lambda  holds. Because \Lambda fl \Sigma  0&, we have +\Sigma  \Delta 
+ss,fl %_ `ae, but the static checks performed by good host \Lambda ffi imply that *\Sigma  \Delta  * and
, \Sigma ss \Delta  ,ss. Invariant (ii) follows from the facts that +\Sigma \Theta ,\Lambda  \Upsilon  +\Theta ,\Lambda  and Active\Xi \Delta  \Delta Active

\Xi . The rest of the invariants follow directly from observations 1,2,and 3.
(d) \Lambda fl \Sigma  0& and \Lambda ffi \Sigma  0&, and top\Theta *O/\Theta \Lambda  \Delta  \Theta *\Upsilon  *\Sigma \Lambda .

By the modeling assumptions, there exists an ,fl \Sigma  ;O/\Delta  such that

,fl\Theta AEfl\Upsilon  *\Lambda  \Delta  \Theta \Lambda fl\Upsilon  \Theta ssae\Pi ae\Theta *\Lambda \Lambda 
for some AEfl and, furthermore, +\Theta ,fl\Lambda  holds. Because \Lambda fl \Sigma  0&, we have +\Sigma  \Delta 
+ss,fl %_ `aess,ffi %_ \Pi ae. Note that invariants (iv), (v) and (vi) for *\Sigma  follow directly
from the same invariants of *; popping *O/\Theta  implies that /\Phi \Xi \Delta ffl/\Phi \Xi .

If ,fl \Sigma  ;! then * \Sigma  ,ss and we use the same reasoning as in Case II.(b).
Otherwise, ,fl \Sigma  ;&. Note that invariant (ii) of configuration * implies that &.! \Sigma 
,&\Pi Active\Xi \Theta !\Lambda  and invariant (iii) implies that , \Sigma  ;& ss +\Theta ,\Lambda  \Upsilon  , \Delta  ,fl.

1. * \Sigma  ,&.In this case,

,ffi \Sigma  ;&. We first show that invariant (iii) holds in * \Sigma . We knowthat
+\Sigma \Theta ,ffi\Lambda  \Delta  \Pi , so let , \Sigma  ;& be given. We must show that +\Sigma \Theta ,\Lambda  \Upsilon  , \Delta  ,ffi.
Suppose for the sake of contradiction that +\Sigma \Theta ,\Lambda  and , i\Delta  ,ffi then

+\Sigma \Theta ,\Lambda  \Delta  +ss,fl %_ `aess,ffi %_ \Pi ae\Theta ,\Lambda  \Delta  +ss,fl %_ `ae\Theta ,\Lambda  ss +\Sigma \Theta ,\Lambda  \Upsilon  , i\Delta  ,fl
But this contradicts invariant (iii) of configuration * which says that , \Sigma 
;& ss +\Theta ,\Lambda  ss +\Theta ,fl\Lambda  \Upsilon  , \Delta  ,fl. We conclude that , \Delta  ,ffi as desired.

Next, we show that Active\Xi \Delta \Theta !\Lambda  \Upsilon  Active\Xi :

Active\Xi \Delta  \Theta !\Lambda  ' ! \Sigma  Tok\Xi \Delta  ss .!\Sigma  \Sigma  , \Sigma ss\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi \Delta  !\Lambda 

' ! \Sigma  \Theta Tok\Xi  AE fl*ffi\Lambda  ss .!\Sigma  \Sigma  ,ss\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi \Delta  !\Lambda 
\Upsilon  ! \Sigma  Tok\Xi  ss .!\Sigma  \Sigma  ,ss\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi  !\Lambda 
' Active\Xi \Theta !\Lambda 

From this implication and the fact that +\Theta ,fl\Lambda  holds, we use invariant (ii) toconclude that

&.* \Sigma  ,&\Pi Active\Xi \Delta \Theta *\Lambda . Consequently, *\Sigma  satisfies invariants (i)
and (ii) as required.

2. * \Sigma  ,!.In this case,

,ffi \Sigma  ;! and it follows that ,ffi i\Delta  ,fl. We show that there are nogood, running entry points in

* \Sigma : Let , \Sigma  ;& be given. We immediately have
that , i\Delta  ,ffi. If , \Delta  ,fl, then as required:

+\Sigma \Theta ,\Lambda  \Delta  +ss,fl %_ `aess,ffi %_ \Pi ae\Theta ,\Lambda  \Delta  +ss,fl %_ `ae\Theta ,\Lambda  \Delta  `\Pi 

188
Assuming , i\Delta  ,fl we have +\Sigma \Theta ,\Lambda  \Delta  +\Theta ,\Lambda , and by invariant (iii) of configuration * it follows that +\Theta ,\Lambda  \Delta  `. Thus, invariants (ii) and (iii) of configurations
*\Sigma  hold trivially.

To show invariant (i), note that , \Sigma ss \Delta  ,ss OE fl*\Sigma ffi.

Active\Xi \Delta \Theta !\Lambda  ' ! \Sigma  Tok\Xi \Delta  ss .!\Sigma  \Sigma  , \Sigma ss\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi \Delta  !\Lambda 

' ! \Sigma  Tok\Xi  AE fl*ffi ss .!\Sigma  \Sigma  ,ss OE fl*\Sigma ffi\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi \Delta  !\Lambda 
\Upsilon  ! \Sigma  Tok\Xi  ss \Theta \Theta ! \Delta  *\Sigma \Lambda  ae \Theta *\Sigma  /\Phi \Xi \Delta  !\Lambda 

ae .!\Sigma  \Sigma  ,ss\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi  !\Lambda \Lambda 
\Upsilon  \Theta ! \Sigma  Tok\Xi  ss \Theta \Theta ! \Delta  *\Sigma \Lambda  ae \Theta *\Sigma  /\Phi \Xi \Delta  !\Lambda \Lambda \Lambda  ae Active\Xi \Theta !\Lambda 

Let !\Upsilon  !\Sigma  \Sigma  ,& be given and suppose Active\Xi \Delta \Theta !\Lambda  ss Active\Xi \Delta \Theta !\Sigma \Lambda . Note thatinvariant (ii) of configuration

* implies that &.! \Sigma  ,&\Pi Active\Xi \Theta !\Lambda , thus we
have Active\Xi \Delta  \Theta !\Lambda  \Upsilon  \Theta ! \Sigma  Tok\Xi  ss \Theta ! \Delta  *\Sigma \Lambda  ae \Theta *\Sigma  /\Phi \Xi \Delta  !\Lambda \Lambda  and similarly,Active

\Xi \Delta \Theta !\Sigma \Lambda  \Upsilon  \Theta !\Sigma  \Sigma  Tok\Xi  ss \Theta !\Sigma  \Delta  *\Sigma \Lambda  ae \Theta *\Sigma  /\Phi \Xi \Delta  !\Sigma \Lambda \Lambda . Suppose ! \Delta  *\Sigma .Then
*\Sigma  \Sigma  ,& and from the definition of /\Phi \Xi \Delta  it follows that &\Theta *\Sigma  /\Phi \Xi \Delta  !\Sigma \Lambda which implies that

!\Sigma  \Delta  *\Sigma  \Delta  ! as required. Otherwise, we have *\Sigma  /\Phi \Xi \Delta  !,which means that
*\Sigma  \Sigma  ,! and it follows that *\Sigma  /\Phi \Xi \Delta  !\Sigma . But this implies
*\Sigma  /\Phi \Xi  ! ss *\Sigma  /\Phi \Xi  !\Sigma , so by invariant (iv) of configuration *, we have ! \Delta  !\Sigma .

(e) \Lambda fl \Sigma  0& and \Lambda ffi \Sigma  0!.

By the modeling assumptions, there exists an ,fl \Sigma  ;O/\Delta  such that

,fl\Theta AEfl\Upsilon  *\Lambda  \Delta  \Theta \Lambda fl\Upsilon  \Theta ssae\Pi ae\Theta *\Lambda \Lambda 
for some AEfl and, furthermore, +\Theta ,fl\Lambda  holds. Because \Lambda fl \Sigma  0&, we have +\Sigma  \Delta 
+ss,fl %_ `ae. Because host \Lambda ffi \Sigma  0! we have *\Sigma  \Delta  * and , \Sigma ss \Delta  ,ss. Invariant (ii)follows from the facts that

+\Sigma \Theta ,\Lambda  \Upsilon  +\Theta ,\Lambda  and Active\Xi \Delta  \Delta  Active\Xi . The rest of the
invariants follow directly from observations 1,2,and 3.

Case III. * transitions via \Theta \Lambda fl\Upsilon  ,o/\Xi \Psi \Theta \Lambda ffi\Upsilon  AEffi\Upsilon  ,ffi\Upsilon  *\Lambda \Lambda .

(a) \Lambda fl \Sigma  0! and \Lambda ffi \Sigma  0& and AO/\Delta  i\Xi  A*\Theta  .

In this case, because \Lambda ffi is a good host, the dynamic check on \Omega ssae\Pi ae prevents the
system configuration from changing. Thus * \Sigma  \Delta  *, and the invariant is immediate.

(b) \Lambda fl \Sigma  0! and \Lambda ffi \Sigma  0& and AO/\Delta  \Xi  A*\Theta  .

Because \Lambda ffi \Sigma  0&, we have *\Sigma O/\Theta  \Delta  *O/\Theta  ' \Theta *\Sigma \Upsilon  *\Lambda  where *\Sigma  \Delta  fl\Lambda ffi\Upsilon  AEffi\Upsilon  ,ffiffiOE\Psi \Theta  is afresh token. Invariants (v) and (vi) hold in

*\Sigma  because they hold in * and *\Sigma  is
fresh. Furthermore, because AO/\Delta  \Xi  A*\Theta  ss \Lambda fl \Sigma  0! it follows that A*\Theta  i\Xi  :, andconsequently

*\Sigma  \Sigma  ,!. +\Sigma  \Delta  + because no good host begins running after this
transition; invariant (iii) follows directly.

189
We next show that invariant (iv) is met. Observe that /\Xi \Delta  \Delta /\Xi  OEfl\Theta *\Sigma \Upsilon  *\Lambda ffi. In
particular, &.!\Pi ! /\Xi \Delta  *\Sigma  and so we have

! /\Phi \Xi \Delta  !\Sigma  ' \Theta ! /\Phi \Xi  !\Sigma \Lambda  ae \Theta ! \Delta  *\Sigma  ss * /\Phi \Xi  !\Sigma \Lambda 
Let !fl\Upsilon  !\Sigma fl\Upsilon  !ffi\Upsilon  !\Sigma ffi be given and suppose that \Theta !fl /\Phi \Xi \Delta  !\Sigma fl\Lambda  ss \Theta !ffi /\Phi \Xi \Delta  !\Sigma ffi\Lambda  ss \Theta !\Sigma fl\Upsilon  !\Sigma ffi \Sigma 
,&\Lambda . From the definition of /\Phi \Xi \Delta  we obtain:

ss\Theta !fl /\Phi \Xi  !\Sigma fl\Lambda  ae \Theta !fl \Delta  *\Sigma  ss * /\Phi \Xi  !\Sigma fl\Lambda ae ss ss\Theta !ffi /\Phi \Xi  !\Sigma ffi\Lambda  ae \Theta !ffi \Delta  *\Sigma  ss * /\Phi \Xi  !\Sigma ffi\Lambda ae
But for each of the four possible alternatives described above, invariant (iv) ofconfiguration

* implies that !\Sigma fl \Delta  !\Sigma ffi as needed. For example, if \Theta !fl /\Phi \Xi  !\Sigma fl\Lambda  ss
\Theta * /\Phi \Xi  !\Sigma ffi\Lambda  then instantiating (iv) with *fl \Delta  !fl\Upsilon  *\Sigma fl \Delta  !\Sigma fl\Upsilon  *ffi \Delta  *\Upsilon  *\Sigma ffi \Delta  !\Sigma ffi yields
!\Sigma fl \Delta  !\Sigma ffi. The other cases are similar.

Next we show that invariants (i) and (ii) are maintained. First, note that , \Sigma ss \Delta  ,ss OE
fl*\Sigma ffi because \Lambda ffi sends the fresh token to \Lambda fl. Also observe that Tok\Xi \Delta  \Delta  Tok\Xi  OEfl*\Sigma ffi
because \Lambda ffi has pushed \Theta *\Sigma \Upsilon  *\Lambda  onto its local stack. We use the fact that * \Sigma  ,ss inthe derivation marked

= below:

Active\Xi \Delta \Theta !\Lambda  ' ! \Sigma  Tok\Xi \Delta  ss .!\Sigma  \Sigma  , \Sigma ss\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi \Delta  !\Lambda 

' ! \Sigma  Tok\Xi  OE fl*\Sigma ffi ss .!\Sigma  \Sigma  ,ss OE fl*\Sigma ffi\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi \Delta  !\Lambda 
' ! \Sigma  Tok\Xi  OE fl*\Sigma ffi ss .!\Sigma  \Sigma  ,ss OE fl*\Sigma ffi\Pi \Theta ! \Delta  !\Sigma \Lambda 

ae\Theta !\Sigma  /\Phi \Xi  ! ae \Theta !\Sigma  \Delta  *\Sigma  ss * /\Phi \Xi  !\Lambda \Lambda 
= ' ! \Sigma  Tok\Xi  OE fl*\Sigma ffi ss .!\Sigma  \Sigma  ,ss OE fl*\Sigma ffi\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi  !\Lambda 

' ! \Sigma  Tok\Xi  OE fl*\Sigma ffi ss \Theta ! \Delta  *\Sigma  ae .!\Sigma  \Sigma  ,ss\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi  !\Lambda \Lambda 
' ! \Delta  *\Sigma  ae Active\Xi \Theta !\Lambda 

Note that, because *\Sigma  \Sigma  ,!, we have Active\Xi \Delta \Theta !\Lambda  ss ! \Sigma  ,& \Upsilon  Active\Xi \Theta !\Lambda .
Consequently, invariants (i) and (ii) hold in * \Sigma  because they hold in *.

(c) \Lambda fl \Sigma  0& and \Lambda ffi \Sigma  0!.

By the modeling assumptions, there exists an ,fl \Sigma  ;O/\Delta  such that

,fl\Theta AEfl\Upsilon  *\Lambda  \Delta  \Theta \Lambda fl\Upsilon  ,o/\Xi \Psi \Theta \Lambda ffi\Upsilon  AEffi\Upsilon  ,ffi\Upsilon  *\Lambda \Lambda 
for some frame AEfl. Furthermore, +\Theta ,fl\Lambda  holds. After this transition, *\Sigma  \Delta  *, and
, \Sigma ss \Delta  ,ss OE fl*ffi because * has been passed to a bad host. Observation 1 shows that
invariants (iv), (v) and (vi) hold immediately. The new running predicate is:

+\Sigma  \Delta  +ss,fl %_ `aesssend\Theta \Lambda ffi\Lambda O/\Delta  %_ \Omega ae
Where \Omega  can be either \Pi  or `, depending on whether the bad host \Lambda ffi replies with a
token to \Lambda fl. However, because \Lambda fl is a good host, the static constraints on inserting

190
,o/\Xi \Psi 's imply that AO/\Theta  \Xi  6\Theta flffi\Lambda . But then, because \Lambda ffi \Sigma  0!, it follows that
AO/\Theta  i\Xi  : \Upsilon  6\Theta flffi\Lambda  i\Xi  :. Furthermore, because the integrity label on the send\Theta \Lambda ffi\Lambda O/\Delta entry point is just

6\Theta flffi\Lambda , we have that send\Theta \Lambda ffi\Lambda O/\Delta  \Sigma  ;!. Thus, whether send\Theta \Lambda ffi\Lambda O/\Delta is running does not affect invariants (ii) and (iii).

Next we calculate the predicate Active\Xi \Delta , recalling that , \Sigma ss \Delta  ,ss OE fl*ffi:

Active\Xi \Delta \Theta !\Lambda  ' ! \Sigma  Tok\Xi \Delta  ss .!\Sigma  \Sigma  , \Sigma ss\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi \Delta  !\Lambda 

' ! \Sigma  Tok\Xi  ss .!\Sigma  \Sigma  ,ss OE fl*ffi\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi  !\Lambda 
' \Theta ! \Sigma  Tok\Xi  ss \Theta ! \Delta  * ae * /\Phi \Xi  !\Lambda \Lambda  ae Active\Xi \Theta !\Lambda 

1. ,fl \Sigma  ;&.In this case, because

+\Theta ,fl\Lambda  holds in configuration *, invariant (ii) tells us that
when ! \Sigma  ,& and Active\Xi \Delta \Theta !\Lambda  it is the case that \Theta ! \Sigma  Tok\Xi  ss\Theta ! \Delta  *ae* /\Phi \Xi  !\Lambda \Lambda .To show that invariant (i) holds in

* \Sigma , suppose !\Upsilon  !\Sigma  \Sigma  ,& ss Active\Xi \Delta  \Theta !\Lambda  ssActive

\Xi \Delta \Theta !\Sigma \Lambda . Then we have

ss! \Sigma  Tok\Xi  ss \Theta ! \Delta  * ae * /\Phi \Xi  !\Lambda ae ss ss!\Sigma  \Sigma  Tok\Xi  ss \Theta !\Sigma  \Delta  * ae * /\Phi \Xi  !\Sigma \Lambda ae
Now suppose * \Sigma  ,&. Then by definition &.*\Sigma \Pi * /\Phi \Xi  *\Sigma , so the above condition
on ! and !\Sigma  becomes !\Upsilon  !\Sigma  \Sigma  Tok\Xi  ss ! \Delta  * ss !\Sigma  \Delta  * as required. Otherwise, if
* \Sigma  ,!, it follows that ! i\Delta  * and !\Sigma  i\Delta  * and we have * /\Phi \Xi  ! and * /\Phi \Xi  !\Sigma . Butthen invariant (iv) of configuration

* implies that ! \Delta  !\Sigma  in this case as well.

To show that invariants (ii) and (iii) hold, we prove that &., \Sigma  ;&\Pi +\Sigma \Theta ,\Lambda .Suppose for contradiction that there was such an

,. By the definition of +\Sigma , weconclude that
, i\Delta  ,fl, but then +\Sigma \Theta ,\Lambda  \Delta  +\Theta ,\Lambda . From the modeling assumption,
we have +\Theta ,fl\Lambda , and yet invariant (iii) of configuration * implies that , \Delta  ,fl,a contradiction.

2. ,fl \Sigma  ;!.In this case, the modeling assumption tells us that

* \Sigma  ,ss, so , \Sigma ss \Delta  ,ss. Thisfact immediately yields that Active

\Xi \Delta  \Delta  Active\Xi , and observations 2 and 3,imply (i) and (iii) hold in
* \Sigma . Invariant (ii) in *\Sigma  also follows directly frominvariant (ii) in

*.

(d) \Lambda fl \Sigma  0& and \Lambda ffi \Sigma  0& and AO/\Delta  i\Xi  A*\Theta .

This case is identical to I.(d).

(e) \Lambda fl \Sigma  0& and \Lambda ffi \Sigma  0& and AO/\Delta  \Xi  A*\Theta .

By the modeling assumptions, there exists an ,fl \Sigma  ;O/\Delta  such that

,fl\Theta AEfl\Upsilon  *\Lambda  \Delta  \Theta \Lambda fl\Upsilon  ,o/\Xi \Psi \Theta \Lambda ffi\Upsilon  AEffi\Upsilon  ,ffi\Upsilon  *\Lambda \Lambda 

191
for some frame AEfl and, furthermore, +\Theta ,fl\Lambda  holds. Because \Lambda ffi \Sigma  0&, we have
*\Sigma O/\Theta  \Delta  *O/\Theta  ' \Theta *\Sigma \Upsilon  *\Lambda  where *\Sigma  \Delta  fl\Lambda ffi\Upsilon  AEffi\Upsilon  ,ffiffiOE\Psi \Theta  is a fresh token. Invariants (v) and(vi) hold in

*\Sigma  because they hold in * and *\Sigma  is fresh. After the transition, we have

+\Sigma  \Delta  +ss,fl %_ `aesssend\Theta \Lambda ffi\Lambda O/\Delta  %_ \Pi ae
1. ,ffi \Sigma  ;&

In this case, *\Sigma  \Sigma  ,&. It follows that &.!\Pi *\Sigma  /\Xi \Delta  !, and consequently /\Phi \Xi \Delta \Delta /\Phi \Xi ,from which we conclude that invariant (iv) holds in

* \Sigma . Because \Lambda fl \Sigma  0&the static constraints on
,o/\Xi \Psi  guarantee that A*\Delta  \Xi  A*\Theta  , which implies that
,fl \Sigma  ;&.

If send\Theta \Lambda fl\Lambda O/\Theta  \Sigma  ;& then , \Sigma ss \Delta  ,ss. We now show that j, \Sigma  ;&\Pi +\Sigma \Theta ,\Lambda  \Upsilon 
, \Delta  send\Theta \Lambda fl\Lambda O/\Theta , from which we may immediately derive that invariant (iii)
holds in *\Sigma . Let , \Sigma  ;& be given and suppose for the sake of contradictionthat

+\Sigma \Theta ,\Lambda  ss , i\Delta  send\Theta \Lambda fl\Lambda O/\Theta . From the definition of +\Sigma  we have +\Sigma \Theta ,\Lambda  \Delta 
+ss,fl %_ `ae\Theta ,\Lambda , and because +\Sigma \Theta ,\Lambda  holds, we have that , i\Delta  ,fl. Thus +\Sigma \Theta ,\Lambda  \Delta 
+\Theta ,\Lambda . But now invariant (iii) and the assumption that +\Theta ,fl\Lambda  holds in * implythat

, \Delta  ,fl, a contradiction. Note that , \Sigma ss \Delta  ,ss ss *\Sigma  \Delta  * \Upsilon  Active\Xi \Delta  \Delta Active

\Xi . Invariants (i) and (ii) follow directly from the fact that they hold inconfiguration

*.

Otherwise, send\Theta \Lambda fl\Lambda O/\Theta  \Sigma  ;! and , \Sigma ss \Delta  ,ss OE fl*\Sigma ffi. We first show that j, \Sigma 
;&\Pi &+\Sigma \Theta ,\Lambda , from which invariants (ii) and (iii) follow immediately. Let , \Sigma 
;& be given. We know that , i\Delta  send\Theta \Lambda fl\Lambda O/\Theta  because send\Theta \Lambda fl\Lambda O/\Theta  \Sigma  ;!; thusfrom the definition of

+\Sigma  we obtain +\Sigma \Theta ,\Lambda  \Delta  +ss,fl %_ `ae\Theta ,\Lambda . If ,fl \Delta  , we
are done. So we have that ,fl i\Delta  ,. Now, however, +\Theta ,\Lambda  ss \Theta , \Sigma  ;&\Lambda  impliesvia invariant (iii) of configuration

* that , \Delta  ,fl, a contradiction. Thus weconclude that
&+\Theta ,\Lambda  as desired.
It remains to show that invariant (i) holds in * \Sigma , so we calculate the predicateActive

\Xi \Delta . The step marked = below uses the fact that *\Sigma  \Sigma  ,& (which, from thedefinition of

/\Xi \Delta  implies that &.!\Pi *\Sigma  /\Phi \Xi \Delta  !):

Active\Xi \Delta \Theta !\Lambda  ' ! \Sigma  Tok\Xi \Delta  ss .!\Sigma  \Sigma  , \Sigma ss\Pi \Theta !\Sigma  \Delta  !\Lambda  ae \Theta !\Sigma  /\Phi \Xi \Delta  !\Lambda 

' ! \Sigma  Tok\Xi  OE fl*\Sigma ffi ss .!\Sigma  \Sigma  ,ss OE fl*\Sigma ffi\Pi \Theta !\Sigma  \Delta  !\Lambda  ae \Theta !\Sigma  /\Phi \Xi  !\Lambda 
= ' ! \Sigma  Tok\Xi  OE fl*\Sigma ffi ss ss\Theta ! \Delta  *\Sigma \Lambda  ae .!\Sigma  \Sigma  ,ss\Pi \Theta !\Sigma  \Delta  !\Lambda ae

\Theta !\Sigma  /\Phi \Xi  !\Lambda ae
\Upsilon  \Theta ! \Delta  *\Sigma \Lambda  ae Active\Xi \Theta !\Lambda 

Observe that invariant (ii) of configuration * implies that there does not exist
! \Sigma  ,& such that Active\Xi \Theta !\Lambda . Thus, Active\Xi \Delta \Theta !\Lambda  ss ! \Sigma  ,& \Upsilon  ! \Delta  *\Sigma , and
invariant (i) of configuration *\Sigma  follows directly.

192
2. ,ffi \Sigma  ;!

In this case, *\Sigma  \Sigma  ,!. We use exactly the same reasoning as in Case III(b).to prove that invariant (iv) holds. Note that because

\Lambda fl \Sigma  0&, the staticconstraints on
,o/\Xi \Psi  imply that ,fl \Sigma  ;& ' send\Theta \Lambda fl\Lambda O/\Theta  \Sigma  ;&.

In the case that ,fl \Sigma  ;!, we reason as in Case III(b). to show that invariants(i), (ii), and (iii) hold.

The last possibility is that ,fl \Sigma  ;&. Here, we have , \Sigma ss \Delta  ,ss because *\Sigma 
has not been passed to a bad entry point. Thus we can calculate Active\Xi \Delta  asfollows:

Active\Xi \Delta \Theta !\Lambda  ' ! \Sigma  Tok\Xi \Delta  ss .!\Sigma  \Sigma  , \Sigma ss\Pi \Theta ! \Delta  !\Sigma \Lambda  ae \Theta !\Sigma  /\Phi \Xi \Delta  !\Lambda 

' ! \Sigma  Tok\Xi  OE fl*\Sigma ffi ss .!\Sigma  \Sigma  ,ss\Pi \Theta ! \Delta  !\Sigma \Lambda 

aess\Theta !\Sigma  \Delta  *\Sigma  ss *\Sigma  /\Phi \Xi  !\Lambda  ae !\Sigma  /\Phi \Xi  !ae
= ' ! \Sigma  Tok\Xi  ss .!\Sigma  \Sigma  ,ss\Pi \Theta ! \Delta  !\Sigma \Lambda  ae !\Sigma  /\Phi \Xi  !

' Active\Xi \Theta !\Lambda 

In the reasoning above, the step marked = uses the fact that

*\Sigma  i\Sigma  ,ss ss &.!\Sigma \Pi !\Sigma  /\Phi \Xi \Delta  *\Sigma 
Invariant (i) follows directly from the fact that (i) holds in configuration *and the equivalence of Active

\Xi \Delta  and Active\Xi . To see that (ii) holds, note that
+\Theta ,fl\Lambda  \Upsilon  &.* \Sigma  ,&\Pi Active\Xi \Theta *\Lambda , but this implies &.* \Sigma  ,&\Pi Active\Sigma \Xi \Theta *\Lambda  asrequired. To establish invariant (iii), let

, \Sigma  ;& be given and suppose +\Theta ,\Lambda .We show that
, \Delta  send\Theta \Lambda fl\Lambda O/\Theta . Suppose by way of contradiction that , i\Delta send
\Theta \Lambda fl\Lambda O/\Theta . Then from the definition of +\Sigma  we have +\Sigma \Theta ,\Lambda  \Delta  +ss,fl %_ `ae\Theta ,\Lambda .By assumption

+\Sigma \Theta ,\Lambda  \Delta  \Pi  and it follows that , i\Delta  ,fl. But now +\Sigma \Theta ,\Lambda  \Delta  +\Theta ,\Lambda and invariant (iii) shows that

, \Delta  ,fl, a contradiction.

8.5 Translation
Given a program and host configuration, the splitting translation is responsible for as-signing a host to each field and statement. The Jif/split compiler takes as input the
annotated source program and a description of the known hosts. It produces as output
a set of Java files that yield the final split program when compiled against the run-timeinterface. There are several steps to this process.

In addition to the usual typechecking performed by an ordinary Java compiler, the
Jif/split front end collects security label information from the annotations in the pro-gram, performing label inference when annotations are omitted. This process results in

a set of label constraints that capture the information flows within the program. Next,

193
the compiler computes a set of possible hosts for each statement and field, subject to
the security constraints described in Section 8.2. If no host can be found for a field orstatement, the splitter conservatively rejects the program as being insecure.

There may also be many valid host assignments for each field or statement, in whichcase performance drives the host selection process. The splitter uses dynamic programming to synthesize a good solution by attempting to minimize the number of remotecontrol transfers and field accesses, two operations that dominate run-time overhead.
The algorithm works on a weighted control-flow graph of the program; the weight on
an edge represents an approximation to the run-time cost of traversing that edge.

This approach also has the advantage that principals may indicate a preference fortheir data to stay on one of severally equally trusted machines (perhaps for performance

reasons) by specifying a lower cost for the preferred machine. For example, to obtainthe example partition shown in Figure 8.4, Alice also specifies a preference for her
data to reside on host &, causing fields OE*, OE4, and \Lambda ,0\Psi \Psi \Phi ,,\Phi O/ to be located on host
&. Without the preference declaration, the optimizer determines that fewer networkcommunications are needed if these fields are located at

, instead. This alternativeassignment is secure because Alice trusts the server equally to her own machine.

After host selection, the splitter inserts the proper calls to the runtime, subject to the
constraints described in Section 8.3. An \Theta ssae\Pi ae must be inserted exactly once on everycontrol flow path out of the corresponding

,o/\Xi \Psi , and the ,o/\Xi \Psi -\Theta ssae\Pi ae pairs must be
well nested to guarantee the stack discipline of the resulting communication protocol.The splitter also uses standard dataflow analysis techniques to infer where to introduce

the appropriate data forwarding.

Finally, the splitter produces Java files that contain the final program fragments.
Each source Jif class % translates to a set of classes %$Iae,\Pi \Pi , one for each known host
\Lambda \Pi  \Sigma  0. In addition to the translated code fragments, each such class contains theinformation used by the runtime system for remote references to other classes. The

translation of a field includes accessor methods that, in addition to the usual get and setoperations, also perform access control checks (which are statically known, as discussed
in Section 8.2). In addition, each source method is represented by one frame class perhost. These frame classes correspond to the

H\Omega OE\Phi A2 arguments needed by the runtimesystem of Figure 8.3; they encapsulate the part of the source method's activation record

visible to a host.

8.6 Implementation
We have implemented the splitter and the necessary run-time support for executing par-titioned programs. Jif/split was written in Java as a 7400-line extension to the existing
Jif compiler. The run-time support library is a 1700-line Java program. Communica194
tion between hosts is encrypted using SSL (the Java Secure Socket Extension (JSSE)
library5, version 1.0.2). To prevent forging, tokens for entry points are hashed using theMD5 implementation from the Cryptix library, version 3.2.0.

6

To evaluate the impact of our design, we implemented several small, distributed pro-grams using the splitter. Because we are using a new programming methodology that

enforces relatively strong security policies, direct comparison with the performance ofother distributed systems was difficult; our primary concern was security, not performance. Nevertheless, the results are encouraging.

8.6.1 Benchmarks
We have implemented a number of programs in this system. The following four are splitacross two or more hosts:

" List compares two identical 100 element linked lists that must be located on dif-ferent hosts because of confidentiality. A third host traverses the lists.
" OT is the oblivious transfer program described earlier in this chapter. One hun-dred transfers are performed.
" Tax simulates a tax preparation service. A client's trading records are stored on a

stockbroker's machine. The client's bank account is stored at a bank's machine.Taxes are computed by a tax preparer on a third host. The principals have distinct

confidentiality concerns, and O/\Phi \Psi \Theta ,,\Lambda `o/ is used twice.
" Work is a compute-intensive program that uses two hosts that communicate relatively little.

Writing these programs requires adding security policies (labels) to some type dec-larations from the equivalent single-machine Java program. These annotations are 11-

25% of the source text, which is not surprising because the programs contain complexsecurity interactions and little real computation.

8.6.2 Experimental Setup
Each subprogram of the split program was assigned to a different physical machine.
Experiments were run on a set of three 1.4 GHz Pentium 4 PCs with 1GB RAM run-ning Windows 2000. Each machine is connected to a 100 Mbit/second Ethernet by a

3Com 3C920 controller. Round-trip ping times between the machines average about

5#,,\Delta AE))*fl+flae*io/ae'\Theta ss)\Delta oe\Theta ffii',*)***\Xi )
6#,,\Delta AE)),,,ae'oe_\Delta ,`-ae\Theta oeOE)\Delta oe\Theta ffii',*)'oe_\Delta ,`-\Sigma \Psi )

195
Table 8.1: Benchmark measurements
Metric List OT Tax Work OT-h Tax-h
Lines 110 50 285 45 175 400
Elapsed time (sec) 0.51 0.33 0.58 0.49 0.28 0.27
Total messages 1608 1002 1200 600 800 800

\Delta \Lambda ffoejffo/ (`2) 400 101 300 0 - -
ffi\Phi \Sigma AE\Pi \Phi \Xi o/ (`2) 2 100 0 0 - -
\Xi ffi\Lambda \Sigma \Lambda  402 200 0 300 - -
ffffi\Lambda \Sigma \Lambda  402 400 600 300 - -
Eliminated (`2) 402 600 400 300 - -

310 ?s. This LAN setting offers a worst-case scenario for our analysis--the overheadsintroduced by our security measures are relatively more costly than in an Internet setting. Even for our local network, network communication dominates performance. All
benchmark programs were run using SSL, which added more overhead: the medianapplication-to-application round-trip time was at least 640

?s for a null Java RMI 7 call
over SSL.

All benchmarks were compiled with version 1.3.0 of the Sun J)\Psi  compiler, and
run with version 1.3.0 of the Java HotSpot Client VM. Compilation and dynamic-linkingoverhead is not included in the times reported.

8.6.3 Results
For all four benchmarks, we measured both running times and total message countsso that performance may be estimated for other network configurations. The first row

of Table 8.1 gives the length of each program in lines of code. The second row givesthe median elapsed wall-clock time for each program over 100 trial runs. The following rows give total message counts and a breakdown of counts by type (`ae\Omega /\Omega O/ and
ss\Phi \Pi H\Lambda \Phi \Theta O/ calls require two messages). The last row shows the number of `ae\Omega /\Omega O/messages eliminated by piggybacking optimizations described below.

For performance evaluation, we used Java RMI to write reference implementationsof the Tax and OT programs and then compared them with our automatically generated
programs. These results are shown in the columns OT-h and Tax-h of Table 8.1. Writ-ing the reference implementation securely and efficiently required some insight that we
obtained from examining the corresponding partitioned code. For example, in the OT
example running on the usual three-host configuration, the code that executes on Alice's

7#,,\Delta AE))*fl+flae*io/ae'\Theta ss)\Delta oe\Theta ffii',*)*ffi\Lambda )oess`)

196
machine should be placed in a critical section to prevent Bob from using a race condition to steal both hidden values. The partitioned code automatically prevents the racecondition.

The hand-coded implementation of OT ran in 0.28 seconds; the automatically partitioned program ran in 0.33 seconds, a slowdown of 1.17. The hand-coded version ofTax also ran in 0.27 seconds; the partitioned program ran in 0.58 seconds, a slowdown

of 2.17. The greater number of messages sent by the partitioned programs explains mostof this slowdown. Other sources of added overhead turn out to be small:

" Inefficient translation of local code
" Run-time checks for incoming requests
" MD5 hashing to prevent forging and replaying of tokens

The prototype Jif/split compiler attempts only simple optimizations for the codegenerated for local use by a single host. The resulting Java programs are likely to have

convoluted control flow that arises as an artifact of our translation algorithm--the intermediate representation of the splitter resembles low-level assembly code more thanJava. This mismatch introduces overheads that the hand-coded programs do not incur.

The overhead could be avoided if Jif/split generated Java bytecode output directly; how-ever, we leave this to future work.

Run-time costs also arise from checking incoming requests and securely hashing
tokens. These costs are relatively small: The cost of checking incoming messages isless than 6% of execution time for all four example programs. The cost of token hashing accounted for approximately 15% of execution time across the four benchmarks.Both of these numbers scale with the number of messages in the system. For programs
with more substantial local computations, we would expect these overheads to be less
significant.For a WAN environment, the useful point of comparison between the hand-coded

and partitioned programs is the total number of messages sent between hosts. Interestingly, the partitioned Tax and OT programs need fewer messages for control transfersthan the hand-coded versions. The hand-coded versions of OT and Tax each require

400 RMI invocations. Because RMI calls use two messages, one for invocation andone for return, these programs send 800 messages. While the total messages needed for
the Jif/split versions of OT and Tax are 1002 and 1200, respectively, only 600 of these
messages in each case are related to control transfers; the rest are data forwards. The im-provement over RMI is possible because the

\Omega ssae\Pi ae and \Theta ssae\Pi ae operations provide moreexpressive control flow than procedure calls. In particular, an RMI call must return to

the calling host, even if the caller immediately makes another remote invocation to athird host. By contrast, an

\Omega ssae\Pi ae or \Theta ssae\Pi ae may jump directly to the third host. Thus,
in a WAN environment, the partitioned programs are likely to execute more quickly

197
than the hand-coded program because control transfers should account for most of the
execution time.

8.6.4 Optimizations
Several simple optimizations improve system performance:

" Calls to the same host do not go through the network.
" Hashes are not computed for tokens used locally to a host.
" Multiple data forwards to the same recipient are combined into a single messageand also piggybacked on

\Theta ssae\Pi ae and \Omega ssae\Pi ae calls when possible. As seen in Table 8.1, this reduces `ae\Omega /\Omega O/ messages by more than 50% (the last row is thenumber of round trips eliminated).

A number of further simple optimizations are likely to be effective. For example,much of the performance difference between the reference implementation of OT and
the partitioned implementation arises from the server's ability to fetch the two fields OE*and

OE4 in a single request. This optimization (combining ss\Phi \Pi H\Lambda \Phi \Theta O/ requests) could beperformed automatically by the splitter as well.

Currently, `ae\Omega /\Omega O/ operations that are not piggybacked with control transfers re-quire an acknowledgment to ensure that all data is forwarded before control reaches
a remote host. It is possible to eliminate the race condition that necessitates this synchronous data forwarding. Because the splitter knows statically what forwards are ex-pected at every entry point, the generated code can block until all forwarded data has

been received. Data transfers that are not piggybacked can then be done in parallel withcontrol transfers. However, this optimization has not been implemented.

8.7 Trusted Computing Base
An important question for any purported security technique is the size and complexity ofthe

trusted computing base (TCB). All else being equal, a distributed execution platformsuffers from a larger TCB than a corresponding single-host execution platform because it

incorporates more hardware and software. On the other hand, the architecture describedhere may increase the participants' confidence that trustworthy hosts are being used to
protect their confidentiality.

What does a principal fl who participates in a collaborative program using this sys-tem have to trust? The declaration signed by

fl indicates to what degree fl trusts the
various hosts. By including a declaration of trust for a host \Lambda  in the declaration, fl must

198
trust the hardware of \Lambda  itself, the \Lambda 's operating system, and the splitter run-time support,
which (in the prototype implementation) implicitly includes Java's.Currently, the Jif/split compiler is also trusted. Ongoing research based on certified

compilation [MWCG98] or proof-carrying code [Nec97] might be used to remove the
compiler from the TCB and instead allow the bytecode itself to be verified [JVM95].Another obvious question about the trusted computing base is to what degree the

partitioning process itself must be trusted. It is clearly important that the subprogramsa program is split into are generated under the same assumptions regarding the trust relationships among principals and hosts. Otherwise, the security of principal fl might be
violated by sending code from different partitionings to hosts trusted by fl. A simple wayto avoid this problem is to compute a one-way hash of all the splitter's inputs--trust declarations and program text--and to embed this hash value into all messages exchanged
by subprograms. During execution, incoming messages are checked to ensure that theycome from the same version of the program.

A related issue is where to partition the program. It is necessary that the host thatgenerates the program partition that executes on host

\Lambda  be trusted to protect all data that
\Lambda  protects during execution. That is, the partitioning host could be permitted to serve in
place of \Lambda  during execution. A natural choice is thus \Lambda  itself: each participating host canindependently partition the program, generating its own subprogram to execute. That the

hosts have partitioned the same program under the same assumptions can be validatedusing the hashing scheme described in the previous paragraph. Thus, the partitioning
process itself can be decentralized yet secure.

8.8 Related Work
Besides the work on information flow already discussed in this thesis, the primary area
of research related to secure program partitioning is support for transparently distributedcomputation.

A number of systems (such as Amoeba and Sprite [DOKT91]) automatically redistribute computation across a distributed system to improve performance, though notsecurity. Various transparently distributed programming languages have been developed as well; a good early example is Emerald [JLHB88]. Modern distributed interfacelanguages such as CORBA [COR91] or Java RMI do not enforce end-to-end security
policies.

Jif and secure program partitioning are complementary to current initiatives for pri-vacy protection on the Internet. For example, the recent Platform for Privacy Preferences (P3P) [p3p] provides a uniform system for specifying users' confidentiality poli-cies. Security-typed languages such as Jif could be used for the implementation of a
P3P-compliant web site, providing the enforcement mechanisms for the P3P policy.

Chapter 9
Conclusions
This chapter summarizes the contributions of this thesis and ends with some potentialfuture directions.
9.1 Summary
This thesis has focused on the theory of various security-typed languages, in which pro-grammers can specify security policies about the data being used in the program. Static
program analysis can detect inconsistencies in the policy, revealing where insecuritymight arise.

One value of security-typed programming languages is that by formalizing the infor-mation-flow problem at a particular level of abstraction it is possible to rule out a certain
class of information leaks. Moreover, the abstractions used in the language definitionsuggest where additional security measures may be needed: for instance, the operating system access control mechanisms could perhaps be used to enforce the assumed
partitioning of memory into high- and low-security portions.

Security-typed languages also can potentially enforce a richer set of security policies than traditionally provided by discretionary access control mechanisms. Becausethe policy descriptions are incorporated into programs, security policy creation becomes

a matter of programming. Security policies that release secret data only in certain cir-cumstances are easy to express, whereas with traditional access control mechanisms, it
is difficult to conditionally release information.

This thesis extends the existing work on security-typed languages in a number ofways. It establishes a

noninterference result for a higher-order language with structured
memory. It also gives an expressive type system for noninterference in a concurrentprogramming language. These results highlight the importance of determinism and the

closely related notion of linearity in information-flow security. Finally, it considers the

199

200
additional constraints necessary to remove the assumption that all secure computation
takes place on a single, trusted computer.

This thesis also presents Jif/split, a prototype compiler for protection of confidential data in a distributed computing environment with heterogeneously trusted hosts.Security policy annotations specified in the source program allow the splitter to partition the code across the network by extracting a suitable communication protocol. The
resulting distributed system satisfies the confidentiality policies of principals involvedwithout violating their trust in available hosts. Jif/split also enforces integrity policies,

which is needed because of the interaction between integrity and confidentiality in thepresence of declassification. The Jif/split prototype demonstrates the feasibility of this
architecture. The experience with simple example programs has shown the benefits of
expressing security policies explicitly in the programming language, particularly withrespect to catching subtle bugs.

The prototype implementation of Jif/split benefited from the theoretical work onsecurity-typed languages in several ways. First, that the security types could guide
an automatic partitioning process became clear only after seeing how much additionalstructure they add to a program. Second, the proofs of noninterference for

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  leddirectly to the discovery of errors and inconsistencies in the implementation of similar

rules in the Jif compiler. Third, and most important, the insights about the role of orderedlinear continuations used in

\Delta \Lambda \Sigma \Delta \Delta \Theta \Lambda  had direct impact on the design of the control-transfermechanisms used in the Jif/split run time.

Building the prototype splitter also led to many observations about information security in a distributed setting. In particular, the Jif/split implementation revealed that Jif'soriginal rule for declassification was insufficient in a distributed setting. The Jif/split

prototype also validates the premise that security-typed programs can help programmers
find subtle security flaws in their software

9.2 Future Work
The work in this thesis and the Jif/split prototype have yielded some insight into the dif-ficulties of building distributed systems with strong end-to-end information-flow guarantees, but there is still much room for improvement.

This thesis has focused on one aspect of security: protecting information security.Other aspects, such as reliability and auditing of transactions, also play a role in the

security of distributed computations, and they should not be neglected.

Of course security and performance are often at odds, and the same is true here.
Jif/split assumes that the security of the data is more important than the performance ofthe system. However, encoding the security policy in the programming language makes

this trade-off more explicit: if the performance of a program under a certain security

201
policy is unsatisfactory, it is possible to relax the policy (for instance, by declaring more
trust in certain hosts, or by reducing the restrictions imposed by the label annotations).Under a relaxed policy, the compiler may be able to find a solution with acceptable

performance--the relaxed security policy spells out what security has been lost for performance. The prototype allows some control over performance by allowing the userto specify relative costs of communication between hosts. The host assignment tries to

find a minimum cost solution, but other constraints could be added--for example, theability to specify a particular host for a given field.

One serious drawback of the security-typed language approach is that the security
policy is decided upon either by the language designer, or the implementer of the pro-gram in question. This means that the

consumer of the software is not able to change orspecify the policy. This stands in contrast with, for example, the security automaton approach of Erlingsson and Schneider [ES99] in which security policies are applied by theuser. However, there is no reason why both techniques cannot be used simultaneously--
perhaps to great benefit on each side.Realistic policies do not fall into the simple noninterference-like models of information-flow security. Programs that involve declassification are potentially dangerous,
and understanding exactly what policy is enforced by a program that uses declassifi-cation is not always easy. Robust declassification and the authority model improve

over previous language-based approaches, but there is still not an appropriate theoreticalmodel for properly reasoning about declassification.

Finally, experience with larger and more realistic programs will be necessary to
determine the real benefits and drawbacks to security-typed languages.

Collaborative computations carried out among users, businesses, and networked in-formation systems continue to increase in complexity, yet there are currently no satisfactory methods for determining whether the end-to-end behavior of these computationsrespect the security needs of the participants. The work described in this thesis is a novel
approach that is a useful step towards solving this essential security problem.

BIBLIOGRAPHY
[ABHR99] Mart'in Abadi, Anindya Banerjee, Nevin Heintze, and Jon Riecke. A corecalculus of dependency. In

Proc. 26th ACM Symp. on Principles of Programming Languages (POPL), pages 147-160, San Antonio, TX, January
1999.

[Abr93] Samson Abramsky. Computational interpretations of linear logic. Theoretical Computer Science, 111:3-57, 1993.

[AG99] Mart'in Abadi and Andrew Gordon. A calculus for cryptographic proto-cols: The spi calculus.

Information and Computation, 148(1):1-70, January 1999.

[Aga00] Johan Agat. Transforming out timing leaks. In Proc. 27th ACM Symp.

on Principles of Programming Languages (POPL), pages 40-53, Boston,
MA, January 2000.

[AP90] M. Abadi and G. D. Plotkin. A PER model of polymorphism. In 5th

Annual Symposium on Logic in Computer Science, pages 355-365. IEEEComputer Society Press, 1990.

[App92] Andrew Appel. Compiling with Continuations. Cambridge University

Press, 1992.

[AR80] Gregory R. Andrews and Richard P. Reitman. An axiomatic approach toinformation flow in programs.

Transactions on Programming Languages
and Systems, 2(1):56-76, 1980.

[Bar84] H.P. Barendregt. The lambda calculus: Its syntax and semantics. In

J. Barwise, D. Kaplan, H. J. Keisler, P. Suppes, and A.S. Troelstra, ed-itors,

Studies in Logic and the Foundation of Mathematics, volume 103.
North-Holland, 1984.

202

203
[BBL84] J. Ban^atre, C. Bryce, and D. Le Met'ayer. Compile-time detection of information flow in sequential programs. In Proceedings of the Europena Symposium on Research in Computer Security, volume 875 of Lecture Notes
in Computer Science, pages 55-73. Springer Verlag, 1984.

[BC02] G'erard Boudol and Ilaria Castellani. Noninterference for concurrent pro-grams and thread systems.

Theoretical Computer Science, 281(1):109-130, June 2002.

[BCY95] William R. Bevier, Richard M. Cohen, and William D. Young. Connectionpolicies and controlled interference. In

Proc. of the 8th IEEE Computer
Security Foundations Workshop, pages 167-176, 1995.

[Bib77] K. J. Biba. Integrity considerations for secure computer systems. Techni-cal Report ESD-TR-76-372, USAF Electronic Systems Division, Bedford,

MA, April 1977.
[Bie99] Gavin Bierman. A classical linear lambda calculus. Theoretical Computer

Science, 227(1-2):43-78, 1999.

[BL75] D. E. Bell and L. J. LaPadula. Secure computer system: Unified exposition

and Multics interpretation. Technical Report ESD-TR-75-306, MITRECorp. MTR-2997, Bedford, MA, 1975. Available as NTIS AD-A023 588.

[BN02] Anindya Banerjee and David A. Naumann. Secure information flow and

pointer confinement in a java-like language. In csfw15, 2002.

[BORT01] Josh Berdine, Peter W. O'Hearn, Uday S. Reddy, and Hayo Thielecke.

Linearly used continuations. In Proceedings of the Continuations Workshop, 2001.

[BP76] D.E. Bell and L.J. La Padula. Secure computer system: Unified exposition and multics interpretation. Technical Report ESD-TR-75-306, TheMITRE Corporation, March 1976.

[CCD88] David Chaum, Claude Cr'epeau, and Ivan Damg*ard. Multiparty unconditionally secure protocols. In Proc. 20th ACM Symp. on Theory of Computing, pages 11-19, 1988.

[CG00] Luca Cardelli and Andrew Gordon. Mobile ambients. Theoretical Computer Science, 240(1):177-213, 2000.

204
[CGW89] Thierry Coquand, Carl A. Gunter, and Glynn Winskel. Domain theoretic

models of polymorphism. Information and Computation, 81(2):123-167,May 1989.

[COR91] OMG. The Common Object Request Broker: Architecture and Specification, December 1991. OMG TC Document Number 91.12.1, Revision1.1.

[CPM^98] Crispin Cowan, Calton Pu, Dave Maier, Heather Hinton, Peat Bakke, Steve

Beattie, Aaron Grier, Perry Wagle, , and Qian Zhang. Stackguard: Au-tomatic adaptive detection and prevention of buffer-overflow attacks. In

Proceedings of the 7th USENIX Security Conference, January 1998.
[CWM99] Karl Crary, David Walker, and Greg Morrisett. Typed memory manage-ment in a calculus of capabilities. In

Proc. 26th ACM Symp. on Principles
of Programming Languages (POPL), pages 262-275, San Antonio, Texas,
January 1999.

[DD77] Dorothy E. Denning and Peter J. Denning. Certification of Programs forSecure Information Flow.

Comm. of the ACM, 20(7):504-513, July 1977.

[DD00] Daniel Damian and Olivier Danvy. Syntactic accidents in program analysis: On the impact of the CPS transformation. In Proc. 5th ACM SIGPLAN
International Conference on Functional Programming (ICFP), pages 209-
220, 2000.

[Den75] Dorothy E. Denning. Secure Information Flow in Computer Systems.Ph.D. dissertation, Purdue University, W. Lafayette, Indiana, USA, May

1975.
[Den76] Dorothy E. Denning. A lattice model of secure information flow. Communications of the ACM, 19(5):236-243, May 1976.

[Den82] Dorothy E. Denning. Cryptography and Data Security. Addison-Wesley,

Reading, Massachusetts, 1982.

[Deu94] Alain Deutsch. Interprocedural may-alias analysis for pointers: Beyandk-limiting. In

Proc. of the '94 SIGPLAN Conference on Programming
Language Design, pages 230-241, 1994.

[DF92] Olivier Danvy and Andrzej Filinski. Representing control: A study ofthe CPS transformation.

Mathematical Structures in Computer Science,
2:361-391, 1992.

205
[DKS99] Ivan Damg*ard, Joe Kilian, and Louis Salvail. On the (im)possibility of

basing oblivious transfer and bit commitment on weakened security as-sumptions. In Jacques Stern, editor,

Advances in Cryptology - Proceedings of EUROCRYPT 99, LNCS 1592, pages 56-73. Springer, 1999.

[DOD85] Department of Defense. Department of Defense Trusted Computer System Evaluation Criteria, DOD 5200.28-STD (The Orange Book) edition,December 1985.

[DOKT91] Fred Douglis, John K. Ousterhout, M. Frans Kaashoek, and Andrew S.

Tanenbaum. A comparison of two distributed systems: Amoeba andSprite.

ACM Transactions on Computer Systems, 4(4), Fall 1991.

[EGH94] M. Emami, R. Ghiya, and L. Hendren. Context-sensitive points-to analysisin the presence of function pointers. In

Proc. of the '94 SIGPLAN Conference on Programming Language Design, pages 242-256, June 1994.

[EGL83] S. Even, O. Goldreich, and A. Lempel. A randomized protocol for signingcontracts. In R.L. Rivest, A. Sherman, and D. Chaum, editors,

Advances
in Cryptology: Proc. of CRYPTO 82, pages 205-210. Plenum Press, 1983.

[ES99] 'Ulfar Erlingsson and Fred B. Schneider. SASI enforcement of security policies: A retrospective. In Proceedings of the 1999 New Security
Paradigms Workshop, September 1999.

[ET99] David Evans and Andrew Twyman. Flexible policy-directed code safety.

In Proc. IEEE Symposium on Security and Privacy, Oakland, May 1999.

[FA99a] Cormac Flanagan and Mart'in Abadi. Object types against races. In

CONCUR'99--Concurrency Theory, volume 1664 of Lecture Notes in
Computer Science, pages 288-303, Eindhoven, The Netherlands, August
1999. Springer-Verlag.

[FA99b] Cormac Flanagan and Mart'in Abadi. Types for safe locking. In Proc. of

the 8th European Symposium on Programming, volume 1576 of Lecture
Notes in Computer Science, pages 91-108, Amsterdam, The Netherlands,
March 1999. Springer-Verlag.

[FB93] J. Mylaert Filho and G. Burn. Continuation passing transformations andabstract interpretation. In

Proc. First Imperial College, Department of
Computing, Workshop on Theory and Formal Methods, 1993.

206
[Fei80] Richard J. Feiertag. A technique for proving specifications are multilevel

secure. Technical Report CSL-109, SRI International Computer ScienceLab, Menlo Park, California, January 1980.

[FF00] Cormac Flanagan and Stephen Freund. Type-based race detection for Java.

In Proc. of the SIGPLAN Conference on Programming Language Design,pages 219-232, Vancouver, Canada, June 2000.

[FG96] C. Fournet and G. Gonthier. The Reflexive CHAM and the Join-Calculus.

In Proc. ACM Symp. on Principles of Programming Languages (POPL),pages 372-385, 1996.

[FG97] Riccardo Focardi and Roberto Gorrieri. The compositional security

checker: A tool for the verification of information flow security proper-ties.

IEEE Transactions on Software Engineering, 23(9), September 1997.

[FG02] Cedric Fournet and Andrew Gordon. Stack inspection: Theory and vari-ants. In

Proc. 29th ACM Symp. on Principles of Programming Languages
(POPL), pages 307-318, 2002.

[Fil92] Andrzej Filinski. Linear continuations. In Proc. 19th ACM Symp. on Principles of Programming Languages (POPL), pages 27-38, 1992.

[Fis72] Michael J. Fischer. Lambda calculus schemata. SIGPLAN Notices,7(1):104-109, January 1972.

[FL94] George Fink and Karl Levitt. Property-based testing of privileged programs. In Proceedings of the 10th Annual Computer Security Applications
Conference, pages 154-163, 1994.

[FLR77] R. J. Feiertag, K. N. Levitt, and L. Robinson. Proving multilevel security

of a system design. Proc. 6th ACM Symp. on Operating System Principles
(SOSP), ACM Operating Systems Review, 11(5):57-66, November 1977.

[FSBJ97] Elena Ferrari, Pierangela Samarati, Elisa Bertino, and Sushil Jajodia. Providing flexibility in information flow control for object-oriented systems.In

Proc. IEEE Symposium on Security and Privacy, pages 130-140, Oak-land, CA, USA, May 1997.

[FSDF93] Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias Felleisen.

The essence of compiling with continuations. In Proc. of the '93 SIGPLAN Conference on Programming Language Design, pages 237-247,
June 1993.

207
[Gat02] Bill Gates. Trustworthy computing. Microsoft e-mail, January 2002.
[GD72] G. S. Graham and Peter J. Denning. Protection: Principles and practice.In

Proc. of the AFIPS Spring Joint Conference, pages 417-429, 1972.

[Gir87] Jean-Yves Girard. Linear logic. Theoretical Computer Science, 50:1-102,1987.

[GJS96] James Gosling, Bill Joy, and Guy Steele. The Java Language Specification. Addison-Wesley, August 1996. ISBN 0-201-63451-1.

[GM82] J. A. Goguen and J. Meseguer. Security policies and security models.

In Proc. IEEE Symposium on Security and Privacy, pages 11-20. IEEEComputer Society Press, April 1982.

[GM84] J. A. Goguen and J. Meseguer. Unwinding and inference control. In Proc.

IEEE Symposium on Security and Privacy, pages 75-86. IEEE ComputerSociety Press, April 1984.

[Gra90] James W. Gray, III. Probabilistic interference. In Proc. IEEE Symposium

on Security and Privacy, pages 170-179. IEEE Computer Society Press,
May 1990.

[Gra91] James W. Gray, III. Towards a mathematical foundation for informationflow security. In

Proc. IEEE Symposium on Security and Privacy, pages
21-34. IEEE Computer Society Press, 1991.

[GS92] J. W. Gray III and P. F. Syverson. A logical approach to multilevel security of probabilistic systems. In Proceedings of the IEEE Symposium
on Security and Privacy, pages 164-176. IEEE Computer Society Press,1992.

[Hen00] Matthew Hennessy. The security picalculus and non-interference. Techni-cal Report Report 05/2000, University of Sussex, School of Cognitive and

Computing Sciences, November 2000.
[HL93] Robert Harper and Mark Lillibridge. Explicit polymorphism and CPS conversion. In Proc. 20th ACM Symp. on Principles of Programming Languages (POPL), pages 206-219, January 1993.

[HR98] Nevin Heintze and Jon G. Riecke. The SLam calculus: Programming

with secrecy and integrity. In Proc. 25th ACM Symp. on Principles of
Programming Languages (POPL), pages 365-377, San Diego, California,
January 1998.

208
[HR00] Matthew Hennessy and James Riely. Information flow vs. resource access in the asynchronous pi-calculus. Technical Report report 03/2000,University of Sussex, 2000.

[HRU76] M. A. Harrison, W. L Ruzzo, and J. D. Ullman. Protection in operatingsystems.

Comm. of the ACM, 19(8):461-471, August 1976.

[HVY00] Kohei Honda, Vasco Vasconcelos, and Nobuko Yoshida. Secure infor-mation flow as typed process behaviour. In

Proc. of the 9th European
Symposium on Programming, volume 1782 of Lecture Notes in Computer
Science, pages 180-199. Springer, 2000.

[HY02] Kohei Honda and Nobuko Yoshida. A uniform type structure for secure

information flow. In Proc. 29th ACM Symp. on Principles of Programming
Languages (POPL), pages 81-92, January 2002.

[JLHB88] Eric Jul, Henry Levy, Norman Hutchinson, and Andrew Black. Fine-grained mobility in the emerald system.

ACM Transactions on Computer
Systems, 6(1):109-133, February 1988.

[JVM95] Sun Microsystems. The Java Virtual Machine Specification, release

1.0 beta edition, August 1995. Available at ftp://ftp.javasoft.com/docs/-vmspec.ps.zip.

[Lam71] Butler W. Lampson. Protection. In Proc. Fifth Princeton Symposium on

Information Sciences and Systems, pages 437-443, Princeton University,March 1971. Reprinted in Operating Systems Review, 8(1), January 1974,

pp. 18-24.
[LE01] David Larochelle and David Evans. Statically detecting likely buffer overflow vulnerabilities. In 2001 USENIX Security Symposium, Washington,D. C., August 2001.

[LR92] W. Landi and B. Ryder. A safe approximation algorithm for interproce-dural pointer aliasing. In

Proc. of the SIGPLAN '92 Conference on Programming Language Design, June 1992.

[LV95] Nancy Lynch and Frits Vaandrager. Forward and backward simulations -Part I: Untimed systems.

Information and Computation, 121(2):214-233,
September 1995. Also, Technical Memo MIT/LCS/TM-486.b (with minorrevisions), Laboratory for Computer Science, Massachusetts Institute of

Technology.

209
[LWG^95] J. R. Lyle, D. R. Wallace, J. R. Graham, K. B. Gallagher, J. P. Poole, and

D. W. Binkley. Unravel: A CASE tool to assist evaluation of high integritysoftware. IR 5691, NIST, 1995.

[Man00] Heiko Mantel. Possibilistic definitions of security: An assembly kit. In

Proc. of the 13th IEEE Computer Security Foundations Workshop, pages185-199, Cambridge, United Kingdom, 2000.

[McC87] Daryl McCullough. Specifications for multi-level security and a hook-up

property. In Proc. IEEE Symposium on Security and Privacy, pages 161-166. IEEE Computer Society Press, May 1987.

[McC88] Daryl McCullough. Noninterference and the composability of security

properties. In Proc. IEEE Symposium on Security and Privacy, pages 177-186. IEEE Computer Society Press, May 1988.

[MCG^99] Greg Morrisett, Karl Crary, Neal Glew, Dan Grossman, Richard Samuels,

Frederick Smith, David Walker, Stephanie Weirich, and Steve Zdancewic.TALx86: A realistic typed assembly language. In

OE\Delta " ACM SIGPLAN
Workshop on Compiler Support for System Software, pages 25-35, 1999.

[McL88a] John McLean. A general theory of composition for a class of "possibilis-tic" properties.

IEEE Transactions on Software Engineering, 22(1):53-67,January 1988.

[McL88b] John McLean. Reasoning about security models. In Proc. IEEE Symposium on Security and Privacy, pages 123-131, Oakland, CA, 1988. IEEEComputer Society Press.

[McL90] John McLean. Security models and information flow. In Proc. IEEE Symposium on Security and Privacy, pages 180-187. IEEE Computer SocietyPress, 1990.

[McL94] John McLean. A general theory of composition for trace sets closed underselective interleaving functions. In

Proc. IEEE Symposium on Security
and Privacy, pages 79-93. IEEE Computer Society Press, May 1994.

[MH02] Massimo Merro and Matthew Hennessy. Bisimulation congruences forsafe ambients. In

Proc. 29th ACM Symp. on Principles of Programming
Languages (POPL), pages 71-80, January 2002.

[Mil89] R. Milner. Communication and Concurrency. Prentice Hall, 1989.

210
[Mit96] John C. Mitchell. Foundations for Programming Languages. Foundations

of Computing Series. The MIT Press, 1996.

[ML98] Andrew C. Myers and Barbara Liskov. Complete, safe information flow

with decentralized labels. In Proc. IEEE Symposium on Security and Privacy, pages 186-197, Oakland, CA, USA, May 1998.

[ML00] Andrew C. Myers and Barbara Liskov. Protecting privacy using the decentralized label model. ACM Transactions on Software Engineering and
Methodology, 9(4):410-442, 2000.

[MNZZ01] Andrew C. Myers, Nathaniel Nystrom, Lantian Zheng, and SteveZdancewic. Jif: Java information flow. Software release. Located at

http://www.cs.cornell.edu/jif, July 2001.
[Mor68] James H. Morris. Lambda Calculus Models of Programming Languages.Ph.D. dissertation, Massachusetts Institute of Technology, 1968.

[MPS86] David MacQueen, Gordon D. Plotkin, and Ravi Sethi. An ideal modelfor recursive polymorphism.

Information and Control, 71(1/2):95-130,
October/November 1986.

[MPW92] R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes.

Information and Computation, 100(1):1-77, 1992.

[MR92a] QingMing Ma and John Reynolds. Types, abstraction, and parametricpolymorphism: Part 2. In S. Brookes, M. Main, A. Melton, M. Mislove, and D. A. Schmidt, editors, Proceedings of the 1991 Mathematical
Foundations of Programming Semantics, number 598 in Lecture Notes inComputer Science, pages 1-40. Springer-Verlag, 1992.

[MR92b] M. D. McIlroy and J. A. Reeds. Multilevel security in the UNIX tradition.

Software--Practice and Experience, 22(8):673-694, August 1992.

[MS01] Heiko Mantel and Andrei Sabelfeld. A generic approach to the securityof multi-threaded programs. In

Proc. of the 14th IEEE Computer Security
Foundations Workshop, pages 200-214. IEEE Computer Society Press,June 2001.

[MTHM97] Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. The

Definition of Standard ML (Revised). The MIT Press, 1997.

[Muc97] Steven S. Muchnick. Advanced Compiler Design and Implementation.

Morgan Kaufmann Publishers, 1997.

211
[MWCG98] Greg Morrisett, David Walker, Karl Crary, and Neal Glew. From System

F to typed assembly language. In Proc. 25th ACM Symp. on Principles of
Programming Languages (POPL), San Diego, California, January 1998.

[MWCG99] Greg Morrisett, David Walker, Karl Crary, and Neal Glew. From System

F to typed assembly language. Transactions on Programming Languages
and Systems, 21(3):528-569, May 1999.

[Mye99] Andrew C. Myers. Mostly-static decentralized information flow control.Technical Report MIT/LCS/TR-783, Massachusetts Institute of Technology, Cambridge, MA, January 1999. Ph.D. thesis.
[Nec97] George C. Necula. Proof-carrying code. In Proc. 24th ACM Symp. on

Principles of Programming Languages (POPL), pages 106-119, January
1997.

[Nie82] Flemming Nielson. A denotational framework for data flow analysis. Acta

Informatica, 18:265-287, 1982.

[p3p] Platform for privacy preferences (P3P). \Delta \Pi \Pi &i??///(/-(ae\Omega ss?&-&.
[PC00] Franc,ois Pottier and Sylvain Conchon. Information flow inference for

free. In Proc. 5th ACM SIGPLAN International Conference on Functional
Programming (ICFP), pages 46-57, September 2000.

[Pin95] Sylvan Pinsky. Absorbing covers and intransitive non-interference. In

Proc. IEEE Symposium on Security and Privacy, 1995.

[Plo75] Gordon D. Plotkin. Call-by-name, call-by-value and the \Delta -calculus. Theoretical Computer Science, 1:125-159, 1975.

[PO95] Jens Palsberg and Peter O/rbaek. Trust in the \Delta -calculus. In Proc. 2nd

International Symposium on Static Analysis, number 983 in Lecture Notes
in Computer Science, pages 314-329. Springer, September 1995.

[Pot02] Franc,ois Pottier. A simple view of type-secure information flow in the

(-calculus. In Proc. of the 15th IEEE Computer Security Foundations
Workshop, 2002.

[PP00] Jeff Polakow and Frank Pfenning. Properties of terms in continuationpassing style in an ordered logical framework. In J. Despeyroux, editor,
2nd Workshop on Logical Frameworks and Meta-languages, Santa Barbara, California, June 2000.

212
[PS99] Benjamin C. Pierce and Davide Sangiorgi. Behavioral equivalence in the

polymorphic pi-calculus. Technical Report MS-CIS-99-10, University ofPennsylvania, April 1999. (Summary in POPL '97).

[PS02] Franc,ois Pottier and Vincent Simonet. Information flow inference for

ML. In Proc. 29th ACM Symp. on Principles of Programming Languages
(POPL), Portland, Oregon, January 2002.

[Rab81] M. Rabin. How to exchange secrets by oblivious transfer. Technical Report TR-81, Harvard Aiken Computation Laboratory, 1981.

[Rei78] Richard Philip Reitman. Information Flow in Parallel Programs: An Axiomatic Approach. Ph.D. dissertation, Cornell University, 1978.

[Rey72] John C. Reynolds. Definitional interpreters for higherorder programminglanguages. In

Conference Record of the 25th National ACM Conference,pages 717-740, August 1972.

[Rey74] John C. Reynolds. Towards a theory of type structure. In Programming

Symposium, volume 19 of Lecture Notes in Computer Science, pages 408-425. Springer-Verlag, Paris, France, April 1974.

[Rey78] John C. Reynolds. Syntactic control of interference. In Proc. 5th ACM

Symp. on Principles of Programming Languages (POPL), pages 39-46,1978.

[Rey83] John C. Reynolds. Types, abstraction, and parametric polymorphism. InR.E.A Mason, editor,

Information Processing, pages 513-523. Elsevier
Science Publishers B.V., 1983.

[RG99] A. W. Roscoe and M. H. Goldsmith. What is intransitive noninterference?In

Proc. of the 12th IEEE Computer Security Foundations Workshop, 1999.

[RH99] James Riely and Matthew Hennessy. Trust and partial typing in open systems of mobile agents. In Proc. 26th ACM Symp. on Principles of Programming Languages (POPL), pages 93-104, San Antonio, TX, January
1999.

[Rie89] Jon G. Riecke. Should a function continue? Masters dissertation, Mas-sachusetts Institute of Technology, Department of Electrical Engineering

and Computer Science, Cambridge, Massachusetts, 1989.

213
[RM96] Jakob Rehof and Torben AE. Mogensen. Tractable constraints in finite

semilattices. In Proc. 3rd International Symposium on Static Analysis,number 1145 in Lecture Notes in Computer Science, pages 285-300.

Springer-Verlag, September 1996.
[Ros95] A. W. Roscoe. Csp and determinism in security modeling. In Proc. IEEE

Symposium on Security and Privacy, 1995.

[RR99] Radu Rugina and Martin Rinard. Pointer analysis for multithreaded programs. In Proc. of the ACM SIGPLAN 1999 Conference on Programming
Language Design, pages 77-90, May 1999.

[Rus92] John Rushby. Noninterference, transitivity and channel-control security

policies. Technical report, SRI, 1992.

[Sab01] Andrei Sabelfeld. The impact of synchronisation on secure informationflow in concurrent programs. In

Proceedings of the Andrei Ershov 4th
International Conference on Perspectives of System Informatics, volume2244 of

Lecture Notes in Computer Science, pages 225-239. SpringerVerlag, July 2001.

[Sch96] B. Schneier. Applied Cryptography. John Wiley and Sons, New York, NY,1996.

[Sch97] Fred B. Schneider. On Concurrent Programming. Springer Verlag, 1997.
[Sch99] Fred B. Schneider, editor. Trust in Cyberspace. National Academy Press,1999.

[Sch01] Fred B. Schneider. Enforceable security policies. ACM Transactions on

Information and System Security, 2001. Also available as TR 99-1759,Computer Science Department, Cornell University, Ithaca, New York.

[SF94] Amr Sabry and Matthias Felleisen. Is continuation-passing useful for data

flow analysis? In Proc. SIGPLAN '94 Conference on Programming Language Design and Implementation, pages 1-12, 1994.

[SM02] Andrei Sabelfeld and Heiko Mantel. Static confidentiality enforcement

for distributed programs. In Proceedings of the 9th Static Analysis Symposium, volume 2477 of Lecture Notes in Computer Science. SpringerVerlag, 2002.

214
[SMH00] Fred B. Schneider, Greg Morrisett, and Robert Harper. A language-based

approach to security. In Informatics--10 Years Back, 10 Years Ahead, vol-ume 2000 of

Lecture Notes in Computer Science. Springer-Verlag, 2000.

[Smi01] Geoffrey Smith. A new type system for secure information flow. In

CSFW14, pages 115-125. IEEE Computer Society Press, jun 2001.

[SNS88] J. G. Steiner, C. Neuman, and J. I. Schiller. Kerberos: An authenticationservice for open network systems. Technical report, Project Athena, MIT,

Cambridge, MA, March 1988.
[SS99] Andrei Sabelfeld and David Sands. A PER model of secure informationflow in sequential programs. In

Proc. of the 8th European Symposium on
Programming, volume 1576 of Lecture Notes in Computer Science, pages
40-58. Springer-Verlag, March 1999.

[SS00] Andrei Sabelfeld and David Sands. Probabilistic noninterference formulti-threaded programs. In

Proc. of the 13th IEEE Computer Security
Foundations Workshop, pages 200-214. IEEE Computer Society Press,July 2000.

[SS01] Andrei Sabelfeld and David Sands. A PER model of secure information

flow in sequential programs. Higher-Order and Symbolic Computation,14(1):59-91, March 2001.

[Ste78] Guy L. Steele. Rabbit: a compiler for scheme. Technical Report AI-TR474, Artificial Intelligence Laboratory, MIT, Cambridge, Massachusetts,May 1978.

[STFW01] Umesh Shankar, Kunal Talwar, Jeffrey S. Foster, and David Wagner. De-tecting format string vulnerabilities with type qualifiers. In

Proceedings of
the 10th USENIX Security Symposium, 2001.

[Str67] C. Strachey. Fundamental concepts in programming languages. Unpub-lished Lecture Notes, Summer School in Computer Programming, August

1967.
[Sut86] David Sutherland. A model of information. In Proc. 9th National Security

Conference, pages 175-183, Gaithersburg, Md., 1986.

[SV98] Geoffrey Smith and Dennis Volpano. Secure information flow in a multithreaded imperative language. In Proc. 25th ACM Symp. on Principles of
Programming Languages (POPL), pages 355-364, San Diego, California,
January 1998.

215
[SV00] Sewell and Vitek. Secure composition of untrusted code: Wrappers and

causality types. In PCSFW: Proceedings of The 13th Computer Security
Foundations Workshop. IEEE Computer Society Press, 2000.

[SWM00] Frederick Smith, David Walker, and Greg Morrisett. Alias types. In Proc.

of the 9th European Symposium on Programming, volume 1782 of Lecture
Notes in Computer Science, pages 366-381, 2000.

[Tip95] Frank Tip. A survey of program slicing techniques. Journal of Programming Languages, 3:121-189, 1995.

[TW99] David N. Turner and Philip Wadler. Operational interpretations of linearlogic.

Theoretical Computer Science, 227(1-2):231-248, September 1999.

[VS97] Dennis Volpano and Geoffrey Smith. Eliminating covert flows with minimum typings. In 10th IEEE Computer Security Foundations Workshop,pages 156-168. IEEE Computer Society Press, June 1997.

[VS00] Dennis Volpano and Geoffrey Smith. Verifying secrets and relative secrecy. In Proc. 27th ACM Symp. on Principles of Programming Languages
(POPL), pages 268-276. ACM Press, January 2000.

[VSI96] Dennis Volpano, Geoffrey Smith, and Cynthia Irvine. A sound type system for secure flow analysis. Journal of Computer Security, 4(3):167-187,1996.

[Wad90] Philip Wadler. Linear types can change the world! In M. Broy and

C. Jones, editors, Progarmming Concepts and Methods, Sea of Galilee,Israel, April 1990. North Holland. IFIP TC 2 Working Conference.

[Wad93] Philip Wadler. A taste of linear logic. In Mathematical Foundations of

Computer Science, volume 711 of Lecture Notes in Computer Science,pages 185-210. Springer-Verlag, 1993.

[WAF00] Dan S. Wallach, Andrew W. Appel, , and Edward W. Felten. The security

architecture formerly known as stack inspection: A security mechanismfor language-based systems.

ACM Transactions on Software Engineering
and Methodology, 9(4), October 2000.

[Wag00] David Wagner. Static analysis and computer security: New techniques for

software assurance. Ph.D. dissertation, University of California at Berkeley, 2000.

216
[Wal00] David Walker. A type system for expressive security policies. In Proc.

27th ACM Symp. on Principles of Programming Languages (POPL), pages254-267. ACM Press, Jan 2000.

[WF92] Andrew K. Wright and Matthias Felleisen. A syntactic approach to typesoundness. Technical Report TR91-160, Rice University, June 1992.
[WF94] Andrew K. Wright and Matthias Felleisen. A syntactic approach to type

soundness. Information and Computation, 115(1):38-94, 1994. Prelimi-nary version in Rice TR 91-160.

[WF98] Dan S. Wallach and Edward W. Felten. Understanding Java stack inspec-tion. In

Proc. IEEE Symposium on Security and Privacy, Oakland, Cali-fornia, USA, May 1998.

[WJ90] J. Todd Wittbold and Dale M. Johnson. Information flow in nondetermin-istic systems. In

Proc. IEEE Symposium on Security and Privacy, pages
144-161, May 1990.

[WM00] David Walker and Greg Morrisett. Alias types for recursive data structures. In Workshop on Types in Compilation, September 2000.

[Ylo96] Tatu Ylonen. SSH - secure login connections over the Internet. In The

Sixth USENIX Security Symposium Proceedings, pages 37-42, San Jose,
California, 1996.

[Zha97] Kan Zhang. A theory for system security. In 10th IEEE Computer Security

Foundations Workshop, pages 148-155. IEEE Computer Society Press,June 1997.

[Zho01] Lidong Zhou. Towards Fault-Tolerant and Secure On-line Services. Ph.D.

dissertation, Cornell University, May 2001.

[ZL97] Aris Zakinthinos and E. Stewart Lee. A general theory of security properties and secure composition. In Proc. IEEE Symposium on Security and
Privacy, Oakland, CA, 1997.

[ZM00] Steve Zdancewic and Andrew C. Myers. Confidentiality and integrity withuntrusted hosts. Technical Report 2000-1810, Computer Science Dept.,

Cornell University, 2000.
[ZM01a] Steve Zdancewic and Andrew C. Myers. Robust declassification. In Proc.

of 14th IEEE Computer Security Foundations Workshop, pages 15-23,
Cape Breton, Canada, June 2001.

217
[ZM01b] Steve Zdancewic and Andrew C. Myers. Secure information flow and

CPS. In Proc. of the 10th European Symposium on Programming, volume2028 of

Lecture Notes in Computer Science, pages 46-61, April 2001.

[ZM02] Steve Zdancewic and Andrew C. Myers. Secure information flow via linear continuations. Higher Order and Symbolic Computation, 15, 2002.

[ZSv00] Lidong Zhou, Fred B. Schneider, and Robbert van Renesse. COCA: A

secure distributed on-line certification authority. Technical Report 2000-1828, Department of Computer Science, Cornell University, December

2000.

[ZZNM01] Steve Zdancewic, Lantian Zheng, Nathaniel Nystrom, and Andrew C. My-ers. Untrusted hosts and confidentiality: Secure program partitioning. In

Proc. 18th ACM Symp. on Operating System Principles (SOSP), volume35(5) of

Operating Systems Review, pages 1-14, Banff, Canada, October2001.

[ZZNM02] Steve Zdancewic, Lantian Zheng, Nathaniel Nystrom, and Andrew C. My-ers. Secure program partitioning.

Transactions on Computer Systems,2002. Forthcoming.