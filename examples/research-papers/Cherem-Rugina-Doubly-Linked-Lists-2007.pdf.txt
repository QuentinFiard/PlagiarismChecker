

Maintaining Doubly-Linked List Invariants inShape Analysis with Local Reasoning

?

Sigmund Cherem and Radu Rugina

Computer Science Department

Cornell University

Ithaca, NY 14853{
siggi,rugina}@cs.cornell.edu

Abstract. This paper presents a novel shape analysis algorithm with local reasoning that is designed to analyze heap structures with structural invariants, such
as doubly-linked lists. The algorithm abstracts and analyzes one single heap cell
at a time. In order to maintain the structural invariants, the analysis uses a local
heap abstraction that models the sub-heap consisting of one cell and its immediate neighbors. The proposed algorithm can successfully analyze standard doublylinked list manipulations.

1 Introduction
Shape analyses are aimed at extracting heap invariants that describe the "shape" ofrecursive data structures [1]. For instance, heap reference count invariants allow a program analyzer to distinguish acyclic and unshared data structures, such as acyclic lists ortrees, from structures with sharing or cycles. Shape information has many potential applications such as: verification of heap manipulations [2]; automatic parallelization [3];static detection of memory leaks and other heap errors [4]; and compile-time memory
management [5]. Statically computing reference count invariants is challenging becausedestructive heap mutations temporarily break these invariants. A shape analysis must
determine that the invariants are restored as the destructive operations finish.In recent work, we have developed a novel shape analysis framework that uses local reasoning about single heap cells [4]. In this framework, the analysis uses a localabstraction to describe the state of a single heap cell. Using the local abstraction, the
analysis tracks the state of the single cell through the program, from the point wherethe cell is allocated, and up to the point where it becomes unreachable. The single
cell is referred to as the tracked cell. As shown in [4], this approach makes it possibleto build efficient intra-procedural and inter-procedural analysis algorithms. However,
a shortcoming of the current formulation is that it cannot accurately compute shapeinformation for data structures with local invariants, such as doubly-linked lists.

In this paper we present a shape analysis with local reasoning about single heapcells that is capable of identifying and maintaining information about doubly-linked list
invariants. We propose a new local abstraction capable of expressing such invariants.Then, we develop an analysis algorithm that computes shape information using this

? This work was supported in part by NSF grants CCF-0541217 and CNS-0406345.

abstraction. The local abstraction for a heap cell describes the local heap around thecell, consisting of the cell itself and its immediate neighboring cells. Points-to relations
between the cell and its neighbors allow the analysis to express local structural invari-ants. The paper shows that maintaining structural invariants for the tracked cell requires
knowledge about its neighbors' reference counts. Our abstraction can also express otherforms of local invariants, in particular the parent-child relationship in trees with parent
pointers. However, this paper mainly focuses on studying doubly-linked lists.

When a distant cell gets closer to the tracked cell and becomes one of its neighbors(for instance, when removing the element next to the tracked cell), a local analysis has

no knowledge about the reference counts of the new neighbor. To address this issue,we propose an

assume-and-check approach: when the analysis of a single cell reachesan assumption point in the program, it assumes facts about the neighbors' reference

counts; at the same time, the analysis checks the reference counts of all tracked cells atthat point, to ensure that the assumptions were correct.

The rest of the paper is organized as follows. Section 2 gives the background. Sec-tion 3 shows an example and discusses the issues that the analysis must overcome. Next,
Section 4 presents the local abstraction and Section 5 shows the analysis algorithm. Fi-nally, related work is discussed in Section 6 and we conclude in Section 7.

2 Background: Local Analysis of Single Heap Cells
This section discusses the key concepts behind heap analysis with local reasoning aboutsingle heap cells. The main idea is that the analysis uses a local abstraction to model
one single heap cell at a time. Hence, the analysis has only local information about theone cell, but knows nothing about the rest of the heap. In contrast, traditional shape
analyses that use shape graphs [6] or 3-valued logic [7] have a global view of the heap.Recent work has explored formulations using procedure-local sub-heaps [8], or using
separation logic [9, 10]. Although these approaches restrict themselves to sub-heaps,their abstractions still describe entire structures (e.g., entire lists), not single cells.

Roughly speaking, an analysis that reasons about single cells is concerned withquestions of the form "if property

X holds for one heap cell before an operation, does
X hold for that cell afterwards?". In contrast, global analyses answer questions of theform "if property

X holds for all the cells before an operation, does X hold for allcells afterwards?". A local analysis is more efficient due to the finer granularity of the

abstraction. However, it is more restricted because less information is available whenanalyzing a single cell.

The local abstraction of a heap cell is referred to as a configuration. The cell de-scribed by the configuration is referred to as the tracked cell. Each configuration contains reference counts for the tracked cell, plus additional information for accuratelymaintaining these reference counts. Reference counts are expressed relative to a region
partitioning of the program's memory (both stack and heap) into a finite set of disjointregions, so that each configuration keeps track of one reference count per region. To
ensure a finite abstraction, reference counts are bound to a fixed value k per region (anda top value is used for larger counts). Usually,

k = 2 suffices. In this paper, we assumea type-safe Java-like language, where a simple region partitioning can be constructed

class DLList {

DLList n, p;
int data;

DLList(int d) {

data = d;
}
}

void insert(DLList x, int d) {

DLList t;
t = x.p;
y = new DLList(d);
y.n = x;
y.p = t;
t.n = y;
x.p = y;
}

Fig. 1. Doubly-linked list insertion

by using one region per variable and one region per heap field. In the rest of the paper,we refer to regions using their variable or field names. The entire heap abstraction at a
program point is the finite set of possible configurations at that point. However, configu-rations are independent, so they can be analyzed separately. The analysis uses efficient,
fine-grained worklist algorithms to process individual configurations, not entire heapabstractions (in a fashion similar to attribute-independent analyses).

For a given program, the analysis generates a configuration after each allocationsite, to model a

representative cell created at that site. Then, the analysis tracks thisconfiguration through the program using a dataflow analysis.

In our previous work [4, 5], each local abstraction is a triple (r, h, m), where rindicates the reference counts per region,

h is a set of expressions that reference thetracked cell (or hit expressions); and
m is a set of expressions that do not reference thecell (
miss expressions). The h and m sets need not be complete; the richer these setsare, the more precise the analysis is. In general, redundant information is avoided, i.e.,

h and m exclude expressions e for which r already indicates whether e hits or misses.

For example, consider an acyclic singly-linked list, where next fields are named n.Assume that the first two list elements are pointed by variables

x and y, respectively.This heap can be described using three local abstractions: (
x1, ?, ?) describes the firstlist element; (
y1n1, {x.n}, ?) describes the second list element; and (n1, ?, {x.n})describes one list element other than the first two, that is, it describes a representative

among the cells in the tail of the list. Here, reference counts are described using su-perscripts, and missing regions have zero reference counts by default. The analysis can
analyze each of these pieces separately, reasoning locally about each of them.

However, the triples (r, h, m) cannot express local structural invariants, such asdoubly-linked list invariants. In this paper we propose a new local abstraction for describing and maintaining structural invariants.

3 Example
Consider the program in Figure 1. The program is written using a Java-like syntax and isused as a running example. The program inserts a new element

y in a doubly-linked list,right before element
x. Each list element has a field n that points to the next element,and a field
p that points to the previous element. A correct manipulation of the list must

x x

y
t

a) Before insert(x) b) After insert(x)
Fig. 2. Counterexample: the property rc for the shaded cell holds before insert(x), but not
after. The shaded box denotes the tracked cell. Solid lines are next links n, and dashed lines are
previous links p.

maintain the doubly-linked list (DLL) invariant:

8h . (h.p 6= null ) h.p.n = h) ^ (h.n 6= null ) h.n.p = h)

3.1 Reference Counts and DLL Invariants
First, we show that maintaining precise heap reference counts requires knowledge aboutthe DLL invariant. Consider the two predicates below for a heap cell

h in a list:

- rc(h) is true if it has reference counts of at most 1 from each of the fields n and p;-

dll(h) indicates that the DLL invariant holds for h.

We ask the following question: given a cell h such that rc(h) holds, but dll(h) mightnot hold before insert, does

rc(h) hold after the insertion? The answer is negative:

rc(h) 6) rc0(h)
where rc(h) and rc0(h) are the values of the reference counting predicate in the statesbefore and after insert, respectively. This is shown by the counterexample in Figure 2. A
concrete heap before insert(x) is shown on the left of the figure, and the resultingheap after the insertion is shown on the right. The cell in question

h (i.e., the trackedcell) is shown using the shaded box. Next links are shown using solid lines, and previous

links are shown using dashed lines. The property rc(h) holds before insert, but not after,because the cell pointed to by

x has two references from n fields in the result heap.
Hence, the analysis must have knowledge about the DLL invariant in order to pre-serve accurate reference counts during destructive doubly-linked list operations. This is

the case for both local and global analyses.

3.2 Maintaining the DLL Invariant Using Local Reasoning
Next we want to determine the amount of local information needed so that a localanalysis can conclude that the DLL invariant is restored. We ask the following question:
if one cell h is such that both rc(h) and dll(h) hold before insert, is it the case that dll(h)

x

y
x t

a) Before insert(x) b) After insert(x)
Fig. 3. Counterexample: a) before insert(x), both the rc and dll properties hold for the shaded
cell; b) after insertion, property dll doesn't hold for the shaded cell.

also holds after insert? Note that nothing is known about the rc and dll properties ofelements other than

h. The answer to this question is again negative:

rc(h) ^ dll(h) 6) dll0(h)
This is shown by the counterexample in Figure 3. The cell in question h is the shadedcell. In the heap before insert both

rc(h) and dll(h) hold. However, the neighboringcell to the left of
h is malformed because it is referenced by two p fields, one from thetracked cell and one from

x. Inserting a new element before x "steals" a reference from
h and breaks its DLL property: after insertion, h.p.n 6= h.Still, it is possible to determine that insert maintains the DLL invariant using local reasoning. The required piece of information is that the neighbors h.n and h.p ofthe tracked cell

h also satisfy the reference count property rc before insertion 1. Theanalysis can then prove that if the tracked cell satisfies

rc and dll before insert, and itsneighbors satisfy
rc, then rc and dll hold for the tracked cell after insert:

rc(h) ^ dll(h) ^ rc(h.p) ^ rc(h.n) ) rc0(h) ^ dll0(h)
The goal of our analysis is to build an appropriate local abstraction and prove thisproperty using that abstraction.

4 The Local Abstraction
Based on the above observations, the local abstraction must capture: a) local invariants,such as the

dll property, and b) reference counts for both the tracked cell and its neigh-bors. We build the abstraction as follows. The configuration of the tracked cell models

the local heap consisting of itself and its immediate neighbors, i.e., those cells that arepointed by, or point to the tracked cell. The configuration models the following:

- Points-to relations between the tracked cell and its neighbors;- Precise reference counts for the tracked cell, from each variable and each field; and
- Partial reference counts for the neighbors, from some variables and fields.
Graphically, a configuration can be thought as being a "circle" whose center is thetracked cell, and whose heap neighbors at distance 1 lie on this circle.

1 A slightly weaker condition is actually sufficient: that h.n has only one n reference, and h.p

has only one p reference, each of them from h.

n1p2t1p1t0y0 n1x1y0

y1
Fig. 4. Example local abstraction.

For instance, the local abstraction shown in Figure 4 arises during the analysis of
insert. The tracked cell is the shaded node in the center. The points-to relations be-tween the center node and its neighbors allow the analysis to express the local structural

invariants. The reference counts from variables (x, y, or t) and fields (n or p) are shownusing superscripts, for each node. Reference counts from variables can only be 0 or 1.
For the tracked cell, the reference counts not shown (from x and y) are zero, by default.For the neighboring cells, the missing reference counts are unknown by default. Hence,
reference counts are fully known for the tracked cell, but partially known for the neigh-bors. To explain the examples in this paper, we will refer to each local abstraction using
the reference counts of the tracked cell. For instance, the above abstraction is n1p2t1.

Note that the local abstraction does not contain summary nodes. In particular, noth-ing is known about the heap beyond the circle. This is the key aspect that distinguishes

it from traditional global abstractions such as shape graphs.

4.1 Analysis of the Example
Figure 5 shows the analysis result for insert using this local abstraction. The possiblelocal abstractions are shown at each point. In each abstraction, the tracked cell is shown
as the shaded node. For simplicity, we consider only two input configurations at theentry of the function,

n1p1 and n1p1x1. The former describes a list cell that is notreferenced by
x; the latter is the cell that x references. Both cases assume that the cellin question is in the middle of the list. Four other configurations describe cases where

the tracked cell is the first or the last element: n1, n1x1, p1, and p1x1. The analysis ofthose cases are similar and we omit them.

Consider the initial abstraction n1p1 and the first assignment t = x.p. The analy-sis tries to determine whether

x.p is the tracked cell. Since there is not enough informa-tion to figure this out, the analysis bifurcates into two possible cases. These correspond

to the first two columns in the figure. In the first case, x.p is not the tracked cell, so
t will not reference the cell after the assignment. The resulting abstraction is n1p1. Inthe second case,

x.p is the tracked cell, so t will reference it after the assignment. Theresulting abstraction is

n1p1t1.

n1p1p1 n1

n2x1y0p1t0y0
p1t0y0 n2x1y0n1p2t1
p1t0y0 n1p2t1
p1t0y0 n1p1t1

y1

n1x1y0

n1p1t1 n1x1
p1t0y0 n1p1t1 n1x1y0

n1p1x1
n1p1x1
n2p1x1

n1p1x1

n2p1x1
n1p1x1
n1p1x1
y1 y1

y1

y1
y1

y1

n1p1
n1p1
n1p1

n1p1
n1p1
n1p1

n1x0
n1x0y0
n1x0y0

n1x0y0
n1x0y0
n1x0y0

p1t0p1t0
p1t0y0
p1t0y0

p1t0y0
p1t0y0
p1t0y0

n1p1t1

p1t1

p1 n1

n1
n1y0p1t1y0
p1t1y0 n1y0

n1y0p2t1y0
n1y0p2t1y0
n1y0

y = new
t.n = y
x.p = y

y.p = t
y.n = x

t = x.p

Fig. 5. Analysis of the example program.
The analysis of t = x.p also infers that x does not reference the right neighborin the first case (otherwise,

x.p references the tracked cell); and that x references theright neighbor in the second case (because the only other cell that has a

p field pointingto the tracked cell is the right neighbor). This information about
x is needed later, whenanalyzing the assignment
x.p = y.

Furthermore, in both cases the analysis of t = x.p infers that t doesn't referencethe left neighbor, as shown by the reference count

t0. This is because the left neighborhas exactly one
p reference, from the tracked cell. If t would point to the left neighbor,then
x would reference the tracked cell, which is known to be false. Hence, the p1

mayAlias(S, vi, vj) , (vi 6= vo 6= vj ^

(8r . ||vi||r = ||vj||r . ||vi||r = ? . ||vj||r = ?))

hit(S, e, v) , 8<:

e = x ^ ||v||x = 1 or
e = x.f ^ ||v||f 6= 0 ^ (9v0 . hit(S, x, v0) ^ v0 !f v) or
e = null ^ v = vnull

contains(S, e) , (9v 2 V . hit(S, e, v))

miss(S, e, v) ,

8>>>>>><

>>>>>>:

e = x ^ ||v||x = 0 or
e = x.f ^ ||v||f = 0 or
e = x ^ (9v0 . ||v0||x = 1 ^ ~mayAlias(S, v, v0)) or
e = x.f ^ ||v||f = 1 ^ (9v0 . v0 !f v ^ miss(S, x, v0)) or
e = null ^ v 6= vnull or
e = x.f ^ hit(S, x, vo) ^ vo !f vnull ^ ~mayAlias(S, v, vnull)

Fig. 6. Queries on configurations

knowledge for the left neighbor allows the analysis to infer that t doesn't reference thatneighbor. As a result, situations such as the one in Figure 3 are not possible.

The analysis of the other statements and local abstractions is similar. The configu-rations at the end of the function indicate that the

rc and dll properties hold for all heapcells at that point.

Abstraction Model The local abstraction is modeled as a star graph S:

S = (V, vo, vnull, O, I, || * ||) where,
vo, vnull 2 V O ` Field*V I ` V *Field ||*|| : V ! (Field [ Var) ! N?

The set V contains all nodes in the graph, where vo 2 V is a distinguished centernode representing the tracked cell. The node

vnull 2 V is a special node to representnull values. The set
O contains outgoing edges from vo. A pair (f, v) 2 O denotes theedge
vo !f v. The special edge vo !f vnull indicates that the field f of the trackedcell is null. Similarly, an incoming edge

v !f vo is denoted by a pair (v, f) 2 I. Thecardinality function || * || models the reference counts for each node in

V , both fromvariables (
Var) and fields (Field). The set N? extends natural numbers with a specialtop value ?, such that ? + 1 = ? - 1 = ?. The heap reference count from a field

f isdenoted ||
v||f . The reference counts from a variable x is denoted as ||v||x. If this valueis not ?, it can only be 1 or 0, indicating whether the cell

v is referenced by variable x ornot. The special value ? represents unknown information. As mentioned in Section 2,

we use an upper bound k (e.g., k = 2) for the number of reference counts per field. Inaddition, the analysis uses a top configuration

S? to model cases where the analysis haslost precision about the tracked cell.

V = {vo, vnull} [ range(O) [ {v | v 2 dom(I) ^ 9x . ||v||x = 1} (1)
vnull /2 dom(I) (2)8

r 2 Var [ Field . ||vo||r 6= ? (3)8
v 2 V, f 2 Field . |{v !f v0 | v0 2 V }| = 1 (4)8
v . ||v||f = 1 ) |{v0 | v0 !f v}| <= 1 (5)8
v1, v2, e . hit(S, e, v1) ^ hit(S, e, v2) ) v1 = v2 (6)

Fig. 7. Consistency invariants maintained by the algorithm.

Given a configuration S, the analysis can derive the queries presented Figure 6:
- Alias information. Two nodes are unaliased if any of their reference counts is in-consistent, i.e. they have different numeric values.

- Hit expressions. The function hit(S, e, v) indicates that expression e references thecell represented by the node

v. This is defined recursively using the reference countsand points-to relations.

- Miss expressions. The function miss(S, e, v) indicates that e doesn't reference thecell represented by

v.

We will use these queries to formalize the analysis algorithm in the next Section.Figure 7 presents several invariants that our analysis maintains at all times:

1. All nodes other than vnull must be directly connected to vo. Moreover, a node vpointing into

vo (v !f vo) must also be pointed by vo (vo !g v) or by somevariable (||
v||x = 1). This invariant ensures that the number of nodes and edges inthe graph is bounded by the number of variables and fields in the program.

2. Since vnull represents null values, it can't have outgoing edges.3. All references to the tracked cell are precisely known.
4. A node can have at most one outgoing edge with the same field.5. If a node

v has a single incoming reference from some field f , a configuration canonly have one node to represent this predecessor.

6. Each expression references at most one node.

5 Analysis Algorithm
We now proceed to present the dataflow algorithm that computes a heap abstraction ateach program point. For each configuration that models the state of the tracked cell
before a statement, the analysis computes a set of configurations that describes thepossible states of the cell after the statement.

We assume a simple program representation consisting of a control-flow graphwhose nodes are simple assignment. Assignments and expressions have the form:

Statements s ::= x = new | x = null | x = y | x = y.f | x.f = y | x.f = nullExpressions

e ::= null | x | x.f

where x 2 Var ranges over variables, and f 2 Field ranges over fields.

focusH(S, x.f) = (V 0, v0o, v0null, O0, I00, || * ||0) where,

S0 = 8>><>>:

unify(addNode(S, vx, x, 1), vx, v) ~contains(S, x) ^ ||vo||f = 1 ^ v !f vo
addNode(S, vx, x, 1) ~contains(S, x) vx fresh
unify(S, vx, v) ||vo||f = 1 ^ v !f vo
S otherwise
I00 = I0 [ {vx !f vo}

focusM(S, x.f) = (V 0, v0o, v0null, O0, I00, || * ||0) where,

S0 = 8<:

unify(addNode(S, v0, x, 0), v0, v) ||vo||f = 1 ^ v !f vo v0 fresh
addNode(S, v0, x, 0) ||vo||f = 1 v0 fresh
S? otherwise
I00 = I0 [ {v0 !f vo}

Fig. 8. Focus operations. The helper functions addNode and unify are defined in Figure 11. We
use S0 as a shorthand notation for (V 0, v0o, v0null, O0, I0, || * ||0).

Initialization As discussed in Section 2, for each allocation site x = new, the analysisbuilds a configuration

S = ({vo, vnull}, vo, vnull, ?, {vo !f vnull | f 2 Field}, || * ||) atthe program point after the allocation, where ||

vo||x = 1 and ||vo||r = 0 for any r 6= x.The configuration describes a representative heap cell allocated at this site. Then, the

analysis tracks this configuration through the program.

Alternatively, if a code fragment is to be analyzed separately, the set of all possibleconfigurations at the beginning of that fragment must be supplied.

Focus operations Given an input configuration describing the state of the tracked cellbefore an assignment statement

e1 = e2, the analysis tries to determine whether e1and
e2 reference the tracked cell. Whenever the analysis cannot determine if ei (i 2{1
, 2}) hits or misses the tracked cell (i.e. ~hit(S, ei, vo)^~miss(S, ei, vo)), the analysisbifurcates and creates two new configurations that are focused with respect to

ei.
Figure 8 shows the focus operations. Since exact reference counts are known for
vo, it is known whether variables hit or miss vo. Therefore, the analysis only focusesexpressions of the form

x.f. To make an expression x.f hit vo, the analysis simplyunifies the predecesor of

vo via field f (v) and the node referenced by x (vx). Theoperation will also add the node

vx or the incoming field f if they didn't exist beforefocusing. A similar algorithm is used to make an expression

x.f miss vo. Although,if ||
vo||f >= 2, it is not possible to express the fact that x.f misses the object. If thissituation occurs, the focus operation returns an imprecise configuration

S? indicatingthat the analysis no longer tracks the state of the tracked cell.

Transfer function The analysis then applies the transfer function to each focused con-figuration. Figure 9 presents the transfer function for an assignment

e1 = e2. First, theanalysis nullifies
e1 using the helper function kill. For store assignments x.f = y, theanalysis also creates the node for

y in case it didn't exist, as this node might become a

transfer(S, e1 = e2) = clean(V 0, v0o, v0null, O00, I00, || * ||00) where,

S0 = j addNode(kill(S, e1), v0, y, 1) e1 = x.f ^ e2 = y ^ ~contains(S, y)kill(S, e

1) otherwise

||v||00r = 8<: ||

v||0r + 1 hit(S, e2, v) ^ [(e1 = x ^ r = x) . (e1 = x.f ^ r = f)], or||
v||0r miss(S, e2, v) . (e1 = x ^ r 6= x) . (r 6= f ^ e1 = x.f), or?

otherwise
O00 = O0 [ {vo !f v | e1 = x.f ^ hit(S0, x, vo) ^ hit(S0, e2, v)}
I00 = I0 [ {v !f vo | e1 = x.f ^ hit(S0, x, v) ^ hit(S0, e2, vo)}

Fig. 9. Transfer function. The helper functions addNode, kill and clean are defined in Figure 11.
We use S0 as a shorthand notation for (V 0, v0o, v0null, O0, I0, || * ||0).

merge(S1, S2) = clean(V 0, v0o, v0null, O0, I0, || * ||0) where,

V 0 = {vi,j | vi 2 V 1 ^ vj 2 V 2}
v0o = vo,o
v0null = vnull,null
O0 = {v0o !f vi,j | v1o !1f vi ^ v2o !2f vj}

I0 = {vi,j !f v0o | vi !1f v1o ^ vj !2f v2o}||

vi,j||0r = ||vi||1r t ||vj||2r

Fig. 10. Merge operation. Precondition: ||v1o|| = ||v2o|| and (v1o !1f v1o , v2o !2f v2o).

neighbor after the store. The reference counts are then updated. The appropriate refer-ence count of each node

v is increased when e2 hits v, it remains unchanged when e2misses, and it is set to ? when the analysis cannot determine whether

e2 hits or misses.The points-to edges are added in the case of store statements. Finally, the clean helper

function removes nodes that are not neighbors of the tracked cell.

Merge operation At join points, the analysis uses the merge operation from Figure 10to combine configurations from different branches. Two configurations are combined
only if they have identical reference counts and the same set of self-edges on the trackedcell. The merge operation defines one node for each pair of nodes in the input configurations. The reference counts are combined using the join in the flat lattice (N?, v).Thus, if

i 6= j: i t i = i, i t j = ?, and i t ? = ? t i = ?. The clean operationguarantess that the number of nodes and edges in the resulting configuration is bounded

by the number of variables and fields in the program.

Auxiliary functions The auxiliary operations used by the analysis are fairly straight-forward. They are shown in Figure 11 and are summarized below:

- The addNode operation adds a neighboring node, without connecting it to vo. Thereference count of the added node from variable

x is set according to i 2 {0, 1}.This function is used both when focusing and when applying the transfer function.

addNode(S, v0, x, i) = (V [ {v0}, vo, vnull, O, I, || * ||0) where,

||v||0r = 8<:

i r = x ^ v = v0?

r 6= x ^ v = v0||
v||r otherwise

kill(S, e) = (V, vo, vnull, O - K, I - K, || * ||0) where,

||v||0r = 8<:

0 e = r = x||

v||r - 1 e = x.f ^ r = f ^ hit(S, e, v)||
v||r otherwise
K = {v !f v0 | e = x.f ^ ~miss(S, x, v)}

clean(S) = (V 0, vo, vnull, O, V 0 C I, V 0 C || * ||) where,

V 0 = {vo, vnull} [ range(O) [ {v | v 2 dom(I) ^ 9x . ||v||x = 1}

where V 0 C f restricts the domain of f to V 0

unify(S, vi, vj) = (V 0, vo, vnull, O0, I0, || * ||0) where,

V 0 = V - {vj}
O0 = O - {vo !f vj} [ {vo !0f vi | vo !f vj 2 O}
I0 = I - {vj !f vo} [ {vi !0f vo | vj !f vo 2 I}

||v||0r = j ||vi||r u ||vj||r v = vi||v||

r otherwise

Fig. 11. Helper operations. The function unify assumes mayAlias(S, vi, vj) holds, and vj 6= vnull.

- The kill operation removes an expression and updates the reference counts accord-ingly. The operation supports strong updates when field expressions are killed.
- The clean operation removes unnecessary nodes from a configuration. This opera-tion is used by the end of the transfer functions and merge operation.
- The unify operation combines two nodes that may alias into one single node. Thisis done by transferring all information from one node to the other. Moreover, the

result has the most precise reference counts from the input nodes.

5.1 Assume-And-Check Approach
Although the analysis can successfully determine that the reference count property rcand the doubly-linked list invariant are preserved for the tracked cell during destructive

operations, in many cases it cannot determine that the reference count property of theneighbors is restored. For instance, in the

insert example from Figure 5 the heapreference counts are not known for the neighboring cell pointed by

y, because y "camefrom the outside" to join the local heap. A similar situation occurs when removing an

element from a list: a cell two levels of indirection away from the tracked cell getscloser and becomes one of its neighbors. As discussed, the neighbor's reference count
information is, however, needed before insert.

We address this issue using an assume-and-check approach. This approach is basedon defining assumption points in the program. We consider that such points are manually marked by the user using a special assume-and-check instruction. The as-sumption points are program points where the analysis can safely restore the reference
count information for the neighbors. As implied by the name, the analysis performs twotasks when it reaches such points:

- Assume: Whenever the analysis of a tracked cell reaches an assumption point, itassumes that the reference count property

rc holds for all of its neighbors. Moreprecisely, all neighbors are assumed to have at most one reference from each field.

This enables the analysis to restore their reference counts: if the current configura-tion is such that the tracked cell points to neighbor

v via some field f , i.e., vo !f v,then the analysis restores
v's reference count from f : ||v||f = 1.- Check: Whenever the analysis of a tracked cell reaches an assumption point, it

checks if the tracked cell itself satisfies the reference count property rc, i.e., if ithas at most one reference per field. When the assumption is violated, the analysis
reports an error and all of the analysis results are invalidated. Otherwise, if allchecks succeed, then all assumptions were correct.

Essentially, restoring the reference counts of the neighbors requires knowledgeabout all cells. The assume-and-check approach provides a simple mechanism for gathering such global information without breaking the local analysis methodology.Standard heap operations typically require one single assumption point, after the
operation finishes. In the example from Section 3, an assume-and-check instruction isadded at the end of the function. This suggests that default assumption at such points
could be used to reduce the amount of annotations. In addition, assume-and-check in-structions can be refined to indicate the specific field for which the reference count must
be assumed and checked.The assumptions presented here are specifically formulated for doubly-linked lists.
Other shapes might require different assumptions. For instance, in the case of trees withparent pointers, the analysis must assume and check that the sum of the reference counts
from left and right fields is at most one, i.e., no cell is pointed by both a left anda

right link.

5.2 Soundness
This section summarizes the formal framework and the soundness result for our anal-ysis. We refer the reader to a technical report [11] for a detailed presentation of the

formal model and the complete proofs.Each concrete program state

oe = (', h) 2 State consists of a variable environment
' that maps variables to values, and a heap h that maps the fields of each location to theirvalues. Values are either heap locations (

Loc) or the constant null. By abuse of notation,we write
l 2 oe to indicate that l is an allocated heap cell, i.e. in the range or domainof
' or h. The execution of the program is modeled using denotational semantics viaa function [[

s]] : State ! State that maps the state oe before a statement s, to the state[[
s]](oe) after the statement. An abstraction function ffoe(l) maps each heap cell l in aconcrete heap to a local abstraction

S = (V, vo, vnull, O, I, || * ||). The relation v is thepartial order over local abstractions. An entire heap abstraction

A consists of a finite setof local abstractions
S. The main result is as follows.

Program Local Abs. Global Abs. (TVLA)

Configs. Avg. Nodes Time Avg. Avg. Nodes Time
In Avg. per Config. (sec) Structures per Struct. (sec)

insertBefore 7 6.5 2.2 0.07 2.7 3.9 0.59
appendLast 4 4.5 2.1 0.06 4.6 3.7 0.77
concat 4 4.5 2.3 0.07 4.8 3.7 0.88
copy 4 4.5 2.1 0.09 4.8 3.5 1.24
insertNth 4 6.2 2.3 0.09 7.0 3.2 1.38
removeData 3 8.2 2.3 0.13 10.1 3.0 1.86
filter 3 26.3 2.0 0.37 24.7 2.2 4.19

Table 1. Analysis Evaluation

Theorem 1. Given a program P , program point p, a concrete state oe that can ariseat point

p during the execution of the program, and an abstraction A that the analysis
computes at that program point, then each concrete heap cell in oe is modeled by at leastone local abstraction in

A: 8l 2 oe . 9S 2 A . ffoe(l) v S.

The correctness proof is divided into four lemmas regarding the correctness of eachof the following: the generating function at allocation sites; the transfer functions; the

focus operation; and the assume-and-check coercions. The correctness of transfer func-tions forms the bulk of the proof.

5.3 Evaluation
We have developed a prototype implementation of the local analysis presented in thispaper in Java, and used it to analyze the doubly-linked list programs shown in Table 1. Our local analysis has successfully verified that all of these programs maintainthe doubly-linked list shape. All of the experiments were run on a 2GHz Pentium machine with 1GB of memory, running Linux.

The input to each program is described using at least 3 configurations (one for themiddle, and one for each end of the list). Additional configurations are needed to indicate where the arguments point in the list. Programs that allocate new heap cells alsoinclude one configuration for the allocation site. The number of input configurations is
shown in the first column of the table.

Each program, except filter, has been annotated with one single assume-and-check instruction, inserted at the end of the program. The

filter program uses a loopto remove several elements from the input list. For this program, and additional assume

annotation has been added at the beginning of the loop body. This ensures that the rcproperty holds on the neighboring cells after every removal from the list. The analysis
successfully verifies the checks at all of the assumption points.

The data in Table 1 shows several statistics about our analysis: the average numberof configurations per program point; the average number of nodes per configuration

(excluding the null node); and the analysis running time. These results show that theanalysis is fast, with an average running time of about 0.1 seconds per program.

To compare our implementation to a global analysis, we have also tested an imple-mentation in TVLA [12]. We have added an instrumentation predicate to describe the
DLL invariant. However, no global predicates, such as reachability, were included inthis implementation. The right part of Table 1 shows the results obtained with TVLA.
We observe that the number of 3-valued structures per program point is roughly equal tothe number of configurations per program point in our analysis, but the number of nodes
in those structures is larger than the number of nodes per configuration. Furthermore,the running time of the TVLA implementation is about 10 times slower. We attribute
this in part to the fact that TVLA uses of a global abstraction, and in part to the fact thatthe TVLA engine is generic, while ours is specialized.

6 Related Work
The work on shape analysis dates back to Jones and Muchnick [13]. They developed adataflow analysis for identifying (the lack of) cyclicity and sharing in heap structures using k-limited abstract heaps. Since then, many different approaches based on dataflowanalysis and abstract interpretation have been proposed to address this problem [14-
18, 6, 7, 19, 20, 8, 9]. Existing techniques include analyses that use path matrices andor matrices that describe reachability [15, 18], reference counting analyses [14], analyses that use shape graphs [21, 19, 6], shape analyses and abstractions expressed usingthree-valued logic [22, 23, 7, 8]. In addition, heap verification techniques using modelchecking or Hoare logic has also been explored [24-26]. Unlike abstract interpretation,logic-based tools rely on theorem provers and typically require heavyweight loop annotations. Alternatively, it is possible to synthesize loop invariants via predicate abstrac-tion [26-30]. The common aspect of all of the above techniques is that the analyzer or
verifier requires a global view of the entire heap in order to analyze a particular pieceof computation. In contrast, the analysis in this paper and our earlier analysis [4] are
fundamentally different, as the analysis has knowledge about the local properties ofone single heap cell, but is oblivious to the way the rest of the heap is structured. This
fine-grained abstraction leads to efficient algorithms. This is achieved at the expenseof giving up on global properties (such as reachability) that involve reasoning about
unbounded sets of cells.

This paper follows our initial work on shape analysis with tracked heap cells [4].The contribution of this work is a new local heap abstraction that expresses local structural invariants, and the development of an analysis that uses this abstraction to maintainthese invariants. This algorithm makes shape analysis with local reasoning about single
cells applicable to an important class of heap structures.

A related direction of research is the recent work on separation logic [31, 32]. Thisline of research has explored extensions of Hoare logic for reasoning about mutable

heap structures, by providing features such as the separating conjunction and the framerule, that makes it easier to write correctness proof for heap-manipulating programs.
Recently, separation logic has also been applied to the shape analysis problem [10, 9].Although the state transformers modify local portions of the abstract heap, their abstractions still describe entire linked structures. For instance, operations such as inserting orremoving elements from a list require knowing that the entire list is well-formed, using a "listness" predicate ls. This predicate behaves similarly to the summary node instandard shape analyses; it describes a global invariant for the entire list, not a local
property of a single cell.

7 Conclusions
We have presented an abstraction and analysis algorithm that makes it possible to ap-ply shape analysis with local reasoning to data structures that maintain structural invariants, such as doubly-linked lists. The local abstraction of a cell describes the localheap around that cell, and is therefore able to express local structural invariants. The
algorithm can successfully show that standard operations such as doubly-linked list in-sertions or removals maintain the doubly-linked list invariant.

References

1. Wilhelm, R., Sagiv, M., Reps, T.: Shape analysis. In: Proceedings of the 2000 International

Conference on Compiler Construction, Berlin, Germany (2000)2. Lev-ami, T., Reps, T., Sagiv, M., Wilhelm, R.: Putting static analysis to work for verification:

A case study. In: Proceedings of the 2000 International Symposium on Software Testing and
Analysis. (2000)3. Ghiya, R., Hendren, L., Zhu, Y.: Detecting parallelism in C programs with recursive data

structures. In: Proceedings of the 1998 International Conference on Compiler Construction,
Lisbon, Portugal (1998)4. Hackett, B., Rugina, R.: Region-based shape analysis with tracked locations. In: Proceedings

of the 32th Annual ACM Symposium on the Principles of Programming Languages, Long
Beach, CA (2005)5. Cherem, S., Rugina, R.: Compile-time deallocation of individual objects. In: Proceedings of

the International Symposium on Memory Management, Ottawa, Canada (2006)6. Sagiv, M., Reps, T., Wilhelm, R.: Solving shape-analysis problems in languages with destructive updating. ACM Transactions on Programming Languages and Systems 20(1)
(1998) 1-507. Sagiv, M., Reps, T., Wilhelm, R.: Parametric shape analysis via 3-valued logic. ACM Transactions on Programming Languages and Systems 24(3) (2002)8. Rinetzky, N., Sagiv, M., Yahav, E.: Interprocedural shape analysis for cutpoint-free programs. In: Proceedings of the 12th International Static Analysis Symposium, London, UK
(2005)9. Distefano, D., O'Hearn, P., Yang, H.: A local shape analysis based on separation logic. In:

Proceedings of the 12th International Conference on Tools and Algorithms for the Construction and Analysis of Systems, Vienna, Austria (2006)10. Gotsman, A., Berdine, J., Cook, B.: Interprocedural shape analysis with separated heap

abstractions. In: The 13th International Static Analysis Symposium, Seoul, Korea (2006)11. Cherem, S., Rugina, R.: Maintaining structural invariants in shape analysis with local reasoning. TR CS TR2006-2048, Cornell University (2006)12. Lev-Ami, T., Sagiv, M.: TVLA: A system for implementing static analyses. In: Proceedings
of the 7th International Static Analysis Symposium, Santa Barbara, CA (2000)13. Jones, N., Muchnick, S.: Flow analysis and optimization of Lisp-like structures. In: Conference Record of the 6th Annual ACM Symposium on the Principles of Programming Languages, San Antonio, TX (1979)

14. Chase, D., Wegman, M., Zadek, F.: Analysis of pointers and structures. In: Proceedings

of the SIGPLAN '91 Conference on Program Language Design and Implementation, White
Plains, NY (1990)15. Hendren, L., Nicolau, A.: Parallelizing programs with recursive data structures. IEEE Transactions on Parallel and Distributed Systems 1(1) (1990) 35-4716. Hendren, L., Hummel, J., Nicolau, A.: A general data dependence test for dynamic, pointerbased data structures. In: Proceedings of the SIGPLAN '94 Conference on Program Language Design and Implementation, Orlando, FL (1994)17. Deutsch, A.: Interprocedural may-alias analysis for pointers: Beyond k-limiting. In: Proceedings of the SIGPLAN '94 Conference on Program Language Design and Implementation, Orlando, FL (1994)18. Ghiya, R., Hendren, L.: Is is a tree, a DAG or a cyclic graph? A shape analysis for heapdirected pointers in C. In: Proceedings of the 23rd Annual ACM Symposium on the Principles of Programming Languages, St. Petersburg Beach, FL (1996)19. Chong, S., Rugina, R.: Static analysis of accessed regions in recursive data structures. In:

Proceedings of the 10th International Static Analysis Symposium, San Diego, CA (2003)20. Rugina, R.: Quantitative shape analysis. In: Proceedings of the 11th International Static
Analysis Symposium, Verona, Italy (2004)21. Sagiv, M., Reps, T., Wilhelm, R.: Solving shape-analysis problems in languages with destructive updating. In: Proceedings of the 23rd Annual ACM Symposium on the Principles
of Programming Languages, St. Petersburg Beach, FL (1996)22. Sagiv, M., Reps, T., Wilhelm, R.: Parametric shape analysis via 3-valued logic. In: Proceedings of the 26th Annual ACM Symposium on the Principles of Programming Languages,
San Antonio, TX (1999)23. Rinetzky, N., Sagiv, M.: Interprocedural shape analysis for recursive programs. In: Proceedings of the 2001 International Conference on Compiler Construction, Genova, Italy (2001)24. Moller, A., Schwartzbach, M.: The pointer assertion logic engine. In: Proceedings of the
SIGPLAN '01 Conference on Program Language Design and Implementation, Snowbird,
UT (2001)25. McPeak, S., Necula, G.: Data structure specification via local equality axioms. In: Proceedings of the 2005 Conference on Computer-Aided Verification, Seattle, WA (2005)26. Lahiri, S., Qadeer, S.: Verifying properties of well-founded linked lists. In: Proceedings of the 33th Annual ACM Symposium on the Principles of Programming Languages,
Charleston, SC (2006)27. Ball, T., Majumdar, R., Millstein, T., Rajamani, S.: Automatic predicate abstraction of C

programs. In: Proceedings of the SIGPLAN '01 Conference on Program Language Design
and Implementation, Snowbird, UT (2001)28. Balaban, I., Pnueli, A., Zuck, L.D.: Shape analysis by predicate abstraction. In Cousot, R.,

ed.: VMCAI. Volume 3385 of Lecture Notes in Computer Science., Springer (2005) 164-18029. Dams, D., Namjoshi, K.S.: Shape analysis through predicate abstraction and model checking.
In Zuck, L.D., Attie, P.C., Cortesi, A., Mukhopadhyay, S., eds.: VMCAI. Volume 2575 of
Lecture Notes in Computer Science., Springer (2003) 310-32430. Bingham, J.D., Rakamaric, Z.: A logic and decision procedure for predicate abstraction

of heap-manipulating programs. In Emerson, E.A., Namjoshi, K.S., eds.: VMCAI. Volume
3855 of Lecture Notes in Computer Science., Springer (2006) 207-22131. Reynolds, J.: Separation logic: A logic for shared mutable data structures. In: Proceedings

of the Seventeenth Annual IEEE Symposium on Logic in Computer Science, Copenhagen,
Denmark (2002)32. Ishtiaq, S., O'Hearn, P.: BI as an assertion language for mutable data structures. In: Proceedings of the 28th Annual ACM Symposium on the Principles of Programming Languages,
London, UK (2001)