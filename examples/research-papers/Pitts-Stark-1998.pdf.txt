

Operational reasoning forfunctions with local state
Andrew Pitts and Ian Stark

Abstract
Languages such as ML or Lisp permit the use of recursively defined function
expressions with locally declared storage locations. Although this can be
very convenient from a programming point of view it severely complicates
the properties of program equivalence even for relatively simple fragments
of such languages--such as the simply typed fragment of Standard ML with
integer-valued references considered here. This paper presents a method for
reasoning about contextual equivalence of programs involving this combination of functional and procedural features. The method is based upon the
use of a certain kind of logical relation parameterised by relations between
program states. The form of this logical relation is novel, in as much as it involves relations not only between program expressions, but also between program continuations (also known as evaluation contexts). The authors found
this approach necessary in order to establish the `Fundamental Property of
logical relations' in the presence of both dynamically allocated local state
and recursion. The logical relation characterises contextual equivalence and
yields a proof of the best known context lemma for this kind of language--
the Mason-Talcott `ciu' theorem. Moreover, it is shown that the method can
prove examples where such a context lemma is not much help and which
involve representation independence, higher order memoising functions, and
profiling functions.

1 Introduction
Lisp and ML are functional programming languages because they treat functions
as values on a par with more concrete forms of data: functions can be passedas arguments, can be returned as the result of computation, can be recursively

defined, and so on. They are also procedural languages because they permit the
use of references (or `cells', or `locations') for storing values: references canbe created dynamically and their contents read and updated as expressions are

evaluated. This paper presents a method for reasoning about the equivalence ofprograms involving this combination of functional and procedural features. What
emerges is an operationally-based form of reasoning about functions with localstate that seems to be both intuitive and theoretically powerful. Throughout we
assume a passing familiarity with the language Standard ML (Milner, Tofte, andHarper 1990) and its associated terminology. If in difficulty, see (Paulson 1991).

227

228 Pitts & Stark
Some motivation
The combination of functional and procedural features in Standard ML is veryexpressive. For example, it permits the programmer to exploit the modularity of

the functional idiom (Hughes 1989) in defining high-level control structures formanipulating program state. The combination is also useful from the point of view
of efficiency, since the use of local storage permits the efficient implementation ofsome functions and data structures with purely functional observable behaviour.

As a simple example, consider the following `memoised' version of the factorial
function in Standard ML.

Example 1.1.

val f = let val a = ref 0 and r = ref 1

fun f0 x = (if x = 0 then 1 else x * f0(x - 1))
in

fn x ) ((if x = !a then () else (a := x; r := f0 x)); !r)
end

(dec1)

The local references a and r are used to store the argument and the result of
the most recent invocation of the function; and the function acts like the purelyfunctional factorial

fun f x = (if x = 0 then 1 else x * f(x - 1)) (dec2)
except that when called with the same argument twice in succession it uses thecached result

!r, saving recomputation. So evaluating

let dec1 in (f 1000 + f 1000) end
will yield the same integer result as evaluating

let dec2 in (f 1000 + f 1000) end
but will only involve computing the factorial of 1000 once. Of course in this
simple example a similar saving can easily be achieved without leaving the purelyfunctional part of the language, for example with

let dec2 ; val x = (f 1000) in (x + x) end.
The point is that in general such functional transformations may require complicated static analysis of the context, whereas the transformation involving the mem-oised version is simply one of replacing occurrences of

dec2 with dec1 uniformly
in any context. The correctness of this optimisation amounts to the assertion that
dec1 and dec2 are contextually equivalent. In general one says that two phrases e1
and e2 in a programming language are contextually equivalent, and writes e1 ,= e2,if for all contexts

C[-], i.e. for all expressions which become complete programs

Operational reasoning for functions with local state 229
when the hole `-' is filled with e1 or e2, executing the program C[e1] yields exactlythe same observable results as executing

C[e2].

Why are dec1 and dec2 contextually equivalent? While it may be easy to seefor some particular context such as

let [-] in (f 1000 + f 1000), that C[dec1] and
C[dec2] evaluate to the same result, it is quite a different matter to prove that thisis so for

all contexts. Nevertheless there are reasons for believing that dec1 ,= dec2
holds, based upon the `privacy' of locally declared references and properties of thestate that remain invariant during evaluation. Here is how the argument goes.

Informal `proof ' of dec1 ,= dec2. Consider the following property:

the integer stored in r is the factorial of that stored in a. (1.1)
Note that if dec1 is evaluated then the two references created satisfy (1.1) (since 1is the factorial of

0). Moreover, the function value bound to f as a result of that
evaluation is such that if (1.1) holds before evaluating an application f(n), then itcontinues to hold afterwards and the value returned agrees with what we would

have obtained using dec2 instead of dec1 (namely the factorial of n).

Given any context C[-], since a and r are bound identifiers in dec1 and
evaluation of expressions respects ff-conversion, we may assume that a and r donot occur in

C[-]; so, the only way that the contents of the created references a
and r could be mutated during evaluation of C[dec1] is through applications of
the function value bound to f. It follows from the previous paragraph both that the
property (1.1) is invariant throughout the evaluation of C[dec1] and that any resultreturned is the same as for

C[dec2]. Since C[-] was arbitrary, dec1 and dec2 arecontextually equivalent. \Lambda ?

The reason why this is only an informal proof resides mainly in the statement
in italics about how a context can make use of its `hole', which certainly needsfurther justification. To emphasise this point, we tease the reader with a similar

informal `proof' of contextual equivalence that turns out to be false. Recall that
int ref is the Standard ML type of integer references: its values are addressesof integer storage locations, and those values can be tested for equality--meaning

equality of the reference addresses rather than equality of their contents. Considerthe following declarations of functions of type

int ref ! int ref.

Example 1.2.

val f = let val a = ref 0 and b = ref 0

in

fn c ) (if c = a then b else a)
end

(dec3)

val f = let val a = ref 0 and b = ref 0

in

fn c ) (if c = b then b else a)
end

(dec4)

230 Pitts & Stark
False `proof ' of dec3 ,= dec4. Given any context C[-], since a and b are boundidentifiers in

deci (i = 3, 4) and evaluation of expressions respects ff-conversion,
we may assume that a and b do not occur in C[-]. Thus in evaluating C[deci] any
value of type int ref which is supplied by C[-] to the function declared by deci
cannot be either a or b. Therefore any such application will always use the secondbranch of the conditional and return

a. So evaluation of C[dec3] will produce thesame result as evaluating
C[dec4]. Since C[-] was arbitrary, dec3 and dec4 are
contextually equivalent. \Lambda ?

The italicised part of this `proof' is of the same kind as in the previous case, butthis time it is false. Indeed

dec3 and dec4 are not contextually equivalent. As withany contextual inequivalence, this can be demonstrated rigorously by exhibiting

a context C[-] for which C[dec3] and C[dec4] produce different results. Such acontext is

let [-]; val c = ref 0 in (f(f c) = f c) end
since in this case C[dec3] evaluates to false whereas C[dec4] evaluates to true.
For in the environment created by evaluating the local declarations in C[dec3](respectively

C[dec4]), f c evaluates to a (respectively a), hence f(f c) evaluates
to b (respectively a) and therefore the test f(f c) = f c yields false (respectively
true). Note that contrary to the expectation in the false `proof' given above, even
though C[-] does not know about the local references a and b, it is able to feedthem as arguments to

f after one application of f to some external reference c.

Incidentally, Example 1.2 demonstrates that the following na"ive extensionality
principle fails for Standard ML functions:

Two expressions F and F 0 of function type oe ! oe0 are contextually
equivalent if for all values V of type oe, F V and F 0 V are contextuallyequivalent expressions of type

oe0.

We have just seen that if F3 and F4 are the expressions of type int ref ! int refthat occur on the right-hand sides of the declarations

dec3 and dec4 respectively,then
F3 6,= F4. On the other hand, one can show for all values c : int ref that
F3 c and F4 c are contextually equivalent. So F3 and F4 do not satisfy the aboveextensionality principle.

This failure of extensionality is not merely a result of mixing higher orderfunctions with imperative features. For in Reynolds' Idealised Algol (1981,
1982) with its call-by-name function application and restriction of local statejust to commands (

i.e. expressions of type unit, in ML terminology), such an
extensionality principle does hold: see (Pitts 1997). Rather, it is the fact thatin ML access to local references can be passed out of their original scope during

evaluation which complicates the properties of contextual equivalence. We saw thiswhen demonstrating

dec3 6,= dec4 in Example 1.2. Incidentally, it is worth noting
that although this example makes use of equality testing on references, the failureof extensionality in ML does not depend upon this feature. (Indeed, in the fragment

Operational reasoning for functions with local state 231
of ML we use in this paper this equality test is definable from more primitive ones:see Remark 2.1.) The operationally-based parametric logical relation we present

in this paper provides a characterisation of contextual equivalence that yields arigorous underpinning for the kind of informal argument used in Example 1.1,
while avoiding the pitfalls illustrated by Example 1.2.

Some background
The methods presented here for reasoning about recursive functions and localstorage are rooted in the work of O'Hearn and Tennent (1995) and Seiber (1995).

These authors use relational parametricity (Reynolds 1983) and logical relations(Plotkin, 1973, 1980) to give denotational models of Algol-like languages which
match the operational behaviour of local variables better than previous modelsdid. Since our goal is not to produce `fully abstract' models, but rather to
identify practically useful proof methods for contextual equivalence, there is some

advantage to concentrating on operationally-based versions of these relationaltechniques. This was done for Algol-like languages in (Pitts 1997). Here

we carry out a similar program for an ML-like language. For the reasonsgiven in the previous subsection, the difficulties which have to be overcome to
produce useful proof methods for ML contextual equivalence are greater thanthose for Algol. Nevertheless, we obtain a fairly light-weight tool compared
with the mathematical structures involved in the denotational models, and onewhich relates directly to the syntax and structural operational semantics of the
language. But of course these operationally-based techniques would not havearisen without the previous, denotational insights. Furthermore, the method we use
to establish the fundamental properties of the operationally-based logical relationwith respect to recursive program constructs relies on operational analogues
of familiar denotational methods (viz. fixed point induction and admissibility
properties).

Mason and Talcott have developed a number of operational methods for rea-soning about Lisp programs with destructive update (Mason and Talcott 1991a;

Mason and Talcott 1992a; Honsell, Mason, Smith, and Talcott 1995). Like us,they highlight the issue of functions with local state, which they call `objects'
(1991b, 1992b). Notions of `constraint' and `equivalence under constraints' areused, which can be loosely identified with the use we make in this paper of relations between states. These lead to a set of reasoning principles that match certain
aspects of our operational logical relation. Their (inv) expresses the fact that prop-erties of local store are preserved; while their (abstract) and (abstractable) say

that if two functions preserve some property of store, and whenever it holds theygive the same result, then they are equivalent. Proofs based on these principles are
similar in some ways to those given in Section 5. There are however limitationsto these methods, which our work removes. For example, the validity of (inv),
(abstract) and (abstractable) is restricted to first-order functions over atoms, asa consequence of their `hands-on' proof through direct consideration of reduc232 Pitts & Stark
tion in certain contexts. Our logical relation has no such restriction (witness thehigher order profiler of Example 5.8). Our techniques then can be seen as a certain
generalisation to higher types of the results of Mason et al, through the powerfulmachinery of parameterised logical relations.

Overview of the paper
In Section 2 we introduce a language of Recursive Functions with local State,
called ReFS, which is the vehicle for the formal development in the rest of thispaper. Syntactically, it is a simply typed lambda calculus: there are ground

types for booleans, integers, the unit value, and integer references; higher typesare built up over these using product and function type constructors. We give
the structural operational semantics of ReFS in terms of an inductively defined
evaluation relation

s, M + V, s0 . (1.2)

This and the associated definition of contextual equivalence are quite standard, andmake ReFS equivalent to a fragment of SML according to its definition in (Milner,

Tofte, and Harper 1990). Harper and Stone (1996) reformulate the operationalsemantics of SML in terms of transitions between configurations containing a
component for the current program continuation, or evaluation context. (See also
Harper, Duba, and MacQueen 1993.) The advantage of this approach is thatit can give a

structurally inductive characterisation of the termination predicate,9
V, s0 (s, M + V, s0) used to define contextual equivalence. Accordingly, inSection 3 we introduce a new termination relation

hs, K, M i# (1.3)
where the component K formalises the ReFS evaluation contexts. The relation
(1.3) is defined by induction on the structure of M and K, and contains the originaltermination relation for + as a retract. We are able to exploit the structural nature of

our formulation of termination to streamline the induction proofs that arise whenproving properties of contextual equivalence. A case in point is the proof of the
Unwinding Theorem 3.2 that completes this section. It expresses a compactnessproperty of recursive function values with respect to termination which we need
later to prove a crucial preservation property of our parametric logical relation(Proposition 4.8(xv)).

The logical relation itself is introduced in Section 4 and its fundamental properties established. It is parameterised by binary relations between states. Apartfrom being operationally- rather than denotationally-based, we are able to make a

pleasing simplification of (O'Hearn and Tennent 1993, Section 6), in that our pa-rameters are just

arbitrary (non-empty) state-relations without any extra structure
of a partial bijection on the underlying address names. In fact the definition ofthe logical relation is rather different from previous such definitions for languages

Operational reasoning for functions with local state 233
with local state, because it involves binary relations between evaluation contexts
K as well as binary relations between expressions M .

We found this approach unavoidable in order to establish the Fundamental
Property of the logical relation (Theorem 4.9) and hence its connection withcontextual equivalence (Theorem 4.10). The reason has to do with the interaction

between recursion and the fact that the `size' of the state (measured by the numberof storage locations allocated) may grow in a non-trivial fashion during evaluation

in a language like ReFS. Thus in (1.2), the number of locations in the final state
s0 may be strictly greater than the number in the initial state s and we cannot`garbage collect' that part of

s0 involving these extra locations, because the value
V may be a function closure using those locations. Now in defining a logicalrelation parameterised by state-relations and based upon the evaluation relation

(1.2), it is natural to use existential quantification over relations on the dynamicallycreated part of

s0: this is what the authors did for their nu-calculus in (Pitts and
Stark 1993), for example. However, such an existential quantification destroys the(operational analogue of the) admissibility property needed to show that recursive

program constructs respect the logical relation--without which there would be noconnection between contextual equivalence and the logical relation.

1

By contrast, the logical relation we give here takes account of evaluation
contexts rather than final states and uses the termination relation (1.3), whichmakes no explicit mention of final states. This allows us to avoid any use of

existential quantification over state relations in the definition and renders the proofof the Fundamental Property relatively straightforward. The price we pay is that

the definition of the logical relation between expressions is intertwined with thedefinition of a `dual' relation between evaluation contexts (program continuations).
However, it is a price worth paying, since not only does it allow us to prove
the crucial Fundamental Property of the logical relation, but also we are able tocharacterise contextual equivalence in terms of the logical relation

2 and deduce the

Mason-Talcott `closed instantiations of uses' theorem for ReFS as a corollary (seeTheorem 4.10). Moreover, we show in Section 5 that we can recover a technique

for proving ReFS contextual equivalence involving existential quantification over`locally invariant' state relations which is reminiscent of the methods of (Pitts and
Stark 1993; Pitts 1997). This Principle of Local Invariants (Proposition 5.1) isput to work in Section 5 to prove examples of contextual equivalence involving
the notion of representation independence, higher-order memoising functions, andhigher-order profiling functions. We also examine the limitations of this method,
giving an example (Example 5.9) of two contextually equivalent ReFS expressions

that are not easily seen to be logically related.

In the final Section 6 we discuss some desirable extensions of the ReFS languageand how our techniques might be extended to cope with them.

1This problem did not surface in (Pitts and Stark 1993) because the nu-calculus does not contain
any recursive features.2A similar characterisation for the nu-calculus definitely fails for the logical relation of (Pitts

and Stark 1993).

234 Pitts & Stark
2 Recursive functions with local state
The examples discussed in the Introduction involved the interaction between recur-sively declared functions and dynamically created, mutable references for storing

integer values. They were phrased in a simply typed fragment of Standard MLwith ground types

bool (booleans), int (integers), unit (one-element type), and
int ref (integer storage locations). In this section we introduce a typed lambdacalculus called ReFS--a language of Recursive Functions with local State. It is

essentially equivalent to the fragment of Standard ML we have in mind and will
be the vehicle for the formal development in the rest of this paper.

The ReFS language
The syntax of ReFS is given in Figure 1. It takes an unusually reduced form, in thatmost operators may take only values as arguments. This is essentially a technical

convenience: it means that all the sequential aspects of the language devolve ontothe

let construct, and can therefore be treated uniformly. Unrestricted forms are
easily defined in terms of let as shown in Figure 2, and we shall use them freely.Note that the ReFS

let is much simpler than that of ML, being neither recursivenor polymorphic.

ReFS has two kinds of identifier, variables (x, y, f, g, . . . ) and location constants(
`, `0, . . . ). The latter occur explicitly in ReFS expressions because we prefer to
avoid the use of environments in the ReFS operational semantics. Variables maybe free or bound, while locations are always free. The form

rec f (x). M binds
free occurrences of the variables f and x in expression M , and let x = M in M 0binds any free occurrences of

x in M 0. We identify expressions and values up to
ff-conversion of bound variables. The finite sets of free variables and locationsof an expression

M are denoted fv (M ) and loc(M ) respectively. We substitutevalues for free variables

M [V /x] in the usual capture-avoiding way; the restriction
to values V arises from the choice of reduced syntax and is appropriate for a call-by-value language.

We only consider expressions that are well-typed. The ReFS types are given inFigure 1:

bool and int are the types of booleans and integers respectively; unit is a
one-value type; loc is the type of names of integer storage locations, correspondingto the Standard ML type

int ref; oe ! oe0 and oe * oe are function and producttypes, corresponding to the Standard ML types

oe -> oe0 and oe * oe0. For simplicity,
we assume that the set Var of variables is partitioned into a family of countablyinfinite subsets, one for each type: thus each variable

x comes with a type oe, and
we write x : oe to indicate this. The rules for assigning types to expressions aregiven in Figure 3 and are quite standard. They inductively define a judgement of

the form \Gamma  ` M : oe, where \Gamma  is a finite subset of Var , M is a ReFS expression,and

oe is a ReFS type. The role of \Gamma  in the judgement is to indicate explicitly a
set of variables free for substitution in M . Indeed, it is not hard to prove that if
\Gamma  ` M : oe is derivable then fv (M ) ` \Gamma . Most of the time we will be dealing

Operational reasoning for functions with local state 235

Expressions M ::= V | if V then M else M | V op V | fst(V ) | snd (V )|

ref (V ) | !V | V := V | V V | let x = M in M

Values V ::= x | true | false | n | () | ` | rec x(x). M | (V, V )

Types oe ::= bool | int | unit | loc | oe ! oe | oe * oe

where

x 2 Var an infinite set of variables,

` 2 Loc an infinite set of locations,
n 2 Z = {. . . , -2, -1, 0, 1, 2, . . . } the set of integers,
op 2 {+, -, =, <=, . . . } a finite set of arithmetic operations and relations.

Figure 1: ReFS syntax

if M1 then M2 else M3 def= let x = M1 in (if x then M2 else M3)

where x /2 fv (M2, M3)

and similar clauses for M1 op M2, (M1, M2), fst (M ), snd (M ), M1M2, ref (M ),
!M , and M1 := M2.

* x. M def= rec f (x). M where f /2 fv (M )

M ; M 0 def= let x = M in M 0 where x /2 fv (M 0)

Ycbv def= rec y(f ). * x. f (yf )x
while B do M def= (rec f (x). if B then (M ; f ()) else ())()

where f, x /2 fv (B, M )

let x = M1; x0 = M2 in M3 def= let x = M1 in (let x0 = M2 in M3)

let (x1, x2) = M1 in M2 def= let x = M1 in let x1 = fst (x) in

let x2 = snd (x) in M2 where x /2 fv (M2)

let f (x) = M1 in M2 def= let f 0 = rec f (x). M1 in M2[f 0/f ]

where f 0 /2 fv (M2)

Figure 2: Sugar for the ReFS syntax

236 Pitts & Stark

\Gamma , x : oe ` x : oe \Gamma  ` true : bool \Gamma  ` false : bool

\Gamma  ` n : int (n 2 Z) \Gamma  ` () : unit \Gamma  ` ` : loc (` 2 Loc)
\Gamma , f : oe ! oe0, x : oe ` M : oe0

\Gamma  ` rec f (x). M : oe ! oe0 (f, x /2 \Gamma )

\Gamma  ` V : oe \Gamma  ` V 0 : oe0

\Gamma  ` (V, V 0) : oe * oe0

\Gamma  ` V : bool \Gamma  ` M : oe \Gamma  ` M 0 : oe

\Gamma  ` if V then M else M 0 : oe
\Gamma  ` V : int \Gamma  ` V 0 : int

\Gamma  ` V op V 0 : fl (fl 2 {bool , int } is the result type of op)

\Gamma  ` V : oe * oe0

\Gamma  ` fst (V ) : oe

\Gamma  ` V : oe * oe0
\Gamma  ` snd (V ) : oe0
\Gamma  ` V : int
\Gamma  ` ref (V ) : loc

\Gamma  ` V : loc
\Gamma  ` !V : int

\Gamma  ` V : loc \Gamma  ` V 0 : int

\Gamma  ` V := V 0 : unit

\Gamma  ` V : oe ! oe0 \Gamma  ` V 0 : oe

\Gamma  ` V V 0 : oe0

\Gamma  ` M : oe \Gamma , x : oe ` M 0 : oe0

\Gamma  ` let x = M in M 0 : oe0 (x /2 \Gamma )

Notation. We use the following notation for various collections of well-typed
expressions and values.

Expoe(\Gamma ) def= {M | \Gamma  ` M : oe} Val oe(\Gamma ) def= {V 2 Expoe(\Gamma ) | V a value}

Expoe def= Expoe(;) Val oe def= Val oe(;)

Exp def= [{Expoe | oe a type} Val def= [{Val oe | oe a type}.

Figure 3: ReFS type assignment

Operational reasoning for functions with local state 237
with closed expressions, by which we mean expressions with no free variables, butquite possibly involving location constants

` 2 Loc.
To further simplify the operational semantics of ReFS we have rolled functionabstraction and recursive function declaration into the one form

rec f (x). M whichcorresponds to the Standard ML value

fn x ) (let fun f x = M in M end).
Figure 2 shows how ordinary lambda abstraction, the call-by-value Y combinator,local recursive function definitions and

while loops are all special cases of this
construct.

The ReFS operations for manipulating store are exactly as in Standard ML, but
restricted to storage of integer values. Expression ref (V ) allocates local store,placing the integer denoted by

V at some fresh location, which is then returned asthe value of the expression; operation

!V fetches the value stored at the location
denoted by V ; and V := V 0 updates it with the integer denoted by V 0, returning theunit value

().

Remark 2.1 (Testing equality of locations). ReFS does not contain a primitiveoperation

eq : loc ! loc ! bool for testing equality of locations (as opposed
to equality of their contents). Nevertheless such an operation is definable. Forexample

eq def= * x. * x0. let v = !x in (x := !x0 + 1; let b = (!x = !x0) in (x := v; b))
has the required evaluation properties with respect to the operational semantics of
ReFS introduced below.

Evaluation of expressions
The meaning of ReFS expressions clearly depends on the current contents ofmemory or

state. We represent states as finite partial functions from locations
to integers s : Loc *fin Z, with dom(s) being the locations actually occupied. Theempty state is denoted

(), and for any state s, location ` and integer n we write
(s; ` := n) for the updated state defined by

dom(s; ` := n) = dom(s) [ {`}

(s; ` := n)(`0) = (s(`0) if `0 6= `,n if `0 = `.
In the case that ` /2 dom(s), we write s \Omega  (` := n) for (s; ` := n). More generally,

given states s and s0 with disjoint domains their smash product s \Omega  s0 is the statewith

dom(s \Omega  s0) = dom(s) [ dom(s0)

(s \Omega  s0)(`) = (s(`) if ` 2 dom(s),s0(`) if ` 2 dom(s0).

238 Pitts & Stark

s, V + V, s (+val)
s, Mb + V, s0
s, if b then Mtrue else Mfalse + V, s0 (+if)

s, n op n0 + c, s if c = n op n0 (+op)
s, fst ((V, V 0)) + V, s (+fst)
s, snd ((V, V 0)) + V 0, s (+snd)
s, M [ (rec f (x). M )/f, V /x ] + V 0, s0

s, (rec f (x). M )V + V 0, s0 (+app)

s, ref (n) + `, s \Omega  (` := n) any ` /2 dom(s) (+ref)

s, !` + n, s if n = s(`) (+get)
s, ` := n + (), (s; ` := n) (+set)
s, M + V, s0 s0, M 0[V /x] + V 0, s00

s, let x = M in M 0 + V 0, s00 (+let)

Figure 4: ReFS evaluation rules

Operational reasoning for functions with local state 239
We write Sta for the set of all states; and if ! ` Loc is a finite set of locationconstants, we write

Sta(!) for the subset of Sta consisting of all states s with
dom(s) = !.

Much as in the Definition of Standard ML (Milner, Tofte, and Harper 1990),we give the operational semantics of ReFS via an inductively defined evaluation

relation of the form

s, M + V, s0 (2.1)

where s, s0 2 Sta, M 2 Exp, and V 2 Val . We consider only well-formed
judgements, where M and V may be given some common type oe, and all locationsused are properly defined:

loc(M ) ` dom(s) and loc(V ) ` dom(s0). The rules
defining the relation are given in Figure 4 and are all quite standard. We write
s, M + to indicate termination, i.e. that s, M + V, s0 holds for some s0, V (and
hence in particular that loc(M ) ` dom(s)).

Even taking into account differences in syntax, there are some differences be-tween this operational semantics and the corresponding fragment of the Standard ML definition (Milner, Tofte, and Harper 1990). For one thing, we have
eliminated the use of environments in the evaluation relation at the expenseof introducing the syntactic operation of substitution. Thus in rule (+app),

M [ (rec f (x). M )/f, V /x ] denotes the result, well-defined up to ff-conversion,of simultaneously substituting

rec f (x). M for all free occurrences of f and V for
all free occurrences of x, in M . The small price to pay for this approach is theexplicit appearance of locations in the syntax of expressions.

More significantly, the reduced syntax has concentrated the sequencing of
evaluation in the language down to just one rule: only (+let) has more than onehypothesis, and most have none.

Contextual equivalence
We regard two expressions of ReFS as equivalent if they can be used interchange-ably in any program without affecting the observable results of program execution. This is formalised by the standard notion of contextual equivalence, suitably
adapted for the language in hand.

As usual, a context C[-] is a ReFS expression in which some subexpressionshave been replaced by occurrences of a parameter, or

hole, `-'. The expression
resulting from filling the holes with an expression M is denoted by C[M ]. Sincethe holes may occur within the scope of

let - and rec-binders, free variables of M
may become bound in C[M ]. This `capture' of variables means that although theoperation of substituting

M for `-' in C[-] respects ff-conversion of M , it does not
necessarily respect ff-conversion of C[-]. Therefore we do not identify contextsup to

ff-conversion.

In the following definitions of contextual preorder and equivalence, we take
convergence at arbitrary type as our basic observable. As it happens, the expres-siveness of contexts means that we could have chosen other observations without

240 Pitts & Stark
changing the relations that result: convergence at unit type, or to a specified integervalue, would do just as well.

Definition 2.2 (Contextual preorder, contextual equivalence).
Suppose that M1, M2 2 Expoe(\Gamma ) are ReFS expressions. We write

\Gamma  ` M1 <= M2 : oe (contextual preorder)
if for all contexts C[-] such that C[M1] and C[M2] are closed terms of the sametype it is the case that

s, C[M1] + ) s, C[M2] +
holds for all states s with loc(C[M1], C[M2]) ` dom(s). We define

\Gamma  ` M1 ,= M2 : oe (contextual equivalence)
to mean that \Gamma  ` M1 <= M2 : oe and \Gamma  ` M2 <= M1 : oe.

It is an easy consequence of these definitions that <= is reflexive and transitive,
and hence that ,= is an equivalence relation; moreover both relations are preservedby all the expression-forming operations of the language (including those that bind

free variables).

3 A structurally inductive definition of termination
Before describing the logical relation for ReFS which is the main contribution of
this paper, we need to describe the continuation-based termination relation uponwhich it depends. As mentioned on page 233, the reformulation of termination

which we present in this section seems necessary in order to formulate a notionof logical relation that respects both dynamically allocated local state and recursively defined higher-order functions. Apart from this, the structurally inductive
definition of termination we give here is very convenient for formalising inductiveproofs about contextual equivalence, for the following reason.

Developing properties of ReFS contextual equivalence directly from its definition is not so easy. This is due to the quantification over all possible contexts thatoccurs in Definition 2.2 together with the nature of the termination relation,

s, M +.
Although it is an inductive (i.e. recursively enumerable) subset of Sta * Exp, itsdefinition is not

structurally inductive. For example, we can derive the rule

s0, M 0[V /x] +
s, let x = M in M 0 + if s, M + V, s

0

but the value expression V used in the substitution M 0[V /x] is not a primitive recursive function of the syntax of let x = M in M 0. As a consequence, the proof meth-ods for contextual equivalence which naturally suggest themselves--induction

Operational reasoning for functions with local state 241
over the structure of contexts and induction on the derivation of termination fromthe rules in Figure 4--very often founder for want of a sufficiently strong induction
hypothesis. We shall fill this need for stronger induction hypotheses by consider-ing a larger set than

Sta * Exp, carving out a subset by structural induction, and
exhibiting the termination relation {(s, M ) | s, M +} as a retract of this subset.The key ingredient in this strategy is a formal version of continuations.

Continuations
The concept of continuation that we extract from ReFS evaluation is fairly
standard. However, our continuations are typed at both argument and result; andwe have no need here of continuation

passing. Continuations take the form offinite lists of expression abstractions
(x)M , with Id for the empty list and `ffi' for
concatenation:

K ::= Id | K ffi (x)M .

Free variables and locations are defined by

fv (Id ) = ; fv (K ffi (x)M ) = fv (K) [ (fv (M ) \ {x})
loc(Id ) = ; loc(K ffi (x)M ) = loc(K) [ loc(M ).

We identify continuations up to ff-conversion of bound variables (free occurrencesof

x in M are bound in (x)M ).

The application K@M of a continuation to an expression is defined by

Id @M def= M
(K ffi (x)M 0)@M def= K@(let x = M in M 0)

and is an expression (well-defined up to ff-conversion). This notion of application
gives a tie-up with evaluation contexts. For ReFS, with its reduced form of syntax,these are simply the subset of expression contexts given by

E[-] ::= [-] | let x = E[-] in M.
For any such E[-], there is a continuation K such that E[M ] j K@M forall expressions

M , and conversely every continuation has a matching evaluation
context. Evaluation contexts were originally derived (as `unlabelled sk-contexts')from continuations in (Felleisen and Friedman 1986).

To each continuation we assign a type oe ffi! oe0, where the notation is meantto suggest the fact that evaluation contexts would give rise to

strict (continuous)
functions in a denotational semantics. The rules for types are as follows:

\Gamma  ` Id : oe ffi! oe \Gamma  ` K : oe2 ffi! oe3\Gamma  ` K ffi (x)M : oe

1 ffi! oe3 if

\Gamma , x : oe1 ` M : oe2

242 Pitts & Stark
Note that if \Gamma  ` K : oe ffi! oe0 and \Gamma  ` M : oe, then \Gamma  ` K@M : oe0. We collecttyped continuations into a range of indexed sets.

Cont oe,oe0(\Gamma ) def= {K | \Gamma  ` K : oe ffi! oe0} Cont oe(\Gamma ) def= [{Cont oe,oe0(\Gamma ) | oe0 a type}

Cont oe def= Cont oe(;) Cont def= [{Cont oe | oe a type}.

Termination
We are now ready to give our structurally defined termination relation. This will
be an inductively defined subset of Sta * Cont * Exp and we write

hs, K, M i#
to indicate that (s, K, M ) is in the subset. As usual we consider only well-formedjudgements, here requiring that

M 2 Expoe and K 2 Cont oe for some type oe,
and that loc(K, M ) ` dom(s). Figure 5 gives the rules defining the relation.Notice that these are now properly structurally inductive, with a simple syntactic

connection between the conclusion and hypothesis of each rule.
Theorem 3.1 (Termination). The two termination relations correspond in the
sense that h

s, K, M i# , s, K@M + . (3.1)

In particular, one has

hs, Id , M i# , s, M + (3.2)h

s, K, M i# , 9V, s0 (s, M + V, s0 & hs0, K, V i#). (3.3)

Proof. One way to prove these properties is to note that

hs, K, M i# , 9s0, V (hs, K, M i !* hs0, Id , V i).
where !* is the reflexive-transitive closure of a suitable transition relation ! be-tween configurations. One can then establish (3.1)-(3.3) via a series of inductions

involving + and !. We omit the details.

The unwinding theorem
In contrast to +, the structural nature of the termination relation # enables many
properties of the contextual preorder and equivalence relations to be proved in arather straightforward way, via an induction on the derivation of h

s, K, M i#. As
an illustration, we give such a proof for the `unwinding theorem' for recursivefunction values in ReFS, which provides a syntactic analogue of Dana Scott's

induction principle for least fixed points and which is needed in the proof of theFundamental Property of the logical relation introduced in the next section. Such

Operational reasoning for functions with local state 243

hs, Id , V i# (#val1)
hs, K, M [V /x]i#h
s, K ffi (x)M, V i# (#val

2)

hs, K, Mbi#h
s, K, if b then Mtrue else Mfalse i# (#if)

hs, K, ci#h
s, K, n op n0i# if c = n op n

0 (#op)

hs, K, V i#h
s, K, fst ((V, V 0))i# (#fst)

hs, K, V 0i#h
s, K, snd ((V, V 0))i# (#snd)

hs, K, M [ (rec f (x). M )/f, V /x ]i#h

s, K, (rec f (x). M )V i# (#app)

hs \Omega  (` := n), K, `i#h

s, K, ref (n)i#

if ` /2 dom(s)[

loc(K) (#ref)

hs, K, ni#h

s, K, !`i# if n = s(`) (#get)

hs; ` := n, K, ()i#h

s, K, ` := ni# (#set)

hs, K ffi (x)M 0, M i#h
s, K, let x = M in M 0i# (#let)

Figure 5: Continuation-based termination relation

244 Pitts & Stark
theorems have been proved by several different people in various contexts: see forexample (Mason, Smith, and Talcott 1996).

We fix some closed recursively defined function value rec f (x). F 2 Val oe!oe0and define the following abbreviations:

\Omega  def= (rec f (x). f x)()
F0 def= * x. \Omega 
Fn+1 def= * x. F [Fn/f ]

F! def= rec f (x). F .

Each Fn is a finite unwinding of the full function F!. The essence of the following

theorem is that these finite approximations provide all the observable behaviour of

F! itself.

Theorem 3.2 (Unwinding). For any M 2 Expoe00(f :oe!oe0) we have

s, M [F!/f ] + , 9n 2 N (s, M [Fn/f ] +).
Equivalently, for any K 2 Cont oe!oe0

hs, K, F!i# , 9n 2 N hs, K, Fni#.
Proof. The two statements in the theorem are equivalent by Theorem 3.1, noting
that for any K and F , K@F is of the form M [F/f ] for some M , and converselythat when

F is a value then s, M [F/f ] + holds if and only if hs, Id ffi (x)M, F i#.
The theorem (in its second formulation) follows from parts (iii) and (iv) of thefollowing lemma, by taking

K0 = K and M 0 = g.

Lemma 3.3. For all M 0 2 Expoe1(g:oe!oe0), K0 2 Cont oe1(g:oe!oe0), and s 2 Sta,
if loc(M 0, K0, F ) ` dom(s) then

(i) for all G 2 Val oe!oe0 with loc(G) ` dom(s)

hs, K0[F0/g], M 0[F0/g]i# ) hs, K0[G/g], M 0[G/g]i#

(ii) for all n 2 N

hs, K0[Fn/g], M 0[Fn/g]i# ) hs, K0[Fn+1/g], M 0[Fn+1/g]i#

(iii) hs, K0[F!/g], M 0[F!/g]i# ) 9n 2 N.hs, K0[Fn/g], M 0[Fn/g]i#

(iv) for all n 2 N

hs, K0[Fn/g], M 0[Fn/g]i# ) hs, K0[F!/g], M 0[F!/g]i#.

Operational reasoning for functions with local state 245
Proof. (i) is proved by induction on the derivation of hs, K0[F0/g], M 0[F0/g]i#from the rules in Figure 5. More precisely, one shows that the set of machine
states

{ hs, K, M i | 8K0, M 0 (K = K0[F0/g] & M = M 0[F0/g]) 8

G hs, K0[G/g], M 0[G/g]i#) }

is closed under those rules. The only non-straightforward case is (#app), where
one uses the easily verified fact that hs, K, \Omega i# cannot hold for any s and K. Weomit the details.

(ii) is proved by induction on n, with part (i) providing the base case of n = 0.
For (iii), again one works by induction on the proof of termination, showingthat the set of machine states

T = { hs, K, M i | 8K0, M 0 (K = K0[F!/g] & M = M 0[F!/g]) 9

n 2 N hs, K0[Fn/g], M 0[Fn/g]i#) }

is closed under the rules of Figure 5 generating #. As for part (i), the only difficult
case is closure under the application rule (#app). For that, suppose we have

hs, K, M [ (rec f (x). M )/f, V /x ]i 2 T. (3.4)
Then we have to show that hs, K, (rec f (x). M )V i 2 T, i.e. that if

K = K0[F!/g] and (rec f (x). M )V = M 0[F!/g] (3.5)
then hs, K0[Fn/g], M 0[Fn/g]i# holds for some finite n. Now (3.5) must holdbecause

M 0 = V1V2 for some values V1 and V2 such that

rec f (x). M = V1[F!/g] and V = V2[F!/g].
The first of these can occur in two situations:

(a) V1 = g and rec f (x). M = F!, thus M = F .
(b) V1 = rec f (x). M1 for some M1 with M = M1[F!/g].
The proof in case (b) is straightforward and we omit it. In case (a) we now have
M [ (rec f (x). M )/f, V /x ] = F [ g/f, V2/x ][F!/g] and so by (3.4) there is somefinite

m with hs, K0[Fm/g], F [ g/f, V2/x ][Fm/g]i#. Using the definition of Fm+1
and rule (#app) gives hs, K0[Fm/g], Fm+1(V2[Fm/g])i# and hence by part (ii) alsoh

s, K0[Fm+1/g], Fm+1(V2[Fm+1/g])i#. But

Fm+1(V2[Fm+1/g]) = (V1V2)[Fm+1/g] = M 0[Fm+1/g]
and so we have the desired conclusion that hs, K0[Fn/g], M 0[Fn/g]i# holds forsome

n (namely n = m + 1).

246 Pitts & Stark

The closure of T under the other rules of Figure 5 requires the same straightfor-ward reasoning as for case (b), and we omit the details.
Finally, part (iv) of the lemma is once again proved by an induction over #: oneshows that the set of machine states

{ hs, K, M i | 8K0, M 0, n (K = K0[Fn/g] & M = M 0[Fn/g]) h

s, K0[F!/g], M 0[F!/g]i#) }

is closed under the rules generating #. Again, the only non-routine case is
for (#app) and for that the proof is very much as for part (iii), with two distinctcases (a) and (b). We omit the details.

Note that the imperative features of ReFS have little r ^ole in the proof of
unwinding. If we had storage of non-ground data, these features would play agreater part, but the same proof methods would still work.

4 A parametric logical relation
In this section we define a family of binary relations between ReFS expressions (ofequal type) parameterised by relations between states and establish its relationship

to contextual equivalence. We prove a `Fundamental Property' typical of logical
relations (Theorem 4.9). This is the main technical result of the paper and itdraws heavily upon the work of the previous section. From the Fundamental

Property we easily deduce an extensionality result for ReFS contextual equivalence(Theorem 4.10) that includes the `ciu' theorem of Mason and Talcott (1992b).

So we get proofs for a range of basic contextual equivalences that are the usualconsequences of the `ciu' theorem. However, our extensionality theorem also
characterises contextual equivalence in terms of the logical relation (with thestate-relation parameter instantiated to the identity). In the next section we shall
show that this characterisation can be used to give quite straightforward proofs forsome examples of contextual equivalence which are not easily seen to be direct

consequences of the `ciu' theorem.

Definitions
We begin by defining a variety of relations between elements of our ReFS language,starting with states.

Definition 4.1 (State relations). Given finite subsets !1, !2 ` Loc, a state relation
from !1 to !2 is a non-empty subset r ` Sta(!1)*Sta(!2). (Recall from page 239that

Sta(!) denotes the set of all states with domain of definition equal to !.) Wewrite

Rel (!1, !2)

Operational reasoning for functions with local state 247
for the set of all such relations. Given r 2 Rel (!1, !2), we refer to !1 and !2 as thedomain and codomain of

r respectively. (Note that since we are assuming that any
state relation r is in particular non-empty,3 its domain and codomain are uniquelydetermined.)

For any finite subset ! ` Loc, the identity state relation on ! is

id ! def= {(s, s) | dom(s) = !}.
Given two state relations relations r 2 Rel (!1, !2) and r0 2 Rel (!01, !02) with
!i " !0i = ; (i = 1, 2), their smash product r \Omega  r0 2 Rel (w1 [ !01, !2 [ !02) isdefined using the smash product of states defined in Section 2:

r \Omega  r0 def= {(s1 \Omega  s01, s2 \Omega  s02) | (s1, s2) 2 r & (s01, s02) 2 r0}.
It is straightforward to show that

id ! \Omega  id !0 = id ![!0 (w " w0 = ;) r \Omega  r0 = r0 \Omega  r

id ; \Omega  r = r r \Omega  (r0 \Omega  r00) = (r \Omega  r0) \Omega  r00

with the last three in particular following from the corresponding property of \Omega  on
states.

We say that a state relation r0 extends another one r, and write r0 B r, if
r0 = r \Omega  r00 for some r00. It follows from the above properties of the smash product\Omega  that the extension relation B is a partial order.

Suppose we have two configurations hs, K, M i and hs0, K0, M 0i of the abstractmachine described in Section 3. We say that they are

convergence equivalent,
written h

s, K, M i l hs0, K0, M 0i

if they are both well formed, i.e. loc(KM ) ` dom(s) and loc(K0M 0) ` dom(s0),and they converge or diverge together:

hs, K, M i# , hs0, K0, M 0i# .
Definition 4.2 (A parametric logical relation for ReFS).For each state relation

r 2 Rel (!1, !2) and each type oe we define three binary
relations:

E oe(r) ` Expoe(!1) * Expoe(!2)K

oe(r) ` Cont oe(!1) * Cont oe(!2)V
oe(r) ` Val oe(!1) * Val oe(!2).
3This is merely a technical convenience which, amongst other things, simplifies the definition
of the logical relation at ground types.

248 Pitts & Stark
Here Expoe(!) denotes the set of closed ReFS expressions of type oe involvinglocation constants in the finite set

!; similarly for continuations Cont oe(!) and
values Val oe(!). We make the definitions of these relations for all r simultaneously.The first relation, between expressions, is defined in terms of the second:

(M1, M2) 2 E oe(r) def, 8r0 B r, (s1, s2) 2 r0, (K1, K2) 2 Koe(r0) .h

s1, K1, M1i l hs2, K2, M2i. (4.1)

The second relation, on continuations, is defined in terms of the third:

(K1, K2) 2 Koe(r) def, 8r0 B r, (s1, s2) 2 r0, (V1, V2) 2 V oe(r0) .h

s1, K1, V1i l hs2, K2, V2i. (4.2)

The final relation, between values, is defined by induction on the structure of thetype

oe:

(c1, c2) 2 Voe(r) def, c1 = c2 for oe 2 {unit , bool , int } (4.3)
(`1, `2) 2 Vloc(r) def, (!`1, !`2) 2 E int (r)

& 8n 2 Z . (`1 := n, `2 := n) 2 E unit (r)

(4.4)

(V1, V2) 2 Voe*oe0(r) def, (fst (V1), fst (V2)) 2 E oe(r)

& (snd (V1), snd (V2)) 2 E oe0(r)

(4.5)

(V1, V2) 2 Voe!oe0(r) def, 8r0 B r, (W1, W2) 2 Voe(r0) .

(V1W1, V2W2) 2 E oe0(r0). (4.6)

We call this family of relations `logical' simply because it relates function
values if, roughly speaking, they map related arguments to related results. Thisis the characteristic feature of a wide range of relations used in connection with the

lambda calculus which ever since (Plotkin 1973, 1980) have been called `logical
relations'.

Note. It is possible to simplify Definition 4.2 by replacing the use of an arbitraryextension

r0 B r by r itself in the defining clauses for Eoe(r) and Koe(r) (but notV

oe!oe0(r)). This simplification depends partly upon the `flat' nature of state inReFS and since we have an eye to generalisations of ReFS (see Section 6), we

chose not to build it into the definition. Furthermore, this simplification wouldcomplicate the proof of the following property.

Lemma 4.3 (Weakening). Extending a state relation preserves existing relations
between expressions, continuations and values: if r0 B r then

(M1, M2) 2 E oe(r) ) (M1, M2) 2 E oe(r0)

(K1, K2) 2 Koe(r) ) (K1, K2) 2 Koe(r0)

(V1, V2) 2 Voe(r) ) (V1, V2) 2 Voe(r0)

Operational reasoning for functions with local state 249
Proof. Clauses (4.1) and (4.2) of Definition 4.2 specify E oe(r) and Koe(r) byquantifying over all extensions

r0 B r and so the first two parts are immediate
(since B is a preorder). The third part concerning values then follows from thefirst, matching the way clauses (4.3) to (4.6) define V

oe(r) in terms of E oe(r).

The definition of the relations Eoe(r) on expressions and Voe(r) on values
are quite different; nevertheless they agree in that values can be considered asexpressions without changing their relations, as the following lemma shows.

Lemma 4.4 (Coincidence). Relations E oe(r) and Voe(r) coincide on values: for
V1, V2 2 Val oe

(V1, V2) 2 Eoe(r) , (V1, V2) 2 Voe(r).

Proof. The direction from right to left follows at once from the definition of E oe(r)and K

oe(r) given in clauses (4.1) and (4.2), together with Lemma 4.3. From left toright, we proceed by cases on the structure of type

oe.

Case oe = unit is trivial, as the only unit value is () and ((), ()) 2 V unit (r) for
any r.

Case oe = bool . Consider the continuation

K = Id ffi (x)(if x then () else \Omega )
where \Omega  is the non-terminating expression used in the Unwinding Theorem 3.2.From the definition of V

bool and Kbool it is not hard to show that (K, K) 2 Kbool (r).Suppose then that
b1, b2 2 {true, false} with (b1, b2) 2 Ebool (r). Since staterelations are by definition non-empty, we can choose some

(s1, s2) 2 r. Then
we have hs1, K, b1i l hs2, K, b2i and hence

hs1, Id , if b1 then () else \Omega i l hs2, Id , if b2 then () else \Omega i.
Since hsi, Id , \Omega i6 # and hsi, Id , ()i# it follows that b1 = b2, and thus (b1, b2) 2V

bool (r) as required.

Case oe = int is similar to the previous case, using the continuation

K = Id ffi (x)(let y = (V1 = x) in if y then () else \Omega )
where V1 is one of the integer values involved.

250 Pitts & Stark
Case oe = loc. Suppose that (`1, `2) 2 E loc(r). We need to prove that (!`1, !`2) 2E

int (r) and also ((`1 := n), (`2 := n)) 2 E unit (r) for every n 2 Z. Supposethat at some extension

r0 B r we have (s1, s2) 2 r0 and (K1, K2) 2 Kint (r0).For the first property, we have to show that h

s1, K1, !`1i l hs2, K2, !`2i. But it is
not hard to verify that ((K1 ffi (x)!x), (K2 ffi (x)!x)) 2 Kloc(r0), and then because
(`1, `2) 2 E loc(r) we obtain

hs1, (K1 ffi (x)!x), `1i l hs2, (K2 ffi (x)!x), `2i
and hence also hs1, K1, !`1i l hs2, K2, !`2i, as required. The argument that
(`1 := n, `2 := n) 2 Eunit (r) is similar.

Case oe = oe1 * oe2. The proof is as in the previous case, this time taking
(K1, K2) 2 Koe1(r0) to (K1 ffi (x) fst (x), K2 ffi (x) fst (x)) 2 Koe(r0) and similarly
with snd .

Case oe = oe1 ! oe2. The proof takes the same form again, based on theobservation that if

r00 B r0 B r and (K1, K2) 2 Koe2(r00) then

( (K1 ffi (x)xW1), (K2 ffi (x)xW2) ) 2 Koe1!oe2(r00)
for all (W1, W2) 2 Voe1(r0).

These last three cases all use the weakening results of Lemma 4.3.

Definition 4.5 (Extension of the logical relation to open expressions).
Given two open expressions M1, M2 2 Expoe(\Gamma ) with loc(Mi) ` !i (i = 1, 2) anda state relation

r 2 Rel (!1, !2) we write

\Gamma  ` M1 {r} M2 : oe
to mean that for all extensions r0 B r and values {V1x, V2x 2 Val oe0 | x : oe0 2 \Gamma }we have

(8x : oe0 2 \Gamma  . (V1x, V2x) 2 Voe0(r0)) ) (M1[~V1/~x], M2[~V2/~x]) 2 E oe(r0).
In particular ; ` M1 {r} M2 : oe holds if and only if (M1, M2) 2 E oe(r), thanks to
Lemma 4.3: so this is indeed an extension of the original logical relation.

The following structural properties of this relation are automatic from the above
definition.

\Gamma  ` M1 {r} M2 : oe ) \Gamma \Gamma 0 ` M1 {r} M2 : oe
\Gamma  ` M1 {r} M2 : oe ) \Gamma  ` M1 {r \Omega  r0} M2 : oe

(\Gamma  ` V1 {r} V2 : oe) & (\Gamma , x : oe ` M1 {r} M2 : oe0) )

\Gamma  ` M1[V1/x] {r} M2[V2/x] : oe0 (V1, V2 2 Val oe(\Gamma )).

In addition to the logical relation, we shall use the following equivalence betweenexpressions.

Operational reasoning for functions with local state 251
Definition 4.6 (`ciu' equivalence). Given M1, M2 2 Expoe we write

M1 ,=ciu M2 : oe
to mean that for all s 2 Sta and K 2 Cont oe with loc(K, M1, M2) ` dom(s),

hs, K, M1i l hs, K, M2i.
We extend this to open expressions by value substitution: for M1, M2 2 Expoe(\Gamma ),

\Gamma  ` M1 ,=ciu M2 : oe
means that for all {Vx 2 Val oe0 | x : oe0 2 \Gamma } we have M1[~V /~x] ,=ciu M2[~V /~x] : oe.
(Note that the Vx may use locations not mentioned in M1 or M2.)

This relation `,=ciu ' coincides with the ciu-equivalence of (Mason and Talcott1991a; Talcott 1997). This is because the results of Section 3 imply that

\Gamma  `
M1 ,=ciu M2 : oe holds if and only if for all suitable value substitutions {Vx | x 2
\Gamma }, evaluation contexts E[-] and states s:

s, E[M1[~V /~x]] + , s, E[M2[~V /~x]] + .
These are the appropriate `closed instantiations of uses' for ReFS expressions. Thenext result shows that the logical relations respect ciu-equivalence.

Lemma 4.7 (Composition). The logical relation is closed under composition with
ciu-equivalence. For closed terms we have\Gamma 

M 01 ,=ciu M1 & (M1, M2) 2 Eoe(r) & M2 ,=ciu M 02\Delta  ) (M 01, M 02) 2 E oe(r)

and more generally for open ones\Gamma 

\Gamma  ` M 01 ,=ciu M1 & \Gamma  ` M1 {r} M2 & \Gamma  ` M2 ,=ciu M 02\Delta  ) \Gamma  ` M 01 {r} M 02 .
Proof. For the first property, suppose that r0 B r and that we have states (s1, s2) 2
r0 and continuations (K1, K2) 2 Koe(r0). Then

hs1, K1, M 01i l hs1, K1, M1i l hs2, K2, M2i l hs2, K2, M 02i
and the result follows by transitivity of `l'. For open expressions, we considervalues {

V1x, V2x 2 Val oe0 | x : oe0 2 \Gamma } with each (V1x, V2x) 2 Voe0(r0) and deduce
that

M 01[~V1/~x] ,=ciu M1[~V1/~x] & M2[~V2/~x] ,=ciu M 02[~V2/~x]

& (M1[~V1/~x], M2[~V2/~x]) 2 E oe(r0).

The first part now gives (M 01[~V1/~x], M 02[~V2/~x]) 2 E oe(r0) and so \Gamma  ` M 01 {r} M 02 as
desired.

252 Pitts & Stark
Fundamental property of the relation
We aim to prove the `Fundamental Property' of the logical relation introduced inDefinition 4.2. Roughly speaking, this says that the relations

Expoe(r) are preserved
by the various operations in the ReFS language; the precise statement is givenbelow in Theorem 4.9.

The reader familiar with previous work on relational parametricity for languages
with storage locations may be surprised that such a property holds withoutsome restriction on the parameterising relations

r. O'Hearn and Tennent (1993,
Section 6) sketch a construction for a language like ReFS in which the parameteris a binary relation between states equipped with a partial bijection between the

underlying sets of locations, which together must satisfy some simple conditionsto do with assignment and look-up. The reason given for the use of the extra
information of a partial bijection is to ensure that the operation for location-equalitytesting preserves the parametric logical relation. But in fact use of partial bijections

is superfluous. We will establish the preservation property for all expressions inReFS with respect to the logical relation simply parameterised by state relations;
and we noted in Remark 2.1 that location-equality testing is definable in ReFS--soin particular it preserves the logical relation. In this respect ReFS is simpler than

the `nu-calculus' studied in (Pitts and Stark 1993) where location-equality testing
is not definable in terms of the rest of the language and use of partial bijectionsbetween locations is unavoidable.

Proposition 4.8. The logical relation is preserved by all the expression-forming
operations of the ReFS language.

(i) \Gamma , x : oe ` x {r} x : oe.
(ii) \Gamma  ` () {r} () : unit .
(iii) \Gamma  ` b {r} b : bool , for each b 2 {true, false}.

(iv) \Gamma  ` n {r} n : int , for any n 2 Z.

(v) \Gamma  ` ` {r \Omega  id {`}} ` : loc, where ` /2 dom(r) [ cod (r).
(vi) If \Gamma  ` V1 {r} V2 : oe and \Gamma  ` V 01 {r} V 02 : oe0 then

\Gamma  ` (V1, V 01 ) {r} (V2, V 02 ) : oe * oe0.

(vii) If \Gamma  ` V1 {r} V2 : bool , \Gamma  ` M1 {r} M2 : oe and \Gamma  ` M 01 {r} M 02 : oe then

\Gamma  ` (if V1 then M1 else M 01) {r} (if V2 then M2 else M 02) : oe.

(viii) If \Gamma  ` V1 {r} V2 : int and \Gamma  ` V 01 {r} V 02 : int then

\Gamma  ` (V1 op V 01 ) {r} (V2 op V 02 ) : fl, where fl is the result type of op.

(ix) If \Gamma  ` V1 {r} V2 : oe * oe0 then \Gamma  ` fst (V1) {r} fst (V2) : oe and

\Gamma  ` snd (V1) {r} snd (V2) : oe0.

Operational reasoning for functions with local state 253

(x) If \Gamma  ` V1 {r} V2 : int then \Gamma  ` ref (V1) {r} ref (V2) : loc.
(xi) If \Gamma  ` V1 {r} V2 : loc then \Gamma  ` !V1 {r} !V2 : int .
(xii) If \Gamma  ` V1 {r} V2 : loc and \Gamma  ` V 01 {r} V 02 : int then

\Gamma  ` (V1 := V 01 ) {r} (V2 := V 02 ) : unit .

(xiii) If \Gamma  ` V1 {r} V2 : oe ! oe0 and \Gamma  ` V 01 {r} V 02 : oe then

\Gamma  ` (V1V 01 ) {r} (V2V 02 ) : oe0.

(xiv) If \Gamma  ` M1 {r} M2 : oe and \Gamma , x : oe ` M 01 {r} M 02 : oe0 then

\Gamma  ` (let x = M1 in M 01) {r} (let x = M2 in M 02) : oe0.

(xv) If \Gamma , f : oe ! oe0, x : oe ` M1 {r} M2 : oe0 then

\Gamma  ` (rec f (x). M1) {r} (rec f (x). M2) : oe ! oe0.

Proof. As might be expected, many of the clauses here have similar proofs,with only four of them ((v), (x), (xiv) and (xv)) requiring individual attention.

Moreover, there is no hard work: essentially all the proofs are compositions of
properties proved earlier. First though we note some general points. Becauseeach clause preserves

\Gamma  and makes no use of it, we may assume without loss of
generality that all of its variables have already been substituted by {r}-relatedvalues, and so take

\Gamma  = ;. We may similarly take just r rather than an extension
r0 B r in all clauses where \Gamma  is the only source of free variables (i.e. (ii)-(xiii)).Lemma 4.4, which says that V

oe(r) and E oe(r) coincide on values, allows us tomove between the two relations and we do this silently throughout.

Cases (i)-(iv) all follow immediately from the definition of {r} and V oe(r). In
case (v) we need to show that

(!`, !`) 2 E int (r \Omega  id {`}) and 8n 2 Z . (` := n, ` := n) 2 Eunit (r \Omega  id {`})
for a given location ` not mentioned by r. We look at the first of these: the second
is treated similarly. Suppose that (s1, s2) 2 (r \Omega  id {`} \Omega  r0) and (K1, K2) 2K

int (r \Omega  id {`} \Omega  r0) for some r0. We have to show

hs1, K1, !`i l hs2, K2, !`i. (4.7)
As (s1, s2) 2 (r \Omega  id {`} \Omega  r0) we know that s1(`) = s2(`) = n for some integer n.Then

hsi, Ki, !`i l hsi, Ki, ni for i = 1, 2. (4.8)
But (n, n) 2 Vint (r \Omega  id {`} \Omega  r0) and as (K1, K2) 2 Kint (r \Omega  id {`} \Omega  r0),

hs1, K1, ni l hs2, K2, ni. (4.9)
Combining (4.8) and (4.9) gives (4.7) as required.

Cases (vi), (vii) and (viii) are all alike and we look only at the first. We have

(V1, V2) 2 E oe(r) and (V 01 , V 02 ) 2 E oe0(r), (4.10)

254 Pitts & Stark
and need to show ((V1, V 01 ), (V2, V 02 )) 2 Voe*oe0(r). This requires

( fst (V1, V 01 ), fst(V2, V 02 ) ) 2 E oe(r)
( snd (V1, V 01 ), snd (V2, V 02 ) ) 2 E oe0(r). (4.11)

The following ciu-equivalences are all straightforward:

fst (V1, V2) ,=ciu V1 fst (V 01 , V 02 ) ,=ciu V 01
snd (V1, V2) ,=ciu V2 snd (V 01 , V 02 ) ,=ciu V 02 (4.12)

and by Lemma 4.7 we can combine these with the logical relations of (4.10) togive (4.11) as required. Such use of ciu-equivalence is also the key to cases (vii)

and (viii).

In case (ix) we are given (V1, V2) 2 Voe*oe0(r) and need to show that
(fst (V1), fst (V2)) 2 E oe(r) and (snd (V1), snd (V2)) 2 Eoe0(r)--but this is ex-actly the definition of V

oe*oe0(r) on page 248. Cases (xi), (xii) and (xiii) use thedefinition of V
(r) at locations and function types in exactly the same way.

For case (x) we again need to consider actual continuations. Suppose that
(V1, V2) 2 Vint (r), i.e. V1 = V2 = n for some n 2 Z. For any r0 B r, (s1, s2) 2 r0,
and (K1, K2) 2 Kloc(r0) we need to show that

hs1, K1, ref (n)i l hs2, K2, ref (n)i. (4.13)
By considering a single reduction step4 we have that

hsi, Ki, ref (n)i l hsi \Omega  (` := n), Ki, `i for i = 1, 2 and ` fresh. (4.14)
Now (s1\Omega (`:=n), s2\Omega (`:=n)) 2 r0\Omega id {`}, by the weakening Lemma 4.3 we have
(K1, K2) 2 Kloc(r0 \Omega  id {`}), and from part (v) we know (`, `) 2 V loc(r0 \Omega  id {`}).
Thus h

s1 \Omega  (` := n), K1, `i l hs2 \Omega  (` := n), K2, `i (4.15)

and this in combination with (4.14) gives (4.13) as required.

In part (xiv) we have the hypothesis that

(M1, M2) 2 E oe(r) and x : oe ` M 01 {r} M 02 : oe0.
Consider r0 B r, (s1, s2) 2 r0, and (K1, K2) 2 Koe0(r0): we need to show

hs1, K1, let x = M1 in M 01i l hs2, K2, let x = M2 in M 02i.
Again, taking one reduction step gives

hsi, Ki, let x = Mi in M 0i i l hsi, Ki ffi (x)M 0i , Mii for i = 1, 2,
4Strictly speaking, the left-to-right implication in (4.14) relies upon the easily verified fact that
the termination relation # is invariant under bijective renamings of location constants.

Operational reasoning for functions with local state 255
and as (M1, M2) 2 E oe(r) it is sufficient to prove that

( K1 ffi (x)M 01, K2 ffi (x)M 02 ) 2 Koe(r0). (4.16)
Suppose that r00 B r0, (s01, s02) 2 r00, and (V1, V2) 2 Voe(r00); we now need

hs01, K1 ffi (x)M 01, V1i l hs02, K2 ffi (x)M 02, V2i. (4.17)
A single reduction step gives

hs0i, Ki ffi (x)M 0i , Vii l hs0i, Ki, M 0i [Vi/x]i for i = 1, 2. (4.18)
Finally the hypothesis on M 0i and choice of Vi gives (M 01[V1/x], M 02[V2/x]) 2E

oe(r00), from which we geth

s01, K1, M 01[V1/x]i l hs02, K2, M 02[V2/x]i. (4.19)
Combining this with (4.18) gives (4.17) and hence (4.16) as required.

For case (xv), concerning recursively defined function values, it is no surprise
that we turn to the Unwinding Theorem 3.2. The first step is to show that fornon-recursive functions

x : oe ` M1 {r} M2 : oe0 ) ` (* x. M1) {r} (* x. M2) (4.20)
which is done through the ciu-equivalence

(* x. M )V ,=ciu M [V /x]
in much the same way as case (vi). Now suppose more generally that we have

f : oe ! oe0, x : oe ` M1 {r} M2 : oe0. (4.21)
As in Section 3, consider the following progressive unwindings:

\Omega  def= (rec f (x). f x)() Fi,n+1 def= * x. Mi[Fi,n/f ]
Fi,0 def= * x. \Omega  Fi,! def= rec f (x). Mi .
for i = 1, 2. We then prove in turn

(\Omega , \Omega ) 2 E oe!oe0(r) (4.22)
(F1,n, F2,n) 2 E oe!oe0(r) (4.23)
(F1,!, F2,!) 2 E oe!oe0(r). (4.24)

The first of these is straightforward as \Omega  never terminates in any context; thisprovides the base case to prove (4.23) by induction on

n, using (4.20) and (4.21)
at each step; and finally the Unwinding Theorem 3.2 allows us to deduce (4.24),which is exactly the desired result:

` (rec f (x). M1) {r} (rec f (x). M2) : oe ! oe0.
What we are using here is that the Eoe(r) relations are admissible, in an appropriate
syntactic variant of the usual notion on domains: if every finite approximation ofsome

(M1, M2) is in E oe(r), then so is (M1, M2) itself.

256 Pitts & Stark
Theorem 4.9 (Fundamental Property of the Logical Relation).

(i) Contexts preserve the identity logical relation: if \Gamma  ` M1 {id !} M2 : oe,

then for any context C[-] with fv (C) ` \Gamma 0 ` \Gamma , loc(C[-]) ` !, and
\Gamma 0 ` C[Mi] : oe0 for i = 1, 2 (so that the hole `-' occurs in C[-] within the
scope of binding occurrences of the variables in \Gamma  \ \Gamma 0), it is the case that
\Gamma 0 ` C[M1] {id !} C[M2] : oe0.

(ii) The identity logical relation is reflexive: if M 2 Expoe(\Gamma ) with loc(M ) ` !,

then \Gamma  ` M {id !} M : oe.

Proof. Part (i) is proved by induction on the structure of C[-], using Proposition 4.8. Part (ii) is then the special case when C[-] has no occurrences of thehole `-' at all, and is just an ordinary expression

M .

The following result draws together all the relations we have defined betweenReFS expressions. It includes the `ciu' theorem of Mason and Talcott (1992b).

Theorem 4.10 (Operational Extensionality). The logical relation {id !}, contextual equivalence ,=, and ciu-equivalence ,=ciu all coincide: for any M1, M2 2
Expoe(\Gamma )

\Gamma  ` M1 {id !} M2 , \Gamma  ` M1 ,= M2 , \Gamma  ` M1 ,=ciu M2 .
Proof. We show that each of the three relations entails the next, in rotation. First,
that

\Gamma  ` M1 {id !} M2 ) \Gamma  ` M1 ,= M2 .

Suppose that M1 and M2 are identity related as shown and that C[-] is somecontext with ; `

C[Mi] : oe0 (i = 1, 2). Using the weakening Lemma 4.3 on
\Gamma  ` M1 {id !} M2 if necessary, we can assume without loss of generality that
loc(C[-]) ` !. Then by Theorem 4.9(i) we have ; ` C[M1] {id !} C[M2], thatis

(C[M1], C[M2]) 2 Eoe0(id !). Given any state s with dom(s) = ! we know that
(s, s) 2 id !; and (Id , Id ) 2 Koe0(id !) holds by definition of Koe0(id !). Thereforefrom the definition of E

oe0(id !) we have

hs, Id , C[M1]i l hs, Id , C[M2]i.
Equivalently (by Theorem 3.1),

s, C[M1] + , s, C[M2] + .
Since this holds for any suitable C[-] and s, we have contextual equivalence of
M1 and M2, as required.

Now for

\Gamma  ` M1 ,= M2 ) \Gamma  ` M1 ,=ciu M2 .

Operational reasoning for functions with local state 257
Consulting the note after Definition 4.6, we recall that ciu-equivalence for anexpression

M is entirely determined by the set of terminations

s, E[M [~V /~x]] +
for states s, evaluation contexts E[-] and values ~V to instantiate the free vari-ables of

M . This however corresponds exactly to termination in the context
E[(* ~x. (-))~V ]. As ciu-equivalence thus requires correspondence only in a sub-set of all contexts, it is clear that it is entailed by contextual equivalence, which

requires agreement on all of them.

Finally,

\Gamma  ` M1 ,=ciu M2 ) \Gamma  ` M1 {id !} M2 .

By Theorem 4.9(ii) we have \Gamma  ` M1 {id !} M1, and Lemma 4.7 lets us composethis with

\Gamma  ` M1 ,=ciu M2 to obtain the logical relation \Gamma  ` M1 {id !} M2 that we
desire.

5 Examples
In this section we look at some practical applications of the parametric logical relation to proving ReFS contextual equivalences, via the Operational ExtensionalityTheorem 4.10.

Before giving applications that make overt use of the logical relation, let us
recall (from Mason and Talcott 1992b, for example) that the coincidence ofcontextual equivalence with ciu-equivalence gives sufficient leverage to prove a

range of basic contextual equivalences. This includes those ciu-equivalences thathold by virtue of the immediate evaluation behaviour of the terms involved, such
as

(rec f (x). M )V ,= M [ (rec f (x). M )/f, V /x ].

It also includes equivalences incorporating `garbage collection', in the manner of
Mason's `strong isomorphism' (Mason 1986; Mason and Talcott 1991a), allowingus to ignore parts of the store that are unreachable.

Using logical relations
To prove specific contextual equivalences via the logical relation, we need to be
able to show that pairs of expressions are indeed related. The next result givesa general technique for demonstrating

(M1, M2) 2 E oe(r): if their evaluation
preserves r and we can exhibit some `local invariant' r00 that correctly capturesthe way

M1 and M2 treat their local variables, then they are logically related.

258 Pitts & Stark
Proposition 5.1 (Principle of Local Invariants). Given a state relation r and
expressions M1, M2, suppose that for all (s1, s2) 2 r,

s1, M1 + V1, s01 ) 9r0, s02, V2 . (s01, s02) 2 (r \Omega  r0)

& s2, M2 + V2, s02 & (V1, V2) 2 E oe(r \Omega  r0)

and

s2, M2 + V2, s02 ) 9r00, s01, V1 . (s01, s02) 2 (r \Omega  r00)

& s1, M1 + V1, s01 & (V1, V2) 2 E oe(r \Omega  r00).

Then (M1, M2) 2 Eoe(r). (We call the state relations r0, r00 local invariants.)
Proof. To prove (M1, M2) 2 E oe(r) it suffices to show for all (s1, s2) 2 r and
(K1, K2) 2 Koe(r) that hs1, K1, M1i# if and only if hs2, K2, M2i# (cf. the Noteon page 248). By the symmetry of the assumptions, it suffices to prove just the

forward direction of this bi-implication. So suppose hs1, K1, M1i#. Then by (3.3)for some

s01 and V ,

s1, M1 + V1, s01 and hs01, K1, V1i#.
So by hypothesis there are r0, s02 and V2 such that s2, M2 + V2, s02, (s01, s02) 2 (r \Omega 
r0), and (V1, V2) 2 E oe(r \Omega  r0). From Lemma 4.3 we have (K1, K2) 2 Koe(r \Omega  r0)
and so hs01, K1, V1i l hs02, K2, V2i. Hence hs02, K2, V2i# and then the other directionof (3.3) gives h

s2, K2, M2i# as desired. Similarly, the second hypothesis implies
that hs2, K2, M2i# ) hs1, K1, M1i# and so we have (M1, M2) 2 E oe(r) asrequired.

This gives us a tool for proving instances of the logical relation. Conversely,if we have that two expressions are related, what can we deduce about them? To
answer this requires a mild restriction on the state relations considered.
Definition 5.2. A state relation r 2 Rel (!1, !2) is closed if every non-element canbe detected as such. That is, for each pair of states

(s1, s2) 2 (Sta(!1)*Sta(!2))\
r there are continuations (K1, K2) 2 Kunit (r) such that

hs1, K1, ()i 6 l hs2, K2, ()i
with one converging and the other diverging.

All the state relations we shall encounter are closed. In particular we have thefollowing result.

Lemma 5.3. If a state relation r 2 Rel (!1, !2) is bijective where defined

(s1, s2) 2 r & (s1, s02) 2 r ) s2 = s02
(s1, s2) 2 r & (s01, s2) 2 r ) s1 = s01

then it is closed.

Operational reasoning for functions with local state 259
Proof. First we note that all states have finite domain, so for any state s we canwrite an expression

test s such that s0, test s + precisely when s0 is of the form s\Omega s00.

Now suppose (s1, s2) 2 (Sta(!1) * Sta(!2)) \ r. We seek r-related continua-tions that distinguish between the two. If there is no

s02 such that (s1, s02) 2 r, then
we choose

K1 def= Id ffi (x) test s1 and K2 def= Id ffi (x)\Omega .

If on the other hand (s1, s02) 2 r holds for some s02, then by assumption on r wemust have

s02 6= s2 (since (s1, s2) /2 r) and we take

K1 def= Id ffi (x) test s1 and K2 def= Id ffi (x) test s02 .
In either case we have hs1, K1, ()i# and hs2, K2, ()i6 #, while these continuations
agree on all state pairs in any r \Omega  r0 and so (K1, K2) 2 Kunit (r) as required.

Proposition 5.4. If (M1, M2) 2 E oe(r) and (s1, s2) 2 r then

s1, M1 + , s2, M2 + .
If r is closed, then related expressions also preserve the state relation:

s1, M1 + V1, s01 and s2, M2 + V2, s02
implies there is r0 such that (s01, s02) 2 (r \Omega  r0).
Proof. For the first part, consider the continuation K = Id ffi (x)() of type
(oe ffi! unit ). Clearly (K, K) 2 Koe(r) and so using (3.3) we can deduce

s1, M1 + , hs1, K, M1i# , hs2, K, M2i# , s2, M2 +
as required. For the second part, suppose that r is closed and that M1 and M2
evaluate as given. Taking r0 = !01 * !02, where !0i = dom(s0i) \ dom(si) (i = 1, 2),we need only show that

(s01|dom(r), s02|cod(r)) 2 r. Since r is closed, if these states
are not so related, then there is some (K1, K2) 2 Kunit (r) that can detect this andhence for which

hs1, K1 ffi (x)(), M1i 6 l hs2, K2 ffi (x)(), M2i.
This however would contradict the assumption that (M1, M2) 2 E oe(r), and
instead we must have (s01|dom(r), s02|cod(r)) 2 r and hence (s01, s02) 2 (r \Omega  r0) asrequired.

This provides a partial converse to Proposition 5.1 (at least as regards termination and treatment of store) which we will use in the higher-order profiling Exam-ple 5.8. At ground types we can do better and show that the resulting values will

also be related. However, the converse of Proposition 5.1 does not hold in general.Example 5.9 gives a pair of logically related expressions where no choice of

r00

260 Pitts & Stark
will make V1 and V2 related. Thus as a method for demonstrating instances of thelogical relation and hence contextual equivalence, the Principle of Local Invariants
of Proposition 5.1 is not complete. Nevertheless, it does provide a powerful methodfor proving equivalences, as the examples in the following subsections show. We

consider various idioms for using functions with local state and prove that they be-have correctly, interacting properly with surrounding code that may itself use state

and higher order functions. The general approach is that we present contextual
equivalences which express the desired behaviour of a program fragment, and thenprove that these hold by using the logical relation. In all cases the crucial step is to

choose the right local invariant that captures the way an expression is expected touse its local store.

Representation independence
Informally, it is clear that if two functions in ReFS have private local storethat they use in different ways to compute the same result, then they should be

contextually equivalent. One can use coincidence of contextual equivalence with
ciu-equivalence to show that this is true for expressions which use local store onlyfor temporary variables. However in ReFS it is also possible to write functions that

rely on store remaining private from one invocation to the next. Logical relationscan capture this notion of privacy through local invariants, and we give here two
examples of how this can lead to proofs of contextual equivalence.

Consider the following expressions of Standard ML:

let val c = ref 1

fun inc () = (c:=!c + 1)
fun test () = (!c > 0)
in

(inc, test)
end

,= let

fun skip () = ()
fun test0 () = true
in

(skip, test0)
end.

The first of these evaluates to a pair of functions sharing a common storage cell c;one function to increment

c, and one to test its contents. However the test alwaysreturns true and the increment cannot be observed; so this expression has an

equivalent simpler version which doesn't bother with the cell c. A correspondingexample in ReFS is this:

Example 5.5.

(let c = ref (1) in (inc c, test c)) ,= (skip, test 0)

: (unit ! unit ) * (unit ! bool )

(5.1)

where

inc def= * c. * x. (c := (!c + 1)) skip def= * x. ()
test def= * c. * x. (!c > 0) test 0 def= * x. true.

Operational reasoning for functions with local state 261
Proof. Although the internal action of these expressions is quite different, they arecontextually equivalent because the value stored in cell

c is always positive. This
invariance property is expressed by the state relation

r def= {(s, ()) | s(`) > 0} 2 Rel ({`}, ;).
Looking at the bodies of the functions inc and skip we can show by Proposition 5.1that

( (` := !` + 1), () ) 2 E unit (r)
because both preserve r. Similarly for the test functions

( (!` > 0), true ) 2 Ebool (r)
because they give equal results provided that r holds. By Proposition 4.8(xv)
lambda abstraction preserves these relations and we can then derive

(inc `, skip) 2 Eunit!unit (r) and (test `, test 0) 2 E unit!bool (r).
Proposition 4.8(vi) now gives

( (inc `, test `), (skip, test 0) ) 2 E (unit!unit)*(unit!bool)(r)
which are the results of evaluating either side of (5.1). Since ((` := 1), ()) 2 r, thecorresponding states resulting from this evaluation are also related and so by the

Principle of Local Invariants (Proposition 5.1)

( (let c = ref (1) in (inc c, test c)), (skip, test 0) ) 2 E (unit!unit)*(unit!bool)(id ;).
The contextual equivalence (5.1) then follows by Operational Extensionality
Theorem 4.10.

The next example considers not private shared state, but more visible store usedin two different but equivalent ways. Consider these two counters in Standard ML:

let val c = ref 0

fun up x = (c := !c + x; !c)
in

up
end

,= let val c = ref 0

fun down x = (c := !c - x; 0 - !c)
in

down
end

which can be written in ReFS thus:
Example 5.6.

(let c = ref (0) in up c) ,= (let c = ref (0) in down c)
where

up def= * c. * x. (c := (!c + x); !c) down def= * c. * x. (c := (!c - x); 0 - !c).

262 Pitts & Stark
Proof. Both of these functions maintain an accumulator, summing the argumentsto successive calls and returning a running total. Internally though, the second
function reverses signs throughout. The appropriate local invariant is the relation r def= {(s1, s2) | s1(`) = -s2(`)} 2 Rel ({`}, {`}). For this we have
(up `, down `) 2 E int!int (r) and the proof of contextual equivalence proceeds
as in the previous example.

In both of these examples, the local store is not in fact private: the functionsdo export a certain limited access to it, both for reading and writing. What is
important though is that this access is certain to preserve the relevant invariant, nomatter how a surrounding program uses it; and as long as the invariant holds, the
results returned by the given functions always agree.

Memoisation
One practical use for local state is in the implementation of a memo function.This is a function that retains a cache of past results in order to assist future

computations. Logical relations provide a means to show that the consistency ofthis cache is maintained, whatever the surrounding program.

Here we consider a higher-order memoisation function, that transforms any
`repeatable' function into a memo function. For simplicity, we only record a singleargument/result pair, and take both to be integers. In Standard ML one might define

this by:

fun memoise f = let val a = ref 0 and r = ref(f 0);

fun f0 x =

((if x = !a then () else (a := x; r := f x)); !r)
in

f0
end

memoise : (int ! int) ! (int ! int)

The idea here is that memoise modifies function f by attaching two private cells, a

and r, to hold the argument and result of its most recent invocation. The resultingfunction

f0 acts like f, except that when called with the same argument twice in
succession it uses the cached result !r, saving recomputation. This can be writtenin ReFS as follows.

Example 5.7. Let

memoise def= * f. let a = ref (0); r = ref (f 0)

in

* x. ((if x = !a then () else (a := x; r := f x)); !r)

.

Operational reasoning for functions with local state 263
We say that F 2 Val int!int computes some total function OE : Z ! Z if for eachstate

s with loc(F ) ` dom(s) and every n 2 Z,

s, F n + OE(n), (s \Omega  sn)
for some sn. Thus F may make use of local or global store, but its results are
`repeatable' in the sense that they do not depend on the global state s and s isunchanged at the end of evaluating the application of

F to a numeral. We claim
that such an F is suitable for memoisation:

memoise F ,= F. (5.2)
In particular for each n 2 Z, (memoise F )n computes the same integer as F n,namely

OE(n).

Proof. First note that

s, memoise F + F 0, (s \Omega  (`a := 0) \Omega  s0 \Omega  (`r := OE(0))) (5.3)
where

F 0 def= * x. ((if x = !`a then () else `a := x; `r := F x); !`r)

is the `memoised' version of F . A suitable local invariant is that locations `a and
`r always hold a valid argument/result pair; which we express with the relation

r def= {(s, ()) | OE(s(`a)) = s(`r)} 2 Rel (!0`a`r, ;).
where !0 = dom(s0) (which by ff-conversion we can assume is disjoint from{

`a, `r}). As before the Principle of Local Invariants (Proposition 5.1) shows thatthe bodies of

F and F 0 are r-related, so we can use Proposition 4.8(xv) to obtain

(F 0, F ) 2 Vint!int (id ! \Omega  r)
where loc(F ) ` !. Since the states (`a := 0; s0; `r := OE(0)) and () are related by r,
taking (5.3) we can apply Proposition 5.1 again to give

((memoise F ), F ) 2 E int!int (id !).
The Operational Extensionality Theorem 4.10 then provides the desired contextualequivalence (5.2).

We considered total functions OE : Z ! Z in this example only to simplifymatters. Extending the definition of `

F computes OE in a repeatable fashion' to
partial functions (when OE(n) is undefined F n must diverge, and vice versa), (5.2)still holds

provided we restrict attention to those OE for which OE(0) is defined, since
memoise initialises the cache using this value.

Note that this same memoisation function can be used repeatedly in a program,to give several memo functions each with their own local store. One memo function

264 Pitts & Stark
can even be used within another without interference. For example, if F and G arefunction abstractions computing

OE and , then the composition F ffi G (definable in
ReFS in the usual way) computes the composition of OE with ; and (5.2) togetherwith the congruence properties of contextual equivalence imply

memoise((memoise F ) ffi (memoise G)) ,= F ffi G
(although one of the memoisations is redundant).

Higher-order profiling
Next we consider the use of local state for profiling function use, i.e. recording the
calls to a particular function as it is used within a larger program. We use contextualequivalence to express two important properties of the profiled function:

* it correctly counts the number of times it is called;

* the overall program is otherwise unaffected.
Both of these assertions are then proved using logical relations, although in thiscase we need to use Proposition 5.4 in addition to the Principle of Local Invariants

(Proposition 5.1).

As with memoisation, a single higher order function can capture the wholeoperation of profiling. In Standard ML:

fun profile f = let val c = ref 0;

fun f0 x = (c:=!c + 1; f x);
fun r () = !c
in

(f0, r)
end

profile : (oe ! oe0) ! ((oe ! oe0) * (unit ! int))

This profile takes any function f and returns an instrumented version f0 together

with a read operation r. Both f0 and r share a private local counter c, incrementedby each call to

f0 and read by means of r(). Otherwise f0 behaves exactly as the
original function f; which may include further side-effects on global or local store.The profiling operation is truly higher order, working with functions of all types;

we could for example safely apply it to the memoise function described earlier.

In ReFS one can write this profiling functional as follows.

Example 5.8.

profile def= * f. (let c = ref (0) in (f 0, r)) where f 0 def= * x. (c := !c + 1; f x)

r def= * x. !c.

Operational reasoning for functions with local state 265
The fact the profiling correctly records function calls means that the followingcontextual equivalence between integer expressions:

let (f 0, r) = profile F
in

P f 0; F V ; Qf 0;
r() + 1

,= let (f 0, r) = profile F

in

P f 0; f 0V ; Qf 0;
r()

(5.4)

holds for any F 2 Val oe!oe0, P, Q 2 Val (oe!oe0)!unit , and V 2 Val oe.

Here the context (P f 0; [-]V ; Qf 0) represents a program using the instrumentedfunction

f 0. Depending on whether its hole is filled with F or f 0, the final total
r() alters by 1. It is significant that the values P and Q have access only to f 0in this context and cannot use

r to read the current contents of the counter. More
generally, the function f 0 on its own is indistinguishable from the original F :

fst (profile F ) ,= F : oe ! oe0 (5.5)
In this contextual equivalence the read operator is thrown away, with fst selectingjust the profiled function

f 0.

Proof. To demonstrate (5.4) and (5.5), look first at the evaluation of the expres-sions in (5.4). The computation is in three parts, followed by examination of the

counter c using the read operation r(). Assume that the counter is bound to loca-tion

` and set

F 0 def= * x. (` := !` + 1; F x). (5.6)

Both sides of (5.4) begin with the same evaluation:

s \Omega  (` := 0), P F 0 + (), s0 \Omega  (` := n) \Omega  s1
for some n 2 Z. Thanks to the `garbage collection' properties of contextualequivalence mentioned at the beginning of this section, the unreachable extra

store s1 need not concern us. The next step is the evaluation of a call to F or F 0:

s0 \Omega  (` := n), F V + V 0, s00 \Omega  (` := n) \Omega  s2
s0 \Omega  (` := n), F 0V + V 0, s00 \Omega  (` := (n + 1)) \Omega  s2

The only difference so far is the value stored at location `. What is importantnow is that

QF 0 preserves this but is otherwise unaffected. The appropriate local
invariant is the relation

r def= {(s, s0) | s0(`) = s(`) + 1} 2 Rel ({`}, {`}),
which is closed, by Lemma 5.3.

By the Fundamental Property of the logical relation (Theorem 4.9(ii)) we have
that both F and Q are id !-related to themselves. Using Proposition 5.1 we canshow directly that increment preserves

r:

( (` := !` + 1), (` := !` + 1) ) 2 E unit (r).

266 Pitts & Stark
Applying Proposition 4.8, we combine all these with the definition (5.6) of F 0 todeduce that the application

QF 0 satisfies

(QF 0, QF 0) 2 E unit (id ! \Omega  r).
We know that the closed relation (id ! \Omega  r) holds before this application, and
Proposition 5.4 now tells us that it also holds after it. Thus

s00 \Omega  (` := n), QF 0 + (), s000 \Omega  (` := n0) \Omega  s3
s00 \Omega  (` := n + 1), QF 0 + (), s000 \Omega  (` := n0 + 1) \Omega  s3

for some n0 >= n, s000, and s3. The last computation for each alternative is then

s000 \Omega  (` := n0), (r() + 1) + (n0 + 1), s000 \Omega  (` := n0)

s000 \Omega  (` := n0 + 1), r() + (n0 + 1), s000 \Omega  (` := n0 + 1).

The final states are (id ! \Omega  r)-related and the returned values are equal; thus by thePrinciple of Local Invariants, the two original expressions are

id !-related and the
equivalence (5.4) follows.

The second equivalence (5.5), that F 0 on its own is indistinguishable from F , ismore straightforward. We need to show that

( (let c = ref (0) in * x. (c := !c + 1; f x)), F ) 2 E oe!oe0(id !)
and this follows by Proposition 5.1 from

(F 0, F ) 2 Voe!oe0(id ! \Omega  r)

where r def= {(s, ()) | s 2 Sta({`})}. Thus the operation profile has exactly the
behaviour we would expect.

As with memoisation, we can apply profile many times to give several profiled
functions, each with its own private counter. So when we write profile F , thefunction

F may have subprocedures within it that are already recording profiles,
without causing interference. The procedure can also be adapted to profile therecursive calls a function makes to itself. The proof in this case is no more

complicated than before, thanks to the fact that logical relations are preserved by
recursive function abstractions (Proposition 4.8(xv)).

A more intricate situation with shared store arises if we use a profiler that keeps
the same global counter for each function that it modifies:

val(g profile, g read) = let val c = ref 0;

fun prof f x = (c := !c + 1; f x);
fun read () = !c
in

(prof, read)
end.

Analogues of the equivalences (5.4) and (5.5) can be given for this global profiler,and proved using logical relations.

Operational reasoning for functions with local state 267
Limitations of the Principle of Local Invariants
We give an example to show that the existence of a local state relation, as asserted

in the hypotheses of the Principle of Local Invariants (Proposition 5.1), althoughsufficient, is not necessary in order for two expressions to be {

id w}-related and
hence to be contextually equivalent.

Consider the following two second-order functions in Standard ML:

val awkward = let val c = ref 0;

fun upto one f = (c := 1; f(); !c)
in

upto one
end

val const one = fn f ) (f(); 1)
awkward, const one : (unit ! unit) ! int.

Both of these evaluate to functions that take a command f as an argument, execute

it and then return the value 1. The second achieves this in a straightforwardmanner, whereas the first achieves it in an awkward manner--through the function

upto one which fetches the return value 1 from private cell c. One expects
awkward and const one to be contextually equivalent because this cell, although
it initially holds 0, is set to 1 before every inspection, and during the execution of
upto one in any context the function f() cannot reset c to 0. We shall turn thisinto a formal proof of equivalence below. First, let us express these functions in

ReFS:
Example 5.9.

awkward ,= const one : (unit ! unit ) ! int (5.7)
where

awkward def= let c = ref (0) in * f. (c := 1; f (); !c)
const one def= * f. (f (); 1).

To show (5.7) using Proposition 5.1 we would need r 2 Rel ({`}, ;) satisfying

( (` := 0), () ) 2 r (5.8)
and (upto one, const one) 2 E (r). (5.9)

where upto one def= * f. (` := 1; f (); !`). From (5.8) we can deduce that
( (* x. (` := 0)), * x. () ) 2 Vunit!unit (r). Using Proposition 4.8(xiii) to combinethis with (5.9), we deduce

( upto one(* x. (` := 0)), const one(* x. ()) ) 2 Eint (r).

268 Pitts & Stark
But these expressions evaluate to give different results

(` := 0), upto one(* x. (` := 0)) + 0, (` := 0)

(), const one(* x. ()) + 1, ().

and this is easily seen to be impossible for expressions related by E at a ground
type. Thus we cannot have both (5.8) and (5.9) at the same time, and there is noway to prove contextual equivalence (5.7) through Proposition 5.1.

We are left in the situation that although (5.7) does hold, and by Theorem 4.10the two expressions are therefore related by E

(id ;), it seems hard to demonstrate
this relation directly. The root of the problem is that the argument (* x. (` := 0)),which causes

upto one to return the surprise value 0, cannot in fact be provided
by any surrounding context. Note that the location ` is not entirely private, sinceits contents can be changed (from

0 to 1) by a use of upto one in a context which
knows nothing of ` (such as [-](* x. ())). (See Stark 1994, $5.4, Example 14 for arelated example, this time of contextual inequivalence.)

This problem with (* x. (` := 0)) resembles known subtleties of contextualequivalence in Algol due to the undefinability of so-called `snapback' operations in
the language (see Pitts 1997, Example 4.1--an example due to O'Hearn). Howeverthis particular example has no direct Algol equivalent, because it relies on the fact

that upto one can both change the state and return a value -- such `active integers'are intentionally excluded from Algol.

We conjecture that a more general form of logical relation can be used todemonstrate the equivalence (5.7) via a result like Proposition 5.1, if we use
parameterising relations r with Kripke-style indexing to capture the one-way natureof state change. Here this would allow the following relation with two components:

r1 oe r2 where r1 = {(s, ()) | s(`) = 0 or 1}

r2 = {(s, ()) | s(`) = 1}.

This is meant to express the fact that the value stored at location ` may progressfrom

0 to 1, but is then fixed. More complex examples of progressing state would
require a more complex index structure.

Without such generalised logical relations, we can proceed only by brute force.

Proof of (5.7). By completeness of ciu-equivalence (Theorem 4.10) it is enoughto consider evaluation in any continuation. In this case we derive the requirement

that for any state s and continuation K with ` /2 dom(s) ' loc(K)

hs \Omega  (` := 0), K, upto onei l hs, K, const onei.
This is equivalent to showing that for any state s and expression M with ` /2
dom(s) ' loc(M ) and fv (M ) ` {g : (unit ! unit ) ! int }

s \Omega  (` := 0), M [upto one /g] + , s, M [const one /g] + . (5.10)

Operational reasoning for functions with local state 269
This can be proved by computation induction, but we first need a suitably stronginduction hypothesis. Define the predicate P

(s, M ) for states s and expressions M
with ` /2 dom(s) ' loc(M ) according to

P(s, M ) def, There is a state s0 and a value V with free variable g such that

1. s, M [const one /g] + V [const one /g], s0
and 2a. 8n 2 Z. s \Omega  (` := n), M [upto one /g]+

V [upto one /g], s0 \Omega  (` := 1)

or 2b. 8n 2 Z. s \Omega  (` := n), M [upto one /g]+

V [upto one /g], s0 \Omega  (` := n)

& s, M [* f. \Omega /g] + V [* f. \Omega /g], s0.

This rather complex expression captures exactly the way that evaluations of
upto one and const one correspond to each other in appropriate contexts. In
particular, whenever M [-/g] is evaluated, it either applies the function replacing g(case 2a), or it does not (case 2b).

The following properties hold of P(s, M ):

8n 2 Z. (P(s, M ) , s \Omega  (` := n), M [upto one /g] +) (5.11)

P(s, M ) , s, M [const one /g] + . (5.12)

The forward implications simply expand the definition of P(s, M ). The reversedirections can be proved by induction on the height of proofs of the evaluations
s\Omega (`:=0), M [upto one /g] + V 0, s0 and s, M [const one /g] + V 0, s0 respectively.All the details are routine: in particular every evaluation rule either creates one of
the situations (2a) or (2b), or preserves an existing one.

These equivalences (5.11) and (5.12) immediately give (5.10), from which the
original contextual equivalence (5.7) follows as indicated.

6 Further topics
We have seen that for each type oe, two ReFS expressions are contextuallyequivalent if and only if they are {

id !}-related. Moreover, this characterisation
of contextual equivalence not only implies the Mason-Talcott `ciu' theorem forReFS, but also allows one to formalise various intuitive arguments about contextual

equivalence based on invariant state relations. The examples in the previous sectiondemonstrate that the logical relation provides a powerful method for establishing

ReFS contextual equivalences. Clearly it is of interest to extend the techniquesintroduced here to larger fragments of Standard ML than that represented by the
ReFS language. In particular we would like to be able to treat:

270 Pitts & Stark

(a) recursively defined types (rather than the simple types of ReFS),
(b) references to data of any type (rather than the integer-valued references of

ReFS), and

(c) no types at all!
(a) would enable one to tackle proofs of equivalence involving efficient implemen-tation with pointers and arrays of data structures with purely functional behaviour.

(One would probably want to consider abstract types at the same time.) (b) is ofinterest because of the connections between object-based programming and the
use of storage for function and procedure values. By (c) we mean the kind of
untyped imperative lambda calculus considered by Mason and Talcott (1991a) andothers; its dynamics includes the phenomena that (a) and (b) introduce in a more

disciplined way, and more besides.

Extension (a) takes us beyond the techniques used in this paper because werelied on the simple nature of ReFS types to define the relations E

oe(r), Koe(r),and V
oe(r) by induction on the structure of the type oe (see Definition 4.2). In thenon-simply typed case one could instead attempt to define these relations for all

types simultaneously by solving a fixed point equation for a suitable operator on
(families of) relations. The addition of algebraic data types (lists, trees, etc.) toReFS could be accommodated in this way. However, general forms of data type

declaration may have negative or mixed-variance occurrences of the type beingdefined. The property required of the logical relation at such a type takes the
form of a fixed point equation for an operator that is non-monotone; so it is notimmediately clear that it can be satisfied. For denotationally-based logical relations
there are ways of overcoming this problem using the `minimal invariance' propertyof recursively defined domains: see (Pitts 1994; Pitts 1996). Operational versions

of the techniques in loc. cit. are possible and can be used to extend the resultspresented here to cover (a). (This suggestion has been taken up for a pure functional
language in Birkedal and Harper 1997.)

Regarding (b), it is well known that the ability to store function values gives rise
to more complex behaviour than storing only values of ground types. For example,it becomes possible to encode recursive function definitions. This is reflected in

the denotational semantics of such storage by the need to solve a mixed-variancedomain equation. In this respect the difficulties which must be overcome to define
a suitable logical relation might seem to be similar to those in case (a). However,
there are further complications. In ReFS any dynamically created state has`support' disjoint from the existing global state: the definition of the logical relation

exploits this fact in the use it makes of the smash product r \Omega  r0 of state-relations.This disjointness of support breaks down with (b), since a global location can
get updated with a function value involving a freshly created location. (Considerfor example

let val b = ref(fn x ) 0) in a := (fn x ) (!b)0) end, where a is
some previously declared identifier of type (int ! int) ref.) Therefore theway the parameterisation of the logical relation treats dynamic allocation is more

Operational reasoning for functions with local state 271
complicated in the presence of (b) and it remains to be seen if the techniques ofthis paper extend to cover this case.

Even for ReFS itself, it is possible to consider more refined versions of the
parameterisation. For example one can consider relations on the flat completepartial order of states rather than on the set of states. Building on work of O'Hearn

and Reynolds (1996), Pitts (1997, Example 4.1) shows how this small alterationhelps with operational reasoning about divergence in Idealised Algol. It seems
likely that it would be similarly useful for ReFS.

Of course the above list of enhancements is hardly complete: one might wellwant to consider I/O effects, or exception mechanisms, for example. When adding

language features, we also need to keep in mind the feasibility of the proofmethod. The strength of the technique presented here lies as much in its usability
as in its theoretical power. Although one may need to develop operationally-based analogues of some rather sophisticated methods from domain theory in
order to define a logical relation (and establish its Fundamental Property) forfunction references and recursive datatypes, these technicalities do not necessarily
complicate the use of logical relations to prove contextual equivalence. We canalready see this in the treatment of recursion. The proof of Proposition 4.8(xv) is
not straightforward, but its statement is simple and its use unrestricted: the logicalrelation is preserved by any recursive function abstraction. Our aim is to further

increase the power of operationally-based logical relations without compromisingtheir ease of use.

The operationally based logical relation we have presented here seems to
provide a convenient and reasonably powerful method for proving contextualequivalences between functions with local store. Once a correct relation between

states has been identified, verifying equivalence involves routine calculations withthe structural operational semantics of the language. However, the examples we

have given are all small-scale. It would be interesting to investigate machine-assistance for proofs using our methods. Note that we do not necessarily have
to implement the proof that logical relations imply contextual equivalence; what
might benefit from machine-assistance is the demonstration, in the case of largeprograms, that two expressions are {

id !}-related.

References

Birkedal, L. and R. Harper (1997). Relational interpretation of recursive types in an

operational setting (Summary). In Proc. TACS'97, Lecture Notes in Computer
Science. Springer-Verlag, Berlin. To appear.

Felleisen, M. and D. P. Friedman (1986). Control operators, the SECD-machine and

the *-calculus. In Formal Description of Programming Concepts III, pp. 193-217.
North Holland.

Harper, R., B. F. Duba, and D. MacQueen (1993). Typing first-class continuations in

ML. Journal of Functional Programming 3(4), 465-484.

272 Pitts & Stark

Harper, R. and C. Stone (1996). A type-theoretic account of Standard ML 1996 (version

2). Technical Report CMU-CS-96-136R, Carnegie Mellon University, Pittsburgh,
PA.

Honsell, F., I. A. Mason, S. F. Smith, and C. L. Talcott (1995). A variable typed logic

of effects. Information and Computation 119(1), 55-90.

Hughes, R. J. M. (1989). Why functional programming matters. The Computer Journal 32(2), 98-107.

Mason, I. A. (1986). The Semantics of Destructive Lisp. Ph. D. thesis, Stanford

University. Also published as CSLI Lecture Notes Number 5, Center for the Study
of Language and Information, Stanford University.

Mason, I. A., S. F. Smith, and C. L. Talcott (1996). From operational semantics to

domain theory. Information and Computation 128(1), 26-47.

Mason, I. A. and C. L. Talcott (1991a). Equivalence in functional languages with

effects. Journal of Functional Programming 1, 287-327.

Mason, I. A. and C. L. Talcott (1991b). Program transformations for configuring

components. In PEPM '91: Proceedings of the ACM/IFIP Symposium on Partial
Evaluation and Semantics-based Program Manipulation, ACM SIGPLAN Notices
26(9), pp. 297-308.

Mason, I. A. and C. L. Talcott (1992a). Inferring the equivalence of functional programs

that mutate data. Theoretical Computer Science 105, 167-215.

Mason, I. A. and C. L. Talcott (1992b). References, local variables and operational

reasoning. In Proceedings of the 7th Annual Symposium on Logic in Computer
Science, pp. 186-197. IEEE Computer Society Press.

Milner, R., M. Tofte, and R. Harper (1990). The Definition of Standard ML. MIT Press.
O'Hearn, P. W. and J. C. Reynolds (1996, April). From Algol to polymorphic linear

lambda-calculus. Draft version, 46 pp.

O'Hearn, P. W. and R. D. Tennent (1993). Relational parametricity and local variables.

In 20th SIGPLAN-SIGACT Symposium on Principles of Programming Languages,
pp. 171-184. ACM Press.

O'Hearn, P. W. and R. D. Tennent (1995). Parametricity and local variables. Journal of

the ACM 42(3), 658-709.

Paulson, L. C. (1991). ML for the Working Programmer. Cambridge University Press.
Pitts, A. M. (1994). Computational adequacy via `mixed' inductive definitions. In

Proc. MFPS'93, New Orleans, LA, USA, April 1993, Volume 802 of Lecture Notes
in Computer Science, pp. 72-82. Springer-Verlag, Berlin.

Pitts, A. M. (1996). Relational properties of domains. Information and Computation 127, 66-90.

Pitts, A. M. (1997). Reasoning about local variables with operationally-based logical

relations. In P. W. O'Hearn and R. D. Tennent (Eds.), Algol-Like Languages,
Volume 2, Chapter 17, pp. 173-193. Birkhauser. First appeared in Proc. LICS'96,
pp 152-163, IEEE Computer Society Press, 1996.

Operational reasoning for functions with local state 273

Pitts, A. M. and I. D. B. Stark (1993). Observable properties of higher order functions

that dynamically create local names, or: What's new? In Proc. MFCS'93, Gda'nsk,
1993, Volume 711 of Lecture Notes in Computer Science, pp. 122-141. SpringerVerlag, Berlin.

Plotkin, G. D. (1973). Lambda-definability and logical relations. Memorandum SAIRM-4, School of Artificial Intelligence, University of Edinburgh.

Plotkin, G. D. (1980). Lambda-definability in the full type hierarchy. In J. P. Seldin

and J. R. Hindley (Eds.), To H. B. Curry: Essays on Combinatory Logic, Lambda
Calculus and Formalism, pp. 363-373. Academic Press.

Reynolds, J. C. (1981). The essence of Algol. In J. W. de Bakker and J. C. van Vliet

(Eds.), Algorithmic Languages. Proceedings of the International Symposium on
Algorithmic Languages, pp. 345-372. North-Holland, Amsterdam.

Reynolds, J. C. (1982). Idealized Algol and its specification logic. In D. N'eel (Ed.),

Tools and Notions for Program Construction, pp. 121-161. Cambridge University
Press.

Reynolds, J. C. (1983). Types, abstraction and parametric polymorphism. In R. E. A.

Mason (Ed.), Information Processing 83, pp. 513-523. North-Holland, Amsterdam.

Seiber, K. (1995). Full abstraction for the second order subset of an ALGOL-like

language. Technical Report A 04/95, Fach. Informatik, Univ. des Saarlandes,
Saarbr"ucken, Germany.

Stark, I. D. B. (1994). Names and Higher-Order Functions. Ph. D. thesis, University

of Cambridge. Also published as Technical Report 363, University of Cambridge
Computer Laboratory, April 1995.

Talcott, C. (1997). Reasoning about functions with effects. In this volume.