

Secrecy Types for Asymmetric Communication

Mart'in Abadi

\Lambda 

InterTrust Strategic Technologies and

Architectural Research Laboratory

Bruno Blanchet

\Lambda 

INRIA Rocquencourt

23rd April 2001

Abstract
We develop a typed process calculus for security protocols in which
types convey secrecy properties. We focus on asymmetric communication
primitives, especially on public-key encryption. These present special difficulties, partly because they rely on related capabilities (e.g., "public"
and "private" keys) with different levels of secrecy and scopes.

1 Introduction
A secret is something you tell to one person at a time, according to a popular
definition. Research on security has led to several other concepts of secrecy
(e.g., [2, 12, 16]). This paper studies secrecy in the context of security protocols
with the methods of process calculi and type systems. Here, a secret is a datum
(such as a cryptographic key) that never appears on a channel on which an
adversary can listen, even if the adversary actively tries to obtain the datum.
We develop a process calculus with a type system in which types convey secrecy
properties and such that well-typed programs keep their secrets.

Many security protocols use asymmetric communication primitives, namely
communication channels with only one fixed end-point (the receiver) and particularly public-key encryption. These primitives present special difficulties, partly
because they rely on pairs of related capabilities (e.g., "public" and "private"
keys) with different levels of secrecy and scopes. Therefore, we concentrate on
these primitives, and their treatment constitutes the main novelty of this work.
An appendix gives corresponding type rules for symmetric primitives, such as
shared-key encryption; they are more straightforward.

Basically, our type system is concerned with the question of when it is permissible to tell a secret, and particularly to one person at a time. Telling it to
one person at a time means that any communication channel used to transmit
the secret has a unique receiver, or, if the secret is sent encrypted, that only one

\Lambda This work was partly done while the authors were at Bell Labs Research, Lucent Technologies.

1

person has the corresponding decryption key. Of course, the person in question
should be allowed to know the secret--it may still be a secret with respect to
the adversary. Moreover, the person should realize that this is a secret, and
treat it accordingly. The type system helps enforce these conditions.

The rest of this introduction describes the process calculus that serves as
setting for this work, the type system, and some of their properties. It also
describes the difficulties connected with public-key encryption and other asymmetric communication primitives. Along the way, the introduction mentions
relevant related work.

The process calculus. The process calculus is a relative of the pi calculus [21]
and the spi calculus [3]. It includes channels with fixed receivers, as in the
local pi calculus [19], the join calculus [11], and many object-oriented languages
(e.g, [6]). Such a channel can be used for transmitting secrets if the adversary
cannot listen on the channel. On the other hand, the capability for sending
on the channel may be published. The channel may therefore convey not only
secrets but also public data from the adversary. The receiver needs static and
dynamic checks for distinguishing these two cases; our type system accounts for
some of these mechanisms.

In addition, the process calculus includes cryptographic operations, specifically public-key encryption. In a public-key encryption scheme, the capabilities
of encryption and decryption are separate (e.g., [18]), and can be handled differently. Hence public-key encryption is often called asymmetric encryption.
Typically, the capability for decryption (the "private" key) remains with one
principal, while the capability for encryption (the "public" key) may be published. Therefore, both secrets and public data from the adversary may be
encrypted under the public key. Thus, pleasingly, public-key encryption resembles communication on channels with fixed receivers. Our process calculus and
type system treat them analogously.

The phrase "public key" has at least two distinct meanings in this context.
It may refer to one of the two keys in a public-key cryptosystem, used for
encrypting data or for verifying digital signatures (which we do not treat here).
Although such a key may be widely known, and it often is in examples, it can
also be kept secret. Alternatively, a "public key" may be a key which happens
to be public, that is, not secret. We try to use "public key" only with the latter
meaning, and prefer "encryption key" for the former.

The type system. The type system is based on old ideas on secrecy levels [10]
and on the newer trend of representing these levels in types (e.g., [1, 9, 13-15,
22, 23, 26, 28]). For example, Public and Secret are the types of public data and
secret data, respectively. In addition, the type system gives information on the
intended usage and structure of data, like standard type systems. For example,
KSecret[T1; T2] is the type of a secret encryption key that is used to encrypt pairs
with components of respective types T1 and T2. Similarly, KPublic[T1; T2] is the
type of a public encryption key. Analogous types apply to channels.

2

Substantial difficulties arise because, in the study of security protocols, we
cannot assume that the adversary politely obeys our typing discipline [1, 9, 27].
Although honest protocol participants may use public channels and public keys
according to declared types, the adversary may be an untyped process and
disregard those types. Nevertheless, the declared types remain useful when
combined with the static and dynamic checks mentioned above.

In this respect, asymmetric communication primitives (channels with fixed
receivers, public-key encryption) are more delicate and interesting than their
symmetric counterparts (shared channels as in the pi calculus, shared-key encryption). A shared channel or shared key that the adversary knows should
never be employed for transmitting secrets, only public data. Therefore, types
like KPublic[Secret] are useless in this setting; a public shared key may simply
be given the type Public. On the other hand, a channel with a fixed receiver
may be employed for transmitting secrets, even if the adversary knows it (as
long as the adversary is not the receiver). Similarly, an encryption key in a
public-key cryptosystem may be employed for encrypting secrets, even if the
adversary knows it (as long as the adversary does not know the corresponding
decryption key). Therefore, types like KPublic[Secret] give useful information.
For instance, although the adversary may encrypt public data under a key of
type KPublic[Secret], this type can tell others that encrypting secrets under the
key is acceptable too, that these secrets will not escape. The typing of asymmetric communication primitives in the context of an untyped adversary is the
main novelty of this work.

Secrecy results. We prove a subject-reduction property, namely, that typing
is preserved by computation. Relying on this property, we also prove a secrecy
theorem that shows that well-typed processes do not reveal their secrets. As an
example, let us consider a well-typed process P with just two free names, a of
type Public and k of type KSecret[T1; T2]. As an adversary, we allow any process
Q with the free name a (and possibly other free names, except for k). The
secrecy theorem implies that the parallel composition of P with an adversary
Q never outputs k on a.

This kind of secrecy guarantee is common and useful in the analysis of security protocols. It is particularly adequate and effective for dealing with the
secrecy of fresh values that can be viewed as atomic, such as keys and nonces. In
contrast, secrecy guarantees based on the concept of noninterference are better
at excluding flows of partial information about compound values and implicit information flows. (See [2, section 6] for some further discussion and references.)
Most type systems for secrecy concern noninterference; a recent exception is
that of Cardelli, Ghelli, and Gordon [9].

Application to protocols. Our type system can be applied to some small
but subtle security protocols. For example, in the Needham-Schroeder publickey protocol [24] (a standard test case), one might expect a certain nonce to be
secret; however, the protocol fails to typecheck under the assumption that this

3

nonce is secret. This failure is not a shortcoming of the type system: it manifests
Lowe's attack on the protocol [17]. On the other hand, a corrected version of
the protocol does typecheck under the assumption. Our secrecy theorem yields
the expected secrecy property in this case.

A variety of other techniques have been applied to this sort of protocol analysis (and to the Needham-Schroeder public-key protocol in particular). They
include theorem proving, model checking, and control-flow analysis methods
(e.g., [7, 8, 17, 20, 25]). Type-based analyses, such as ours, are in part appealing because of their simplicity and because of their connections to classical
information-flow methods. They do not require exhaustive state-space exploration; they take advantage of the structure of protocols. On the other hand,
they are not always applicable: some reasonable examples fail to typecheck for
trivial reasons (much as in virtually all typed programming languages and logics). Typing is a discipline, and it works best for processes that use channels
and keys in disciplined ways, but disciplined design can lead to more robust
protocols [1, 4, 5].

Outline. The next section defines the process calculus. Section 3 defines a
concept of secrecy. Section 4 presents the type system. Section 5 establishes the
secrecy theorem and other results. Section 6 develops two examples. Section 7
concludes. The appendix shows how to deal with symmetric communication
primitives and gives some details of proofs.

2 The Process Calculus (Untyped)
This section introduces our process calculus, by giving its syntax and informal
semantics and then formalizing its operational semantics.

2.1 Syntax and Informal Semantics
The syntax of our calculus is summarized in Figure 1. It assumes an infinite
set of names and an infinite set of variables; a, b, c, k, s, and similar identifiers
range over names, and x, y, and z range over variables. For simplicity, we do
not formally separate the names for channels and those for keys. The syntax
distinguishes a category of terms (data) and processes (programs). The terms
are variables, names, and terms of the form fM1; : : : MngM , which represent
encryptions. The processes include constructs for communication, concurrency,
and dynamic name creation, roughly those of the pi calculus, a construct for
decryption (case M of fx1; : : : ; xngk : P else Q), and a conditional (if M =
N then P else Q). As usual, we may omit an "else" clause when it consists of
the nil process 0.

The calculus is polyadic, in the sense that messages are tuples of terms, and
asynchronous, in the sense that the output construct does not have a built-in
acknowledgment. It is also local, as explained below. Therefore, the calculus

4

M; N ::= terms

x; y; z variable
a; b; c; k; s name
fM1; : : : ; MngM encryption

P; Q ::= processes

M hM1; : : : ; Mni output
a(x1; : : : ; xn):P input
0 nil
P j Q parallel composition
!P replication
(*a)P restriction
case M of fx1; : : : ; xngk : P else Q decryption
if M = N then P else Q conditional

Figure 1: Syntax of the process calculus
could be called the local, asynchronous, polyadic spi calculus--but we refrain
from such a jargon overload.

The calculus is based on asymmetric communication: channels with only
one fixed end-point (the receiver) and public-key encryption. We adopt an
elegant, economical approach to asymmetric communication from the local pi
calculus [19]. In the local pi calculus, input is possible only on channels that
are syntactically represented by names (and not variables). Output is possible
on channels represented by names or variables. Thus, the input capability for a
channel a remains within the scope of the restriction (*a)P where a is created,
while the output capability can be transmitted outside. Further, we extend this
approach to public-key encryption, as follows. Decryption is possible only with
keys that are syntactically represented by names (and not variables). Encryption
is possible with keys represented by names or variables. Thus, we model that
the encryption capability may be public while the decryption capability remains
private, in the scope where it is generated. We do not explicitly model the
distribution of decryption keys across scopes; it is relatively unimportant in
public-key cryptosystems.

Thus, when a name a refers to a channel, it represents both end-points of
the channel, that is, the capabilities for output and input on the channel. A
variable can confer only the former capability, even if its value is a at run-time.
Similarly, a name k will not represent a single encryption or decryption key,
but rather the pair of an encryption key and a corresponding decryption key.
A variable can confer only the capability of encrypting, even if its value is k at
run-time. (The original spi calculus has a different syntax for key pairs: two
different terms represent the two keys in a pair, and there is a function that
generates public keys from secrets. We believe that our results can be adapted
to that syntax, but here prefer the leaner local syntax.)

5

Specifically, the constructs for asymmetric communication are output, input,
encryption, and decryption:

ffl The process M hM1; : : : ; Mni outputs the tuple M1; : : : ; Mn on M . Here

an arbitrary term M is used to refer to a channel: M can be a variable,
a name, or even an encryption. This last case is however unimportant for
the present purposes; when M is an encryption, no process can receive the
message M hM1; : : : ; Mni.

ffl The process a(x1; : : : ; xn):P inputs a message with n components on channel a, then executes P with the variables x1; : : : ; xn bound to the contents
of the message. Note that a must be a name.

ffl The term fM1; : : : ; MngM represents an encryption of the tuple M1; : : : ;

Mn under M . Here an arbitrary term M is used to refer to an encryption
key: M can be a variable, a name, or even an encryption. This last case
is however unimportant, again; when M is an encryption, no process can
decrypt fM1; : : : ; MngM .

ffl In the process case M of fx1; : : : ; xngk : P else Q, the term M is decrypted with the key k. If M is indeed a ciphertext encrypted under k, and
the underlying plaintext has n components, then the process P is executed
with the variables x1; : : : ; xn bound to those components. Otherwise, the
process Q is executed. Note that k must be a name.

The remaining constructs are standard. The nil process 0 does nothing.
The process P j Q is the parallel composition of P and Q. The replication !P
represents any number of copies of the process P in parallel. The restriction
(*a)P creates a new name a, and then executes P . The conditional if M =
N then P else Q executes P if M and N evaluate to the same closed term;
otherwise, it executes Q. This construct is not always present in relatives of the
pi calculus, but it is helpful in modeling security protocols.

For example, the following expression is a process:

(*k)(ahki j !b(x):case x of fygk : chyi)
This process relies on three public channels, a, b, and c. It generates a fresh key
pair k; outputs the corresponding encryption key on a; and receives messages
on b, filtering for one encrypted under k, of which it outputs the plaintext on c.

The name a is bound in (*a)P . The variables x1; : : : ; xn are bound in P
in the processes a(x1; : : : ; xn):P and case M of fx1; : : : ; xngk : P else Q. We
write fn(P ) and fv (P ) for the sets of names and variables free in P , respectively.
A process is closed if it has no free variables; it may have free names. We
identify processes up to renaming of bound names and variables. We write
fM1=x1; : : : ; Mn=xng for the substitution that replaces x1, : : : , xn with M1,
: : : , Mn, respectively.

6

P j 0 j P
P j Q j Q j P
(P j Q) j R j P j (Q j R)
!P j P j !P

(*a1)(*a2)P j (*a2)(*a1)P if a1 6= a2
(*a)(P j Q) j P j (*a)Q if a =2 fn(P )

P j Q ) P j R j Q j R
P j Q ) !P j !Q
P j Q ) (*a)P j (*a)Q

P j P
Q j P ) P j Q
P j Q; Q j R ) P j R

Figure 2: Structural congruence
ahM1; : : : ; Mni j a(x1; : : : ; xn):P

! P fM1=x1; : : : ; Mn=xng (Red I/O)

case fM1; : : : ; Mngk of fx1; : : : ; xngk : P else Q

! P fM1=x1; : : : ; Mn=xng (Red Decrypt 1)
case M of fx1; : : : ; xngk : P else Q ! Q

if M is not of the form fM1; : : : ; Mngk (Red Decrypt 2)

if M = M then P else Q ! P (Red Cond 1)
if M = N then P else Q ! Q

if M 6= N (Red Cond 2)

P ! Q ) P j R ! Q j R (Red Par)
P ! Q ) (*a)P ! (*a)Q (Red Res)

P 0 j P; P ! Q; Q j Q0 ) P 0 ! Q0 (Red j)

Figure 3: Reduction
2.2 Formal Semantics
The rules of Figure 3 axiomatize the reduction relation ! for processes; they are
a formal definition for the operational semantics of our calculus. The auxiliary
rules of Figure 2 axiomatize the structural congruence relation j; this relation
is useful for transforming processes so that the reduction rules can be applied.
Both j and ! are defined only on closed processes. (In particular, we do
not include rules for structural congruence under an input, a decryption, or a
conditional; such rules are not necessary to apply reduction rules.) All rules are
fairly standard.

Using this operational semantics, we can give a precise definition of a simple
concept of output, which we use below in a definition of secrecy. Here, !\Lambda  is
the reflexive and transitive closure of !.

Definition 1 The process P outputs M immediately on c if and only if P j
chM i j R for some process R. The process P outputs M on c if and only if
P !\Lambda  Q and Q outputs M immediately on c for some process Q.

7

3 A Definition of Secrecy
This section defines a concept of secrecy for the calculus, relying on the operational semantics of section 2.2.

We think of an attacker as any process Q of the calculus, under some restrictions that characterize the attacker's initial capabilities. We formulate the
restrictions by using a set of names RW ("read-write") and a set of closed
terms W ("write"). Initially, the attacker is able to output, input, encrypt,
and decrypt using the names of RW . He can output and encrypt using names
in W . He has the terms in RW and W , and can compute on them and include
them in messages. In the course of computation, the attacker may acquire some
additional capabilities not represented in RW and W , by creating fresh names
and receiving terms in messages.

In order to express the limited use of the terms in W , we also introduce
a set of variables fx1; : : : ; xlg of the same cardinality l as W . When W =
fM1; : : : ; Mlg, the attacker is a process Q of the form Q0fM1=x1; : : : ; Ml=xlg.
Since Q0 should be a well-formed process before the application of the substitution fM1=x1; : : : ; Ml=xlg, it cannot input or decrypt using the variables fx1;
: : : ; xlg. Further, in order to express that the attacker cannot initially use any
other names or terms, we impose that fn(Q0) ` RW and fv (Q0) ` fx1; : : : ; xlg.

Definition 2 Let RW be a finite set of names and let W = fM1; : : : ; Mlg
be a finite set of closed terms. The process Q is a (RW ; W )-adversary if and
only if it is of the form Q0fM1=x1; : : : ; Ml=xlg for some process Q0 such that
fn(Q0) ` RW and fv(Q0) ` fx1; : : : ; xlg.

We say that a process preserves the secrecy of a piece of data M if the
process never publishes M , or anything that would permit the computation of
M , even in interaction with an attacker. This concept of secrecy is common
in the literature on security protocols. A precise definition of it appears in [2],
for the spi calculus; Cardelli, Ghelli, and Gordon use that definition in their
work on secrecy and groups in the pi calculus [9]. Here we introduce and use
a different definition that captures the same concept. This definition takes into
account asymmetric communication; it is also more syntactic, and a little easier
to treat in our proofs.

Definition 3 Let RW be a finite set of names and let W be a finite set of closed
terms. The process P preserves the secrecy of M from (RW ; W ) if and only if
P j Q does not output M on c for any (RW ; W )-adversary Q and any c 2 RW .

Clearly, if P preserves the secrecy of M from (RW ; W ), it cannot output M on
some c 2 RW , that is, on one of the channels on which an (RW ; W )-adversary
can read. This guarantee corresponds to the informal requirement that P never
publishes M on its own. Moreover, P cannot publish data that would enable
an adversary to compute M , because the adversary could go on to output M
on some c 2 RW .

8

For instance, (*k)ahfsgk; ki preserves the secrecy of s from (fag; ;). This
process publishes an encryption of s and the corresponding encryption key on
the channel a, but keeps the decryption key, so s does not escape. Similarly,
ahfsgk; ki preserves the secrecy of s from (fag; fkg). However, ahfsgk; ki does
not preserve the secrecy of s from (fa; kg; ;): the adversary

a(x; y):case x of fzgk : ahzi
can receive fsgk on a, decrypt s, and resend it on a. As a more substantial,
untyped example we consider the following process P :

P

\Delta = (*k)(ahfk

1; k2gki j !b(x):case x of fy1; y2gk : chy1i)

This process relies on three public channels, a, b, and c. It generates a fresh
key pair k; outputs the encryption fk1; k2gk on a; and receives messages on b,
filtering for one encrypted under k, of which it outputs the first component of
the plaintext on c. Although P does not output k1 in clear on its own, it does
not preserve the secrecy of k1 from (fa; cg; fbg): the adversary

a(x):bhxi
can receive fk1; k2gk on a and resend it on b, causing k1 to appear on c. On the
other hand, P does preserve the secrecy of k2 from (fa; cg; fbg). Other examples
appear in section 6; they are larger and have types.

4 The Type System
The types of our type system are defined by the grammar:
T ::= types

Public
Secret
CPublic[T1; : : : ; Tn]
CSecret[T1; : : : ; Tn]
KSecret[T1; : : : ; Tn]
KPublic[T1; : : : ; Tn]

We let L range over fPublic; Secretg, and may for example write CL[T1; : : : ; Tn]
and KL[T1; : : : ; Tn]. The subtyping relation is the least reflexive relation such
that CL[T1; : : : ; Tn] ^ L and KL[T1; : : : ; Tn] ^ L. (We do not have Secret ^
Public or vice versa.)

The types have the following informal meanings:

ffl Public is the type of public data, and is a supertype of all types CPublic[T1;

: : : ; Tn] and KPublic[T1; : : : ; Tn].

ffl Similarly, Secret is the type of secret data, and is a supertype of all types

CSecret[T1; : : : ; Tn] and KSecret[T1; : : : ; Tn].

9

ffl CSecret[T1; : : : ; Tn] is the type of a channel on which the adversary cannot

send messages, and which conveys n-tuples with components of respective
types T1; : : : ; Tn.

ffl Similarly, KSecret[T1; : : : ; Tn] is the type of an encryption key that the

adversary does not have, and which is used to encrypt n-tuples with components of respective types T1; : : : ; Tn.

ffl CPublic[T1; : : : ; Tn] is the type of a channel on which the adversary may

send messages; the channel may be intended to convey n-tuples with components of respective types T1; : : : ; Tn, but the adversary may send any
data it has (that is, any public data) on the channel.

ffl Similarly, KPublic[T1; : : : ; Tn] is the type of an encryption key that the

adversary may have; this key may be intended for encrypting n-tuples
with components of respective types T1; : : : ; Tn, but the adversary may
encrypt any data it has (that is, any public data) under this key.

Figures 4 and 5 give the rules of the type system. In the rules, the metavariable u ranges over names and variables. The rules concern four judgments:

ffl E ` \Pi  means that E is a well-formed environment. The environment E is

well-formed if and only if E is a list of pairs u : T where each u is a name
or a variable and distinct from all others in E.

ffl E ` M : T means that M is a term of type T in the environment E.

Basically, names and variables have the types declared in E, and any
supertypes, while encryptions all have the type Public.

ffl E `\Pi  M : S means that S is the set of possible "true" types of M in the

environment E.

ffl E ` P says that the process P is well-typed in the environment E.
The type rules for output say that any public data can be sent on a public
channel (Output Public), and tuples with the expected types T1; : : : ; Tn can be
sent on a channel of type CL[T1; : : : ; Tn] (Output CL). Therefore, by subtyping,
any public data can be sent on a channel of type CPublic[T1; : : : ; Tn]. This use
of the channel may not seem to conform to its declared type. However, it is
unavoidable, since we expect that an attacker can use the channel; moreover, it
does not cause harm from the point of view of secrecy. Similarly, the type rule
(Output Public) also permits processes that use an encryption as a channel,
such as fM gkhN i. A standard type system might attempt to exclude such
processes. Ours does not, essentially because an attacker might run fM gkhN i,
but this does not cause harm from the point of view of secrecy. On the other
hand, the attacker cannot have channels of type CSecret[T1; : : : ; Tn]. Therefore,
we can guarantee that such channels are represented by names at run-time and
that only tuples with types T1; : : : ; Tn can be sent on such channels.

As for input, we distinguish three cases, considering the type of the channel
a on which an input happens:

10

Well-formed environment:

; ` \Pi 

E ` \Pi  u =2 dom(E)

E; u : T ` \Pi 

Terms:

E ` \Pi  (u : T ) 2 E

E ` u : T (Atom)
E ` M : Public 8i 2 f1; : : : ; ng; E ` Mi : Public

E ` fM1; : : : ; MngM : Public (Encrypt Public)

E ` M : KL[T1; : : : ; Tn] 8i 2 f1; : : : ; ng; E ` Mi : Ti

E ` fM1; : : : ; MngM : Public (Encrypt K

L)

E ` M : T T ^ T 0

E ` M : T 0 (Subsumption)

Sets of types of terms:

E ` \Pi  (x : T ) 2 E
E `\Pi  x : fT 0 j T 0 ^ T g (Variable

s)

E ` \Pi  (a : T ) 2 E

E `\Pi  a : fT g (Name

s)

E ` fM1; : : : ; MngM : Public
E `\Pi  fM1; : : : ; MngM : fPublicg (Encryption

s)

Figure 4: Type rules: environments and terms
ffl If a is of type Public, then the corresponding output must have been typed

using (Output Public), so the input values are public. Rule (Input Public)
treats this case. This rule may seem superfluously liberal, but it is helpful
in our proofs. It enables us to type an arbitrary adversary, which can input
public values on the public channels on which it listens (see section 5).

ffl When a is of type CPublic[T1; : : : ; Tn], two cases arise. In the first case,

the corresponding output has been typed using (Output Public) and subtyping. Then the input values are of type Public. In the second case, the
corresponding output has been typed using (Output CL). In this case,
the input values have the expected types T1; : : : ; Tn. Rule (Input CPublic)
takes into account both cases, by checking that the process P executed
after the input is well-typed in both.

ffl When a is of type CSecret[T1; : : : ; Tn], it cannot be known by the attacker,

and the corresponding output must have been typed using (Output CL).
The input values are therefore of the expected types T1; : : : ; Tn.

11

E ` M : Public 8i 2 f1; : : : ; ng; E ` Mi : Public

E ` MhM1; : : : ; Mni (Output Public)
E ` M : CL[T1; : : : ; Tn] 8i 2 f1; : : : ; ng; E ` Mi : Ti

E ` MhM1; : : : ; Mni (Output C

L)

(a : Public) 2 E E; x1 : Public; : : : ; xn : Public ` P

E ` a(x1; : : : ; xn):P (Input Public)

(a : CPublic[T1; : : : ; Tm]) 2 E E; x1 : Public; : : : ; xn : Public ` P

E; x1 : T1; : : : ; xm : Tm ` P if m = n

E ` a(x1; : : : ; xn):P

(Input CPublic)

(a : CSecret[T1; : : : ; Tn]) 2 E E; x1 : T1; : : : ; xn : Tn ` P

E ` a(x1; : : : ; xn):P (Input C

Secret)

E ` \Pi 
E ` 0 (Nil)
E ` P E ` Q

E ` P j Q (Parallel)

E ` P
E ` !P (Replication)
E; a : T ` P

E ` (*a)P (Restriction)

E ` M : Public (k : Public) 2 E
E; x1 : Public; : : : ; xn : Public ` P E ` Q

E ` case M of fx1; : : : ; xngk : P else Q (Decrypt Public)
E ` M : Public (k : KPublic[T1; : : : ; Tm]) 2 E

E; x1 : Public; : : : ; xn : Public ` P E ` Q

E; x1 : T1; : : : ; xm : Tm ` P if m = n

E ` case M of fx1; : : : ; xngk : P else Q (Decrypt K

Public)

E ` M : Public (k : KSecret[T1; : : : ; Tn]) 2 E

E; x1 : T1; : : : ; xn : Tn ` P E ` Q

E ` case M of fx1; : : : ; xngk : P else Q (Decrypt K

Secret)

E `\Pi  M : S1 E `\Pi  N : S2 if S1 " S2 6= ; then E ` P E ` Q

E ` if M = N then P else Q

(Cond)

Figure 5: Type rules: processes

12

The type rules for encryption are similar to those for output. Any public
data can be encrypted under a public encryption key (Encrypt Public), and
data of types T1; : : : ; Tn can be encrypted under a key of type KL[T1; : : : ; Tn]
(Encrypt KL). Ciphertexts are always of type Public; this typing simplifies
the rules and is reasonable for most protocols (particularly for most public-key
protocols).

The type rules for decryption resemble those for input, in the same way as
those for encryption resemble those for output.

The type rules for nil, parallel composition, replication, and restriction are
standard. It is worth noting that we use a Curry-style typing for restriction, so
we do not mention a type of a explicitly in the construct (*a). (That is, we do
not write (*a : T ) for some T .) This style of typing gives rise to an interesting
form of polymorphism: the type of a can change according to the environment.
For instance, in c(x):(*a)xhai, with c of type CPublic[CSecret[Secret]], a can be
of type Secret when x is of type CSecret[Secret], and of type Public when x is of
type Public, so that the output xhai is well-typed in both cases.

Rule (Cond) exploits the idea that if two terms M and N cannot have the
same type, then they are certainly different. In this case, the process if M =
N then P else Q may be well-typed without P being well-typed. To determine
whether M and N may have the same type, we determine the set of possible
types of M and N . If M is a variable x, and (x : T ) 2 E, then x may of
course have type T . Because of subtyping, x may also be substituted at runtime by a name whose type is a subtype of T . Hence the possible types of x
are fT 0 j T 0 ^ T g. When M is a name a, its only possible type is the type
assigned to it in the environment. When M is a ciphertext, its only possible
type is Public, by definition of the judgment E ` M : T .

The following example illustrates the use of rule (Cond), informally. Suppose
that a participant A in a security protocol invents a fresh quantity a of type
Secret (as a nonce challenge), sends it on a channel of type CSecret[Secret], so a
should remain secret. Some time later, A gets a ciphertext encrypted under a
key k of type KPublic[Secret; T ]; decryption yields a pair x1; x2. The type system
covers two possibilities: (1) x1 has type Secret and x2 has type T , (2) both are
public (for example, because the attacker constructed the ciphertext). That is,
the type rule for decryption (Decrypt KPublic) has hypotheses that correspond
to each of these possibilities. Suppose further that A checks, dynamically, that
x1 = a (and halts if x1 6= a). This check guarantees that x1 has type Secret, and
hence is not public. At the same time, it guarantees that x2 has type T . After
the check, A can assume that x2 has type T , and act accordingly. Dynamic
checks of this sort are common and important in security protocols, for example
in those of section 6.

This type system reflects a binary view of secrecy, according to which the
world is divided into system and attacker, and a secret is something that the
attacker does not have. When we wish to express that a piece of data is a secret
for a given set of principals, we define the system to include only the processes
that represent those principals.

13

In this respect and in others, our type system is most similar to that of
Abadi [1] for the spi calculus and that of Cardelli, Ghelli, and Gordon [9, section
4] for the pi calculus. Both treat only symmetric communication primitives. The
latter, however, is mostly introduced as an auxiliary type system for a proof.
The proof concerns another type system, which elegantly exploits a powerful
construct for group creation. Group creation directly supports a rich view of
secrecy that does not simply divide the world into two parts. We believe that the
type system with group creation can be extended with symmetric cryptographic
primitives, of the kind modeled in the appendix, and further extended to deal
with asymmetric communication. Unfortunately (as far as we can tell) this last
extension does not retain the elegance of the original.

5 The Secrecy Theorem and Other Results
This section studies the type system of section 4. First it establishes a subjectreduction theorem and a typability lemma. Then it derives the secrecy theorem
sketched in the introduction. Finally, it touches on the question of the existence
of "best" typings.

5.1 Subject Reduction and Typability
The subject-reduction theorem says that typing is preserved by computation.
We give details of its proof in the appendix; it is mostly a fairly routine induction
on computations with a case analysis on typing proofs.

Theorem 1 (Subject congruence and subject reduction) If E ` P and
if P j Q or P ! Q then E ` Q.

The following typability lemma says that every process is well-typed, at least
in a fairly trivial way that makes its free names public. This lemma is important
because it means that any process that represents an adversary is well-typed.
It is a formal counterpart to the informal idea that the type system cannot
constrain the adversary.

Lemma 1 (Typability) Let P be an untyped process. If fn(P ) ` fa1; : : : ; ang,
fv(P ) ` fx1; : : : ; xmg, and Ti ^ Public for all i 2 f1; : : : ; mg, then

a1 : Public; : : : ; an : Public; x1 : T1; : : : ; xm : Tm ` P
Proof The proof is by induction on the structure of P . In the case of restriction, the type of the new name is Public. Input is typed by (Input Public),
output by (Output Public), decryption by (Decrypt Public), and encryption by
(Encrypt Public). 2

14

5.2 Secrecy
The secrecy theorem says that if a closed process P is well-typed in an environment E, and a name s has type Secret in E, then P preserves the secrecy
of s from (RW ; W ), where RW is the set of names declared Public in E, and
W is the set of names declared CPublic[: : : ] or KPublic[: : : ]. The name s may be
declared Secret in E, but it may also be declared CSecret[: : : ] or KSecret[: : : ]. In
other words, P preserves the secrecy of Secret names against adversaries that
can output, input, encrypt, and decrypt on names declared Public and that can
output and encrypt on names declared CPublic[: : : ] and KPublic[: : : ].

Theorem 2 (Secrecy) Let P be a closed process. Suppose that E ` P and
E ` s : Secret. Let

RW = fa j (a : Public) 2 Eg

W = fa

0 j (a0 : CPublic[: : : ]) 2 E or (a0 : KPublic[: : : ]) 2 Eg

Then P preserves the secrecy of s from (RW ; W ).
Proof The secrecy theorem is a fairly easy consequence of the subjectreduction theorem and the typability lemma. (In truth, the type system and
the definition of secrecy were refined with this proof of the secrecy theorem in
mind.)

Suppose that RW = fa1; :::; ang and W = fa01; :::; a0lg, and that T 0i is the
type of a0i in E, so (a0i : T 0i ) 2 E for all i 2 f1; : : : ; lg.

In order to derive a contradiction, we assume that P does not preserve the secrecy of s from (RW ; W ). Then there exists a process Q = Q0fa01=x1; : : : ; a0l=xlg
with fn(Q0) ` RW and fv(Q0) ` fx1; : : : ; xlg, such that P j Q !\Lambda  R and
R j chsi j R0, where c 2 RW . By Lemma 1, a1 : Public; : : : ; an : Public; x1 :
T 01; : : : ; xl : T 0l ` Q0. By a standard substitution lemma (Lemma 2, given in the
appendix), E ` Q0fa01=x1; : : : ; a0l=xlg, that is, E ` Q. Therefore, E ` P j Q. By
Theorem 1, E ` R and E ` chsi j R0. Since c 2 RW , we have (c : Public) 2 E,
so E ` chsi could have been derived only by (Output Public). Such a derivation
would require that E ` s : Public. However, this is impossible, since we have
E ` s : Secret and the two typings are incompatible. We have a contradiction,
so P preserves the secrecy of s from (RW ; W ). 2

We restate a special case of the theorem, as it may be particularly clear.
Corollary 1 Suppose that a:Public; s:T ` P with T ^ Secret. Then P preserves
the secrecy of s from (fag; ;). That is, for all closed processes Q such that
fn(Q) ` fag, P j Q does not output s on a.

For instance, we can obtain a : Public; s : Secret ` (*k)ahfsgk; ki by letting
k : KPublic[Secret]. So this corollary implies that (*k)ahfsgk; ki preserves the
secrecy of s from (fag; ;), as claimed in section 3. In other words, if Q is a
closed process and fn(Q) ` fag, then ((*k)ahfsgk; ki) j Q does not output s

15

on a. Thus, assuming that Q does not have s in advance, Q cannot guess s or
compute it from the message on a.

Further examples appear in section 6.

5.3 "Most Secret" Typings
The secrecy theorem provides a method for proving that a process P preserves
the secrecy of a name. Suppose that in fact P preserves the secrecy of two
different names s and s0, and that this can be proved using the secrecy theorem,
treating each of the names separately. The two applications of the secrecy
theorem may in general rely on two different ways of showing that P is welltyped, with two different typing environments E and E0. We must have that
E ` s : Secret and E0 ` s0 : Secret. However, we may also have E ` s0 : Public
and E0 ` s : Public. Ideally, in order to save work, we may like to have a single
environment E such that E ` P , E ` s : Secret, and E ` s0 : Secret. Roughly, E
should make secret as much as possible, thus providing a "most secret" typing
for P .

Unfortunately, "most secret" typings do not always exist, as the following
small example indicates. For the process P ,

P

\Delta = chs; ai j cha; s0i

we can establish both:

a : Public; c : CPublic[Secret; Public]; s : Secret; s

0 : Public ` P

a : Public; c : CPublic[Public; Secret]; s : Public; s

0 : Secret ` P

but we cannot establish:

a : Public; c : T0; s : Secret; s

0 : Secret ` P

for any T0, or even

a : Public; c : T0; s : T; s

0 : T 0 ` P

for any T0, T , and T 0 such that T; T 0 ^ Secret. Here we set a : Public in order
to model that the attacker may have a; the constraint a : Public can also be
imposed, artificially, by putting a(x):case x of fyga : 0 in parallel with P . This
example uses only a modest fragment of the process calculus; other examples
should arise from the type rule for conditionals.

6 Typed Examples
This section develops two examples, based on security protocols. The first
protocol does not rely on cryptography; the second one, the Needham-Schroeder
public-key protocol, does. Although both are fairly small, informal reasoning

16

about them is error-prone and difficult. The type system provides a simple yet
rigorous approach for proving secrecy properties of the protocols.

In the examples, we use notations common in informal protocol descriptions.
We present a protocol by listing the messages exchanged by its participants. A
step where A sends a message M to B on a channel c is written:

Message n. A ! B : M on c
or simply

Message n. A ! B : M
if the channel is public and unimportant. However, this notation should be
interpreted with care. Although B is the intended receiver of the message M ,
anyone else who can listen on channel c may get M instead of B, and B may not
get M at all, or may get a different message. The integer n indicates that this
step is intended as the nth in a protocol execution, though again this information
should be viewed as a wish or a hint rather than as a guarantee. If assurance is
needed about any of these matters it must be provided as part of the function
of the protocol (see [2, 4]).

6.1 An Example without Cryptography
Although this example does not include cryptography, it resembles some examples that do. It concerns the following protocol in which a principal A sends a
secret s to a principal B:

Message 1. A ! B : k; a on b
Message 2. B ! A : k; b0 on a
Message 3. A ! B : s on b0

Here, a and b are channels with A and B as only receivers, respectively; k is
a secret nonce, created by A; and b0 is a new channel, created by B, with B
as only receiver and A as only sender. Instead of sending s directly on b, A
creates the nonce k and sends it along with the return channel a on b; B's reply
contains k, as proof of origin; the reply also includes the fresh channel b0 on
which A sends s. This channel is analogous to a session key in a cryptographic
protocol.

In our calculus, we may represent the principals of this protocol by the
processes:

A

\Delta = (*k)(bhk; ai j a(x; y):if x = k then yhsi)

and

B

\Delta = b(x; y):(*b0)(yhx; b0i j b0(z):0)

17

We can then use our type system to prove that s remains secret, as expected.
For this proof, we let:

E

\Delta = a : CPublic[Secret; CSecret[Secret]];

b : CPublic[Secret; CPublic[Secret; CSecret[Secret]]];
s : Secret

and obtain E; c : Public ` A j B for any c, as follows. In the typing of A, we
choose k : Secret. The output bhk; ai is then typed by (Output CL). The input
a(x; y) is typed by (Input CPublic), and two cases arise:

(1) x:Public; y :Public: This case is vacuous by rule (Cond): in the test x = k,

the two terms cannot have the same type.

(2) x : Secret; y : CSecret[Secret]: In this case, the output yhsi is typed by

(Output CL).

The input b(x; y) is also typed by (Input CPublic), and again two cases arise:

(1) x : Public; y : Public: In this case, we let b0 : Public.
(2) x : Secret; y : CPublic[Secret; CSecret[Secret]]: In this case, instead, we let

b0 : CSecret[Secret].

In both cases, the rest of process B is easy to typecheck. Having derived E; c :
Public ` A j B, we apply Theorem 2, and conclude that A j B preserves the
secrecy of s from (fcg; fa; bg).

We can also treat a more general system in which A and B communicate
with other principals: A may initiate sessions with others than B, and B is
willing to respond to several principals at once. Still, s should remain within
A j B, and not escape to third parties.

The following process represents the system:

P

\Delta = (A j A0) j !B

Here A0 is an arbitrary process, notionally grouped with A, which may receive
messages on a, under the assumption that E; E0 ` A0 for some E0. In particular, this assumption implies that A0 respects the secrecy of s and uses a in
conformance with a : CPublic[Secret; CSecret[Secret]]. For example, A0 may be:

A

0 \Delta = (*k)(chk; ai j a(x; y):if x = k then yhs0i)

that is, a variant of A that initiates a session with a third party on the channel c
and sends s0. It follows that E; E0 ` P , so Theorem 2 still applies. Remarkably,
the replication of B causes no complication whatsoever. In contrast, replication
tends to be problematic for proof methods based on state-space exploration.

18

6.2 The Needham-Schroeder Public-Key Protocol
The core of the Needham-Schroeder public-key protocol [24] is as follows:

Message 1. A ! B : fsA; AgkB
Message 2. B ! A : fsA; sBgkA
Message 3. A ! B : fsBgkB

In this description we assume that A knows B's public encryption key kB in
advance, and symmetrically that B knows A's public encryption key kA in
advance. (Below, we even name A and B by their keys.) All messages are
encrypted under these keys and travel on public channels. In the first message,
A sends a fresh nonce sA as well as the name A. In the second, B replies with
sA and a fresh nonce sB. Upon receipt of this message, A checks sA and resends
sB to B in the final message.

The goals of this protocol are not entirely explicit in its original description.
However, one might interpret that the protocol is intended to establish sA and
sB as shared secrets for A and B. Subsequently, A and B might combine these
nonces in the computation of a session key.

However, as Lowe pointed out, the protocol does not guarantee the secrecy of
the nonce sB [17]. An attacker C can run the protocol with A, and impersonate
A in a concurrent run with B, obtaining sB from A:

Message 1. A ! C : fsA; AgkC
Message 1'. C(A) ! B : fsA; AgkB
Message 2'. B ! C(A) : fsA; sBgkA
Message 2. C ! A : fsA; sBgkA
Message 3. A ! C : fsBgkC
Message 3'. C(A) ! B : fsBgkB

Here we prime the numbers of the messages of the protocol run in which C
impersonates A, and write C(A) for C in those messages.

Lowe's variant of the Needham-Schroeder public-key protocol defends against
this scenario with an extra field that identifies B in message 2:

Message 1. A ! B : fsA; AgkB
Message 2. B ! A : fsA; sB; BgkA
Message 3. A ! B : fsBgkB

Upon receipt of message 2, A should check this field, and send message 3 only
if this field identifies the expected origin of the message. Thus, an attacker C
cannot obtain fsBgkC from A, because C cannot produce fsA; sB; CgkA to send
to A.

Our type system provides a new perspective on the Needham-Schroeder
public-key protocol and on Lowe's variant. After expressing a fragment of the
original protocol in our process calculus, we show that it does not typecheck
under the assumption that sB secret. The failure of typechecking corresponds
to Lowe's scenario. Then we consider a stronger variant, for which we can
establish the secrecy of sA and sB by typing.

19

6.2.1 Typing the Original Protocol (or Not)
We represent the original protocol with the processes:

P

\Delta = A j B

A

\Delta = A

B j AC1 j : : : j ACn

AX

\Delta = (*s

A)A

0

X

A

0

X

\Delta = c

X hfsA; kAgkX i

j cA(x):case x of fy1; y2gkA : if y1 = sA then cX hfy2gkX i

B

\Delta = (*s

B)B

0

B

0 \Delta = cB(x):case x of fy

1; y2gkB :

if y2 = kA then (cAhfy1; sBgkAi j cB(z1):case z1 of fz2gkB : 0)

The process P represents a complete system that consists of n + 1 instances of
A and one instance of B. One of the instances of A, called AB, starts a session
with B; the others, with other principals C1, : : : , Cn. In AX , we represent the
identity of A by the key kA. For simplicity, we write B so that it communicates
only with A, as this suffices in Lowe's scenario and for our present purposes.
We use channel cX for messages to principal X, but leave open the scope of cX
so that the adversary may also receive those messages.

Attempting to type these processes, we set cA; cB; cC1; : : : ; cCn : Public.
These types correspond to the assumption that the adversary can receive the
messages sent on cA; cB; cC1; : : : ; cCn. We set kC1; : : : ; kCn : Public. These
types mean that the adversary can decrypt using the keys kC1; : : : ; kCn, and
corresponds to the view of the third parties C1, : : : , Cn as part of the adversary. The keys kA and kB should be of types of the form KPublic[: : : ], since they
may be used for encryption by anyone. Finally, we may hope to have sA : Secret
in A and sB : Secret in B, since we may expect these nonces to be secret--and
may hope to apply Theorem 2. However, this typing attempt fails.

More precisely, we let:

E

\Delta = c

A : Public; cB : Public; cC1 : Public; : : : ; cCn : Public;

kC1 : Public; : : : ; kCn : Public;

kA : KPublic[: : : ]; kB : KPublic[: : : ];
sB : Secret

Then:

E 6` A j B

0

This failure appears when we try to type AC1 and B0. For B0, we need kA :
KPublic[Public; Secret]. Therefore, we may have y2 : Secret in AC1, but then the
message cC1hfy2gkC

1 i is not well-typed, since kC1 : Public. The test y1 = sAin A

C1 cannot eliminate this conflict, because y1 : Public (by the type of kA)

and also sA : Public (because AC1 sends sA under kC1 ). In summary, as Lowe's

scenario demonstrates, y2 should (sometimes) be treated as a secret in AC1, yet
y2 is given to C1, which is part of the adversary.

20

6.2.2 Typing a Stronger Variant
A stronger variant of the Needham-Schroeder protocol does not suffer from this
typing failure. In our calculus, this variant is:

P

\Delta = A j B

A

\Delta = A

B j AC1 j : : : j ACn

AX

\Delta = (*s

A)A

0X

A

0

X

\Delta = c

X hfsA; kAgkX i

j cA(x):case x of fy1; y2; y3gkA :

if y3 = kX then if y1 = sA then cX hfy2gy3i

B

\Delta = (*s

B)B

0

B

0 \Delta = cB(x):case x of fy

1; y2gkB :

if y2 = kA then (cAhfy1; sB; kBgkAi

j cB(z1):case z1 of fz2gkB : 0)

Much as Lowe suggested, B's second message contains kB, identifying the origin
of the message. We can type this variant establishing that it preserves the
secrecy of the nonces sA and sB.

We consider sB first. We let:

E

\Delta = c

A : Public; cB : Public; cC1 : Public; : : : ; cCn : Public;

kC1 : Public; : : : ; kCn : Public;
kA : KPublic[Public; Secret; KPublic[Secret]];
kB : KPublic[Secret];
sB : Secret

and obtain:

E ` A j B

0

from E; sA : Public ` A0X and E; sB : Secret ` B0, which in turn we prove as
follows:

ffl For E; sA : Public ` A0X , we first obtain E; sA : Public ` cXhfsA; kAgkX i

by (Encrypt Public). In addition, we apply (Decrypt KPublic) to the decryption of fy1; y2; y3gkA, and two cases arise:

(1) y1 : Public; y2 : Public; y3 : Public: The encryption fy2gy3 is typed by

(Encrypt Public).

(2) y1 :Public; y2 :Secret; y3:KPublic[Secret]: In AB, the encryption fy2gy3

is typed by (Encrypt KL). In AC1 , : : : , ACn, the test y3 = kX
eliminates this case, since there kX 's type is Public.

ffl In B0, we type the first decryption by (Decrypt KPublic), with y1 : Public

and y2 : Public. We type the encryption fy1; sB; kBgkA using (Encrypt
KL), and the decryption of fz2gkB using (Decrypt KPublic).

21

Having derived E ` A j B0, we apply Theorem 2, and conclude that A j B0
preserves the secrecy of sB from

(fcA; cB; cC1; : : : ; cCn; kC1; : : : ; kCng; fkA; kBg)
In order to establish the secrecy of sA, now, we let:

E

\Delta = c

A : Public; cB : Public; cC1 : Public; : : : ; cCn : Public;

kC1 : Public; : : : ; kCn : Public;
kA : KPublic[Secret; Public; KPublic[Secret; Public]];
kB : KPublic[Secret; Public];
sA : Secret

and obtain:

E ` A

0

B j B j AC1 j : : : j ACn

This typing is similar to that for sB; it uses sA : Public in AC1 , : : : , ACn and
sB : Public. We apply Theorem 2, and conclude that A0B j B j AC1 j : : : j ACn
preserves the secrecy of sA from

(fcA; cB; cC1; : : : ; cCn; kC1; : : : ; kCng; fkA; kBg)
While we find this example satisfying, it also suggests some possible improvements to the type system. First, the proofs of secrecy for sA and sB are clearly
separate, and they even rely on different types for kA and kB. This separation
may be unfortunate but inevitable within the type system; section 5.3 shows a
simpler example of this phenomenon. Furthermore, the type system allows the
use of the key kB for two messages of different sizes because all the components
of one of the messages are public, but it is not hard to imagine protocols where
more general rules for polymorphic and dynamic typing would be needed in
similar situations.

7 Conclusion
This paper presents a type system that can serve in establishing secrecy properties of processes. The type system is superficially straightforward: it consists
of fairly elementary rules in a standard format. The proof of its soundness
(the subject-reduction theorem) is also fairly standard; the subject-reduction
theorem then yields the main secrecy theorem. This simplicity is not entirely
accidental: we explored more complex type systems (with dependent types) and
notions of secrecy before arriving at the current ones.

On the other hand, the type system is powerful enough to apply to some
delicate security protocols, yielding concise proofs for subtle results. It is also
fairly tricky, when examined more closely. For instance, as indicated above, the
type rules allow certain forms of polymorphism.

22

M; N ::= terms

x; y; z variable
a; b; c; k; s name
fM1; : : : ; MngM encryption

P; Q ::= processes

M hM1; : : : ; Mni output
M (x1; : : : ; xn):P input
0 nil
P j Q parallel composition
!P replication
(*a)P restriction
case M of fx1; : : : ; xngN : P else Q decryption
if M = N then P else Q conditional

Figure 6: Syntax of the process calculus with symmetric communication primitives

A challenging subject for further work is to develop type systems with richer
forms of polymorphism, with stronger theories, perhaps even with algorithms
for inferring secrecy types. In another direction, it would be worthwhile to
give type rules for more cryptographic primitives, for example for digital signatures. Finally, it would be useful to integrate proofs by typing with other proof
methods.

Appendix
A Symmetric Communication
Type systems analogous to that of section 4 can be developed for processes that
rely on symmetric communication primitives. We sketch such a type system
for an extension of the pi calculus with shared-key cryptography, a basic spi
calculus. The syntax of the process calculus is given in Figure 6.

As indicated in the introduction, we do not need types such as CPublic[Secret]
and KPublic[Secret] in this type system. We simply assign the type Public to all
the data that the adversary may have. We can also do without subtyping, so
the judgment E `\Pi  M : S is no longer needed. The following grammar for types
suffices:

T ::= types

Public
CSecret[T1; : : : ; Tn]
KSecret[T1; : : : ; Tn]

23

The judgment E ` \Pi  is defined as in section 4.
Terms:

E ` \Pi  (u : T ) 2 E

E ` u : T (Atom)
E ` M : Public 8i 2 f1; : : : ; ng; E ` Mi : Public

E ` fM1; : : : ; MngM : Public (Encrypt Public)

E ` M : KSecret[T1; : : : ; Tn] 8i 2 f1; : : : ; ng; E ` Mi : Ti

E ` fM1; : : : ; MngM : Public

(Encrypt KSecret)

Processes:

E ` M : Public 8i 2 f1; : : : ; ng; E ` Mi : Public

E ` MhM1; : : : ; Mni (Output Public)
E ` M : CSecret[T1; : : : ; Tn] 8i 2 f1; : : : ; ng; E ` Mi : Ti

E ` MhM1; : : : ; Mni (Output C

Secret)

E ` M : Public E; x1 : Public; : : : ; xn : Public ` P

E ` M (x1; : : : ; xn):P (Input Public)

E ` M : CSecret[T1; : : : ; Tn] E; x1 : T1; : : : ; xn : Tn ` P

E ` M (x1; : : : ; xn):P (Input C

Secret)

E ` M : Public E ` N : Public
E; x1 : Public; : : : ; xn : Public ` P E ` Q

E ` case M of fx1; : : : ; xngN : P else Q (Decrypt Public)
E ` M : Public E ` N : KSecret[T1; : : : ; Tn]

E; x1 : T1; : : : ; xn : Tn ` P E ` Q

E ` case M of fx1; : : : ; xngN : P else Q (Decrypt K

Secret)

E ` M : T1 E ` N : T2 if T1 = T2 then E ` P E ` Q

E ` if M = N then P else Q (Cond)

Rules (Nil), (Parallel), (Replication), and (Restriction) are as in section 4.

Figure 7: Type rules in the symmetric case

24

Some type rules remain unchanged; others can be removed or simplified. The
rules (Output CL) and (Encrypt KL) are restricted to the case L = Secret,
since the types KPublic[: : : ] and CPublic[: : : ] no longer exist. The rules (Input
CPublic) and (Decrypt KPublic) are removed for the same reason. The other
rules for input and decryption have to be adapted since any term can be used to
represented an input channel or a decryption key, not just names. The rule for
conditionals, (Cond), is simpler because of the absence of subtyping. Figure 7
summarizes the resulting type system. It is an extension of the type system of
Cardelli, Ghelli, and Gordon [9, section 4] to shared-key cryptography, with the
notations Public instead of Un (untrusted) and CPublic[T1; : : : ; Tn] instead of
Ch[T1; : : : ; Tn].

B Proof of Subject Reduction
This section gives additional details on the proof of subject reduction.
Lemma 2 (Substitution) If E; E0 ` M : T and E; x : T; E0 ` M 0 : T 0 then
E; E0 ` M 0fM=xg : T 0. If E; E0 ` M : T and E; x : T; E0 ` P then E; E0 `
P fM=xg.

Proof The proof is by induction on the derivations of E; x : T; E0 ` M 0 : T 0
and of E; x : T; E ` P . The treatment of most rules is straightforward. In the
case of (Cond), we use that if E; E0 ` M : T and E; x : T; E0 `\Pi  M 0 : S then
E; E0 `\Pi  M 0fM=xg : S0 with S0 ` S. This property is obvious when M 0 6= x.
When M 0 = x, we have S = fT 0 j T 0 ^ T g, and we proceed by a case analysis
on the form of M .

ffl When M is an encryption, T = Public and S0 = fPublicg ` S.
ffl When M is a variable y, let T 0 be such that (y : T 0) 2 E; E0. We have

S0 = fT 00 j T 00 ^ T 0g and T 0 ^ T (since (y :T 0) 2 E; E0 and E; E0 ` M :T ).
Therefore, S0 ` S.

ffl When M is a name a, let T 0 be such that (a : T 0) 2 E; E0. We have

S0 = fT 0g with T 0 ^ T . Therefore, S0 ` S.

2

Lemma 3 (Subject congruence) If E ` P and P j Q then E ` Q.
Proof This proof is similar to the corresponding proof for the type system
of Cardelli, Ghelli, and Gordon [9]; it is an easy induction on the derivation of
P j Q. 2

Lemma 4 (Subject reduction) If E ` P and P ! Q then E ` Q.
Proof The proof is by induction on the derivation of P ! Q. We detail the
cases of three reduction rules; the remaining cases are easy.

25

ffl In the case of (Red I/O), we have

ahM1; : : : ; Mni j a(x1; : : : ; xn):P ! P fM1=x1; : : : ; Mn=xng
We assume E ` ahM1; : : : ; Mni j a(x1; : : : ; xn):P . This must have been
derived using the rule (Parallel). Therefore, we have E ` ahM1; : : : ; Mni
and E ` a(x1; : : : ; xn):P . We distinguish three cases, corresponding to
three possible derivations of E ` a(x1; : : : ; xn):P .

(1) If E ` a(x1; : : : ; xn):P has been derived using (Input CSecret), then

(a : CSecret[T1; : : : ; Tn]) 2 E and E; x1 : T1; : : : ; xn : Tn ` P . Therefore, E 6` a : Public, and E ` ahM1; : : : ; Mni has been derived using
(Output CL). The hypotheses of this rule include E ` Mi : Ti for all
i 2 f1; : : : ; ng.

(2) If E ` a(x1; : : : ; xn):P has been derived using (Input CPublic), then

(a : CPublic[T1; : : : ; Tm]) 2 E, E; x1 : Public; : : : ; xn : Public ` P , and,
if m = n, E; x1 : T1; : : : ; xn : Tn ` P . If E ` ahM1; : : : ; Mni has
been derived using (Output Public), we have E ` Mi : Public for
all i 2 f1; : : : ; ng. If E ` ahM1; : : : ; Mni has been derived using
(Output CL), we have m = n and E ` Mi : Ti for all i 2 f1; : : : ; ng.

(3) If E ` a(x1; : : : ; xn):P has been derived using (Input Public), then

(a : Public) 2 E and E; x1 : Public; : : : ; xn : Public ` P . Therefore,
E 6` a : CL[: : : ], and E ` ahM1; : : : ; Mni has been derived using
(Output Public). The hypotheses of this rule include E ` Mi : Public
for all i 2 f1; : : : ; ng.

In all cases, we obtain E ` P fM1=x1; : : : ; Mn=xng by Lemma 2.
ffl In the case of (Red Cond 1), we have if M = M then P else Q ! P .

We assume E ` if M = M then P else Q. This must have been derived
using (Cond) from E `\Pi  M : S1, E `\Pi  M : S2, E ` Q, and, if S1 " S2 6= ;,
E ` P . Since E `\Pi  M : S1 and E `\Pi  M : S2 imply that S1 = S2 6= ;, we
obtain E ` P .

ffl In the case of (Red Decrypt 1), we have

case fM1; : : : ; Mngk of fx1; : : : ; xngk : P else Q

! P fM1=x1; : : : ; Mn=xng

We assume E ` case fM1; : : : ; Mngk of fx1; : : : ; xngk : P else Q. We
distinguish three cases, corresponding to three possible derivations of this
judgment.

(1) If E ` case fM1; : : : ; Mngk of fx1; : : : ; xngk : P else Q has been

derived using (Decrypt KSecret), then (k : KSecret[T1; : : : ; Tn]) 2 E
and E; x1 : T1; : : : ; xn : Tn ` P . Therefore, E 6` k : Public, and
E ` fM1; : : : ; Mngk : Public has been derived using (Encrypt KL).
The hypotheses of this rule include E ` Mi : Ti for all i 2 f1; : : : ; ng.

26

(2) If E ` case fM1; : : : ; Mngk of fx1; : : : ; xngk : P else Q has been

derived using (Decrypt KPublic), then (k : KPublic[T1; : : : ; Tm]) 2 E,
E; x1 : Public; : : : ; xn : Public ` P , and, if m = n, E; x1 : T1; : : : ; xn :
Tn ` P . If E ` fM1; : : : ; Mngk : Public has been derived using
(Encrypt Public), we have E ` Mi : Public for all i 2 f1; : : : ; ng. If
E ` fM1; : : : ; Mngk : Public has been derived using (Encrypt KL),
we have m = n and E ` Mi : Ti for all i 2 f1; : : : ; ng.

(3) If E ` case fM1; : : : ; Mngk of fx1; : : : ; xngk : P else Q has been

derived using (Decrypt Public), then (k : Public) 2 E and E; x1 :
Public; : : : ; xn : Public ` P . Therefore, E 6` k : KL[: : : ], and E `
fM1; : : : ; Mngk:Public has been derived using (Encrypt Public). The
hypotheses of this rule include E ` Mi : Public for all i 2 f1; : : : ; ng.

In all cases, we obtain E ` P fM1=x1; : : : ; Mn=xng by Lemma 2.

2

References

[1] Mart'in Abadi. Secrecy by typing in security protocols. Journal of the ACM,

46(5):749-786, September 1999.

[2] Mart'in Abadi. Security protocols and their properties. In F.L. Bauer

and R. Steinbrueggen, editors, Foundations of Secure Computation, NATO
Science Series, pages 39-60. IOS Press, 2000. Volume for the 20th International Summer School on Foundations of Secure Computation, held in
Marktoberdorf, Germany (1999).

[3] Mart'in Abadi and Andrew D. Gordon. A calculus for cryptographic protocols: The spi calculus. Information and Computation, 148(1):1-70, January
1999. An extended version appeared as Digital Equipment Corporation
Systems Research Center report No. 149, January 1998.

[4] Mart'in Abadi and Roger Needham. Prudent engineering practice for cryptographic protocols. IEEE Transactions on Software Engineering, 22(1):6-
15, January 1996.

[5] Ross Anderson and Roger Needham. Robustness principles for public key

protocols. In Proceedings of Crypto '95, pages 236-247, 1995.

[6] Andrew Birrell, Greg Nelson, Susan Owicki, and Edward Wobber. Network

objects. Software Practice and Experience, S4(25):87-130, December 1995.

[7] Chiara Bodei. Security Issues in Process Calculi. PhD thesis, Universit`a

di Pisa, January 2000.

27

[8] Chiara Bodei, Pierpaolo Degano, Flemming Nielson, and Hanne Riis Nielson. Control flow analysis for the ss-calculus. In CONCUR'98: Concurrency
Theory, volume 1466 of Lecture Notes in Computer Science, pages 84-98.
Springer Verlag, September 1998.

[9] Luca Cardelli, Giorgio Ghelli, and Andrew D. Gordon. Secrecy and group

creation. In Catuscia Palamidessi, editor, CONCUR 2000: Concurrency
Theory, volume 1877 of Lecture Notes in Computer Science, pages 365-379.
Springer-Verlag, August 2000.

[10] Dorothy E. Denning. Cryptography and Data Security. Addison-Wesley,

Reading, Mass., 1982.

[11] C'edric Fournet and Georges Gonthier. The reflexive chemical abstract

machine and the join-calculus. In Proceedings of the 23rd ACM Symposium
on Principles of Programming Languages, pages 372-385, January 1996.

[12] Shafi Goldwasser and Silvio Micali. Probabilistic encryption. Journal of

Computer and System Sciences, 28:270-299, April 1984.

[13] Nevin Heintze and Jon G. Riecke. The SLam calculus: programming with

secrecy and integrity. In Proceedings of the 25th ACM Symposium on Principles of Programming Languages, pages 365-377, 1998.

[14] Matthew Hennessy and James Riely. Information flow vs. resource access

in the asynchronous pi-calculus. In Proceedings of the 27th International
Colloquium on Automata, Languages and Programming, Lecture Notes in
Computer Science, pages 415-427. Springer-Verlag, 2000.

[15] Kohei Honda, Vasco Vasconcelos, and Nobuko Yoshida. Secure information flow as typed process behaviour. In Gert Smolka, editor, Programming
Languages and Systems: Proceedings of the 9th European Symposium on
Programming (ESOP 2000), Held as Part of the Joint European Conferences on Theory and Practice of Software (ETAPS 2000), volume 1782 of
Lecture Notes in Computer Science, pages 180-199. Springer-Verlag, 2000.

[16] K. Rustan M. Leino and Rajeev Joshi. A semantic approach to secure information flow. In Mathematics of Program Construction, 4th International
Conference, volume 1422 of Lecture Notes in Computer Science, pages 254-
271. Springer Verlag, 1998.

[17] Gavin Lowe. Breaking and fixing the Needham-Schroeder public-key protocol using FDR. In Tools and Algorithms for the Construction and Analysis
of Systems, volume 1055 of Lecture Notes in Computer Science, pages 147-
166. Springer Verlag, 1996.

[18] Alfred J. Menezes, Paul C. van Oorschot, and Scott A. Vanstone. Handbook

of Applied Cryptography. CRC Press, 1996.

28

[19] Massimo Merro and Davide Sangiorgi. On asynchrony in name-passing

calculi. In Proceedings of the 25th International Colloquium on Automata,
Languages and Programming, volume 1443 of Lecture Notes in Computer
Science, pages 856-867. Springer-Verlag, 1998.

[20] Jon Millen and Harald Ruess. Protocol-independent secrecy. In Proceedings

2000 IEEE Symposium on Security and Privacy, pages 110-119, May 2000.

[21] Robin Milner, Joachim Parrow, and David Walker. A calculus of mobile

processes, parts I and II. Information and Computation, 100:1-40 and
41-77, September 1992.

[22] Andrew C. Myers. JFlow: Practical mostly-static information flow control.

In Proceedings of the 26th ACM Symposium on Principles of Programming
Languages, pages 228-241, January 1999.

[23] Andrew C. Myers and Barbara Liskov. A decentralized model for information flow control. In Proceedings of the 16th ACM Symposium on Operating
System Principles, pages 129-142, 1997.

[24] Roger M. Needham and Michael D. Schroeder. Using encryption for authentication in large networks of computers. Communications of the ACM,
21(12):993-999, December 1978.

[25] L. C. Paulson. The inductive approach to verifying cryptographic protocols.

Journal of Computer Security, 6(1-2):85-128, 1998.

[26] Fran,cois Pottier and Sylvain Conchon. Information flow inference for free.

In Proceedings of the 2000 ACM SIGPLAN International Conference on
Functional Programming (ICFP'00), pages 46-57, September 2000.

[27] James Riely and Matthew Hennessy. Trust and partial typing in open

systems of mobile agents. In Proceedings of the 26th ACM Symposium on
Principles of Programming Languages, pages 93-104, January 1999.

[28] Dennis Volpano, Cynthia Irvine, and Geoffrey Smith. A sound type system

for secure flow analysis. Journal of Computer Security, 4:167-187, 1996.

29