

An Automatic Verifier for Java-like Programs

Based on Dynamic Frames

Jan Smans1, Bart Jacobs1, Frank Piessens1, and Wolfram Schulte2

1 Katholieke Universiteit Leuven, Belgium{

jans,bartj,frank}@cs.kuleuven.be
2 Microsoft Research Redmond, USA

schulte@microsoft.com

Abstract. Data abstraction is crucial in the construction of modular
programs, since it ensures that internal changes in one module do not
propagate to other modules. In object-oriented programs, classes typically enforce data abstraction by providing access to their internal state
only through methods. By using method calls in method contracts, data
abstraction can be extended to specifications. In this paper, methods
used for this purpose must be side-effect free, and are called pure methods.
We present an approach to the automatic verification of object-oriented
programs that use pure methods for data abstraction. The cornerstone
of our approach is the solution to the framing problem, i.e. client code
must be able to determine whether state changes affect the return values
of pure methods. More specifically, we extend each method contract with
a method footprint, an upper bound on the memory locations read or
written by the corresponding method. Footprints are specified using dynamic frames, special pure methods that return sets of memory locations.
Thanks to this abstraction, implementations can evolve independently
from specifications, loosely coupled only by pure functions.
We implemented this approach in a custom build of the Spec# program
verifier, and used it to automatically verify several challenging programs,
including the iterator and observer patterns. The verifier itself and the
examples shown in this paper can be downloaded from the authors' homepage [1].

1 Introduction
The principle of data abstraction is a central concept in object-oriented program-ming. That is, a class typically hides its implementation details from clients, and
instead offers methods to access its internal state. Adherence to the principle ofdata abstraction ensures that client code remains independent of the implementation of classes it is using, and as a consequence that changing the implementa-tion of a class (within the boundaries described by its contract) does not affect
clients. For example, consider the class Cell shown in Figure 1. Each Cell objectholds an integer value which is stored in the private field

x. Client code can onlyaccess
x through the getter getX and the setter setX . Since clients only depend

on the getter and setter, changing Cell 's internal representation does not affectthem. In particular, changing the implementation will not affect the correctness
of the client program of Figure 1(b).

To preserve data abstraction within specifications, specifications must bewritten in an implementation-independent manner. In particular, specifications

should not expose the private fields of a class. One way to achieve this indepen-dence is to use method calls within specifications. In this paper, methods used
for this purpose must be side-effect free, and are called pure methods. Non-puremethods are called mutators. For example, the behavior of the mutator setX
is specified by describing its effect on the pure method getX . The specificationof Cell never mentions the field

x. Using pure methods within specifications

class Cell {

private int x;

Cell()

writes ;;
ensures getX () = 0;
ensures footprint().isFresh();{ }

pure int getX ()

reads footprint();{
return x; }

void setX (int value)

writes footprint();
ensures getX () = value;
ensures footprint().newElemsFresh();{
x := value; }

pure set footprint()

reads footprint();{
return { &x }; }}

(a)

Cell c1 := new Cell();
c1.setX (5);

Cell c2 := new Cell();
c2.setX (10);

assert c1.getX () = 5;

(b)

Fig. 1. A class Cell and a client program.
gives rise to a framing problem [2, Challenge 3], i.e. client code must be ableto determine the effect of heap changes on the return values of pure methods.
For instance, to show that c1.getX () equals 5 at the end of the code snippet inFigure 1(b), we must be able to deduce that creating and modifying

c2 does notaffect the state of
c1. This deduction should not rely on Cell's implementation,since doing so would break information hiding.

Recently, Kassios [3, 4] proposed a promising solution to the framing problem.More specifically, he proposes using dynamic frames, specification variables (similar to pure methods) that return sets of memory locations, to specify the effect ofmutators and the dependencies of specification variables in an abstract manner.
However, his solution is formulated in the context of an idealized, higher-orderlogical framework. For example, it does not show how to apply the approach to
Java-like inheritance. Furthermore, the proposed approach is not applied in thecontext of an automatic program verifier for first-order logic.

In this paper, we propose an approach to the automatic verification of anno-tated Java-like object-oriented programs that combines pure methods to achieve
data abstraction with Kassios' solution to the framing problem. More specifically,to solve the framing problem, we extend each method contract with a method
footprint which specifies an upper bound on the memory locations read or writ-ten by the corresponding method. A memory location is an (object identifier,
field name) pair. The footprint of a pure method (reads annotation) specifiesan upper bound on the memory locations the pure method depends on, while a
mutator's footprint (writes annotation) specifies an upper bound on the loca-tions writable by the method. To prove that a heap change (i.e. a field update
or mutator invocation) does not affect the return value of a pure method, onesimply has to show that the footprint of the state change is disjoint from the
pure method's footprint.

In our running example, the method footprint of both getX and setX isthe singleton containing the receiver's field

x. However, saying so explicitly inthe method contract would expose the field

x to clients and break informationhiding. To specify method footprints in an implementation-independent manner,

we allow developers to define dynamic frames, special pure methods that returna set of memory locations. These dynamic frames can then be used to abstractly
specify method footprints. The method footprint is an example of a dynamicframe, and it is used to specify the footprint of all of Cell 's methods.

Given Cell 's specification, we can now prove the assertion at the end of thecode snippet in Figure 1(b). Informally, the reasoning goes as follows. The specification of Cell guarantees that the constructor only writes to locations that wereunallocated in the method pre-state, and that the new object's footprint contains
only such locations. Since footprints of existing objects contain only allocatedlocations, the assignment

c1 := new Cell(); creates a new object whose foot-print is disjoint from any existing object's footprint. setX 's postcondition ensures

that c1.getX () equals 5 after the call statement c1.setX (5);. Furthermore, themutator's specification ensures that it only modifies unallocated locations and
locations in receiver's pre-state footprint, and that it only adds newly allocatedobjects to that footprint. The next assignment

c2 := new Cell (); creates a newfootprint for
c2 disjoint from any other footprint. Because of this disjointness,the following statement

c2.setX (10); affects neither c1.getX () nor c1.footprint().It follows that the assertion

c1.getX () equals 5 still holds despite the interveningcreation of and update to
c2.

In summary, the contributions of this paper are the following:

- We propose an approach to the automatic verification of Java-like object-oriented programs that combines the use of pure methods for data abstraction with Kassios' approach to solve the framing problem. In particular, weshow how Kassios' solution applies to Java-like inheritance [3, Future Work].
- We implemented our approach in a tool [1], and used it to automaticallyverify challenging examples, such as the iterator and observer patterns.

The remainder of this paper is structured as follows. In Section 2, we explainhow programs such as the one shown in Figure 1 can be verified automatically.
In Section 3, we demonstrate the expressive power of our approach by showinghow it verifies various object-oriented programming and specification patterns.
Section 4 extends the solution of Section 2 with support for inheritance. Finally,we discuss our experience with the verifier prototype, compare with related work
and conclude in Sections 5, 6 and 7.

2 Solution
SJava In this paper we restrict our attention to a small Java-like language, called
SJava. SJava does not include features such as exceptions and multi-threading.However,

SJava extends regular Java in three ways:(1)
SJava introduces a new primitive type set. An expression of type set rep-resents a set of memory locations. A memory location is an (object reference, field

name) pair, and the location corresponding to e.f is denoted by &e.f. The stan-dard mathematical set operations such as [, ", and 2 can applied to expressions
of type set. In addition, postconditions can apply isFresh and newElemsFreshto expressions of type set:

s.isFresh() is a two-state predicate expressing that scontains only fresh locations (i.e. locations corresponding to objects that were

not allocated in the method pre-state), and s.newElemsFresh() is a two-statepredicate denoting that only fresh locations are added to

s. universe denotes theset of all locations. elems(
a) denotes the locations corresponding to the elementsof the array
a.(2) A method in an

SJava program can be marked with a pure annotation,indicating that it can be used in specifications. The body of a pure method

consists of a single return statement returning a side-effect free expression. Anexpression is side-effect free if it does not contain object or array creations,
simple or compound assignments, increment or decrement operators, and onlycalls pure methods. Non-pure methods are called mutators. Pure methods with
return type set are called dynamic frames.(3) Each method has a corresponding method contract, consisting of preconditions, a method footprint and postconditions. Preconditions and postcon-ditions are boolean side-effect free expressions. The former define valid method
pre-states, while the latter define valid method post-states. A method footprintis a side-effect free expression of type

set. The footprint of a pure method (readsannotation) specifies the locations that can potentially be be read by the method,

while a mutator's footprint (writes annotation) specifies the locations that canbe modified by the method. More specifically, a mutator can only modify

o.f

if &o.f is in the method's footprint or if o was unallocated at the start of themethod. Pure methods have no need for writes clauses, since by definition they
are not allowed to modify any location. Mutators have no need for reads clauses,and can read any location. Indeed, the effect of heap changes on the return values of mutators is not relevant in our approach (no axiom is generated to framethe return value of mutators) as only pure methods can be used in specifications. Only parameters and the variable this may occur free in preconditionsand footprints. Postconditions can additionally mention the variable

result, de-noting the return value of the method. Furthermore, postconditions may contain

old expressions old(e), denoting the value of the expression e in the method'spre-state.

In this section, we consider only SJava without inheritance. Section 4 explainshow inheritance can be supported.

Verification Our verifier takes an SJava program as input and generates, via atranslation into an intermediate verification language, a set of verification conditions. The verification conditions are first-order logical formulas whose validityimplies the correctness of the program. The formulas are analyzed automatically
by satisfiability-modulo-theory (SMT) solvers. Our approach is based on a gen-eral approach described in [5]. In this subsection, we focus on novel aspects of
our approach: namely the way pure methods and their contracts are modeled inthe verification logic and the way method footprints are enforced.

Notation Heaps are modeled in the verification logic as maps from object refer-ences and field names to values. For example, the expression

h[o, f ] denotes thevalue of the field
f of object o in heap h. The function wf returns whether a givenheap is well-formed, i.e. whether the fields of allocated objects point to allocated

objects. $Heap denotes the current value of the global heap. Allocatedness ofobjects is tracked by means of a special boolean field named $allocated .J

EKh1,h2,r denotes the translation of the side-effect free expression E to first-order logic, where

h1 denotes the heap, h2 denotes the pre-state heap (used inthe translation of old expressions), and

r denotes the term to be substituted forthe variable result. We will omit the second and third parameter for single-state

predicates.
Pure Methods We treat pure methods as follows. For every pure method

pure t m(t1 x1, . . . , tn xn)

requires P ; reads R; ensures Q;{ return

E; }

defined in a class C, a function symbol #C.m is introduced in the verificationlogic that takes a heap, the receiver and the method parameters as its formal

parameters. To define the function symbol's meaning, three kinds of axiomsare generated: an implementation axiom, a framing axiom, and a postcondition
axiom.

(1) The implementation axiom declares that the result of the function #C.mis equal to evaluating the method body.

8heap, o, x1, . . . , xn * wf (heap) ^ heap[o, $allocated] ^ JP Kheap )#

C.m(heap, o, x1, . . . , xn) = JEKheap

The implementation axiom can only be used within the module where C isdefined.

(2) The framing axiom states that the function #C.m only depends on lo-cations in

m's footprint R. More specifically, a state change does not affect thereturn value of

m if m's precondition holds in the pre and post-state and iflocations in
m's footprint have equal values.

8heap1, heap2, o, x1, . . . , xn * wf (heap1) ^ wf (heap2)^heap

1[o, $allocated] ^ heap2[o, $allocated] ^ JP Kheap1 ^ JP Kheap2^(8q, f * (q, f) 2 JRK

heap1 ) heap1[q, f ] = heap2[q, f ]) )#
C.m(heap1, o, x1, . . . , xn) = #C.m(heap2, o, x1, . . . , xn)

The framing axiom can only be used by modules that use the module where Cis defined.

(3) The postcondition axiom axiomatizes the pure method's postcondition.

8heap, o, x1, . . . , xn * wf (heap) ^ heap[o, $allocated] ^ JP Kheap )J

QKheap,heap,#C.m(heap,o,x1,...,xn)

m's postcondition axiom can only be used by modules that use the modulewhere

C is defined. For each dynamic frame, a default postcondition axiomis added stating that the dynamic frame only contains allocated objects. This

axiom holds because of the well-formedness of the heap which implies that onlyallocated objects are reachable from allocated objects.

Our verifier prototype determines automatically which modules are beingused within a certain method implementation by looking at the declared type of
fields, parameters and local variables. A module is never considered to use itself.
Footprints Method footprints are enforced differently for mutators and for puremethods. For a pure method

m with footprint R, we check that every location(directly or indirectly) read by the method body is an element of

R. More specif-ically, we check at each field access and method invocation within the body that

the set of objects read by the subexpression is a subset of R. For a field access
o.f, the set of read locations equals the singleton {(o, f )}. To determine the setof locations read by a callee, we rely on the callee's reads annotation.

The footprint W of a mutator m is checked by means of an additional post-condition: for each location (

o, f), either m does not affect the value of the (o, f),or
o was not allocated in the method pre-state, or the location was an elementof
W . 8o, f * old($Heap[o, f ]) = $Heap[o, f].

~old($Heap[o, $allocated ]).(

o, f) 2 JW Kold($Heap)

This postcondition is used to enforce the footprint and to verify client code.

Soundness The soundness of our approach rests on two pillars: (I) the con-sistency of the verification logic and (II) the property that the value of a pure
method is preserved by a state change, provided the footprint of the state changeis disjoint from the pure method's footprint.

To satisfy the former component, we must ensure that the axioms gener-ated based on user-defined pure methods are consistent. One way to enforce this
consistency is to impose two restrictions: the module usage relation is acyclicand pure methods only call pure methods in used modules. Enforcing these
restrictions guarantees termination of pure methods, which ensures (1) that im-plementation axioms are consistent, (2) that postconditions and reads clauses
have to be proven (as there is always a path leading to the post-state), and (3)that the proof of a postcondition/framing axiom cannot rely on itself.

To show (II) we argue informally as follows. The postcondition of a muta-tor ensures that the method cannot modify allocated locations outside of its
footprint. Similarly, by checking that every subexpression of the body of a puremethod reads a subset of the method's footprint, we know that the value of a
pure method depends only on locations within its footprint. Suppose the muta-tor

m writes X, that the pure method p reads Y , and that X and Y are disjoint.Since method footprints can only contain allocated locations,

m cannot modifylocations within
Y , since doing so would violate its writes clause. Hence, thevalue of
p is preserved. Note that p is preserved, even if X and Y are no longerdisjoint in

m's post-state, since m can only write to the pre-state footprint X.

3 Invariants, Aggregates and Peers
In this section, we demonstrate how various object-oriented programming andspecification patterns can be handled using our approach. More specifically, we
focus on object invariants, aggregate objects and peer objects. It is importantto note that supporting these patterns does not require any additional methodological machinery. All the examples shown in this paper have been verified au-tomatically using our verifier prototype. Both the prototype and the examples
can be downloaded from the authors' homepage [1].

Object Invariants An object invariant describes what it means for an objectto be in a consistent state. For example, consider class ArrayList in Figure 2.
An ArrayList object o is consistent if o.items points to a non-null array, and if
o.count is a valid index in the array.Some other approaches such as [6, 7] treat object invariants differently from

regular predicates, thereby introducing additional complexity. In our approachan object invariant is just another pure, boolean method. For instance, in class
ArrayList the method invariant specifies the object invariant. To assume/assertthe object invariant, it suffices to assume/assert that the invariant method returns true.Some readers may have noticed the peculiar, conditional form of invariant's
footprint. If o.invariant() returns true, then it is framed by o.footprint(); otherwise, o.invariant() may depend on any location (universe denotes the set ofall locations). It suffices to frame

o.invariant() only when it returns true, sinceclient code that relies on the reads clause typically only "sees" valid ArrayList

objects. Instead of using a conditional reads clause, one could frame invariantby footprint(). However, one would also have to remove footprint's precondition,
and modify footprint 's body to take into account invalid object states, therebyessentially duplicating the part of the invariant.

Aggregate Objects Many objects internally use other objects to help repre-sent their internal state. Such objects are sometimes called aggregate objects.
Typically, the consistency of an aggregate object implies the consistency of allits helper objects, and an aggregate object's footprint includes the footprint
of all its helper objects. Consider the class Stack shown in Figure 2. A Stackobject internally uses an ArrayList object to represent its internal state, and
can therefore be considered an aggregate object. A stack's footprint includes itsarraylist's footprint, and a Stack object's invariant implies the invariant of the
internal ArrayList object.

Our approach does not impose any (built-in) aliasing restrictions. In particu-lar, it does not forbid an aggregate object from leaking references to its internal

helper objects. For example, a Stack is allowed to pass a reference to its inter-nal ArrayList to client code. However, in that case client code will not be able
to establish disjointness between the aggregate object's footprint and the helperobject's footprint. As a consequence, updating the helper object causes the client
to lose all information (given by the return values of its pure methods) aboutthe aggregate object, and as a result clients cannot falsely assume that the state
of the aggregate object is preserved when one of the helper objects is modified.The return value of pure methods can change over time. In particular, locations can be added to or removed from an object's footprint. For example, themethod Switch (in class Stack ) shown below exchanges the internal ArrayList of
the receiver and the parameter other . Again, our approach does not impose spe-cial methodological rules to ensure this "ownership transfer" takes place safely.

void Switch(Stack other)

requires other 6= null ^ other.invariant();
requires invariant() ^ footprint() " other.footprint() = ;;
writes footprint() [ other.footprint();
ensures invariant() ^ other.invariant();
ensures size() = old(other.size()) ^ other.size() = old(size());
ensures footprint() " other.footprint() = ;;
ensures (footprint() [ other.footprint()).newElemsFresh();{
ArrayList tmp = contents; contents = other.contents; other.contents = tmp; }

Peer Objects The examples considered so far can be verified using traditionalownership-based solutions, since the object graph has an hierarchical, tree-like
structure. However, many object-oriented programming patterns, including the

class ArrayList {

int count;
Object[] items;

ArrayList()

writes ;;
ensures invariant() ^ size() = 0;
ensures footprint().isFresh();{
items := new Object[10]; }

void add(Object o);

requires invariant();
writes footprint();
ensures invariant();
ensures size() = old(size() + 1);
ensures get(size() - 1) = o;
ensures 8i 2 (0 : size() - 1) * get(i) = old(get(i));
ensures footprint().newElemsfresh();{
. . . }

pure Object get(int i);

requires invariant() ^ 0 <= i < size();
reads footprint();{
return items[i]; }

pure int size();

requires invariant();
reads footprint();
ensures 0 <= result;{
return count; }

pure bool invariant()

reads invariant()?footprint() : universe;{
return items 6= null ^ 0 <= count <= items.length; }

pure set footprint()

requires invariant();
reads footprint();{
return {&count, &items} [ elems(items); }}

class Stack {

ArrayList contents;

Stack()

writes ;;
ensures invariant() ^ size() = 0;
ensures footprint().isFresh();{
contents := new ArrayList(); }

void Push(Object o)

requires invariant();
writes footprint();
ensures invariant();
ensures size() = old(size()) + 1;
ensures footprint().newElemsFresh();{
contents.add(o); }

pure int size()

requires invariant();
reads footprint();{
return contents.size(); }

pure bool invariant()

reads invariant()?footprint() : universe;{

return contents 6= null^

contents.invariant()^
&contents 62 contents.footprint();}

pure set footprint()

requires invariant();
reads footprint();{
return {&contents} [ contents.footprint(); }}

Fig. 2. A class ArrayList and a class Stack. Stack objects internally use ArrayList
objects.

observer and iterator pattern, do not follow this structure. For example, con-sider class iterator in Figure 3. No single iterator uniquely "owns" the list, and
similarly the list does not own its iterators.Modifying a list while iterators are iterating over it can give rise to unexpected exceptions. For example, removing elements from a list can cause anArrayOutOfBoundsException in a corresponding iterator's next method. However, since the reads clause of an iterator's invariant includes the footprint ofthe corresponding list, any modification to the list immediately invalidates its
corresponding iterators, making it impossible to use an iterator which is "out ofsync" with its list.

class Iterator {

ArrayList list;
int index ;

Iterator(ArrayList l)

requires l 6= null ^ l.invariant();
writes ;;
ensures invariant();
ensures list() = l;
ensures footprint().isFresh();{
list := l; }

Object next()

requires invariant() ^ hasNext();
writes footprint();
ensures invariant() ^ list() = old(list());
ensures footprint().newElemsFresh();{
return list.items[index + +]; }

pure bool hasNext()

requires invariant();
reads footprint() [ list().footprint();{
return index < list.count; }

pure ArrayList list()

requires invariant();
reads footprint();{
return list; }

pure bool invariant()

reads invariant()?

(footprint() [ list().footprint()) : universe;{
return list 6= null ^ list.invariant()^

0 <= index <= list.count^
&list 62 list.footprint()^
&index 62 list.footprint(); }

pure set footprint()

requires invariant();
reads footprint();{
return {&list, &index }; } }

Fig. 3. The iterator pattern.
4 Inheritance
Adding inheritance to SJava complicates the handling of pure methods, sinceinheritance allows binding method calls statically and dynamically, depending
on the method itself and on the calling context. More specifically, an abstractmethod is always dynamically bound, while a private or final method is always

statically bound. Non-abstract, non-private methods can either be statically ordynamically bound: a super call to such a method is statically bound, but any
other call is dynamically bound.To model the fact that a call to a pure method

m in a class C can be bothstatically and dynamically bound, we introduce two function symbols for every

pure method in the verification logic (instead of only one): #C.m and #C.mD(similar to [7, 8]). The former function symbol represents statically bound calls
to m, and is axiomatized as described in Section 2. The latter function symbolrepresents dynamically bound calls is axiomatized by relating it to the former
symbol using the following axiom.

8heap, o, x1, . . . , xn * typeof (o) = C )#

C.mD(heap, o, x1, . . . , xn) = #C.m(heap, o, x1, . . . , xn)

That is, given that the dynamic type of some object o (denoted by typeof (o)) is
C, one may assume that dynamically bound calls to the object equal staticallybound calls to

C's method m. In addition, whenever a method D.m overrides amethod
A.m, the following axiom is added: two dynamically bound calls of myield the same result whenever the receiver's dynamic type is a subtype (denoted

by <:) of D.

8heap, o, x1, . . . , xn * typeof (o) <: D )#

A.mD(heap, o, x1, . . . , xn) = #D.mD(heap, o, x1, . . . , xn)

Calls on the receiver object in method contracts are treated differently from suchcalls in code. If a method call is dynamically bound, then calls on the receiver

object in the method contract are treated as dynamically bound; otherwise callsin the contract on the receiver are treated as statically bound. Methods themselves are verified assuming they are called statically, i.e. calls in the contracton the receiver are bound statically. Doing so is sound, provided every subclass
overrides each method. Indeed, if a method is called statically, then the callerand callee agree on the method contract. If a method is called dynamically, then
the dynamic type of the receiver equals the static type, and therefore the staticcontract equals the dynamic one.

To ensure Liskov's substitution principle, we impose the restriction that over-riding methods must inherit the contract of overridden methods as is. The only
exception to this rule are postconditions. More specifically, an overriding methodmay extend the contract of the overridden method with additional postconditions. More flexible approaches to ensure proper subtyping exist (e.g. [9]), andcombining them with our approach is part of future work.

5 Discussion
Defaults The examples shown in this paper contain on about 2 lines of spec-ification for every line of code, where we consider the invariant and footprint
methods to be part of the specification. To reduce this annotation overhead,

we propose using defaults for common programming and specification patterns.More specifically, we propose generating footprint and invariant methods based
on field modifiers, and adding default contracts to methods. Using these defaultsreduces the number of annotation in class Stack of Figure 2 from 17 to 3.

The scheme is as follows. The footprint and invariant methods in a class Care generated based on

C's fields. That is, the footprint method includes loca-tions corresponding to
C's fields. Moreover, fields may be marked with a repmodifier. The footprint of an object referenced from one of

C's rep fields is alsoincluded in the footprint. Finally,
C's footprint method includes the footprintof the superclass.
C's invariant method states that rep fields are non-null, thatthe footprints of rep objects and of the superclass do not contain locations corresponding to fields of C, and that those footprints are mutually disjoint. Thefootprint method requires the invariant and reads itself. The invariant method
reads the footprint, provided it returns true.Each method is given a default method contract. Pure methods require the
invariant and read the footprint. Constructors write the new object's footprint,ensure the invariant, and ensure that the footprint contains only fresh locations.
Other mutators require and ensure the invariant, write the pre-state footprint,and ensure that the footprint is only extended with fresh locations.

Experience Table 1 lists the time taken to discharge the verification conditionsgenerated for each program. The experiments have been carried out on a regular
desktop pc with a Pentium 4 3.00 Ghz CPU and 512 Mb of RAM.The verifier prototype is a custom build of the Spec# program verifier [10],
and uses 2 theorem provers: Z3 and Simplify. The latter prover is only used if theformer fails to verify a verification condition. Z3 is typically faster than Simplify,
but is sometimes unable to prove the constructor's postcondition stating thatelements in the new object's footprint are fresh.

cell fraction list, stack & iterator observer masterclock
# lines 20 52 138 85 74
time taken 0.6 1.6 25.2 15.1 11.4

Table 1. Table showing the time taken (in seconds) to verify the examples. Examples
not shown in this paper can be downloaded from [1].

6 Related Work
The approach presented in this paper was inspired by the work of Kassios [3, 4].Kassios uses specification variables, similar to our pure methods, to achieve data
abstraction. To solve the framing problem, he proposes using dynamic framesto abstractly specify the footprint of specification variables and the effect of

mutator methods. Dynamic frames are specification variables that hold sets ofmemory locations. However, Kassios' solution is presented in the context of an
idealized, higher-order logical framework. We show how Kassios' ideas can beincorporated in a program verifier for a Java-like language based on first-order
logic, and demonstrate that many interesting examples can be verified automat-ically. Moreover, we extend his solution to deal with Java-like inheritance.

In the basic Boogie methodology [6], data abstraction is limited to objectinvariants. More specifically, each object has a ghost field inv , and the methodology ensures that the invariant of an object o holds whenever o.inv is true. Toensure the soundness of the approach, the Boogie methodology imposes several
restrictions: inv can only be updated using special operations called pack and
unpack, updating a field o.f requires o.inv to be false, and finally the invariantitself can only mention fields within the object's ownership cone. The dynamic

frames approach can be considered to be conceptually simpler than the Boogiemethodology (and its extensions), since it does not impose any methodological
restrictions.

In [11] and [12], the authors extend the basic Boogie methodology to dealwith non-hierarchical object structures. In particular, they allow invariants to

mention fields outside of the object's ownership cone provided certain visibilityrequirements are met. More specifically, if the invariant of class

C mentions afield
f of a non-owned object, then C must be visible in the the class declaring
f. No such restriction is present in our approach.

[7, 13] and [14] both extend the basic Boogie methodology with support fordata abstraction using pure methods. Similarly to our approach, they model pure

methods as functions in the verification logic. Both approaches essentially solvethe framing problem by encoding in the verification logic that these functions
depend only on a number of ownership cones instead of on the entire heap.To ensure the consistency of the verification logic (regardless of the addition of
axioms generated based on pure methods), [7] and [14] enforce the terminationof pure methods. The former approach does so by checking the acyclicity of the
call-graph at load-time. The latter approach relies on a heuristic for finding awell-founded order. One of the major differences between their approach and
ours is that we allow pure methods to depend on any location, as long as thelocation is an element of the method's footprint (which can be any expression of
type set), and it is up to client code to track disjointness of method footprints,while they only allow pure methods to depend on objects in a limited number
of ownership cones (indicated by means of rep modifiers on fields).

Leino and M"uller [15] extend the basic Boogie methodology with model fieldsto achieve data abstraction. A model field declaration consists of a type, a name,

and a constraint. A model field cannot be assigned to within the program text;instead the model field is assigned a random value satisfying the constraint
whenever the object is being packed. To prevent unsound reasoning arising fromunsatisfiable constraints, Leino and M"uller require the theorem prover to come
up with a witness before assuming the constraint holds. However, experienceshows that theorem provers (in particular Simplify) are unable to find witnesses

even in simple cases, and as such it is unlikely that their approach is suitable foruse within an automatic program verifier.

Parkinson and Bierman [16, 17] extend separation logic to the Java program-ming language, introducing abstract predicates to attain data abstraction. Their
solution has not been implemented in an automatic program verifier, and the fea-sibility of automatic verification has not been shown. Furthermore, Parkinson's
abstract predicates are not part of the programming language itself, while puremethods are. This might make it easier for programmers to use pure methods.

In [18], the authors propose using data groups to specify side-effects. A datagroup represents a set of variables (similarly to our footprint methods), and
mutator methods can abstractly specify their footprint using a modifies clausein terms of these data groups (similarly to our writes clauses which use footprint methods). However, to ensure the soundness, their approach imposes twomethodological restrictions: the pivot uniqueness and owner exclusion restriction. Our approach requires no such restrictions, and as a consequence it canhandle programs that [18] cannot. For example, the former restriction rules out
sharing of representation objects, as is the case in the iterator example shownin Figure 3.

Banerjee, Naumann and Rosenberg [19] propose using regions, state-dependentexpressions similar to our method footprints, to specify the effect of mutators.
They develop a Hoare-style calculus and proof its soundness. However, the logicis not implemented and, in effect, there are some challenges to do so when one
would target SMT solvers, e.g. they use ghost state and "recursion" to expressreachability, and they use frame subsumption, which should only be applied on
demand.

M"uller [8]'s thesis combines model fields with an ownership type system calledUniverses. Model fields are similar to pure methods that have no parameters.

Model fields may depend on the fields of owned objects and the fields of peerobjects, i.e. objects with the same owner as the receiver. However, model fields
can only depend on peers if a model field is visible within the peer. For example,if the pure method hasNext from Figure 3 were a model field, then hasNext would
have to be visible to the class ArrayList. Our approach has no such restriction.

7 Conclusion
In summary, this paper proposed an approach to the automatic verification ofJava-like programs that combines the use of pure methods to achieve data abstraction with Kassios' solution to the framing problem [3, 4]. More specifically,we solve the framing problem by extending each method contract with a method
footprint, an upper bound on the set of memory locations read or written bythe corresponding method. Thanks to the use of dynamic frames, pure methods
that return a set of memory locations, these method footprints can be specifiedwithout breaking information hiding. The approach has been implemented in a
prototype [1], which has been used to automatically verify several challengingprograms, including the iterator and observer pattern. We plan to extend our

approach to concurrent programs, and apply our approach in a larger case-study.
Acknowledgments
The authors thank Rustan Leino and David Naumann for helpful comments anddiscussions. Jan Smans is a research assistant of the Fund for Scientific Research

- Flanders (FWO). Bart Jacobs is a postdoctoral fellow of the Fund for ScientificResearch - Flanders (FWO).

References

1. http://www.cs.kuleuven.be/~jans/DFJ
2. Leavens, G.T., Leino, K.R.M., M"uller, P.: Specification and verification challenges

for sequential object-oriented programs. In: Formal Aspects of Computing
3. Kassios, Y.: A Theory of Object Oriented Refinement. PhD thesis, University of

Toronto (2006)
4. Kassios, Y.T.: Dynamic frames: Support for framing, dependencies and sharing

without restrictions. In: Formal Methods. (2006)
5. Leino, K.R.M., Schulte, W.: A verifying compiler for a multi-threaded objectoriented language. In: Marktoberdorf Summer School Lecture Notes. (2006)
6. Barnett, M., DeLine, R., Fahndrich, M., Leino, K.R.M., Schulte, W.: Verification

of object-oriented programs with invariants. Journal of Object Technology 3(6)
(2004)
7. Jacobs, B., Piessens, F.: Verification of programs with inspector methods. In:

FTFJP. (2006)
8. M"uller, P.: Modular Specification and Verification of Object-Oriented Programs.

PhD thesis, FernUniversit"at Hagen (2001)
9. Dhara, K.K., Leavens, G.T.: Forcing behavioral subtyping through specification

inheritance. In: ICSE. (1996)
10. Barnett, M., Leino, K.R.M., Schulte, W.: The spec# programming system: An

overview. In: CASSIS. (2004)
11. Leino, K.R.M., M"uller, P.: Object invariants in dynamic contexts. In: ECOOP.

(2004)
12. Barnett, M., Naumann, D.A.: Friends need a bit more: Maintaining invariants over

shared state. In: MPC. (2004)
13. Jacobs, B., Piessens, F.: Inspector methods for state abstraction. Journal of Object

Technology 6(5) (2007)
14. Darvas, A., Leino, K.R.M.: Practical reasoning about invocations and implementations of pure methods. In: FASE. (2007)
15. Leino, K.R.M., M"uller., P.: A verification methodology for model fields. In: ESOP.

(2006)
16. Parkinson, M.: Local Reasoning for Java. PhD thesis, University of Cambridge

(2005)
17. Parkinson, M., Bierman, G.: Separation logic and abstraction. In: POPL. (2005)
18. Leino, K.R.M., Poetzsch-Heffter, A., Zhou, Y.: Using data groups to specify and

check side effects. In: PLDI. (2002)
19. Banerjee, A., Naumann, D.A., Rosenberg, S.: Regional logic for local reasoning

about global invariants. In: Unpublished. (2007)